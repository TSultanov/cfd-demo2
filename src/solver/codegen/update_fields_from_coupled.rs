use super::state_access::{state_component_expr, state_scalar_expr, state_vec2_expr};
use crate::solver::model::{IncompressibleMomentumFields, StateLayout};
use super::wgsl_ast::{
    AccessMode, Attribute, Block, Function, GlobalVar, Item, Module, Param, StorageClass,
    StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_update_fields_from_coupled_wgsl(
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (update_fields_from_coupled)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::GlobalVar(shared_max_u_var()));
    module.push(Item::GlobalVar(shared_max_p_var()));
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Fields (consolidated state buffers)".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 1: Linear solver outputs".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            0,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            0,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 0, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var("x", Type::array(Type::F32), 1, 0, AccessMode::Read),
        storage_var(
            "max_diff_result",
            Type::array(Type::Custom("atomic<u32>".to_string())),
            1,
            1,
            AccessMode::ReadWrite,
        ),
    ]
}

fn shared_max_u_var() -> GlobalVar {
    GlobalVar::new(
        "shared_max_u",
        Type::Custom("array<f32, 64>".to_string()),
        StorageClass::Workgroup,
        None,
        Vec::new(),
    )
}

fn shared_max_p_var() -> GlobalVar {
    GlobalVar::new(
        "shared_max_p",
        Type::Custom("array<f32, 64>".to_string()),
        StorageClass::Workgroup,
        None,
        Vec::new(),
    )
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &IncompressibleMomentumFields) -> Function {
    let params = vec![
        Param::new(
            "global_id",
            Type::vec3_u32(),
            vec![Attribute::Builtin("global_invocation_id".to_string())],
        ),
        Param::new(
            "local_id",
            Type::vec3_u32(),
            vec![Attribute::Builtin("local_invocation_id".to_string())],
        ),
        Param::new(
            "wg_id",
            Type::vec3_u32(),
            vec![Attribute::Builtin("workgroup_id".to_string())],
        ),
    ];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &IncompressibleMomentumFields) -> Block {
    let mut stmts = Vec::new();
    let stride = layout.stride();
    let u_field = fields.u.name();
    let p_field = fields.p.name();

    stmts.push(dsl::let_("idx", "global_id.x"));
    stmts.push(dsl::let_("lid", "local_id.x"));
    stmts.push(dsl::var_typed("diff_u", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("diff_p", Type::F32, Some("0.0")));
    stmts.push(dsl::let_(
        "num_cells",
        &format!("arrayLength(&state) / {}u", stride),
    ));

    let u_old_expr = state_vec2_expr(layout, "state", "idx", u_field);
    let p_old_expr = state_scalar_expr(layout, "state", "idx", p_field);

    let u_x_target = state_component_expr(layout, "state", "idx", u_field, 0);
    let u_y_target = state_component_expr(layout, "state", "idx", u_field, 1);
    let p_target = state_component_expr(layout, "state", "idx", p_field, 0);

    stmts.push(dsl::if_block(
        "idx < num_cells",
        dsl::block(vec![
            dsl::let_("u_new_val", "x[3u * idx + 0u]"),
            dsl::let_("v_new_val", "x[3u * idx + 1u]"),
            dsl::let_("p_new_val", "x[3u * idx + 2u]"),
            dsl::let_("u_old_val", &u_old_expr),
            dsl::let_("p_old_val", &p_old_expr),
            dsl::let_("alpha_u", "constants.alpha_u"),
            dsl::let_("alpha_p", "constants.alpha_p"),
            dsl::let_(
                "u_updated_x",
                "u_old_val.x + alpha_u * (u_new_val - u_old_val.x)",
            ),
            dsl::let_(
                "u_updated_y",
                "u_old_val.y + alpha_u * (v_new_val - u_old_val.y)",
            ),
            dsl::let_(
                "p_updated",
                "p_old_val + alpha_p * (p_new_val - p_old_val)",
            ),
            dsl::assign(&u_x_target, "u_updated_x"),
            dsl::assign(&u_y_target, "u_updated_y"),
            dsl::assign(&p_target, "p_updated"),
            dsl::assign(
                "diff_u",
                "max(abs(u_updated_x - u_old_val.x), abs(u_updated_y - u_old_val.y))",
            ),
            dsl::assign("diff_p", "abs(p_updated - p_old_val)"),
        ]),
        None,
    ));

    stmts.push(dsl::assign("shared_max_u[lid]", "diff_u"));
    stmts.push(dsl::assign("shared_max_p[lid]", "diff_p"));
    stmts.push(dsl::call_stmt("workgroupBarrier()"));

    stmts.push(dsl::for_loop(
        dsl::for_init_var("stride", "32u"),
        "stride > 0u",
        dsl::for_step_assign("stride", "stride / 2u"),
        dsl::block(vec![
            dsl::if_block(
                "lid < stride",
                dsl::block(vec![
                    dsl::assign(
                        "shared_max_u[lid]",
                        "max(shared_max_u[lid], shared_max_u[lid + stride])",
                    ),
                    dsl::assign(
                        "shared_max_p[lid]",
                        "max(shared_max_p[lid], shared_max_p[lid + stride])",
                    ),
                ]),
                None,
            ),
            dsl::call_stmt("workgroupBarrier()"),
        ]),
    ));

    stmts.push(dsl::if_block(
        "lid == 0u",
        dsl::block(vec![
            dsl::call_stmt("atomicMax(&max_diff_result[0], bitcast<u32>(shared_max_u[0]))"),
            dsl::call_stmt("atomicMax(&max_diff_result[1], bitcast<u32>(shared_max_p[0]))"),
        ]),
        None,
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::incompressible_momentum_model;

    #[test]
    fn update_fields_codegen_emits_state_arrays() {
        let model = incompressible_momentum_model();
        let wgsl = generate_update_fields_from_coupled_wgsl(&model.state_layout, &model.fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("atomicMax"));
        let stride = model.state_layout.stride();
        assert!(wgsl.contains(&format!("arrayLength(&state) / {stride}u")));
    }
}
