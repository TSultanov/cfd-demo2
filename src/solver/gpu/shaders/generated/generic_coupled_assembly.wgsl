// GENERATED BY CFD2 CODEGEN (generic_coupled_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
    pressure_coupling_alpha: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(9) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<uniform> constants: Constants;

// Group 2: Solver (block CSR values + RHS)

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let scalar_offset = scalar_row_offsets[idx];
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = scalar_offset * 1u;
    for (var rank = 0u; rank < num_neighbors; rank++) {
        matrix_values[start_row_0 + rank * 1u + 0u] = 0.0;
    }
    var diag_0: f32 = 0.0;
    var rhs_0: f32 = 0.0;
    diag_0 += vol * constants.density / constants.dt;
    rhs_0 += vol * constants.density / constants.dt * state_old[idx * 1u + 0u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * constants.density / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_0 = diag_0 - vol * constants.density / constants.dt + diag_bdf2;
        rhs_0 = rhs_0 - vol * constants.density / constants.dt * state_old[idx * 1u + 0u] + vol * constants.density / constants.dt * (factor_n * state_old[idx * 1u + 0u] - factor_nm1 * state_old_old[idx * 1u + 0u]);
    }
    for (var k = start; k < end; k++) {
        let face = cell_faces[k];
        let other_raw = face_neighbor[face];
        if (other_raw < 0) {
        } else {
            let other_idx = u32(other_raw);
            let other_center = cell_centers[other_idx];
            let normal = face_normals[face];
            let dx = other_center.x - center.x;
            let dy = other_center.y - center.y;
            let dist = abs(dx * normal.x + dy * normal.y);
            let area = face_areas[face];
            let scalar_mat_idx = cell_face_matrix_indices[k];
            let neighbor_rank = scalar_mat_idx - scalar_offset;
            let diff_coeff_phi = 1.0 * area / dist;
            diag_0 += diff_coeff_phi;
            matrix_values[start_row_0 + neighbor_rank * 1u + 0u] -= diff_coeff_phi;
        }
    }
    let diag_rank = diagonal_indices[idx] - scalar_offset;
    matrix_values[start_row_0 + diag_rank * 1u + 0u] += diag_0;
    rhs[idx * 1u + 0u] = rhs_0;
}
