use super::state_access::{state_component_expr, state_scalar_expr, state_vec2_expr};
use crate::solver::model::CompressibleFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl_ast::{
    AccessMode, Attribute, Block, Function, GlobalVar, Item, Module, Param, Stmt, StructDef,
    StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_compressible_apply_wgsl(
    layout: &StateLayout,
    fields: &CompressibleFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (compressible_apply)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Fields (consolidated state buffers)".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 1: Solver".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("precond_type", Type::U32),
            StructField::new("precond_model", Type::U32),
            StructField::new("precond_theta_floor", Type::F32),
        ],
    )
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            0,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            0,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 0, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_iter",
            Type::array(Type::F32),
            0,
            9,
            AccessMode::Read,
        ),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![storage_var(
        "solution",
        Type::array(Type::F32),
        1,
        0,
        AccessMode::Read,
    )]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CompressibleFields) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CompressibleFields) -> Block {
    let mut stmts = Vec::new();
    let rho_field = fields.rho.name();
    let rho_u_field = fields.rho_u.name();
    let rho_e_field = fields.rho_e.name();
    let stride = layout.stride();
    let rho_target = state_scalar_expr(layout, "state", "idx", rho_field);
    let rho_u_x_target = state_component_expr(layout, "state", "idx", rho_u_field, 0);
    let rho_u_y_target = state_component_expr(layout, "state", "idx", rho_u_field, 1);
    let rho_e_target = state_scalar_expr(layout, "state", "idx", rho_e_field);

    stmts.push(dsl::let_("idx", "global_id.x"));
    stmts.push(dsl::let_("stride", &format!("{stride}u")));
    stmts.push(dsl::let_("num_cells", "arrayLength(&state)"));
    stmts.push(dsl::if_block(
        "idx * stride >= num_cells",
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    let rho_base_expr = state_scalar_expr(layout, "state", "idx", rho_field);
    let rho_u_base_expr = state_vec2_expr(layout, "state", "idx", rho_u_field);
    let rho_e_base_expr = state_scalar_expr(layout, "state", "idx", rho_e_field);
    stmts.push(dsl::let_("rho_base", &rho_base_expr));
    stmts.push(dsl::let_("rho_u_base", &rho_u_base_expr));
    stmts.push(dsl::let_("rho_e_base", &rho_e_base_expr));

    stmts.push(dsl::let_("base", "idx * 4u"));
    stmts.push(dsl::let_("delta_rho", "solution[base + 0u]"));
    stmts.push(dsl::let_("delta_rho_u_x", "solution[base + 1u]"));
    stmts.push(dsl::let_("delta_rho_u_y", "solution[base + 2u]"));
    stmts.push(dsl::let_("delta_rho_e", "solution[base + 3u]"));

    stmts.push(dsl::let_("relax", "constants.alpha_u"));
    stmts.push(dsl::var("rho_new", "rho_base + relax * delta_rho"));
    stmts.push(dsl::var(
        "rho_u_new_x",
        "rho_u_base.x + relax * delta_rho_u_x",
    ));
    stmts.push(dsl::var(
        "rho_u_new_y",
        "rho_u_base.y + relax * delta_rho_u_y",
    ));
    stmts.push(dsl::var("rho_e_new", "rho_e_base + relax * delta_rho_e"));

    stmts.push(dsl::assign(&rho_target, "rho_new"));
    stmts.push(dsl::assign(&rho_u_x_target, "rho_u_new_x"));
    stmts.push(dsl::assign(&rho_u_y_target, "rho_u_new_y"));
    stmts.push(dsl::assign(&rho_e_target, "rho_e_new"));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_apply_codegen_emits_solution_binding() {
        let model = compressible_model();
        let fields = model.fields.compressible().expect("compressible fields");
        let wgsl = generate_compressible_apply_wgsl(&model.state_layout, fields);
        assert!(wgsl.contains("solution"));
        assert!(wgsl.contains("rho_new"));
        assert!(wgsl.contains("state_old"));
    }
}
