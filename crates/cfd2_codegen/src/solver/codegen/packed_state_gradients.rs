use super::dsl as typed;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use super::KernelWgsl;
use crate::solver::ir::StateLayout;

pub fn generate_packed_state_gradients_wgsl(
    layout: &StateLayout,
    unknown_stride: u32,
) -> Result<KernelWgsl, String> {
    let stride = layout.stride();
    if unknown_stride == 0 {
        return Err("packed_state_gradients requires unknown_stride > 0".to_string());
    }
    if unknown_stride > stride {
        return Err(format!(
            "packed_state_gradients requires unknown_stride ({unknown_stride}) <= state stride ({stride})"
        ));
    }

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (packed_state_gradients)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, unknown_stride)));
    Ok(KernelWgsl::from(module))
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("eos_gamma", Type::F32),
            StructField::new("eos_gm1", Type::F32),
            StructField::new("eos_r", Type::F32),
            StructField::new("eos_dp_drho", Type::F32),
            StructField::new("eos_p_offset", Type::F32),
            StructField::new("eos_theta_ref", Type::F32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::Read),
        uniform_var(
            "constants",
            Type::Custom("Constants".to_string()),
            1,
            3,
        ),
        storage_var(
            "grad_state",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            4,
            AccessMode::ReadWrite,
        ),
    ]
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(layout: &StateLayout, unknown_stride: u32) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, unknown_stride),
    )
}

fn main_body(layout: &StateLayout, unknown_stride: u32) -> Block {
    let stride = layout.stride();

    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    // Skip the full Greenâ€“Gauss pass for first-order upwind to keep overhead low.
    stmts.push(dsl::if_block_expr(
        Expr::ident("constants").field("scheme").eq(Expr::from(0u32)),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "cell_center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_typed_expr(
        "cell_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("cell_center")).expr(),
    ));

    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));

    // Accumulators: one vec2 per coupled unknown component.
    for component in 0..unknown_stride {
        let var_name = format!("grad_acc_{component}");
        stmts.push(dsl::var_typed_expr(
            &var_name,
            Type::vec2_f32(),
            Some(dsl::vec2_f32(0.0, 0.0)),
        ));
    }

    // Face loop.
    let face_loop_body = {
        let mut body = Vec::new();

        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neighbor_raw",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "is_boundary",
            Expr::ident("neighbor_raw").eq(-1),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "face_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_typed_expr(
            "face_center_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
        ));
        body.push(dsl::var_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            Some(
                typed::VecExpr::<2>::from_xy_fields(
                    Expr::ident("face_normals").index(Expr::ident("face_idx")),
                )
                .expr(),
            ),
        ));
        let cell_to_face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("cell_center_vec")));
        body.push(dsl::if_block_expr(
            cell_to_face
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
                .lt(0.0),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("normal_vec"),
                typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .neg()
                    .expr(),
            )]),
            None,
        ));

        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center_vec",
            Type::vec2_f32(),
            Some(Expr::ident("face_center_vec")),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            dsl::block(vec![
                dsl::let_expr(
                    "neighbor",
                    Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
                ),
                dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
                dsl::if_block_expr(
                    Expr::ident("owner").ne(Expr::ident("idx")),
                    dsl::block(vec![dsl::assign_expr(
                        Expr::ident("other_idx"),
                        Expr::ident("owner"),
                    )]),
                    None,
                ),
                dsl::let_expr(
                    "other_center",
                    dsl::array_access("cell_centers", Expr::ident("other_idx")),
                ),
                dsl::assign_expr(
                    Expr::ident("other_center_vec"),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
                ),
            ]),
            None,
        ));

        body.push(dsl::let_expr(
            "d_own",
            dsl::distance(Expr::ident("cell_center_vec"), Expr::ident("face_center_vec")),
        ));
        body.push(dsl::let_expr(
            "d_neigh",
            dsl::distance(Expr::ident("other_center_vec"), Expr::ident("face_center_vec")),
        ));
        body.push(dsl::let_expr(
            "total_dist",
            Expr::ident("d_own") + Expr::ident("d_neigh"),
        ));
        body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
        body.push(dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ));
        body.push(dsl::let_expr(
            "lambda_other",
            Expr::from(1.0) - Expr::ident("lambda"),
        ));

        for component in 0..unknown_stride {
            let cell_val = Expr::ident("state")
                .index(Expr::ident("idx") * stride + Expr::from(component));
            let interior_other = Expr::ident("state")
                .index(Expr::ident("other_idx") * stride + Expr::from(component));

            let bc_table_idx =
                Expr::ident("face_idx") * Expr::from(unknown_stride) + Expr::from(component);
            let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
            let value = dsl::array_access("bc_value", bc_table_idx);
            let from_bc = dsl::select(
                dsl::select(cell_val.clone(), value.clone(), kind.eq(Expr::from(1u32))),
                cell_val.clone() + value * Expr::ident("d_own"),
                kind.eq(Expr::from(2u32)),
            );

            let other_val = dsl::select(interior_other, from_bc, Expr::ident("is_boundary"));
            let phi_face =
                cell_val * Expr::ident("lambda") + other_val * Expr::ident("lambda_other");

            let acc_name = format!("grad_acc_{component}");
            let contrib = typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .mul_scalar(phi_face * Expr::ident("area"))
                .expr();
            body.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(&acc_name),
                contrib,
            ));
        }

        dsl::block(body)
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        face_loop_body,
    ));

    // Write out gradients (divide by volume) into the packed `grad_state` buffer.
    for component in 0..unknown_stride {
        let acc_name = format!("grad_acc_{component}");
        let grad_vec = typed::VecExpr::<2>::from_expr(Expr::ident(&acc_name))
            .mul_scalar(Expr::from(1.0) / dsl::max(Expr::ident("vol"), 1e-12))
            .expr();
        stmts.push(dsl::let_typed_expr(
            &format!("grad_out_{component}"),
            Type::vec2_f32(),
            grad_vec,
        ));

        let out = Expr::ident(&format!("grad_out_{component}"));
        let out_idx = Expr::ident("idx") * stride + Expr::from(component);
        stmts.push(dsl::assign_expr(
            Expr::ident("grad_state").index(out_idx.clone()).field("x"),
            out.clone().field("x"),
        ));
        stmts.push(dsl::assign_expr(
            Expr::ident("grad_state").index(out_idx).field("y"),
            out.field("y"),
        ));
    }

    Block::new(stmts)
}
