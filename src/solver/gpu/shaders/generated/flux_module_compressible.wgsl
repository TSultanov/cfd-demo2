// GENERATED BY CFD2 CODEGEN (flux_module)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;

// Group 2: Boundary conditions (per face x unknown)

@group(2) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(2) @binding(1) 
var<storage, read> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32 = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = owner + value * d_own;
    }
    return select(interior, boundary, is_boundary);
}

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = neighbor == -1;
    var neigh_idx: u32 = owner;
    if (neighbor != -1) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    let c_owner = cell_centers[owner];
    let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    if (dot(face_center_vec - c_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    let c_neigh = cell_centers[neigh_idx];
    var c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec: vec2<f32> = c_neigh_vec;
    if (is_boundary) {
        c_neigh_vec = face_center_vec;
    }
    let d_own = abs(dot(face_center_vec - c_owner_vec, normal_vec));
    let d_neigh = abs(dot(c_neigh_vec - face_center_vec, normal_vec));
    let total_dist = d_own + d_neigh;
    var lambda: f32 = 0.5;
    if (total_dist > 0.000001) {
        lambda = d_neigh / total_dist;
    }
    let lambda_other = 1.0 - lambda;
    let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
    let dist_proj = abs(dot(d_vec, normal_vec));
    let dist = max(dist_proj, 0.000001);
    let s_own_T = bc_neighbor_scalar(state[owner * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_own_grad_T_x = state[owner * 22u + 16u];
    let s_own_grad_T_y = state[owner * 22u + 17u];
    let s_own_grad_rho_x = state[owner * 22u + 12u];
    let s_own_grad_rho_y = state[owner * 22u + 13u];
    let s_own_grad_rho_u_x_x = state[owner * 22u + 3u];
    let s_own_grad_rho_u_x_y = state[owner * 22u + 4u];
    let s_own_grad_rho_u_y_x = state[owner * 22u + 5u];
    let s_own_grad_rho_u_y_y = state[owner * 22u + 6u];
    let s_own_grad_u_x_x = state[owner * 22u + 18u];
    let s_own_grad_u_x_y = state[owner * 22u + 19u];
    let s_own_grad_u_y_x = state[owner * 22u + 20u];
    let s_own_grad_u_y_y = state[owner * 22u + 21u];
    let s_own_rho = bc_neighbor_scalar(state[owner * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_own_rho_u_x = select(bc_neighbor_scalar(state[owner * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_own_rho_u_y = select(bc_neighbor_scalar(state[owner * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let s_neigh_T = bc_neighbor_scalar(state[neigh_idx * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_neigh_grad_T_x = select(state[neigh_idx * 22u + 16u], state[owner * 22u + 16u], is_boundary);
    let s_neigh_grad_T_y = select(state[neigh_idx * 22u + 17u], state[owner * 22u + 17u], is_boundary);
    let s_neigh_grad_rho_x = select(state[neigh_idx * 22u + 12u], state[owner * 22u + 12u], is_boundary);
    let s_neigh_grad_rho_y = select(state[neigh_idx * 22u + 13u], state[owner * 22u + 13u], is_boundary);
    let s_neigh_grad_rho_u_x_x = select(state[neigh_idx * 22u + 3u], state[owner * 22u + 3u], is_boundary);
    let s_neigh_grad_rho_u_x_y = select(state[neigh_idx * 22u + 4u], state[owner * 22u + 4u], is_boundary);
    let s_neigh_grad_rho_u_y_x = select(state[neigh_idx * 22u + 5u], state[owner * 22u + 5u], is_boundary);
    let s_neigh_grad_rho_u_y_y = select(state[neigh_idx * 22u + 6u], state[owner * 22u + 6u], is_boundary);
    let s_neigh_grad_u_x_x = select(state[neigh_idx * 22u + 18u], state[owner * 22u + 18u], is_boundary);
    let s_neigh_grad_u_x_y = select(state[neigh_idx * 22u + 19u], state[owner * 22u + 19u], is_boundary);
    let s_neigh_grad_u_y_x = select(state[neigh_idx * 22u + 20u], state[owner * 22u + 20u], is_boundary);
    let s_neigh_grad_u_y_y = select(state[neigh_idx * 22u + 21u], state[owner * 22u + 21u], is_boundary);
    let s_neigh_rho = bc_neighbor_scalar(state[neigh_idx * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_neigh_rho_u_x = select(bc_neighbor_scalar(state[neigh_idx * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_neigh_rho_u_y = select(bc_neighbor_scalar(state[neigh_idx * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let _cse_3 = s_own_rho_u_x;
    let _cse_4 = s_own_rho_u_y;
    let _cse_2 = vec2<f32>(_cse_3, _cse_4);
    let _cse_1 = _cse_2 * 1.0 / s_own_rho;
    let _cse_0 = dot(_cse_1, normal_vec);
    let _cse_12 = f32(low_mach_params.model) - 2.0;
    let _cse_11 = abs(_cse_12);
    let _cse_10 = 1.0 - _cse_11;
    let _cse_9 = max(0.0, _cse_10);
    let _cse_16 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_15 = constants.eos_gamma * _cse_16;
    let _cse_14 = _cse_15 / s_own_rho;
    let _cse_13 = _cse_14 + constants.eos_dp_drho;
    let _cse_8 = _cse_9 * _cse_13;
    let _cse_21 = f32(low_mach_params.model);
    let _cse_20 = abs(_cse_21);
    let _cse_19 = 1.0 - _cse_20;
    let _cse_18 = max(0.0, _cse_19);
    let _cse_23 = _cse_0 * _cse_0;
    let _cse_22 = min(_cse_23, _cse_13);
    let _cse_17 = _cse_18 * _cse_22;
    let _cse_7 = _cse_8 + _cse_17;
    let _cse_28 = f32(low_mach_params.model) - 1.0;
    let _cse_27 = abs(_cse_28);
    let _cse_26 = 1.0 - _cse_27;
    let _cse_25 = max(0.0, _cse_26);
    let _cse_31 = low_mach_params.theta_floor * _cse_13;
    let _cse_30 = max(_cse_23, _cse_31);
    let _cse_29 = min(_cse_30, _cse_13);
    let _cse_24 = _cse_25 * _cse_29;
    let _cse_6 = _cse_7 + _cse_24;
    let _cse_5 = sqrt(_cse_6);
    let _cse_35 = s_neigh_rho_u_x;
    let _cse_36 = s_neigh_rho_u_y;
    let _cse_34 = vec2<f32>(_cse_35, _cse_36);
    let _cse_33 = _cse_34 * 1.0 / s_neigh_rho;
    let _cse_32 = dot(_cse_33, normal_vec);
    let _cse_44 = s_neigh_rho * constants.eos_r * s_neigh_T;
    let _cse_43 = constants.eos_gamma * _cse_44;
    let _cse_42 = _cse_43 / s_neigh_rho;
    let _cse_41 = _cse_42 + constants.eos_dp_drho;
    let _cse_40 = _cse_9 * _cse_41;
    let _cse_47 = _cse_32 * _cse_32;
    let _cse_46 = min(_cse_47, _cse_41);
    let _cse_45 = _cse_18 * _cse_46;
    let _cse_39 = _cse_40 + _cse_45;
    let _cse_51 = low_mach_params.theta_floor * _cse_41;
    let _cse_50 = max(_cse_47, _cse_51);
    let _cse_49 = min(_cse_50, _cse_41);
    let _cse_48 = _cse_25 * _cse_49;
    let _cse_38 = _cse_39 + _cse_48;
    let _cse_37 = sqrt(_cse_38);
    var a_plus: f32 = max(0.0, max(_cse_0 + _cse_5, _cse_32 + _cse_37));
    var a_minus: f32 = min(0.0, min(_cse_0 - _cse_5, _cse_32 - _cse_37));
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_56 = s_own_rho_u_x;
        let _cse_57 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_55 = _cse_56 + _cse_57;
        let _cse_59 = s_own_rho_u_y;
        let _cse_60 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_58 = _cse_59 + _cse_60;
        let _cse_54 = vec2<f32>(_cse_55, _cse_58);
        let _cse_63 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_62 = s_own_rho + _cse_63;
        let _cse_61 = 1.0 / _cse_62;
        let _cse_53 = _cse_54 * _cse_61;
        let _cse_52 = dot(_cse_53, normal_vec);
        let _cse_72 = _cse_62 * constants.eos_r;
        let _cse_74 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_73 = s_own_T + _cse_74;
        let _cse_71 = _cse_72 * _cse_73;
        let _cse_70 = constants.eos_gamma * _cse_71;
        let _cse_69 = _cse_70 / _cse_62;
        let _cse_68 = _cse_69 + constants.eos_dp_drho;
        let _cse_67 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_68;
        let _cse_77 = _cse_52 * _cse_52;
        let _cse_76 = min(_cse_77, _cse_68);
        let _cse_75 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_76;
        let _cse_66 = _cse_67 + _cse_75;
        let _cse_81 = low_mach_params.theta_floor * _cse_68;
        let _cse_80 = max(_cse_77, _cse_81);
        let _cse_79 = min(_cse_80, _cse_68);
        let _cse_78 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_79;
        let _cse_65 = _cse_66 + _cse_78;
        let _cse_64 = sqrt(_cse_65);
        let _cse_86 = s_neigh_rho_u_x;
        let _cse_88 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_87 = dot(_cse_88, face_center_vec - c_neigh_cell_vec);
        let _cse_85 = _cse_86 + _cse_87;
        let _cse_90 = s_neigh_rho_u_y;
        let _cse_92 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_91 = dot(_cse_92, face_center_vec - c_neigh_cell_vec);
        let _cse_89 = _cse_90 + _cse_91;
        let _cse_84 = vec2<f32>(_cse_85, _cse_89);
        let _cse_96 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_95 = dot(_cse_96, face_center_vec - c_neigh_cell_vec);
        let _cse_94 = s_neigh_rho + _cse_95;
        let _cse_93 = 1.0 / _cse_94;
        let _cse_83 = _cse_84 * _cse_93;
        let _cse_82 = dot(_cse_83, normal_vec);
        let _cse_105 = _cse_94 * constants.eos_r;
        let _cse_108 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_107 = dot(_cse_108, face_center_vec - c_neigh_cell_vec);
        let _cse_106 = s_neigh_T + _cse_107;
        let _cse_104 = _cse_105 * _cse_106;
        let _cse_103 = constants.eos_gamma * _cse_104;
        let _cse_102 = _cse_103 / _cse_94;
        let _cse_101 = _cse_102 + constants.eos_dp_drho;
        let _cse_100 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_101;
        let _cse_111 = _cse_82 * _cse_82;
        let _cse_110 = min(_cse_111, _cse_101);
        let _cse_109 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_110;
        let _cse_99 = _cse_100 + _cse_109;
        let _cse_115 = low_mach_params.theta_floor * _cse_101;
        let _cse_114 = max(_cse_111, _cse_115);
        let _cse_113 = min(_cse_114, _cse_101);
        let _cse_112 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_113;
        let _cse_98 = _cse_99 + _cse_112;
        let _cse_97 = sqrt(_cse_98);
        a_plus = max(0.0, max(_cse_52 + _cse_64, _cse_82 + _cse_97));
        a_minus = min(0.0, min(_cse_52 - _cse_64, _cse_82 - _cse_97));
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_120 = s_own_rho_u_x;
        let _cse_124 = s_neigh_rho_u_x;
        let _cse_123 = _cse_120 * 0.625 + _cse_124 * 0.375;
        let _cse_122 = _cse_123 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_121 = _cse_122 - _cse_120;
        let _cse_119 = _cse_120 + _cse_121;
        let _cse_126 = s_own_rho_u_y;
        let _cse_130 = s_neigh_rho_u_y;
        let _cse_129 = _cse_126 * 0.625 + _cse_130 * 0.375;
        let _cse_128 = _cse_129 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_127 = _cse_128 - _cse_126;
        let _cse_125 = _cse_126 + _cse_127;
        let _cse_118 = vec2<f32>(_cse_119, _cse_125);
        let _cse_136 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_135 = _cse_136 * 0.125;
        let _cse_134 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + _cse_135;
        let _cse_133 = _cse_134 - s_own_rho;
        let _cse_132 = s_own_rho + _cse_133;
        let _cse_131 = 1.0 / _cse_132;
        let _cse_117 = _cse_118 * _cse_131;
        let _cse_116 = dot(_cse_117, normal_vec);
        let _cse_143 = _cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T);
        let _cse_142 = constants.eos_gamma * _cse_143;
        let _cse_141 = _cse_142 / _cse_132;
        let _cse_140 = _cse_141 + constants.eos_dp_drho;
        let _cse_146 = _cse_116 * _cse_116;
        let _cse_145 = min(_cse_146, _cse_140);
        let _cse_144 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_145;
        let _cse_139 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_140 + _cse_144;
        let _cse_149 = max(_cse_146, low_mach_params.theta_floor * _cse_140);
        let _cse_148 = min(_cse_149, _cse_140);
        let _cse_147 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_148;
        let _cse_138 = _cse_139 + _cse_147;
        let _cse_137 = sqrt(_cse_138);
        let _cse_155 = _cse_124 * 0.625 + _cse_120 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_154 = _cse_155 - _cse_124;
        let _cse_153 = _cse_124 + _cse_154;
        let _cse_158 = _cse_130 * 0.625 + _cse_126 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_157 = _cse_158 - _cse_130;
        let _cse_156 = _cse_130 + _cse_157;
        let _cse_152 = vec2<f32>(_cse_153, _cse_156);
        let _cse_165 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_164 = dot(_cse_165, c_owner_vec - c_neigh_cell_vec);
        let _cse_163 = _cse_164 * 0.125;
        let _cse_162 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_163;
        let _cse_161 = _cse_162 - s_neigh_rho;
        let _cse_160 = s_neigh_rho + _cse_161;
        let _cse_159 = 1.0 / _cse_160;
        let _cse_151 = _cse_152 * _cse_159;
        let _cse_150 = dot(_cse_151, normal_vec);
        let _cse_173 = _cse_160 * constants.eos_r;
        let _cse_172 = _cse_173 * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T);
        let _cse_171 = constants.eos_gamma * _cse_172;
        let _cse_170 = _cse_171 / _cse_160;
        let _cse_169 = _cse_170 + constants.eos_dp_drho;
        let _cse_176 = _cse_150 * _cse_150;
        let _cse_175 = min(_cse_176, _cse_169);
        let _cse_174 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_175;
        let _cse_168 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_169 + _cse_174;
        let _cse_179 = max(_cse_176, low_mach_params.theta_floor * _cse_169);
        let _cse_178 = min(_cse_179, _cse_169);
        let _cse_177 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_178;
        let _cse_167 = _cse_168 + _cse_177;
        let _cse_166 = sqrt(_cse_167);
        a_plus = max(0.0, max(_cse_116 + _cse_137, _cse_150 + _cse_166));
        a_minus = min(0.0, min(_cse_116 - _cse_137, _cse_150 - _cse_166));
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_184 = s_own_rho_u_x;
        let _cse_188 = s_neigh_rho_u_x;
        let _cse_187 = _cse_188 - _cse_184;
        let _cse_186 = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), min(_cse_187, 0.0));
        let _cse_185 = min(_cse_186, max(_cse_187, 0.0));
        let _cse_183 = _cse_184 + _cse_185;
        let _cse_190 = s_own_rho_u_y;
        let _cse_194 = s_neigh_rho_u_y;
        let _cse_193 = _cse_194 - _cse_190;
        let _cse_192 = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), min(_cse_193, 0.0));
        let _cse_191 = min(_cse_192, max(_cse_193, 0.0));
        let _cse_189 = _cse_190 + _cse_191;
        let _cse_182 = vec2<f32>(_cse_183, _cse_189);
        let _cse_198 = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec), min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_197 = min(_cse_198, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_196 = s_own_rho + _cse_197;
        let _cse_195 = 1.0 / _cse_196;
        let _cse_181 = _cse_182 * _cse_195;
        let _cse_180 = dot(_cse_181, normal_vec);
        let _cse_205 = _cse_196 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)));
        let _cse_204 = constants.eos_gamma * _cse_205;
        let _cse_203 = _cse_204 / _cse_196;
        let _cse_202 = _cse_203 + constants.eos_dp_drho;
        let _cse_208 = _cse_180 * _cse_180;
        let _cse_207 = min(_cse_208, _cse_202);
        let _cse_206 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_207;
        let _cse_201 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_202 + _cse_206;
        let _cse_211 = max(_cse_208, low_mach_params.theta_floor * _cse_202);
        let _cse_210 = min(_cse_211, _cse_202);
        let _cse_209 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_210;
        let _cse_200 = _cse_201 + _cse_209;
        let _cse_199 = sqrt(_cse_200);
        let _cse_218 = _cse_184 - _cse_188;
        let _cse_217 = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_218, 0.0));
        let _cse_216 = min(_cse_217, max(_cse_218, 0.0));
        let _cse_215 = _cse_188 + _cse_216;
        let _cse_222 = _cse_190 - _cse_194;
        let _cse_221 = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_222, 0.0));
        let _cse_220 = min(_cse_221, max(_cse_222, 0.0));
        let _cse_219 = _cse_194 + _cse_220;
        let _cse_214 = vec2<f32>(_cse_215, _cse_219);
        let _cse_228 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_227 = dot(_cse_228, face_center_vec - c_neigh_cell_vec);
        let _cse_226 = max(_cse_227, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_225 = min(_cse_226, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_224 = s_neigh_rho + _cse_225;
        let _cse_223 = 1.0 / _cse_224;
        let _cse_213 = _cse_214 * _cse_223;
        let _cse_212 = dot(_cse_213, normal_vec);
        let _cse_236 = _cse_224 * constants.eos_r;
        let _cse_237 = s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0));
        let _cse_235 = _cse_236 * _cse_237;
        let _cse_234 = constants.eos_gamma * _cse_235;
        let _cse_233 = _cse_234 / _cse_224;
        let _cse_232 = _cse_233 + constants.eos_dp_drho;
        let _cse_240 = _cse_212 * _cse_212;
        let _cse_239 = min(_cse_240, _cse_232);
        let _cse_238 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_239;
        let _cse_231 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_232 + _cse_238;
        let _cse_243 = max(_cse_240, low_mach_params.theta_floor * _cse_232);
        let _cse_242 = min(_cse_243, _cse_232);
        let _cse_241 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_242;
        let _cse_230 = _cse_231 + _cse_241;
        let _cse_229 = sqrt(_cse_230);
        a_plus = max(0.0, max(_cse_180 + _cse_199, _cse_212 + _cse_229));
        a_minus = min(0.0, min(_cse_180 - _cse_199, _cse_212 - _cse_229));
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_248 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_257 = dot(_cse_248, _cse_248);
        let _cse_259 = _cse_257 * _cse_257;
        let _cse_258 = _cse_259 + 0.000000000000000000000000000001;
        let _cse_256 = dot(_cse_248, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_257 / _cse_258;
        let _cse_255 = 2.0 * _cse_256;
        let _cse_254 = _cse_255 - 1.0;
        let _cse_253 = min(_cse_254, 1999.0);
        let _cse_252 = max(-2001.0, _cse_253);
        let _cse_260 = abs(_cse_252);
        let _cse_251 = _cse_252 + _cse_260;
        let _cse_250 = _cse_251 / (1.0 + _cse_260);
        let _cse_249 = _cse_250 * lambda_other;
        let _cse_247 = _cse_248 * _cse_249;
        let _cse_246 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_247;
        let _cse_267 = 2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0;
        let _cse_266 = min(_cse_267, 1999.0);
        let _cse_265 = max(-2001.0, _cse_266);
        let _cse_264 = (_cse_265 + abs(_cse_265)) / (1.0 + abs(_cse_265));
        let _cse_263 = _cse_264 * lambda_other;
        let _cse_262 = _cse_263 * (s_neigh_rho - s_own_rho);
        let _cse_261 = s_own_rho + _cse_262;
        let _cse_245 = _cse_246 * 1.0 / _cse_261;
        let _cse_244 = dot(_cse_245, normal_vec);
        let _cse_271 = constants.eos_gamma * _cse_261 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / _cse_261;
        let _cse_270 = _cse_271 + constants.eos_dp_drho;
        let _cse_272 = _cse_244 * _cse_244;
        let _cse_269 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_270 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_272, _cse_270) + max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * min(max(_cse_272, low_mach_params.theta_floor * _cse_270), _cse_270);
        let _cse_268 = sqrt(_cse_269);
        let _cse_285 = dot(_cse_248, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))))) * _cse_257;
        let _cse_284 = _cse_285 / _cse_258;
        let _cse_283 = 2.0 * _cse_284;
        let _cse_282 = _cse_283 - 1.0;
        let _cse_281 = min(_cse_282, 1999.0);
        let _cse_280 = max(-2001.0, _cse_281);
        let _cse_286 = abs(_cse_280);
        let _cse_279 = _cse_280 + _cse_286;
        let _cse_278 = _cse_279 / (1.0 + _cse_286);
        let _cse_277 = _cse_278 * lambda;
        let _cse_276 = _cse_248 * _cse_277;
        let _cse_275 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_276;
        let _cse_296 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001);
        let _cse_295 = 2.0 * _cse_296;
        let _cse_294 = _cse_295 - 1.0;
        let _cse_293 = min(_cse_294, 1999.0);
        let _cse_292 = max(-2001.0, _cse_293);
        let _cse_297 = abs(_cse_292);
        let _cse_291 = _cse_292 + _cse_297;
        let _cse_290 = _cse_291 / (1.0 + _cse_297);
        let _cse_289 = _cse_290 * lambda;
        let _cse_288 = _cse_289 * (s_neigh_rho - s_own_rho);
        let _cse_287 = s_neigh_rho - _cse_288;
        let _cse_274 = _cse_275 * 1.0 / _cse_287;
        let _cse_273 = dot(_cse_274, normal_vec);
        let _cse_304 = _cse_287 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T));
        let _cse_303 = constants.eos_gamma * _cse_304;
        let _cse_302 = _cse_303 / _cse_287;
        let _cse_301 = _cse_302 + constants.eos_dp_drho;
        let _cse_305 = _cse_273 * _cse_273;
        let _cse_300 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_301 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_305, _cse_301);
        let _cse_307 = min(max(_cse_305, low_mach_params.theta_floor * _cse_301), _cse_301);
        let _cse_306 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_307;
        let _cse_299 = _cse_300 + _cse_306;
        let _cse_298 = sqrt(_cse_299);
        a_plus = max(0.0, max(_cse_244 + _cse_268, _cse_273 + _cse_298));
        a_minus = min(0.0, min(_cse_244 - _cse_268, _cse_273 - _cse_298));
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_312 = s_own_rho_u_x;
        let _cse_316 = s_neigh_rho_u_x;
        let _cse_315 = _cse_312 * 0.625 + _cse_316 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_312;
        let _cse_314 = max(_cse_315, min(_cse_316 - _cse_312, 0.0));
        let _cse_313 = min(_cse_314, max(_cse_316 - _cse_312, 0.0));
        let _cse_311 = _cse_312 + _cse_313;
        let _cse_318 = s_own_rho_u_y;
        let _cse_322 = s_neigh_rho_u_y;
        let _cse_321 = _cse_318 * 0.625 + _cse_322 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_318;
        let _cse_320 = max(_cse_321, min(_cse_322 - _cse_318, 0.0));
        let _cse_319 = min(_cse_320, max(_cse_322 - _cse_318, 0.0));
        let _cse_317 = _cse_318 + _cse_319;
        let _cse_310 = vec2<f32>(_cse_311, _cse_317);
        let _cse_327 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_326 = _cse_327 - s_own_rho;
        let _cse_325 = max(_cse_326, min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_324 = min(_cse_325, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_323 = s_own_rho + _cse_324;
        let _cse_309 = _cse_310 * 1.0 / _cse_323;
        let _cse_308 = dot(_cse_309, normal_vec);
        let _cse_334 = _cse_323 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)));
        let _cse_333 = constants.eos_gamma * _cse_334;
        let _cse_332 = _cse_333 / _cse_323;
        let _cse_331 = _cse_332 + constants.eos_dp_drho;
        let _cse_337 = _cse_308 * _cse_308;
        let _cse_336 = min(_cse_337, _cse_331);
        let _cse_335 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_336;
        let _cse_330 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_331 + _cse_335;
        let _cse_340 = max(_cse_337, low_mach_params.theta_floor * _cse_331);
        let _cse_339 = min(_cse_340, _cse_331);
        let _cse_338 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_339;
        let _cse_329 = _cse_330 + _cse_338;
        let _cse_328 = sqrt(_cse_329);
        let _cse_347 = _cse_316 * 0.625 + _cse_312 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_316;
        let _cse_346 = max(_cse_347, min(_cse_312 - _cse_316, 0.0));
        let _cse_345 = min(_cse_346, max(_cse_312 - _cse_316, 0.0));
        let _cse_344 = _cse_316 + _cse_345;
        let _cse_351 = _cse_322 * 0.625 + _cse_318 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_322;
        let _cse_350 = max(_cse_351, min(_cse_318 - _cse_322, 0.0));
        let _cse_349 = min(_cse_350, max(_cse_318 - _cse_322, 0.0));
        let _cse_348 = _cse_322 + _cse_349;
        let _cse_343 = vec2<f32>(_cse_344, _cse_348);
        let _cse_358 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_357 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_358;
        let _cse_356 = _cse_357 - s_neigh_rho;
        let _cse_355 = max(_cse_356, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_354 = min(_cse_355, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_353 = s_neigh_rho + _cse_354;
        let _cse_352 = 1.0 / _cse_353;
        let _cse_342 = _cse_343 * _cse_352;
        let _cse_341 = dot(_cse_342, normal_vec);
        let _cse_365 = _cse_353 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_364 = constants.eos_gamma * _cse_365;
        let _cse_363 = _cse_364 / _cse_353;
        let _cse_362 = _cse_363 + constants.eos_dp_drho;
        let _cse_368 = _cse_341 * _cse_341;
        let _cse_367 = min(_cse_368, _cse_362);
        let _cse_366 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_367;
        let _cse_361 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_362 + _cse_366;
        let _cse_371 = max(_cse_368, low_mach_params.theta_floor * _cse_362);
        let _cse_370 = min(_cse_371, _cse_362);
        let _cse_369 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_370;
        let _cse_360 = _cse_361 + _cse_369;
        let _cse_359 = sqrt(_cse_360);
        a_plus = max(0.0, max(_cse_308 + _cse_328, _cse_341 + _cse_359));
        a_minus = min(0.0, min(_cse_308 - _cse_328, _cse_341 - _cse_359));
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_376 = s_own_rho_u_x;
        let _cse_379 = s_neigh_rho_u_x;
        let _cse_378 = _cse_376 * 0.625 + _cse_379 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_376;
        let _cse_377 = _cse_378 * abs(_cse_379 - _cse_376) / max(abs(_cse_379 - _cse_376), abs(_cse_378) + 0.00000001) * max((_cse_379 - _cse_376) * _cse_378, 0.0) / max(abs((_cse_379 - _cse_376) * _cse_378), 0.00000001);
        let _cse_375 = _cse_376 + _cse_377;
        let _cse_381 = s_own_rho_u_y;
        let _cse_384 = s_neigh_rho_u_y;
        let _cse_383 = _cse_381 * 0.625 + _cse_384 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_381;
        let _cse_382 = _cse_383 * abs(_cse_384 - _cse_381) / max(abs(_cse_384 - _cse_381), abs(_cse_383) + 0.00000001) * max((_cse_384 - _cse_381) * _cse_383, 0.0) / max(abs((_cse_384 - _cse_381) * _cse_383), 0.00000001);
        let _cse_380 = _cse_381 + _cse_382;
        let _cse_374 = vec2<f32>(_cse_375, _cse_380);
        let _cse_389 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_388 = _cse_389 - s_own_rho;
        let _cse_387 = _cse_388 * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(_cse_388) + 0.00000001);
        let _cse_386 = _cse_387 * max((s_neigh_rho - s_own_rho) * _cse_388, 0.0) / max(abs((s_neigh_rho - s_own_rho) * _cse_388), 0.00000001);
        let _cse_385 = s_own_rho + _cse_386;
        let _cse_373 = _cse_374 * 1.0 / _cse_385;
        let _cse_372 = dot(_cse_373, normal_vec);
        let _cse_396 = _cse_385 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001));
        let _cse_395 = constants.eos_gamma * _cse_396;
        let _cse_394 = _cse_395 / _cse_385;
        let _cse_393 = _cse_394 + constants.eos_dp_drho;
        let _cse_399 = _cse_372 * _cse_372;
        let _cse_398 = min(_cse_399, _cse_393);
        let _cse_397 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_398;
        let _cse_392 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_393 + _cse_397;
        let _cse_402 = max(_cse_399, low_mach_params.theta_floor * _cse_393);
        let _cse_401 = min(_cse_402, _cse_393);
        let _cse_400 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_401;
        let _cse_391 = _cse_392 + _cse_400;
        let _cse_390 = sqrt(_cse_391);
        let _cse_409 = _cse_379 * 0.625 + _cse_376 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_408 = _cse_409 - _cse_379;
        let _cse_407 = _cse_408 * abs(_cse_376 - _cse_379) / max(abs(_cse_376 - _cse_379), abs(_cse_408) + 0.00000001) * max((_cse_376 - _cse_379) * _cse_408, 0.0) / max(abs((_cse_376 - _cse_379) * _cse_408), 0.00000001);
        let _cse_406 = _cse_379 + _cse_407;
        let _cse_413 = _cse_384 * 0.625 + _cse_381 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_412 = _cse_413 - _cse_384;
        let _cse_411 = _cse_412 * abs(_cse_381 - _cse_384) / max(abs(_cse_381 - _cse_384), abs(_cse_412) + 0.00000001) * max((_cse_381 - _cse_384) * _cse_412, 0.0) / max(abs((_cse_381 - _cse_384) * _cse_412), 0.00000001);
        let _cse_410 = _cse_384 + _cse_411;
        let _cse_405 = vec2<f32>(_cse_406, _cse_410);
        let _cse_420 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_419 = _cse_420 * 0.125;
        let _cse_418 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_419;
        let _cse_417 = _cse_418 - s_neigh_rho;
        let _cse_416 = _cse_417 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_417) + 0.00000001);
        let _cse_422 = (s_own_rho - s_neigh_rho) * _cse_417;
        let _cse_421 = max(_cse_422, 0.0) / max(abs(_cse_422), 0.00000001);
        let _cse_415 = _cse_416 * _cse_421;
        let _cse_414 = s_neigh_rho + _cse_415;
        let _cse_404 = _cse_405 * 1.0 / _cse_414;
        let _cse_403 = dot(_cse_404, normal_vec);
        let _cse_429 = _cse_414 * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001));
        let _cse_428 = constants.eos_gamma * _cse_429;
        let _cse_427 = _cse_428 / _cse_414;
        let _cse_426 = _cse_427 + constants.eos_dp_drho;
        let _cse_432 = _cse_403 * _cse_403;
        let _cse_431 = min(_cse_432, _cse_426);
        let _cse_430 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_431;
        let _cse_425 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_426 + _cse_430;
        let _cse_435 = max(_cse_432, low_mach_params.theta_floor * _cse_426);
        let _cse_434 = min(_cse_435, _cse_426);
        let _cse_433 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_434;
        let _cse_424 = _cse_425 + _cse_433;
        let _cse_423 = sqrt(_cse_424);
        a_plus = max(0.0, max(_cse_372 + _cse_390, _cse_403 + _cse_423));
        a_minus = min(0.0, min(_cse_372 - _cse_390, _cse_403 - _cse_423));
    }
    let denom = max(a_plus - a_minus, 0.000001);
    let _cse_441 = f32(low_mach_params.model) - 2.0;
    let _cse_440 = abs(_cse_441);
    let _cse_439 = 1.0 - _cse_440;
    let _cse_438 = max(0.0, _cse_439);
    let _cse_437 = 1.0 - _cse_438;
    let _cse_436 = _cse_437 * low_mach_params.pressure_coupling_alpha;
    let _cse_442 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_443 = s_neigh_rho * constants.eos_r * s_neigh_T;
    var u_l_0: f32 = s_own_rho + _cse_436 * _cse_442 / max(constants.eos_gamma * _cse_442 / s_own_rho + constants.eos_dp_drho, 0.000000000001);
    var u_r_0: f32 = s_neigh_rho + _cse_436 * _cse_443 / max(constants.eos_gamma * _cse_443 / s_neigh_rho + constants.eos_dp_drho, 0.000000000001);
    var f_l_0: f32 = s_own_rho * dot(vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) * 1.0 / s_own_rho, normal_vec);
    var f_r_0: f32 = s_neigh_rho * dot(vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) * 1.0 / s_neigh_rho, normal_vec);
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_445 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_444 = s_own_rho + _cse_445;
        let _cse_451 = f32(low_mach_params.model) - 2.0;
        let _cse_450 = abs(_cse_451);
        let _cse_449 = 1.0 - _cse_450;
        let _cse_448 = max(0.0, _cse_449);
        let _cse_447 = 1.0 - _cse_448;
        let _cse_446 = _cse_447 * low_mach_params.pressure_coupling_alpha;
        let _cse_453 = _cse_444 * constants.eos_r;
        let _cse_455 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_454 = s_own_T + _cse_455;
        let _cse_452 = _cse_453 * _cse_454;
        let _cse_458 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_457 = dot(_cse_458, face_center_vec - c_neigh_cell_vec);
        let _cse_456 = s_neigh_rho + _cse_457;
        let _cse_460 = _cse_456 * constants.eos_r;
        let _cse_463 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_462 = dot(_cse_463, face_center_vec - c_neigh_cell_vec);
        let _cse_461 = s_neigh_T + _cse_462;
        let _cse_459 = _cse_460 * _cse_461;
        u_l_0 = _cse_444 + _cse_446 * _cse_452 / max(constants.eos_gamma * _cse_452 / _cse_444 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_456 + _cse_446 * _cse_459 / max(constants.eos_gamma * _cse_459 / _cse_456 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_444 * dot(vec2<f32>(s_own_rho_u_x + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), s_own_rho_u_y + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec)) * 1.0 / _cse_444, normal_vec);
        f_r_0 = _cse_456 * dot(vec2<f32>(s_neigh_rho_u_x + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), s_neigh_rho_u_y + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec)) * 1.0 / _cse_456, normal_vec);
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_467 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_469 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_468 = _cse_469 * 0.125;
        let _cse_466 = _cse_467 + _cse_468;
        let _cse_465 = _cse_466 - s_own_rho;
        let _cse_464 = s_own_rho + _cse_465;
        let _cse_475 = f32(low_mach_params.model) - 2.0;
        let _cse_474 = abs(_cse_475);
        let _cse_473 = 1.0 - _cse_474;
        let _cse_472 = max(0.0, _cse_473);
        let _cse_471 = 1.0 - _cse_472;
        let _cse_470 = _cse_471 * low_mach_params.pressure_coupling_alpha;
        let _cse_477 = _cse_464 * constants.eos_r;
        let _cse_481 = s_own_T * 0.625 + s_neigh_T * 0.375;
        let _cse_483 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_482 = _cse_483 * 0.125;
        let _cse_480 = _cse_481 + _cse_482;
        let _cse_479 = _cse_480 - s_own_T;
        let _cse_478 = s_own_T + _cse_479;
        let _cse_476 = _cse_477 * _cse_478;
        let _cse_487 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_490 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_489 = dot(_cse_490, c_owner_vec - c_neigh_cell_vec);
        let _cse_488 = _cse_489 * 0.125;
        let _cse_486 = _cse_487 + _cse_488;
        let _cse_485 = _cse_486 - s_neigh_rho;
        let _cse_484 = s_neigh_rho + _cse_485;
        let _cse_492 = _cse_484 * constants.eos_r;
        let _cse_496 = s_neigh_T * 0.625 + s_own_T * 0.375;
        let _cse_499 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_498 = dot(_cse_499, c_owner_vec - c_neigh_cell_vec);
        let _cse_497 = _cse_498 * 0.125;
        let _cse_495 = _cse_496 + _cse_497;
        let _cse_494 = _cse_495 - s_neigh_T;
        let _cse_493 = s_neigh_T + _cse_494;
        let _cse_491 = _cse_492 * _cse_493;
        let _cse_500 = s_own_rho_u_x;
        let _cse_501 = s_neigh_rho_u_x;
        let _cse_502 = s_own_rho_u_y;
        let _cse_503 = s_neigh_rho_u_y;
        u_l_0 = _cse_464 + _cse_470 * _cse_476 / max(constants.eos_gamma * _cse_476 / _cse_464 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_484 + _cse_470 * _cse_491 / max(constants.eos_gamma * _cse_491 / _cse_484 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_464 * dot(vec2<f32>(_cse_500 + _cse_500 * 0.625 + _cse_501 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_500, _cse_502 + _cse_502 * 0.625 + _cse_503 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_502) * 1.0 / _cse_464, normal_vec);
        f_r_0 = _cse_484 * dot(vec2<f32>(_cse_501 + _cse_501 * 0.625 + _cse_500 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_501, _cse_503 + _cse_503 * 0.625 + _cse_502 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_503) * 1.0 / _cse_484, normal_vec);
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_507 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_508 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_506 = max(_cse_507, _cse_508);
        let _cse_509 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_505 = min(_cse_506, _cse_509);
        let _cse_504 = s_own_rho + _cse_505;
        let _cse_515 = f32(low_mach_params.model) - 2.0;
        let _cse_514 = abs(_cse_515);
        let _cse_513 = 1.0 - _cse_514;
        let _cse_512 = max(0.0, _cse_513);
        let _cse_511 = 1.0 - _cse_512;
        let _cse_510 = _cse_511 * low_mach_params.pressure_coupling_alpha;
        let _cse_517 = _cse_504 * constants.eos_r;
        let _cse_521 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_522 = min(s_neigh_T - s_own_T, 0.0);
        let _cse_520 = max(_cse_521, _cse_522);
        let _cse_523 = max(s_neigh_T - s_own_T, 0.0);
        let _cse_519 = min(_cse_520, _cse_523);
        let _cse_518 = s_own_T + _cse_519;
        let _cse_516 = _cse_517 * _cse_518;
        let _cse_528 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_527 = dot(_cse_528, face_center_vec - c_neigh_cell_vec);
        let _cse_529 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_526 = max(_cse_527, _cse_529);
        let _cse_530 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_525 = min(_cse_526, _cse_530);
        let _cse_524 = s_neigh_rho + _cse_525;
        let _cse_532 = _cse_524 * constants.eos_r;
        let _cse_537 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_536 = dot(_cse_537, face_center_vec - c_neigh_cell_vec);
        let _cse_538 = min(s_own_T - s_neigh_T, 0.0);
        let _cse_535 = max(_cse_536, _cse_538);
        let _cse_539 = max(s_own_T - s_neigh_T, 0.0);
        let _cse_534 = min(_cse_535, _cse_539);
        let _cse_533 = s_neigh_T + _cse_534;
        let _cse_531 = _cse_532 * _cse_533;
        let _cse_540 = s_own_rho_u_x;
        let _cse_542 = s_neigh_rho_u_x;
        let _cse_541 = _cse_542 - _cse_540;
        let _cse_543 = s_own_rho_u_y;
        let _cse_545 = s_neigh_rho_u_y;
        let _cse_544 = _cse_545 - _cse_543;
        let _cse_546 = _cse_540 - _cse_542;
        let _cse_547 = _cse_543 - _cse_545;
        u_l_0 = _cse_504 + _cse_510 * _cse_516 / max(constants.eos_gamma * _cse_516 / _cse_504 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_524 + _cse_510 * _cse_531 / max(constants.eos_gamma * _cse_531 / _cse_524 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_504 * dot(vec2<f32>(_cse_540 + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), min(_cse_541, 0.0)), max(_cse_541, 0.0)), _cse_543 + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), min(_cse_544, 0.0)), max(_cse_544, 0.0))) * 1.0 / _cse_504, normal_vec);
        f_r_0 = _cse_524 * dot(vec2<f32>(_cse_542 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_546, 0.0)), max(_cse_546, 0.0)), _cse_545 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_547, 0.0)), max(_cse_547, 0.0))) * 1.0 / _cse_524, normal_vec);
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_559 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y));
        let _cse_558 = _cse_559 * (s_neigh_rho - s_own_rho);
        let _cse_561 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho);
        let _cse_560 = _cse_561 + 0.000000000000000000000000000001;
        let _cse_557 = _cse_558 / _cse_560;
        let _cse_556 = 2.0 * _cse_557;
        let _cse_555 = _cse_556 - 1.0;
        let _cse_554 = min(_cse_555, 1999.0);
        let _cse_553 = max(-2001.0, _cse_554);
        let _cse_562 = abs(_cse_553);
        let _cse_552 = _cse_553 + _cse_562;
        let _cse_563 = 1.0 + _cse_562;
        let _cse_551 = _cse_552 / _cse_563;
        let _cse_550 = _cse_551 * lambda_other;
        let _cse_549 = _cse_550 * (s_neigh_rho - s_own_rho);
        let _cse_548 = s_own_rho + _cse_549;
        let _cse_568 = 2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001);
        let _cse_567 = _cse_568 - 1.0;
        let _cse_566 = min(_cse_567, 1999.0);
        let _cse_565 = max(-2001.0, _cse_566);
        let _cse_564 = _cse_548 * constants.eos_r * (s_own_T + (_cse_565 + abs(_cse_565)) / (1.0 + abs(_cse_565)) * lambda_other * (s_neigh_T - s_own_T));
        let _cse_581 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_580 = dot(c_neigh_cell_vec - c_owner_vec, _cse_581);
        let _cse_579 = _cse_580 * (s_neigh_rho - s_own_rho);
        let _cse_578 = _cse_579 / _cse_560;
        let _cse_577 = 2.0 * _cse_578;
        let _cse_576 = _cse_577 - 1.0;
        let _cse_575 = min(_cse_576, 1999.0);
        let _cse_574 = max(-2001.0, _cse_575);
        let _cse_582 = abs(_cse_574);
        let _cse_573 = _cse_574 + _cse_582;
        let _cse_583 = 1.0 + _cse_582;
        let _cse_572 = _cse_573 / _cse_583;
        let _cse_571 = _cse_572 * lambda;
        let _cse_570 = _cse_571 * (s_neigh_rho - s_own_rho);
        let _cse_569 = s_neigh_rho - _cse_570;
        let _cse_585 = _cse_569 * constants.eos_r;
        let _cse_594 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001);
        let _cse_593 = 2.0 * _cse_594;
        let _cse_592 = _cse_593 - 1.0;
        let _cse_591 = min(_cse_592, 1999.0);
        let _cse_590 = max(-2001.0, _cse_591);
        let _cse_595 = abs(_cse_590);
        let _cse_589 = (_cse_590 + _cse_595) / (1.0 + _cse_595);
        let _cse_588 = _cse_589 * lambda;
        let _cse_587 = _cse_588 * (s_neigh_T - s_own_T);
        let _cse_586 = s_neigh_T - _cse_587;
        let _cse_584 = _cse_585 * _cse_586;
        let _cse_596 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_602 = dot(_cse_596, _cse_596);
        let _cse_604 = _cse_602 * _cse_602;
        let _cse_603 = _cse_604 + 0.000000000000000000000000000001;
        let _cse_601 = dot(_cse_596, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_602 / _cse_603;
        let _cse_600 = 2.0 * _cse_601;
        let _cse_599 = _cse_600 - 1.0;
        let _cse_598 = min(_cse_599, 1999.0);
        let _cse_597 = max(-2001.0, _cse_598);
        let _cse_610 = dot(_cse_596, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))))) * _cse_602;
        let _cse_609 = _cse_610 / _cse_603;
        let _cse_608 = 2.0 * _cse_609;
        let _cse_607 = _cse_608 - 1.0;
        let _cse_606 = min(_cse_607, 1999.0);
        let _cse_605 = max(-2001.0, _cse_606);
        let _cse_611 = abs(_cse_605);
        u_l_0 = _cse_548 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_564 / max(constants.eos_gamma * _cse_564 / _cse_548 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_569 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_584 / max(constants.eos_gamma * _cse_584 / _cse_569 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_548 * dot((vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_596 * (_cse_597 + abs(_cse_597)) / (1.0 + abs(_cse_597)) * lambda_other) * 1.0 / _cse_548, normal_vec);
        f_r_0 = _cse_569 * dot((vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_596 * (_cse_605 + _cse_611) / (1.0 + _cse_611) * lambda) * 1.0 / _cse_569, normal_vec);
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_617 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_619 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_618 = _cse_619 * 0.125;
        let _cse_616 = _cse_617 + _cse_618;
        let _cse_615 = _cse_616 - s_own_rho;
        let _cse_620 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_614 = max(_cse_615, _cse_620);
        let _cse_621 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_613 = min(_cse_614, _cse_621);
        let _cse_612 = s_own_rho + _cse_613;
        let _cse_627 = f32(low_mach_params.model) - 2.0;
        let _cse_626 = abs(_cse_627);
        let _cse_625 = 1.0 - _cse_626;
        let _cse_624 = max(0.0, _cse_625);
        let _cse_623 = 1.0 - _cse_624;
        let _cse_622 = _cse_623 * low_mach_params.pressure_coupling_alpha;
        let _cse_629 = _cse_612 * constants.eos_r;
        let _cse_635 = s_own_T * 0.625 + s_neigh_T * 0.375;
        let _cse_637 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_636 = _cse_637 * 0.125;
        let _cse_634 = _cse_635 + _cse_636;
        let _cse_633 = _cse_634 - s_own_T;
        let _cse_638 = min(s_neigh_T - s_own_T, 0.0);
        let _cse_632 = max(_cse_633, _cse_638);
        let _cse_639 = max(s_neigh_T - s_own_T, 0.0);
        let _cse_631 = min(_cse_632, _cse_639);
        let _cse_630 = s_own_T + _cse_631;
        let _cse_628 = _cse_629 * _cse_630;
        let _cse_645 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_648 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_647 = dot(_cse_648, c_owner_vec - c_neigh_cell_vec);
        let _cse_646 = _cse_647 * 0.125;
        let _cse_644 = _cse_645 + _cse_646;
        let _cse_643 = _cse_644 - s_neigh_rho;
        let _cse_649 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_642 = max(_cse_643, _cse_649);
        let _cse_650 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_641 = min(_cse_642, _cse_650);
        let _cse_640 = s_neigh_rho + _cse_641;
        let _cse_652 = _cse_640 * constants.eos_r;
        let _cse_658 = s_neigh_T * 0.625 + s_own_T * 0.375;
        let _cse_661 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_660 = dot(_cse_661, c_owner_vec - c_neigh_cell_vec);
        let _cse_659 = _cse_660 * 0.125;
        let _cse_657 = _cse_658 + _cse_659;
        let _cse_656 = _cse_657 - s_neigh_T;
        let _cse_662 = min(s_own_T - s_neigh_T, 0.0);
        let _cse_655 = max(_cse_656, _cse_662);
        let _cse_663 = max(s_own_T - s_neigh_T, 0.0);
        let _cse_654 = min(_cse_655, _cse_663);
        let _cse_653 = s_neigh_T + _cse_654;
        let _cse_651 = _cse_652 * _cse_653;
        let _cse_664 = s_own_rho_u_x;
        let _cse_665 = s_neigh_rho_u_x;
        let _cse_666 = _cse_665 - _cse_664;
        let _cse_667 = s_own_rho_u_y;
        let _cse_668 = s_neigh_rho_u_y;
        let _cse_669 = _cse_668 - _cse_667;
        let _cse_670 = _cse_664 - _cse_665;
        let _cse_671 = _cse_667 - _cse_668;
        u_l_0 = _cse_612 + _cse_622 * _cse_628 / max(constants.eos_gamma * _cse_628 / _cse_612 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_640 + _cse_622 * _cse_651 / max(constants.eos_gamma * _cse_651 / _cse_640 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_612 * dot(vec2<f32>(_cse_664 + min(max(_cse_664 * 0.625 + _cse_665 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_664, min(_cse_666, 0.0)), max(_cse_666, 0.0)), _cse_667 + min(max(_cse_667 * 0.625 + _cse_668 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_667, min(_cse_669, 0.0)), max(_cse_669, 0.0))) * 1.0 / _cse_612, normal_vec);
        f_r_0 = _cse_640 * dot(vec2<f32>(_cse_665 + min(max(_cse_665 * 0.625 + _cse_664 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_665, min(_cse_670, 0.0)), max(_cse_670, 0.0)), _cse_668 + min(max(_cse_668 * 0.625 + _cse_667 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_668, min(_cse_671, 0.0)), max(_cse_671, 0.0))) * 1.0 / _cse_640, normal_vec);
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_677 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_679 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_678 = _cse_679 * 0.125;
        let _cse_676 = _cse_677 + _cse_678;
        let _cse_675 = _cse_676 - s_own_rho;
        let _cse_683 = abs(_cse_675);
        let _cse_682 = _cse_683 + 0.00000001;
        let _cse_681 = max(abs(s_neigh_rho - s_own_rho), _cse_682);
        let _cse_680 = abs(s_neigh_rho - s_own_rho) / _cse_681;
        let _cse_674 = _cse_675 * _cse_680;
        let _cse_686 = (s_neigh_rho - s_own_rho) * _cse_675;
        let _cse_685 = max(_cse_686, 0.0);
        let _cse_688 = abs(_cse_686);
        let _cse_687 = max(_cse_688, 0.00000001);
        let _cse_684 = _cse_685 / _cse_687;
        let _cse_673 = _cse_674 * _cse_684;
        let _cse_672 = s_own_rho + _cse_673;
        let _cse_690 = _cse_672 * constants.eos_r;
        let _cse_694 = s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_693 = _cse_694 - s_own_T;
        let _cse_692 = _cse_693 * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(_cse_693) + 0.00000001) * max((s_neigh_T - s_own_T) * _cse_693, 0.0) / max(abs((s_neigh_T - s_own_T) * _cse_693), 0.00000001);
        let _cse_691 = s_own_T + _cse_692;
        let _cse_689 = _cse_690 * _cse_691;
        let _cse_700 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_703 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_702 = dot(_cse_703, c_owner_vec - c_neigh_cell_vec);
        let _cse_701 = _cse_702 * 0.125;
        let _cse_699 = _cse_700 + _cse_701;
        let _cse_698 = _cse_699 - s_neigh_rho;
        let _cse_707 = abs(_cse_698);
        let _cse_706 = _cse_707 + 0.00000001;
        let _cse_705 = max(abs(s_own_rho - s_neigh_rho), _cse_706);
        let _cse_704 = abs(s_own_rho - s_neigh_rho) / _cse_705;
        let _cse_697 = _cse_698 * _cse_704;
        let _cse_710 = (s_own_rho - s_neigh_rho) * _cse_698;
        let _cse_709 = max(_cse_710, 0.0);
        let _cse_712 = abs(_cse_710);
        let _cse_711 = max(_cse_712, 0.00000001);
        let _cse_708 = _cse_709 / _cse_711;
        let _cse_696 = _cse_697 * _cse_708;
        let _cse_695 = s_neigh_rho + _cse_696;
        let _cse_714 = _cse_695 * constants.eos_r;
        let _cse_721 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_720 = dot(_cse_721, c_owner_vec - c_neigh_cell_vec);
        let _cse_719 = _cse_720 * 0.125;
        let _cse_718 = s_neigh_T * 0.625 + s_own_T * 0.375 + _cse_719;
        let _cse_717 = _cse_718 - s_neigh_T;
        let _cse_722 = (s_own_T - s_neigh_T) * _cse_717;
        let _cse_716 = _cse_717 * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(_cse_717) + 0.00000001) * max(_cse_722, 0.0) / max(abs(_cse_722), 0.00000001);
        let _cse_715 = s_neigh_T + _cse_716;
        let _cse_713 = _cse_714 * _cse_715;
        let _cse_723 = s_own_rho_u_x;
        let _cse_726 = s_neigh_rho_u_x;
        let _cse_725 = _cse_723 * 0.625 + _cse_726 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_724 = _cse_725 - _cse_723;
        let _cse_727 = s_own_rho_u_y;
        let _cse_730 = s_neigh_rho_u_y;
        let _cse_729 = _cse_727 * 0.625 + _cse_730 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_728 = _cse_729 - _cse_727;
        let _cse_732 = _cse_726 * 0.625 + _cse_723 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_731 = _cse_732 - _cse_726;
        let _cse_733 = (_cse_723 - _cse_726) * _cse_731;
        let _cse_735 = _cse_730 * 0.625 + _cse_727 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_734 = _cse_735 - _cse_730;
        u_l_0 = _cse_672 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_689 / max(constants.eos_gamma * _cse_689 / _cse_672 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_695 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_713 / max(constants.eos_gamma * _cse_713 / _cse_695 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_672 * dot(vec2<f32>(_cse_723 + _cse_724 * abs(_cse_726 - _cse_723) / max(abs(_cse_726 - _cse_723), abs(_cse_724) + 0.00000001) * max((_cse_726 - _cse_723) * _cse_724, 0.0) / max(abs((_cse_726 - _cse_723) * _cse_724), 0.00000001), _cse_727 + _cse_728 * abs(_cse_730 - _cse_727) / max(abs(_cse_730 - _cse_727), abs(_cse_728) + 0.00000001) * max((_cse_730 - _cse_727) * _cse_728, 0.0) / max(abs((_cse_730 - _cse_727) * _cse_728), 0.00000001)) * 1.0 / _cse_672, normal_vec);
        f_r_0 = _cse_695 * dot(vec2<f32>(_cse_726 + _cse_731 * abs(_cse_723 - _cse_726) / max(abs(_cse_723 - _cse_726), abs(_cse_731) + 0.00000001) * max(_cse_733, 0.0) / max(abs(_cse_733), 0.00000001), _cse_730 + _cse_734 * abs(_cse_727 - _cse_730) / max(abs(_cse_727 - _cse_730), abs(_cse_734) + 0.00000001) * max((_cse_727 - _cse_730) * _cse_734, 0.0) / max(abs((_cse_727 - _cse_730) * _cse_734), 0.00000001)) * 1.0 / _cse_695, normal_vec);
    }
    fluxes[idx * 8u + 0u] = (a_plus * f_l_0 - a_minus * f_r_0 + a_plus * a_minus * (u_r_0 - u_l_0)) / denom * area;
    let _cse_738 = s_own_rho_u_x;
    let _cse_739 = s_own_rho_u_y;
    let _cse_737 = vec2<f32>(_cse_738, _cse_739);
    let _cse_736 = _cse_737.x;
    let _cse_742 = s_neigh_rho_u_x;
    let _cse_743 = s_neigh_rho_u_y;
    let _cse_741 = vec2<f32>(_cse_742, _cse_743);
    let _cse_740 = _cse_741.x;
    let _cse_744 = normal_vec.x;
    let _cse_752 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
    let _cse_751 = _cse_752 * lambda;
    let _cse_753 = vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
    let _cse_750 = _cse_751 + _cse_753;
    let _cse_749 = _cse_750.x;
    let _cse_759 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
    let _cse_758 = _cse_759 * lambda;
    let _cse_760 = vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
    let _cse_757 = _cse_758 + _cse_760;
    let _cse_756 = _cse_757.y;
    let _cse_755 = _cse_749 + _cse_756;
    let _cse_754 = 0.6666667 * _cse_755;
    let _cse_748 = _cse_749 - _cse_754;
    let _cse_747 = _cse_748 * _cse_744;
    let _cse_762 = _cse_757.x;
    let _cse_763 = normal_vec.y;
    let _cse_761 = _cse_762 * _cse_763;
    let _cse_746 = _cse_747 + _cse_761;
    let _cse_745 = constants.viscosity * _cse_746;
    var u_l_1: f32 = _cse_736;
    var u_r_1: f32 = _cse_740;
    var f_l_1: f32 = _cse_736 * dot(_cse_737 * 1.0 / s_own_rho, normal_vec) + s_own_rho * constants.eos_r * s_own_T * _cse_744 - _cse_745;
    var f_r_1: f32 = _cse_740 * dot(_cse_741 * 1.0 / s_neigh_rho, normal_vec) + s_neigh_rho * constants.eos_r * s_neigh_T * _cse_744 - _cse_745;
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_767 = s_own_rho_u_x;
        let _cse_768 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_766 = _cse_767 + _cse_768;
        let _cse_770 = s_own_rho_u_y;
        let _cse_771 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_769 = _cse_770 + _cse_771;
        let _cse_765 = vec2<f32>(_cse_766, _cse_769);
        let _cse_764 = _cse_765.x;
        let _cse_775 = s_neigh_rho_u_x;
        let _cse_777 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_776 = dot(_cse_777, face_center_vec - c_neigh_cell_vec);
        let _cse_774 = _cse_775 + _cse_776;
        let _cse_779 = s_neigh_rho_u_y;
        let _cse_781 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_780 = dot(_cse_781, face_center_vec - c_neigh_cell_vec);
        let _cse_778 = _cse_779 + _cse_780;
        let _cse_773 = vec2<f32>(_cse_774, _cse_778);
        let _cse_772 = _cse_773.x;
        let _cse_783 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_782 = s_own_rho + _cse_783;
        let _cse_784 = normal_vec.x;
        let _cse_792 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_791 = _cse_792 * lambda;
        let _cse_793 = vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_790 = _cse_791 + _cse_793;
        let _cse_789 = _cse_790.x;
        let _cse_799 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_798 = _cse_799 * lambda;
        let _cse_800 = vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_797 = _cse_798 + _cse_800;
        let _cse_796 = _cse_797.y;
        let _cse_795 = _cse_789 + _cse_796;
        let _cse_794 = 0.6666667 * _cse_795;
        let _cse_788 = _cse_789 - _cse_794;
        let _cse_787 = _cse_788 * _cse_784;
        let _cse_802 = _cse_797.x;
        let _cse_803 = normal_vec.y;
        let _cse_801 = _cse_802 * _cse_803;
        let _cse_786 = _cse_787 + _cse_801;
        let _cse_785 = constants.viscosity * _cse_786;
        let _cse_806 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_805 = dot(_cse_806, face_center_vec - c_neigh_cell_vec);
        let _cse_804 = s_neigh_rho + _cse_805;
        u_l_1 = _cse_764;
        u_r_1 = _cse_772;
        f_l_1 = _cse_764 * dot(_cse_765 * 1.0 / _cse_782, normal_vec) + _cse_782 * constants.eos_r * (s_own_T + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec)) * _cse_784 - _cse_785;
        f_r_1 = _cse_772 * dot(_cse_773 * 1.0 / _cse_804, normal_vec) + _cse_804 * constants.eos_r * (s_neigh_T + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec)) * _cse_784 - _cse_785;
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_810 = s_own_rho_u_x;
        let _cse_814 = _cse_810 * 0.625;
        let _cse_816 = s_neigh_rho_u_x;
        let _cse_815 = _cse_816 * 0.375;
        let _cse_813 = _cse_814 + _cse_815;
        let _cse_817 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_812 = _cse_813 + _cse_817;
        let _cse_811 = _cse_812 - _cse_810;
        let _cse_809 = _cse_810 + _cse_811;
        let _cse_819 = s_own_rho_u_y;
        let _cse_823 = _cse_819 * 0.625;
        let _cse_825 = s_neigh_rho_u_y;
        let _cse_824 = _cse_825 * 0.375;
        let _cse_822 = _cse_823 + _cse_824;
        let _cse_826 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_821 = _cse_822 + _cse_826;
        let _cse_820 = _cse_821 - _cse_819;
        let _cse_818 = _cse_819 + _cse_820;
        let _cse_808 = vec2<f32>(_cse_809, _cse_818);
        let _cse_807 = _cse_808.x;
        let _cse_833 = _cse_816 * 0.625;
        let _cse_834 = _cse_810 * 0.375;
        let _cse_832 = _cse_833 + _cse_834;
        let _cse_837 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_836 = dot(_cse_837, c_owner_vec - c_neigh_cell_vec);
        let _cse_835 = _cse_836 * 0.125;
        let _cse_831 = _cse_832 + _cse_835;
        let _cse_830 = _cse_831 - _cse_816;
        let _cse_829 = _cse_816 + _cse_830;
        let _cse_842 = _cse_825 * 0.625;
        let _cse_843 = _cse_819 * 0.375;
        let _cse_841 = _cse_842 + _cse_843;
        let _cse_846 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_845 = dot(_cse_846, c_owner_vec - c_neigh_cell_vec);
        let _cse_844 = _cse_845 * 0.125;
        let _cse_840 = _cse_841 + _cse_844;
        let _cse_839 = _cse_840 - _cse_825;
        let _cse_838 = _cse_825 + _cse_839;
        let _cse_828 = vec2<f32>(_cse_829, _cse_838);
        let _cse_827 = _cse_828.x;
        let _cse_849 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_848 = _cse_849 - s_own_rho;
        let _cse_847 = s_own_rho + _cse_848;
        let _cse_850 = normal_vec.x;
        let _cse_858 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_857 = _cse_858 * lambda;
        let _cse_856 = _cse_857 + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_855 = _cse_856.x;
        let _cse_864 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_863 = _cse_864 * lambda;
        let _cse_862 = _cse_863 + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_861 = _cse_862.y;
        let _cse_860 = _cse_855 + _cse_861;
        let _cse_859 = 0.6666667 * _cse_860;
        let _cse_854 = _cse_855 - _cse_859;
        let _cse_853 = _cse_854 * _cse_850;
        let _cse_866 = _cse_862.x;
        let _cse_865 = _cse_866 * normal_vec.y;
        let _cse_852 = _cse_853 + _cse_865;
        let _cse_851 = constants.viscosity * _cse_852;
        let _cse_870 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_869 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_870;
        let _cse_868 = _cse_869 - s_neigh_rho;
        let _cse_867 = s_neigh_rho + _cse_868;
        u_l_1 = _cse_807;
        u_r_1 = _cse_827;
        f_l_1 = _cse_807 * dot(_cse_808 * 1.0 / _cse_847, normal_vec) + _cse_847 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * _cse_850 - _cse_851;
        f_r_1 = _cse_827 * dot(_cse_828 * 1.0 / _cse_867, normal_vec) + _cse_867 * constants.eos_r * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * _cse_850 - _cse_851;
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_874 = s_own_rho_u_x;
        let _cse_877 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_880 = s_neigh_rho_u_x;
        let _cse_879 = _cse_880 - _cse_874;
        let _cse_878 = min(_cse_879, 0.0);
        let _cse_876 = max(_cse_877, _cse_878);
        let _cse_881 = max(_cse_879, 0.0);
        let _cse_875 = min(_cse_876, _cse_881);
        let _cse_873 = _cse_874 + _cse_875;
        let _cse_883 = s_own_rho_u_y;
        let _cse_886 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_889 = s_neigh_rho_u_y;
        let _cse_888 = _cse_889 - _cse_883;
        let _cse_887 = min(_cse_888, 0.0);
        let _cse_885 = max(_cse_886, _cse_887);
        let _cse_890 = max(_cse_888, 0.0);
        let _cse_884 = min(_cse_885, _cse_890);
        let _cse_882 = _cse_883 + _cse_884;
        let _cse_872 = vec2<f32>(_cse_873, _cse_882);
        let _cse_871 = _cse_872.x;
        let _cse_897 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_896 = dot(_cse_897, face_center_vec - c_neigh_cell_vec);
        let _cse_899 = _cse_874 - _cse_880;
        let _cse_898 = min(_cse_899, 0.0);
        let _cse_895 = max(_cse_896, _cse_898);
        let _cse_900 = max(_cse_899, 0.0);
        let _cse_894 = min(_cse_895, _cse_900);
        let _cse_893 = _cse_880 + _cse_894;
        let _cse_905 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_904 = dot(_cse_905, face_center_vec - c_neigh_cell_vec);
        let _cse_907 = _cse_883 - _cse_889;
        let _cse_906 = min(_cse_907, 0.0);
        let _cse_903 = max(_cse_904, _cse_906);
        let _cse_908 = max(_cse_907, 0.0);
        let _cse_902 = min(_cse_903, _cse_908);
        let _cse_901 = _cse_889 + _cse_902;
        let _cse_892 = vec2<f32>(_cse_893, _cse_901);
        let _cse_891 = _cse_892.x;
        let _cse_911 = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec), min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_910 = min(_cse_911, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_909 = s_own_rho + _cse_910;
        let _cse_912 = normal_vec.x;
        let _cse_920 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_919 = _cse_920 * lambda;
        let _cse_921 = vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_918 = _cse_919 + _cse_921;
        let _cse_917 = _cse_918.x;
        let _cse_927 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_926 = _cse_927 * lambda;
        let _cse_928 = vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_925 = _cse_926 + _cse_928;
        let _cse_924 = _cse_925.y;
        let _cse_923 = _cse_917 + _cse_924;
        let _cse_922 = 0.6666667 * _cse_923;
        let _cse_916 = _cse_917 - _cse_922;
        let _cse_915 = _cse_916 * _cse_912;
        let _cse_930 = _cse_925.x;
        let _cse_929 = _cse_930 * normal_vec.y;
        let _cse_914 = _cse_915 + _cse_929;
        let _cse_913 = constants.viscosity * _cse_914;
        let _cse_934 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_933 = max(_cse_934, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_932 = min(_cse_933, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_931 = s_neigh_rho + _cse_932;
        u_l_1 = _cse_871;
        u_r_1 = _cse_891;
        f_l_1 = _cse_871 * dot(_cse_872 * 1.0 / _cse_909, normal_vec) + _cse_909 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * _cse_912 - _cse_913;
        f_r_1 = _cse_891 * dot(_cse_892 * 1.0 / _cse_931, normal_vec) + _cse_931 * constants.eos_r * (s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * _cse_912 - _cse_913;
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_938 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_949 = vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_948 = dot(_cse_938, _cse_949);
        let _cse_950 = dot(_cse_938, _cse_938);
        let _cse_947 = _cse_948 * _cse_950;
        let _cse_952 = _cse_950 * _cse_950;
        let _cse_951 = _cse_952 + 0.000000000000000000000000000001;
        let _cse_946 = _cse_947 / _cse_951;
        let _cse_945 = 2.0 * _cse_946;
        let _cse_944 = _cse_945 - 1.0;
        let _cse_943 = min(_cse_944, 1999.0);
        let _cse_942 = max(-2001.0, _cse_943);
        let _cse_953 = abs(_cse_942);
        let _cse_941 = _cse_942 + _cse_953;
        let _cse_954 = 1.0 + _cse_953;
        let _cse_940 = _cse_941 / _cse_954;
        let _cse_939 = _cse_940 * lambda_other;
        let _cse_937 = _cse_938 * _cse_939;
        let _cse_936 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_937;
        let _cse_935 = _cse_936.x;
        let _cse_970 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_969 = dot(c_neigh_cell_vec - c_owner_vec, _cse_970);
        let _cse_972 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_971 = dot(c_neigh_cell_vec - c_owner_vec, _cse_972);
        let _cse_968 = vec2<f32>(_cse_969, _cse_971);
        let _cse_967 = dot(_cse_938, _cse_968);
        let _cse_966 = _cse_967 * _cse_950;
        let _cse_965 = _cse_966 / _cse_951;
        let _cse_964 = 2.0 * _cse_965;
        let _cse_963 = _cse_964 - 1.0;
        let _cse_962 = min(_cse_963, 1999.0);
        let _cse_961 = max(-2001.0, _cse_962);
        let _cse_973 = abs(_cse_961);
        let _cse_960 = _cse_961 + _cse_973;
        let _cse_974 = 1.0 + _cse_973;
        let _cse_959 = _cse_960 / _cse_974;
        let _cse_958 = _cse_959 * lambda;
        let _cse_957 = _cse_938 * _cse_958;
        let _cse_956 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_957;
        let _cse_955 = _cse_956.x;
        let _cse_984 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001;
        let _cse_983 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / _cse_984;
        let _cse_982 = 2.0 * _cse_983;
        let _cse_981 = _cse_982 - 1.0;
        let _cse_980 = min(_cse_981, 1999.0);
        let _cse_979 = max(-2001.0, _cse_980);
        let _cse_985 = abs(_cse_979);
        let _cse_978 = (_cse_979 + _cse_985) / (1.0 + _cse_985);
        let _cse_977 = _cse_978 * lambda_other;
        let _cse_976 = _cse_977 * (s_neigh_rho - s_own_rho);
        let _cse_975 = s_own_rho + _cse_976;
        let _cse_987 = (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x - 0.6666667 * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y)) * normal_vec.x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).x * normal_vec.y;
        let _cse_986 = constants.viscosity * _cse_987;
        let _cse_997 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho);
        let _cse_996 = _cse_997 / _cse_984;
        let _cse_995 = 2.0 * _cse_996;
        let _cse_994 = _cse_995 - 1.0;
        let _cse_993 = min(_cse_994, 1999.0);
        let _cse_992 = max(-2001.0, _cse_993);
        let _cse_998 = abs(_cse_992);
        let _cse_991 = (_cse_992 + _cse_998) / (1.0 + _cse_998);
        let _cse_990 = _cse_991 * lambda;
        let _cse_989 = _cse_990 * (s_neigh_rho - s_own_rho);
        let _cse_988 = s_neigh_rho - _cse_989;
        u_l_1 = _cse_935;
        u_r_1 = _cse_955;
        f_l_1 = _cse_935 * dot(_cse_936 * 1.0 / _cse_975, normal_vec) + _cse_975 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) * normal_vec.x - _cse_986;
        f_r_1 = _cse_955 * dot(_cse_956 * 1.0 / _cse_988, normal_vec) + _cse_988 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) * normal_vec.x - _cse_986;
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_1002 = s_own_rho_u_x;
        let _cse_1008 = s_neigh_rho_u_x;
        let _cse_1007 = _cse_1002 * 0.625 + _cse_1008 * 0.375;
        let _cse_1006 = _cse_1007 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1005 = _cse_1006 - _cse_1002;
        let _cse_1010 = _cse_1008 - _cse_1002;
        let _cse_1009 = min(_cse_1010, 0.0);
        let _cse_1004 = max(_cse_1005, _cse_1009);
        let _cse_1011 = max(_cse_1010, 0.0);
        let _cse_1003 = min(_cse_1004, _cse_1011);
        let _cse_1001 = _cse_1002 + _cse_1003;
        let _cse_1013 = s_own_rho_u_y;
        let _cse_1019 = s_neigh_rho_u_y;
        let _cse_1018 = _cse_1013 * 0.625 + _cse_1019 * 0.375;
        let _cse_1017 = _cse_1018 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1016 = _cse_1017 - _cse_1013;
        let _cse_1021 = _cse_1019 - _cse_1013;
        let _cse_1020 = min(_cse_1021, 0.0);
        let _cse_1015 = max(_cse_1016, _cse_1020);
        let _cse_1022 = max(_cse_1021, 0.0);
        let _cse_1014 = min(_cse_1015, _cse_1022);
        let _cse_1012 = _cse_1013 + _cse_1014;
        let _cse_1000 = vec2<f32>(_cse_1001, _cse_1012);
        let _cse_999 = _cse_1000.x;
        let _cse_1030 = _cse_1008 * 0.625 + _cse_1002 * 0.375;
        let _cse_1031 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1029 = _cse_1030 + _cse_1031;
        let _cse_1028 = _cse_1029 - _cse_1008;
        let _cse_1033 = _cse_1002 - _cse_1008;
        let _cse_1032 = min(_cse_1033, 0.0);
        let _cse_1027 = max(_cse_1028, _cse_1032);
        let _cse_1034 = max(_cse_1033, 0.0);
        let _cse_1026 = min(_cse_1027, _cse_1034);
        let _cse_1025 = _cse_1008 + _cse_1026;
        let _cse_1040 = _cse_1019 * 0.625 + _cse_1013 * 0.375;
        let _cse_1041 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1039 = _cse_1040 + _cse_1041;
        let _cse_1038 = _cse_1039 - _cse_1019;
        let _cse_1043 = _cse_1013 - _cse_1019;
        let _cse_1042 = min(_cse_1043, 0.0);
        let _cse_1037 = max(_cse_1038, _cse_1042);
        let _cse_1044 = max(_cse_1043, 0.0);
        let _cse_1036 = min(_cse_1037, _cse_1044);
        let _cse_1035 = _cse_1019 + _cse_1036;
        let _cse_1024 = vec2<f32>(_cse_1025, _cse_1035);
        let _cse_1023 = _cse_1024.x;
        let _cse_1046 = min(max(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho, min(s_neigh_rho - s_own_rho, 0.0)), max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1045 = s_own_rho + _cse_1046;
        let _cse_1054 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_1053 = _cse_1054 * lambda;
        let _cse_1052 = _cse_1053 + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_1051 = _cse_1052.x;
        let _cse_1059 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_1058 = _cse_1059 * lambda;
        let _cse_1057 = _cse_1058 + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_1056 = _cse_1051 + _cse_1057.y;
        let _cse_1055 = 0.6666667 * _cse_1056;
        let _cse_1050 = _cse_1051 - _cse_1055;
        let _cse_1049 = _cse_1050 * normal_vec.x;
        let _cse_1048 = _cse_1049 + _cse_1057.x * normal_vec.y;
        let _cse_1047 = constants.viscosity * _cse_1048;
        let _cse_1062 = max(s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1061 = min(_cse_1062, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1060 = s_neigh_rho + _cse_1061;
        u_l_1 = _cse_999;
        u_r_1 = _cse_1023;
        f_l_1 = _cse_999 * dot(_cse_1000 * 1.0 / _cse_1045, normal_vec) + _cse_1045 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * normal_vec.x - _cse_1047;
        f_r_1 = _cse_1023 * dot(_cse_1024 * 1.0 / _cse_1060, normal_vec) + _cse_1060 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * normal_vec.x - _cse_1047;
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_1066 = s_own_rho_u_x;
        let _cse_1072 = s_neigh_rho_u_x;
        let _cse_1071 = _cse_1066 * 0.625 + _cse_1072 * 0.375;
        let _cse_1070 = _cse_1071 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1069 = _cse_1070 - _cse_1066;
        let _cse_1074 = _cse_1072 - _cse_1066;
        let _cse_1075 = max(abs(_cse_1074), abs(_cse_1069) + 0.00000001);
        let _cse_1073 = abs(_cse_1074) / _cse_1075;
        let _cse_1068 = _cse_1069 * _cse_1073;
        let _cse_1077 = _cse_1074 * _cse_1069;
        let _cse_1076 = max(_cse_1077, 0.0) / max(abs(_cse_1077), 0.00000001);
        let _cse_1067 = _cse_1068 * _cse_1076;
        let _cse_1065 = _cse_1066 + _cse_1067;
        let _cse_1079 = s_own_rho_u_y;
        let _cse_1085 = s_neigh_rho_u_y;
        let _cse_1084 = _cse_1079 * 0.625 + _cse_1085 * 0.375;
        let _cse_1083 = _cse_1084 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1082 = _cse_1083 - _cse_1079;
        let _cse_1087 = _cse_1085 - _cse_1079;
        let _cse_1088 = max(abs(_cse_1087), abs(_cse_1082) + 0.00000001);
        let _cse_1086 = abs(_cse_1087) / _cse_1088;
        let _cse_1081 = _cse_1082 * _cse_1086;
        let _cse_1090 = _cse_1087 * _cse_1082;
        let _cse_1089 = max(_cse_1090, 0.0) / max(abs(_cse_1090), 0.00000001);
        let _cse_1080 = _cse_1081 * _cse_1089;
        let _cse_1078 = _cse_1079 + _cse_1080;
        let _cse_1064 = vec2<f32>(_cse_1065, _cse_1078);
        let _cse_1063 = _cse_1064.x;
        let _cse_1098 = _cse_1072 * 0.625 + _cse_1066 * 0.375;
        let _cse_1100 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1099 = _cse_1100 * 0.125;
        let _cse_1097 = _cse_1098 + _cse_1099;
        let _cse_1096 = _cse_1097 - _cse_1072;
        let _cse_1102 = _cse_1066 - _cse_1072;
        let _cse_1103 = max(abs(_cse_1102), abs(_cse_1096) + 0.00000001);
        let _cse_1101 = abs(_cse_1102) / _cse_1103;
        let _cse_1095 = _cse_1096 * _cse_1101;
        let _cse_1106 = _cse_1102 * _cse_1096;
        let _cse_1105 = max(_cse_1106, 0.0);
        let _cse_1108 = abs(_cse_1106);
        let _cse_1107 = max(_cse_1108, 0.00000001);
        let _cse_1104 = _cse_1105 / _cse_1107;
        let _cse_1094 = _cse_1095 * _cse_1104;
        let _cse_1093 = _cse_1072 + _cse_1094;
        let _cse_1114 = _cse_1085 * 0.625 + _cse_1079 * 0.375;
        let _cse_1116 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1115 = _cse_1116 * 0.125;
        let _cse_1113 = _cse_1114 + _cse_1115;
        let _cse_1112 = _cse_1113 - _cse_1085;
        let _cse_1118 = _cse_1079 - _cse_1085;
        let _cse_1119 = max(abs(_cse_1118), abs(_cse_1112) + 0.00000001);
        let _cse_1117 = abs(_cse_1118) / _cse_1119;
        let _cse_1111 = _cse_1112 * _cse_1117;
        let _cse_1122 = _cse_1118 * _cse_1112;
        let _cse_1121 = max(_cse_1122, 0.0);
        let _cse_1124 = abs(_cse_1122);
        let _cse_1123 = max(_cse_1124, 0.00000001);
        let _cse_1120 = _cse_1121 / _cse_1123;
        let _cse_1110 = _cse_1111 * _cse_1120;
        let _cse_1109 = _cse_1085 + _cse_1110;
        let _cse_1092 = vec2<f32>(_cse_1093, _cse_1109);
        let _cse_1091 = _cse_1092.x;
        let _cse_1126 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1125 = _cse_1126 - s_neigh_rho;
        u_l_1 = _cse_1063;
        u_r_1 = _cse_1091;
        f_l_1 = _cse_1063 * dot(_cse_1064 * 1.0 / (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)), normal_vec) + (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)) * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) * normal_vec.x - constants.viscosity * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x - 0.6666667 * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y)) * normal_vec.x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).x * normal_vec.y);
        f_r_1 = _cse_1091 * dot(_cse_1092 * 1.0 / (s_neigh_rho + _cse_1125 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1125) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1125, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1125), 0.00000001)), normal_vec) + (s_neigh_rho + _cse_1125 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1125) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1125, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1125), 0.00000001)) * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001)) * normal_vec.x - constants.viscosity * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x - 0.6666667 * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y)) * normal_vec.x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).x * normal_vec.y);
    }
    fluxes[idx * 8u + 1u] = (a_plus * f_l_1 - a_minus * f_r_1 + a_plus * a_minus * (u_r_1 - u_l_1)) / denom * area;
    let _cse_1129 = s_own_rho_u_x;
    let _cse_1130 = s_own_rho_u_y;
    let _cse_1128 = vec2<f32>(_cse_1129, _cse_1130);
    let _cse_1127 = _cse_1128.y;
    let _cse_1133 = s_neigh_rho_u_x;
    let _cse_1134 = s_neigh_rho_u_y;
    let _cse_1132 = vec2<f32>(_cse_1133, _cse_1134);
    let _cse_1131 = _cse_1132.y;
    let _cse_1135 = normal_vec.y;
    let _cse_1142 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
    let _cse_1141 = _cse_1142 * lambda;
    let _cse_1143 = vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
    let _cse_1140 = _cse_1141 + _cse_1143;
    let _cse_1139 = _cse_1140.y;
    let _cse_1144 = normal_vec.x;
    let _cse_1138 = _cse_1139 * _cse_1144;
    let _cse_1150 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
    let _cse_1149 = _cse_1150 * lambda;
    let _cse_1151 = vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
    let _cse_1148 = _cse_1149 + _cse_1151;
    let _cse_1147 = _cse_1148.y;
    let _cse_1154 = _cse_1140.x;
    let _cse_1153 = _cse_1154 + _cse_1147;
    let _cse_1152 = 0.6666667 * _cse_1153;
    let _cse_1146 = _cse_1147 - _cse_1152;
    let _cse_1145 = _cse_1146 * _cse_1135;
    let _cse_1137 = _cse_1138 + _cse_1145;
    let _cse_1136 = constants.viscosity * _cse_1137;
    var u_l_2: f32 = _cse_1127;
    var u_r_2: f32 = _cse_1131;
    var f_l_2: f32 = _cse_1127 * dot(_cse_1128 * 1.0 / s_own_rho, normal_vec) + s_own_rho * constants.eos_r * s_own_T * _cse_1135 - _cse_1136;
    var f_r_2: f32 = _cse_1131 * dot(_cse_1132 * 1.0 / s_neigh_rho, normal_vec) + s_neigh_rho * constants.eos_r * s_neigh_T * _cse_1135 - _cse_1136;
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_1158 = s_own_rho_u_x;
        let _cse_1159 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_1157 = _cse_1158 + _cse_1159;
        let _cse_1161 = s_own_rho_u_y;
        let _cse_1162 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_1160 = _cse_1161 + _cse_1162;
        let _cse_1156 = vec2<f32>(_cse_1157, _cse_1160);
        let _cse_1155 = _cse_1156.y;
        let _cse_1166 = s_neigh_rho_u_x;
        let _cse_1168 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1167 = dot(_cse_1168, face_center_vec - c_neigh_cell_vec);
        let _cse_1165 = _cse_1166 + _cse_1167;
        let _cse_1170 = s_neigh_rho_u_y;
        let _cse_1172 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1171 = dot(_cse_1172, face_center_vec - c_neigh_cell_vec);
        let _cse_1169 = _cse_1170 + _cse_1171;
        let _cse_1164 = vec2<f32>(_cse_1165, _cse_1169);
        let _cse_1163 = _cse_1164.y;
        let _cse_1174 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1173 = s_own_rho + _cse_1174;
        let _cse_1175 = normal_vec.y;
        let _cse_1182 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_1181 = _cse_1182 * lambda;
        let _cse_1183 = vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_1180 = _cse_1181 + _cse_1183;
        let _cse_1179 = _cse_1180.y;
        let _cse_1184 = normal_vec.x;
        let _cse_1178 = _cse_1179 * _cse_1184;
        let _cse_1190 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_1189 = _cse_1190 * lambda;
        let _cse_1191 = vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_1188 = _cse_1189 + _cse_1191;
        let _cse_1187 = _cse_1188.y;
        let _cse_1194 = _cse_1180.x;
        let _cse_1193 = _cse_1194 + _cse_1187;
        let _cse_1192 = 0.6666667 * _cse_1193;
        let _cse_1186 = _cse_1187 - _cse_1192;
        let _cse_1185 = _cse_1186 * _cse_1175;
        let _cse_1177 = _cse_1178 + _cse_1185;
        let _cse_1176 = constants.viscosity * _cse_1177;
        let _cse_1197 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1196 = dot(_cse_1197, face_center_vec - c_neigh_cell_vec);
        let _cse_1195 = s_neigh_rho + _cse_1196;
        u_l_2 = _cse_1155;
        u_r_2 = _cse_1163;
        f_l_2 = _cse_1155 * dot(_cse_1156 * 1.0 / _cse_1173, normal_vec) + _cse_1173 * constants.eos_r * (s_own_T + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec)) * _cse_1175 - _cse_1176;
        f_r_2 = _cse_1163 * dot(_cse_1164 * 1.0 / _cse_1195, normal_vec) + _cse_1195 * constants.eos_r * (s_neigh_T + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec)) * _cse_1175 - _cse_1176;
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_1201 = s_own_rho_u_x;
        let _cse_1205 = _cse_1201 * 0.625;
        let _cse_1207 = s_neigh_rho_u_x;
        let _cse_1206 = _cse_1207 * 0.375;
        let _cse_1204 = _cse_1205 + _cse_1206;
        let _cse_1208 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1203 = _cse_1204 + _cse_1208;
        let _cse_1202 = _cse_1203 - _cse_1201;
        let _cse_1200 = _cse_1201 + _cse_1202;
        let _cse_1210 = s_own_rho_u_y;
        let _cse_1214 = _cse_1210 * 0.625;
        let _cse_1216 = s_neigh_rho_u_y;
        let _cse_1215 = _cse_1216 * 0.375;
        let _cse_1213 = _cse_1214 + _cse_1215;
        let _cse_1217 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1212 = _cse_1213 + _cse_1217;
        let _cse_1211 = _cse_1212 - _cse_1210;
        let _cse_1209 = _cse_1210 + _cse_1211;
        let _cse_1199 = vec2<f32>(_cse_1200, _cse_1209);
        let _cse_1198 = _cse_1199.y;
        let _cse_1224 = _cse_1207 * 0.625;
        let _cse_1225 = _cse_1201 * 0.375;
        let _cse_1223 = _cse_1224 + _cse_1225;
        let _cse_1228 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1227 = dot(_cse_1228, c_owner_vec - c_neigh_cell_vec);
        let _cse_1226 = _cse_1227 * 0.125;
        let _cse_1222 = _cse_1223 + _cse_1226;
        let _cse_1221 = _cse_1222 - _cse_1207;
        let _cse_1220 = _cse_1207 + _cse_1221;
        let _cse_1233 = _cse_1216 * 0.625;
        let _cse_1234 = _cse_1210 * 0.375;
        let _cse_1232 = _cse_1233 + _cse_1234;
        let _cse_1237 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1236 = dot(_cse_1237, c_owner_vec - c_neigh_cell_vec);
        let _cse_1235 = _cse_1236 * 0.125;
        let _cse_1231 = _cse_1232 + _cse_1235;
        let _cse_1230 = _cse_1231 - _cse_1216;
        let _cse_1229 = _cse_1216 + _cse_1230;
        let _cse_1219 = vec2<f32>(_cse_1220, _cse_1229);
        let _cse_1218 = _cse_1219.y;
        let _cse_1240 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1239 = _cse_1240 - s_own_rho;
        let _cse_1238 = s_own_rho + _cse_1239;
        let _cse_1241 = normal_vec.y;
        let _cse_1248 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_1247 = _cse_1248 * lambda;
        let _cse_1246 = _cse_1247 + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_1245 = _cse_1246.y;
        let _cse_1244 = _cse_1245 * normal_vec.x;
        let _cse_1254 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_1253 = _cse_1254 * lambda;
        let _cse_1252 = _cse_1253 + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_1251 = _cse_1252.y;
        let _cse_1257 = _cse_1246.x;
        let _cse_1256 = _cse_1257 + _cse_1251;
        let _cse_1255 = 0.6666667 * _cse_1256;
        let _cse_1250 = _cse_1251 - _cse_1255;
        let _cse_1249 = _cse_1250 * _cse_1241;
        let _cse_1243 = _cse_1244 + _cse_1249;
        let _cse_1242 = constants.viscosity * _cse_1243;
        let _cse_1261 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1260 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_1261;
        let _cse_1259 = _cse_1260 - s_neigh_rho;
        let _cse_1258 = s_neigh_rho + _cse_1259;
        u_l_2 = _cse_1198;
        u_r_2 = _cse_1218;
        f_l_2 = _cse_1198 * dot(_cse_1199 * 1.0 / _cse_1238, normal_vec) + _cse_1238 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * _cse_1241 - _cse_1242;
        f_r_2 = _cse_1218 * dot(_cse_1219 * 1.0 / _cse_1258, normal_vec) + _cse_1258 * constants.eos_r * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * _cse_1241 - _cse_1242;
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_1265 = s_own_rho_u_x;
        let _cse_1268 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_1271 = s_neigh_rho_u_x;
        let _cse_1270 = _cse_1271 - _cse_1265;
        let _cse_1269 = min(_cse_1270, 0.0);
        let _cse_1267 = max(_cse_1268, _cse_1269);
        let _cse_1272 = max(_cse_1270, 0.0);
        let _cse_1266 = min(_cse_1267, _cse_1272);
        let _cse_1264 = _cse_1265 + _cse_1266;
        let _cse_1274 = s_own_rho_u_y;
        let _cse_1277 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_1280 = s_neigh_rho_u_y;
        let _cse_1279 = _cse_1280 - _cse_1274;
        let _cse_1278 = min(_cse_1279, 0.0);
        let _cse_1276 = max(_cse_1277, _cse_1278);
        let _cse_1281 = max(_cse_1279, 0.0);
        let _cse_1275 = min(_cse_1276, _cse_1281);
        let _cse_1273 = _cse_1274 + _cse_1275;
        let _cse_1263 = vec2<f32>(_cse_1264, _cse_1273);
        let _cse_1262 = _cse_1263.y;
        let _cse_1288 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1287 = dot(_cse_1288, face_center_vec - c_neigh_cell_vec);
        let _cse_1290 = _cse_1265 - _cse_1271;
        let _cse_1289 = min(_cse_1290, 0.0);
        let _cse_1286 = max(_cse_1287, _cse_1289);
        let _cse_1291 = max(_cse_1290, 0.0);
        let _cse_1285 = min(_cse_1286, _cse_1291);
        let _cse_1284 = _cse_1271 + _cse_1285;
        let _cse_1296 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1295 = dot(_cse_1296, face_center_vec - c_neigh_cell_vec);
        let _cse_1298 = _cse_1274 - _cse_1280;
        let _cse_1297 = min(_cse_1298, 0.0);
        let _cse_1294 = max(_cse_1295, _cse_1297);
        let _cse_1299 = max(_cse_1298, 0.0);
        let _cse_1293 = min(_cse_1294, _cse_1299);
        let _cse_1292 = _cse_1280 + _cse_1293;
        let _cse_1283 = vec2<f32>(_cse_1284, _cse_1292);
        let _cse_1282 = _cse_1283.y;
        let _cse_1302 = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec), min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1301 = min(_cse_1302, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1300 = s_own_rho + _cse_1301;
        let _cse_1303 = normal_vec.y;
        let _cse_1310 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_1309 = _cse_1310 * lambda;
        let _cse_1311 = vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_1308 = _cse_1309 + _cse_1311;
        let _cse_1307 = _cse_1308.y;
        let _cse_1306 = _cse_1307 * normal_vec.x;
        let _cse_1317 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_1316 = _cse_1317 * lambda;
        let _cse_1318 = vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_1315 = _cse_1316 + _cse_1318;
        let _cse_1314 = _cse_1315.y;
        let _cse_1321 = _cse_1308.x;
        let _cse_1320 = _cse_1321 + _cse_1314;
        let _cse_1319 = 0.6666667 * _cse_1320;
        let _cse_1313 = _cse_1314 - _cse_1319;
        let _cse_1312 = _cse_1313 * _cse_1303;
        let _cse_1305 = _cse_1306 + _cse_1312;
        let _cse_1304 = constants.viscosity * _cse_1305;
        let _cse_1325 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_1324 = max(_cse_1325, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1323 = min(_cse_1324, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1322 = s_neigh_rho + _cse_1323;
        u_l_2 = _cse_1262;
        u_r_2 = _cse_1282;
        f_l_2 = _cse_1262 * dot(_cse_1263 * 1.0 / _cse_1300, normal_vec) + _cse_1300 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * _cse_1303 - _cse_1304;
        f_r_2 = _cse_1282 * dot(_cse_1283 * 1.0 / _cse_1322, normal_vec) + _cse_1322 * constants.eos_r * (s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * _cse_1303 - _cse_1304;
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_1329 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_1340 = vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_1339 = dot(_cse_1329, _cse_1340);
        let _cse_1341 = dot(_cse_1329, _cse_1329);
        let _cse_1338 = _cse_1339 * _cse_1341;
        let _cse_1343 = _cse_1341 * _cse_1341;
        let _cse_1342 = _cse_1343 + 0.000000000000000000000000000001;
        let _cse_1337 = _cse_1338 / _cse_1342;
        let _cse_1336 = 2.0 * _cse_1337;
        let _cse_1335 = _cse_1336 - 1.0;
        let _cse_1334 = min(_cse_1335, 1999.0);
        let _cse_1333 = max(-2001.0, _cse_1334);
        let _cse_1344 = abs(_cse_1333);
        let _cse_1332 = _cse_1333 + _cse_1344;
        let _cse_1345 = 1.0 + _cse_1344;
        let _cse_1331 = _cse_1332 / _cse_1345;
        let _cse_1330 = _cse_1331 * lambda_other;
        let _cse_1328 = _cse_1329 * _cse_1330;
        let _cse_1327 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_1328;
        let _cse_1326 = _cse_1327.y;
        let _cse_1361 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1360 = dot(c_neigh_cell_vec - c_owner_vec, _cse_1361);
        let _cse_1363 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1362 = dot(c_neigh_cell_vec - c_owner_vec, _cse_1363);
        let _cse_1359 = vec2<f32>(_cse_1360, _cse_1362);
        let _cse_1358 = dot(_cse_1329, _cse_1359);
        let _cse_1357 = _cse_1358 * _cse_1341;
        let _cse_1356 = _cse_1357 / _cse_1342;
        let _cse_1355 = 2.0 * _cse_1356;
        let _cse_1354 = _cse_1355 - 1.0;
        let _cse_1353 = min(_cse_1354, 1999.0);
        let _cse_1352 = max(-2001.0, _cse_1353);
        let _cse_1364 = abs(_cse_1352);
        let _cse_1351 = _cse_1352 + _cse_1364;
        let _cse_1365 = 1.0 + _cse_1364;
        let _cse_1350 = _cse_1351 / _cse_1365;
        let _cse_1349 = _cse_1350 * lambda;
        let _cse_1348 = _cse_1329 * _cse_1349;
        let _cse_1347 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_1348;
        let _cse_1346 = _cse_1347.y;
        let _cse_1375 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001;
        let _cse_1374 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / _cse_1375;
        let _cse_1373 = 2.0 * _cse_1374;
        let _cse_1372 = _cse_1373 - 1.0;
        let _cse_1371 = min(_cse_1372, 1999.0);
        let _cse_1370 = max(-2001.0, _cse_1371);
        let _cse_1376 = abs(_cse_1370);
        let _cse_1369 = (_cse_1370 + _cse_1376) / (1.0 + _cse_1376);
        let _cse_1368 = _cse_1369 * lambda_other;
        let _cse_1367 = _cse_1368 * (s_neigh_rho - s_own_rho);
        let _cse_1366 = s_own_rho + _cse_1367;
        let _cse_1378 = ((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).y * normal_vec.x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y - 0.6666667 * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y)) * normal_vec.y;
        let _cse_1377 = constants.viscosity * _cse_1378;
        let _cse_1388 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho);
        let _cse_1387 = _cse_1388 / _cse_1375;
        let _cse_1386 = 2.0 * _cse_1387;
        let _cse_1385 = _cse_1386 - 1.0;
        let _cse_1384 = min(_cse_1385, 1999.0);
        let _cse_1383 = max(-2001.0, _cse_1384);
        let _cse_1389 = abs(_cse_1383);
        let _cse_1382 = (_cse_1383 + _cse_1389) / (1.0 + _cse_1389);
        let _cse_1381 = _cse_1382 * lambda;
        let _cse_1380 = _cse_1381 * (s_neigh_rho - s_own_rho);
        let _cse_1379 = s_neigh_rho - _cse_1380;
        u_l_2 = _cse_1326;
        u_r_2 = _cse_1346;
        f_l_2 = _cse_1326 * dot(_cse_1327 * 1.0 / _cse_1366, normal_vec) + _cse_1366 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) * normal_vec.y - _cse_1377;
        f_r_2 = _cse_1346 * dot(_cse_1347 * 1.0 / _cse_1379, normal_vec) + _cse_1379 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) * normal_vec.y - _cse_1377;
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_1393 = s_own_rho_u_x;
        let _cse_1399 = s_neigh_rho_u_x;
        let _cse_1398 = _cse_1393 * 0.625 + _cse_1399 * 0.375;
        let _cse_1397 = _cse_1398 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1396 = _cse_1397 - _cse_1393;
        let _cse_1401 = _cse_1399 - _cse_1393;
        let _cse_1400 = min(_cse_1401, 0.0);
        let _cse_1395 = max(_cse_1396, _cse_1400);
        let _cse_1402 = max(_cse_1401, 0.0);
        let _cse_1394 = min(_cse_1395, _cse_1402);
        let _cse_1392 = _cse_1393 + _cse_1394;
        let _cse_1404 = s_own_rho_u_y;
        let _cse_1410 = s_neigh_rho_u_y;
        let _cse_1409 = _cse_1404 * 0.625 + _cse_1410 * 0.375;
        let _cse_1408 = _cse_1409 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1407 = _cse_1408 - _cse_1404;
        let _cse_1412 = _cse_1410 - _cse_1404;
        let _cse_1411 = min(_cse_1412, 0.0);
        let _cse_1406 = max(_cse_1407, _cse_1411);
        let _cse_1413 = max(_cse_1412, 0.0);
        let _cse_1405 = min(_cse_1406, _cse_1413);
        let _cse_1403 = _cse_1404 + _cse_1405;
        let _cse_1391 = vec2<f32>(_cse_1392, _cse_1403);
        let _cse_1390 = _cse_1391.y;
        let _cse_1421 = _cse_1399 * 0.625 + _cse_1393 * 0.375;
        let _cse_1422 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1420 = _cse_1421 + _cse_1422;
        let _cse_1419 = _cse_1420 - _cse_1399;
        let _cse_1424 = _cse_1393 - _cse_1399;
        let _cse_1423 = min(_cse_1424, 0.0);
        let _cse_1418 = max(_cse_1419, _cse_1423);
        let _cse_1425 = max(_cse_1424, 0.0);
        let _cse_1417 = min(_cse_1418, _cse_1425);
        let _cse_1416 = _cse_1399 + _cse_1417;
        let _cse_1431 = _cse_1410 * 0.625 + _cse_1404 * 0.375;
        let _cse_1432 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1430 = _cse_1431 + _cse_1432;
        let _cse_1429 = _cse_1430 - _cse_1410;
        let _cse_1434 = _cse_1404 - _cse_1410;
        let _cse_1433 = min(_cse_1434, 0.0);
        let _cse_1428 = max(_cse_1429, _cse_1433);
        let _cse_1435 = max(_cse_1434, 0.0);
        let _cse_1427 = min(_cse_1428, _cse_1435);
        let _cse_1426 = _cse_1410 + _cse_1427;
        let _cse_1415 = vec2<f32>(_cse_1416, _cse_1426);
        let _cse_1414 = _cse_1415.y;
        let _cse_1437 = min(max(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho, min(s_neigh_rho - s_own_rho, 0.0)), max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1436 = s_own_rho + _cse_1437;
        let _cse_1442 = vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary));
        let _cse_1441 = _cse_1442 * lambda;
        let _cse_1440 = _cse_1441 + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other;
        let _cse_1448 = vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary));
        let _cse_1447 = _cse_1448 * lambda;
        let _cse_1446 = _cse_1447 + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other;
        let _cse_1445 = _cse_1446.y;
        let _cse_1450 = _cse_1440.x + _cse_1445;
        let _cse_1449 = 0.6666667 * _cse_1450;
        let _cse_1444 = _cse_1445 - _cse_1449;
        let _cse_1443 = _cse_1444 * normal_vec.y;
        let _cse_1439 = _cse_1440.y * normal_vec.x + _cse_1443;
        let _cse_1438 = constants.viscosity * _cse_1439;
        let _cse_1453 = max(s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1452 = min(_cse_1453, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1451 = s_neigh_rho + _cse_1452;
        u_l_2 = _cse_1390;
        u_r_2 = _cse_1414;
        f_l_2 = _cse_1390 * dot(_cse_1391 * 1.0 / _cse_1436, normal_vec) + _cse_1436 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * normal_vec.y - _cse_1438;
        f_r_2 = _cse_1414 * dot(_cse_1415 * 1.0 / _cse_1451, normal_vec) + _cse_1451 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * normal_vec.y - _cse_1438;
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_1457 = s_own_rho_u_x;
        let _cse_1463 = s_neigh_rho_u_x;
        let _cse_1462 = _cse_1457 * 0.625 + _cse_1463 * 0.375;
        let _cse_1461 = _cse_1462 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1460 = _cse_1461 - _cse_1457;
        let _cse_1465 = _cse_1463 - _cse_1457;
        let _cse_1466 = max(abs(_cse_1465), abs(_cse_1460) + 0.00000001);
        let _cse_1464 = abs(_cse_1465) / _cse_1466;
        let _cse_1459 = _cse_1460 * _cse_1464;
        let _cse_1468 = _cse_1465 * _cse_1460;
        let _cse_1467 = max(_cse_1468, 0.0) / max(abs(_cse_1468), 0.00000001);
        let _cse_1458 = _cse_1459 * _cse_1467;
        let _cse_1456 = _cse_1457 + _cse_1458;
        let _cse_1470 = s_own_rho_u_y;
        let _cse_1476 = s_neigh_rho_u_y;
        let _cse_1475 = _cse_1470 * 0.625 + _cse_1476 * 0.375;
        let _cse_1474 = _cse_1475 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1473 = _cse_1474 - _cse_1470;
        let _cse_1478 = _cse_1476 - _cse_1470;
        let _cse_1479 = max(abs(_cse_1478), abs(_cse_1473) + 0.00000001);
        let _cse_1477 = abs(_cse_1478) / _cse_1479;
        let _cse_1472 = _cse_1473 * _cse_1477;
        let _cse_1481 = _cse_1478 * _cse_1473;
        let _cse_1480 = max(_cse_1481, 0.0) / max(abs(_cse_1481), 0.00000001);
        let _cse_1471 = _cse_1472 * _cse_1480;
        let _cse_1469 = _cse_1470 + _cse_1471;
        let _cse_1455 = vec2<f32>(_cse_1456, _cse_1469);
        let _cse_1454 = _cse_1455.y;
        let _cse_1489 = _cse_1463 * 0.625 + _cse_1457 * 0.375;
        let _cse_1491 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1490 = _cse_1491 * 0.125;
        let _cse_1488 = _cse_1489 + _cse_1490;
        let _cse_1487 = _cse_1488 - _cse_1463;
        let _cse_1493 = _cse_1457 - _cse_1463;
        let _cse_1494 = max(abs(_cse_1493), abs(_cse_1487) + 0.00000001);
        let _cse_1492 = abs(_cse_1493) / _cse_1494;
        let _cse_1486 = _cse_1487 * _cse_1492;
        let _cse_1497 = _cse_1493 * _cse_1487;
        let _cse_1496 = max(_cse_1497, 0.0);
        let _cse_1499 = abs(_cse_1497);
        let _cse_1498 = max(_cse_1499, 0.00000001);
        let _cse_1495 = _cse_1496 / _cse_1498;
        let _cse_1485 = _cse_1486 * _cse_1495;
        let _cse_1484 = _cse_1463 + _cse_1485;
        let _cse_1505 = _cse_1476 * 0.625 + _cse_1470 * 0.375;
        let _cse_1507 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1506 = _cse_1507 * 0.125;
        let _cse_1504 = _cse_1505 + _cse_1506;
        let _cse_1503 = _cse_1504 - _cse_1476;
        let _cse_1509 = _cse_1470 - _cse_1476;
        let _cse_1510 = max(abs(_cse_1509), abs(_cse_1503) + 0.00000001);
        let _cse_1508 = abs(_cse_1509) / _cse_1510;
        let _cse_1502 = _cse_1503 * _cse_1508;
        let _cse_1513 = _cse_1509 * _cse_1503;
        let _cse_1512 = max(_cse_1513, 0.0);
        let _cse_1515 = abs(_cse_1513);
        let _cse_1514 = max(_cse_1515, 0.00000001);
        let _cse_1511 = _cse_1512 / _cse_1514;
        let _cse_1501 = _cse_1502 * _cse_1511;
        let _cse_1500 = _cse_1476 + _cse_1501;
        let _cse_1483 = vec2<f32>(_cse_1484, _cse_1500);
        let _cse_1482 = _cse_1483.y;
        let _cse_1517 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1516 = _cse_1517 - s_neigh_rho;
        u_l_2 = _cse_1454;
        u_r_2 = _cse_1482;
        f_l_2 = _cse_1454 * dot(_cse_1455 * 1.0 / (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)), normal_vec) + (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)) * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) * normal_vec.y - constants.viscosity * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).y * normal_vec.x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y - 0.6666667 * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y)) * normal_vec.y);
        f_r_2 = _cse_1482 * dot(_cse_1483 * 1.0 / (s_neigh_rho + _cse_1516 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1516) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1516, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1516), 0.00000001)), normal_vec) + (s_neigh_rho + _cse_1516 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1516) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1516, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1516), 0.00000001)) * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001)) * normal_vec.y - constants.viscosity * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).y * normal_vec.x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y - 0.6666667 * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y)) * normal_vec.y);
    }
    fluxes[idx * 8u + 2u] = (a_plus * f_l_2 - a_minus * f_r_2 + a_plus * a_minus * (u_r_2 - u_l_2)) / denom * area;
    let _cse_1520 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_1519 = _cse_1520 / max(constants.eos_gm1, 0.000000000001);
    let _cse_1525 = s_own_rho_u_x;
    let _cse_1526 = s_own_rho_u_y;
    let _cse_1524 = vec2<f32>(_cse_1525, _cse_1526);
    let _cse_1523 = _cse_1524 * 1.0 / s_own_rho;
    let _cse_1522 = dot(_cse_1523, _cse_1523);
    let _cse_1521 = 0.5 * s_own_rho * _cse_1522;
    let _cse_1518 = _cse_1519 + _cse_1521;
    let _cse_1529 = s_neigh_rho * constants.eos_r * s_neigh_T;
    let _cse_1528 = _cse_1529 / max(constants.eos_gm1, 0.000000000001);
    let _cse_1534 = s_neigh_rho_u_x;
    let _cse_1535 = s_neigh_rho_u_y;
    let _cse_1533 = vec2<f32>(_cse_1534, _cse_1535);
    let _cse_1532 = _cse_1533 * 1.0 / s_neigh_rho;
    let _cse_1531 = dot(_cse_1532, _cse_1532);
    let _cse_1530 = 0.5 * s_neigh_rho * _cse_1531;
    let _cse_1527 = _cse_1528 + _cse_1530;
    var u_l_3: f32 = _cse_1518;
    var u_r_3: f32 = _cse_1527;
    var f_l_3: f32 = (_cse_1518 + _cse_1520) * dot(_cse_1523, normal_vec);
    var f_r_3: f32 = (_cse_1527 + _cse_1529) * dot(_cse_1532, normal_vec);
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_1541 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1540 = s_own_rho + _cse_1541;
        let _cse_1539 = _cse_1540 * constants.eos_r;
        let _cse_1543 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_1542 = s_own_T + _cse_1543;
        let _cse_1538 = _cse_1539 * _cse_1542;
        let _cse_1537 = _cse_1538 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1545 = 0.5 * _cse_1540;
        let _cse_1550 = s_own_rho_u_x;
        let _cse_1551 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_1549 = _cse_1550 + _cse_1551;
        let _cse_1553 = s_own_rho_u_y;
        let _cse_1554 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_1552 = _cse_1553 + _cse_1554;
        let _cse_1548 = vec2<f32>(_cse_1549, _cse_1552);
        let _cse_1555 = 1.0 / _cse_1540;
        let _cse_1547 = _cse_1548 * _cse_1555;
        let _cse_1546 = dot(_cse_1547, _cse_1547);
        let _cse_1544 = _cse_1545 * _cse_1546;
        let _cse_1536 = _cse_1537 + _cse_1544;
        let _cse_1562 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1561 = dot(_cse_1562, face_center_vec - c_neigh_cell_vec);
        let _cse_1560 = s_neigh_rho + _cse_1561;
        let _cse_1559 = _cse_1560 * constants.eos_r;
        let _cse_1565 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_1564 = dot(_cse_1565, face_center_vec - c_neigh_cell_vec);
        let _cse_1563 = s_neigh_T + _cse_1564;
        let _cse_1558 = _cse_1559 * _cse_1563;
        let _cse_1557 = _cse_1558 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1567 = 0.5 * _cse_1560;
        let _cse_1572 = s_neigh_rho_u_x;
        let _cse_1574 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1573 = dot(_cse_1574, face_center_vec - c_neigh_cell_vec);
        let _cse_1571 = _cse_1572 + _cse_1573;
        let _cse_1576 = s_neigh_rho_u_y;
        let _cse_1578 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1577 = dot(_cse_1578, face_center_vec - c_neigh_cell_vec);
        let _cse_1575 = _cse_1576 + _cse_1577;
        let _cse_1570 = vec2<f32>(_cse_1571, _cse_1575);
        let _cse_1579 = 1.0 / _cse_1560;
        let _cse_1569 = _cse_1570 * _cse_1579;
        let _cse_1568 = dot(_cse_1569, _cse_1569);
        let _cse_1566 = _cse_1567 * _cse_1568;
        let _cse_1556 = _cse_1557 + _cse_1566;
        u_l_3 = _cse_1536;
        u_r_3 = _cse_1556;
        f_l_3 = (_cse_1536 + _cse_1538) * dot(_cse_1547, normal_vec);
        f_r_3 = (_cse_1556 + _cse_1558) * dot(_cse_1569, normal_vec);
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_1587 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_1589 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_1588 = _cse_1589 * 0.125;
        let _cse_1586 = _cse_1587 + _cse_1588;
        let _cse_1585 = _cse_1586 - s_own_rho;
        let _cse_1584 = s_own_rho + _cse_1585;
        let _cse_1583 = _cse_1584 * constants.eos_r;
        let _cse_1582 = _cse_1583 * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T);
        let _cse_1581 = _cse_1582 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1595 = s_own_rho_u_x;
        let _cse_1599 = _cse_1595 * 0.625;
        let _cse_1601 = s_neigh_rho_u_x;
        let _cse_1600 = _cse_1601 * 0.375;
        let _cse_1598 = _cse_1599 + _cse_1600;
        let _cse_1597 = _cse_1598 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1596 = _cse_1597 - _cse_1595;
        let _cse_1594 = _cse_1595 + _cse_1596;
        let _cse_1603 = s_own_rho_u_y;
        let _cse_1607 = _cse_1603 * 0.625;
        let _cse_1609 = s_neigh_rho_u_y;
        let _cse_1608 = _cse_1609 * 0.375;
        let _cse_1606 = _cse_1607 + _cse_1608;
        let _cse_1605 = _cse_1606 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1604 = _cse_1605 - _cse_1603;
        let _cse_1602 = _cse_1603 + _cse_1604;
        let _cse_1593 = vec2<f32>(_cse_1594, _cse_1602);
        let _cse_1610 = 1.0 / _cse_1584;
        let _cse_1592 = _cse_1593 * _cse_1610;
        let _cse_1591 = dot(_cse_1592, _cse_1592);
        let _cse_1590 = 0.5 * _cse_1584 * _cse_1591;
        let _cse_1580 = _cse_1581 + _cse_1590;
        let _cse_1618 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_1621 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1620 = dot(_cse_1621, c_owner_vec - c_neigh_cell_vec);
        let _cse_1619 = _cse_1620 * 0.125;
        let _cse_1617 = _cse_1618 + _cse_1619;
        let _cse_1616 = _cse_1617 - s_neigh_rho;
        let _cse_1615 = s_neigh_rho + _cse_1616;
        let _cse_1614 = _cse_1615 * constants.eos_r;
        let _cse_1624 = s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1623 = _cse_1624 - s_neigh_T;
        let _cse_1622 = s_neigh_T + _cse_1623;
        let _cse_1613 = _cse_1614 * _cse_1622;
        let _cse_1612 = _cse_1613 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1633 = _cse_1601 * 0.625;
        let _cse_1634 = _cse_1595 * 0.375;
        let _cse_1632 = _cse_1633 + _cse_1634;
        let _cse_1636 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1635 = _cse_1636 * 0.125;
        let _cse_1631 = _cse_1632 + _cse_1635;
        let _cse_1630 = _cse_1631 - _cse_1601;
        let _cse_1629 = _cse_1601 + _cse_1630;
        let _cse_1640 = _cse_1609 * 0.625 + _cse_1603 * 0.375;
        let _cse_1642 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1641 = _cse_1642 * 0.125;
        let _cse_1639 = _cse_1640 + _cse_1641;
        let _cse_1638 = _cse_1639 - _cse_1609;
        let _cse_1637 = _cse_1609 + _cse_1638;
        let _cse_1628 = vec2<f32>(_cse_1629, _cse_1637);
        let _cse_1643 = 1.0 / _cse_1615;
        let _cse_1627 = _cse_1628 * _cse_1643;
        let _cse_1626 = dot(_cse_1627, _cse_1627);
        let _cse_1625 = 0.5 * _cse_1615 * _cse_1626;
        let _cse_1611 = _cse_1612 + _cse_1625;
        u_l_3 = _cse_1580;
        u_r_3 = _cse_1611;
        f_l_3 = (_cse_1580 + _cse_1582) * dot(_cse_1592, normal_vec);
        f_r_3 = (_cse_1611 + _cse_1613) * dot(_cse_1627, normal_vec);
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_1651 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1652 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_1650 = max(_cse_1651, _cse_1652);
        let _cse_1653 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_1649 = min(_cse_1650, _cse_1653);
        let _cse_1648 = s_own_rho + _cse_1649;
        let _cse_1647 = _cse_1648 * constants.eos_r;
        let _cse_1654 = s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0));
        let _cse_1646 = _cse_1647 * _cse_1654;
        let _cse_1645 = _cse_1646 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1660 = s_own_rho_u_x;
        let _cse_1665 = s_neigh_rho_u_x;
        let _cse_1664 = _cse_1665 - _cse_1660;
        let _cse_1663 = min(_cse_1664, 0.0);
        let _cse_1662 = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), _cse_1663);
        let _cse_1666 = max(_cse_1664, 0.0);
        let _cse_1661 = min(_cse_1662, _cse_1666);
        let _cse_1659 = _cse_1660 + _cse_1661;
        let _cse_1668 = s_own_rho_u_y;
        let _cse_1673 = s_neigh_rho_u_y;
        let _cse_1672 = _cse_1673 - _cse_1668;
        let _cse_1671 = min(_cse_1672, 0.0);
        let _cse_1670 = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), _cse_1671);
        let _cse_1674 = max(_cse_1672, 0.0);
        let _cse_1669 = min(_cse_1670, _cse_1674);
        let _cse_1667 = _cse_1668 + _cse_1669;
        let _cse_1658 = vec2<f32>(_cse_1659, _cse_1667);
        let _cse_1675 = 1.0 / _cse_1648;
        let _cse_1657 = _cse_1658 * _cse_1675;
        let _cse_1656 = dot(_cse_1657, _cse_1657);
        let _cse_1655 = 0.5 * _cse_1648 * _cse_1656;
        let _cse_1644 = _cse_1645 + _cse_1655;
        let _cse_1684 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1683 = dot(_cse_1684, face_center_vec - c_neigh_cell_vec);
        let _cse_1685 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_1682 = max(_cse_1683, _cse_1685);
        let _cse_1686 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_1681 = min(_cse_1682, _cse_1686);
        let _cse_1680 = s_neigh_rho + _cse_1681;
        let _cse_1679 = _cse_1680 * constants.eos_r;
        let _cse_1688 = min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0));
        let _cse_1687 = s_neigh_T + _cse_1688;
        let _cse_1678 = _cse_1679 * _cse_1687;
        let _cse_1677 = _cse_1678 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1696 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_1698 = _cse_1660 - _cse_1665;
        let _cse_1697 = min(_cse_1698, 0.0);
        let _cse_1695 = max(_cse_1696, _cse_1697);
        let _cse_1699 = max(_cse_1698, 0.0);
        let _cse_1694 = min(_cse_1695, _cse_1699);
        let _cse_1693 = _cse_1665 + _cse_1694;
        let _cse_1703 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_1705 = _cse_1668 - _cse_1673;
        let _cse_1704 = min(_cse_1705, 0.0);
        let _cse_1702 = max(_cse_1703, _cse_1704);
        let _cse_1706 = max(_cse_1705, 0.0);
        let _cse_1701 = min(_cse_1702, _cse_1706);
        let _cse_1700 = _cse_1673 + _cse_1701;
        let _cse_1692 = vec2<f32>(_cse_1693, _cse_1700);
        let _cse_1707 = 1.0 / _cse_1680;
        let _cse_1691 = _cse_1692 * _cse_1707;
        let _cse_1690 = dot(_cse_1691, _cse_1691);
        let _cse_1689 = 0.5 * _cse_1680 * _cse_1690;
        let _cse_1676 = _cse_1677 + _cse_1689;
        u_l_3 = _cse_1644;
        u_r_3 = _cse_1676;
        f_l_3 = (_cse_1644 + _cse_1646) * dot(_cse_1657, normal_vec);
        f_r_3 = (_cse_1676 + _cse_1678) * dot(_cse_1691, normal_vec);
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_1719 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001;
        let _cse_1718 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / _cse_1719;
        let _cse_1717 = 2.0 * _cse_1718;
        let _cse_1716 = _cse_1717 - 1.0;
        let _cse_1715 = min(_cse_1716, 1999.0);
        let _cse_1714 = max(-2001.0, _cse_1715);
        let _cse_1720 = abs(_cse_1714);
        let _cse_1713 = _cse_1714 + _cse_1720;
        let _cse_1712 = _cse_1713 / (1.0 + _cse_1720);
        let _cse_1711 = _cse_1712 * lambda_other;
        let _cse_1710 = _cse_1711 * (s_neigh_rho - s_own_rho);
        let _cse_1709 = s_own_rho + _cse_1710;
        let _cse_1726 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_1736 = dot(_cse_1726, _cse_1726);
        let _cse_1735 = dot(_cse_1726, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_1736;
        let _cse_1738 = _cse_1736 * _cse_1736;
        let _cse_1737 = _cse_1738 + 0.000000000000000000000000000001;
        let _cse_1734 = _cse_1735 / _cse_1737;
        let _cse_1733 = 2.0 * _cse_1734;
        let _cse_1732 = _cse_1733 - 1.0;
        let _cse_1731 = min(_cse_1732, 1999.0);
        let _cse_1730 = max(-2001.0, _cse_1731);
        let _cse_1739 = abs(_cse_1730);
        let _cse_1729 = _cse_1730 + _cse_1739;
        let _cse_1728 = _cse_1729 / (1.0 + _cse_1739);
        let _cse_1727 = _cse_1728 * lambda_other;
        let _cse_1725 = _cse_1726 * _cse_1727;
        let _cse_1724 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_1725;
        let _cse_1723 = _cse_1724 * 1.0 / _cse_1709;
        let _cse_1722 = dot(_cse_1723, _cse_1723);
        let _cse_1721 = 0.5 * _cse_1709 * _cse_1722;
        let _cse_1708 = _cse_1709 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / max(constants.eos_gm1, 0.000000000001) + _cse_1721;
        let _cse_1752 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho);
        let _cse_1751 = _cse_1752 / _cse_1719;
        let _cse_1750 = 2.0 * _cse_1751;
        let _cse_1749 = _cse_1750 - 1.0;
        let _cse_1748 = min(_cse_1749, 1999.0);
        let _cse_1747 = max(-2001.0, _cse_1748);
        let _cse_1753 = abs(_cse_1747);
        let _cse_1746 = _cse_1747 + _cse_1753;
        let _cse_1745 = _cse_1746 / (1.0 + _cse_1753);
        let _cse_1744 = _cse_1745 * lambda;
        let _cse_1743 = _cse_1744 * (s_neigh_rho - s_own_rho);
        let _cse_1742 = s_neigh_rho - _cse_1743;
        let _cse_1741 = _cse_1742 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T));
        let _cse_1769 = vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))));
        let _cse_1768 = dot(_cse_1726, _cse_1769);
        let _cse_1767 = _cse_1768 * _cse_1736;
        let _cse_1766 = _cse_1767 / _cse_1737;
        let _cse_1765 = 2.0 * _cse_1766;
        let _cse_1764 = _cse_1765 - 1.0;
        let _cse_1763 = min(_cse_1764, 1999.0);
        let _cse_1762 = max(-2001.0, _cse_1763);
        let _cse_1770 = abs(_cse_1762);
        let _cse_1761 = _cse_1762 + _cse_1770;
        let _cse_1760 = _cse_1761 / (1.0 + _cse_1770);
        let _cse_1759 = _cse_1760 * lambda;
        let _cse_1758 = _cse_1726 * _cse_1759;
        let _cse_1757 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_1758;
        let _cse_1771 = 1.0 / _cse_1742;
        let _cse_1756 = _cse_1757 * _cse_1771;
        let _cse_1755 = dot(_cse_1756, _cse_1756);
        let _cse_1754 = 0.5 * _cse_1742 * _cse_1755;
        let _cse_1740 = _cse_1741 / max(constants.eos_gm1, 0.000000000001) + _cse_1754;
        u_l_3 = _cse_1708;
        u_r_3 = _cse_1740;
        f_l_3 = (_cse_1708 + _cse_1709 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T))) * dot(_cse_1723, normal_vec);
        f_r_3 = (_cse_1740 + _cse_1741) * dot(_cse_1756, normal_vec);
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_1779 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1778 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + _cse_1779;
        let _cse_1777 = _cse_1778 - s_own_rho;
        let _cse_1776 = max(_cse_1777, min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1775 = min(_cse_1776, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1774 = s_own_rho + _cse_1775;
        let _cse_1773 = _cse_1774 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)));
        let _cse_1785 = s_own_rho_u_x;
        let _cse_1791 = s_neigh_rho_u_x;
        let _cse_1790 = _cse_1785 * 0.625 + _cse_1791 * 0.375;
        let _cse_1789 = _cse_1790 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1788 = _cse_1789 - _cse_1785;
        let _cse_1793 = _cse_1791 - _cse_1785;
        let _cse_1792 = min(_cse_1793, 0.0);
        let _cse_1787 = max(_cse_1788, _cse_1792);
        let _cse_1794 = max(_cse_1793, 0.0);
        let _cse_1786 = min(_cse_1787, _cse_1794);
        let _cse_1784 = _cse_1785 + _cse_1786;
        let _cse_1796 = s_own_rho_u_y;
        let _cse_1802 = s_neigh_rho_u_y;
        let _cse_1801 = _cse_1796 * 0.625 + _cse_1802 * 0.375;
        let _cse_1800 = _cse_1801 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1799 = _cse_1800 - _cse_1796;
        let _cse_1803 = _cse_1802 - _cse_1796;
        let _cse_1798 = max(_cse_1799, min(_cse_1803, 0.0));
        let _cse_1797 = min(_cse_1798, max(_cse_1803, 0.0));
        let _cse_1795 = _cse_1796 + _cse_1797;
        let _cse_1783 = vec2<f32>(_cse_1784, _cse_1795);
        let _cse_1804 = 1.0 / _cse_1774;
        let _cse_1782 = _cse_1783 * _cse_1804;
        let _cse_1781 = dot(_cse_1782, _cse_1782);
        let _cse_1780 = 0.5 * _cse_1774 * _cse_1781;
        let _cse_1772 = _cse_1773 / max(constants.eos_gm1, 0.000000000001) + _cse_1780;
        let _cse_1816 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1815 = dot(_cse_1816, c_owner_vec - c_neigh_cell_vec);
        let _cse_1814 = _cse_1815 * 0.125;
        let _cse_1813 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_1814;
        let _cse_1812 = _cse_1813 - s_neigh_rho;
        let _cse_1811 = max(_cse_1812, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1810 = min(_cse_1811, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1809 = s_neigh_rho + _cse_1810;
        let _cse_1808 = _cse_1809 * constants.eos_r;
        let _cse_1807 = _cse_1808 * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_1806 = _cse_1807 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1826 = _cse_1791 * 0.625 + _cse_1785 * 0.375;
        let _cse_1825 = _cse_1826 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1824 = _cse_1825 - _cse_1791;
        let _cse_1827 = _cse_1785 - _cse_1791;
        let _cse_1823 = max(_cse_1824, min(_cse_1827, 0.0));
        let _cse_1822 = min(_cse_1823, max(_cse_1827, 0.0));
        let _cse_1821 = _cse_1791 + _cse_1822;
        let _cse_1833 = _cse_1802 * 0.625 + _cse_1796 * 0.375;
        let _cse_1832 = _cse_1833 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1831 = _cse_1832 - _cse_1802;
        let _cse_1834 = _cse_1796 - _cse_1802;
        let _cse_1830 = max(_cse_1831, min(_cse_1834, 0.0));
        let _cse_1829 = min(_cse_1830, max(_cse_1834, 0.0));
        let _cse_1828 = _cse_1802 + _cse_1829;
        let _cse_1820 = vec2<f32>(_cse_1821, _cse_1828);
        let _cse_1835 = 1.0 / _cse_1809;
        let _cse_1819 = _cse_1820 * _cse_1835;
        let _cse_1818 = dot(_cse_1819, _cse_1819);
        let _cse_1817 = 0.5 * _cse_1809 * _cse_1818;
        let _cse_1805 = _cse_1806 + _cse_1817;
        u_l_3 = _cse_1772;
        u_r_3 = _cse_1805;
        f_l_3 = (_cse_1772 + _cse_1773) * dot(_cse_1782, normal_vec);
        f_r_3 = (_cse_1805 + _cse_1807) * dot(_cse_1819, normal_vec);
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_1842 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1841 = _cse_1842 - s_own_rho;
        let _cse_1840 = _cse_1841 * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(_cse_1841) + 0.00000001);
        let _cse_1844 = (s_neigh_rho - s_own_rho) * _cse_1841;
        let _cse_1843 = max(_cse_1844, 0.0) / max(abs(_cse_1844), 0.00000001);
        let _cse_1839 = _cse_1840 * _cse_1843;
        let _cse_1838 = s_own_rho + _cse_1839;
        let _cse_1837 = _cse_1838 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001));
        let _cse_1850 = s_own_rho_u_x;
        let _cse_1856 = s_neigh_rho_u_x;
        let _cse_1855 = _cse_1850 * 0.625 + _cse_1856 * 0.375;
        let _cse_1854 = _cse_1855 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1853 = _cse_1854 - _cse_1850;
        let _cse_1852 = _cse_1853 * abs(_cse_1856 - _cse_1850) / max(abs(_cse_1856 - _cse_1850), abs(_cse_1853) + 0.00000001);
        let _cse_1858 = (_cse_1856 - _cse_1850) * _cse_1853;
        let _cse_1857 = max(_cse_1858, 0.0) / max(abs(_cse_1858), 0.00000001);
        let _cse_1851 = _cse_1852 * _cse_1857;
        let _cse_1849 = _cse_1850 + _cse_1851;
        let _cse_1860 = s_own_rho_u_y;
        let _cse_1866 = s_neigh_rho_u_y;
        let _cse_1865 = _cse_1860 * 0.625 + _cse_1866 * 0.375;
        let _cse_1864 = _cse_1865 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1863 = _cse_1864 - _cse_1860;
        let _cse_1862 = _cse_1863 * abs(_cse_1866 - _cse_1860) / max(abs(_cse_1866 - _cse_1860), abs(_cse_1863) + 0.00000001);
        let _cse_1868 = (_cse_1866 - _cse_1860) * _cse_1863;
        let _cse_1867 = max(_cse_1868, 0.0) / max(abs(_cse_1868), 0.00000001);
        let _cse_1861 = _cse_1862 * _cse_1867;
        let _cse_1859 = _cse_1860 + _cse_1861;
        let _cse_1848 = vec2<f32>(_cse_1849, _cse_1859);
        let _cse_1869 = 1.0 / _cse_1838;
        let _cse_1847 = _cse_1848 * _cse_1869;
        let _cse_1846 = dot(_cse_1847, _cse_1847);
        let _cse_1845 = 0.5 * _cse_1838 * _cse_1846;
        let _cse_1836 = _cse_1837 / max(constants.eos_gm1, 0.000000000001) + _cse_1845;
        let _cse_1878 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1877 = _cse_1878 * 0.125;
        let _cse_1876 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_1877;
        let _cse_1875 = _cse_1876 - s_neigh_rho;
        let _cse_1874 = _cse_1875 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1875) + 0.00000001);
        let _cse_1880 = (s_own_rho - s_neigh_rho) * _cse_1875;
        let _cse_1879 = max(_cse_1880, 0.0) / max(abs(_cse_1880), 0.00000001);
        let _cse_1873 = _cse_1874 * _cse_1879;
        let _cse_1872 = s_neigh_rho + _cse_1873;
        let _cse_1871 = _cse_1872 * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001));
        let _cse_1889 = _cse_1856 * 0.625 + _cse_1850 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1888 = _cse_1889 - _cse_1856;
        let _cse_1887 = _cse_1888 * abs(_cse_1850 - _cse_1856) / max(abs(_cse_1850 - _cse_1856), abs(_cse_1888) + 0.00000001);
        let _cse_1891 = (_cse_1850 - _cse_1856) * _cse_1888;
        let _cse_1890 = max(_cse_1891, 0.0) / max(abs(_cse_1891), 0.00000001);
        let _cse_1886 = _cse_1887 * _cse_1890;
        let _cse_1885 = _cse_1856 + _cse_1886;
        let _cse_1896 = _cse_1866 * 0.625 + _cse_1860 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1895 = _cse_1896 - _cse_1866;
        let _cse_1894 = _cse_1895 * abs(_cse_1860 - _cse_1866) / max(abs(_cse_1860 - _cse_1866), abs(_cse_1895) + 0.00000001);
        let _cse_1898 = (_cse_1860 - _cse_1866) * _cse_1895;
        let _cse_1897 = max(_cse_1898, 0.0) / max(abs(_cse_1898), 0.00000001);
        let _cse_1893 = _cse_1894 * _cse_1897;
        let _cse_1892 = _cse_1866 + _cse_1893;
        let _cse_1884 = vec2<f32>(_cse_1885, _cse_1892);
        let _cse_1899 = 1.0 / _cse_1872;
        let _cse_1883 = _cse_1884 * _cse_1899;
        let _cse_1882 = dot(_cse_1883, _cse_1883);
        let _cse_1881 = 0.5 * _cse_1872 * _cse_1882;
        let _cse_1870 = _cse_1871 / max(constants.eos_gm1, 0.000000000001) + _cse_1881;
        u_l_3 = _cse_1836;
        u_r_3 = _cse_1870;
        f_l_3 = (_cse_1836 + _cse_1837) * dot(_cse_1847, normal_vec);
        f_r_3 = (_cse_1870 + _cse_1871) * dot(_cse_1883, normal_vec);
    }
    fluxes[idx * 8u + 3u] = (a_plus * f_l_3 - a_minus * f_r_3 + a_plus * a_minus * (u_r_3 - u_l_3)) / denom * area;
    var u_l_4: f32 = 0.0;
    var u_r_4: f32 = 0.0;
    var f_l_4: f32 = 0.0;
    var f_r_4: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    fluxes[idx * 8u + 4u] = (a_plus * f_l_4 - a_minus * f_r_4 + a_plus * a_minus * (u_r_4 - u_l_4)) / denom * area;
    var u_l_5: f32 = 0.0;
    var u_r_5: f32 = 0.0;
    var f_l_5: f32 = 0.0;
    var f_r_5: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    fluxes[idx * 8u + 5u] = (a_plus * f_l_5 - a_minus * f_r_5 + a_plus * a_minus * (u_r_5 - u_l_5)) / denom * area;
    var u_l_6: f32 = 0.0;
    var u_r_6: f32 = 0.0;
    var f_l_6: f32 = 0.0;
    var f_r_6: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    fluxes[idx * 8u + 6u] = (a_plus * f_l_6 - a_minus * f_r_6 + a_plus * a_minus * (u_r_6 - u_l_6)) / denom * area;
    var u_l_7: f32 = 0.0;
    var u_r_7: f32 = 0.0;
    var f_l_7: f32 = 0.0;
    var f_r_7: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    fluxes[idx * 8u + 7u] = (a_plus * f_l_7 - a_minus * f_r_7 + a_plus * a_minus * (u_r_7 - u_l_7)) / denom * area;
}
