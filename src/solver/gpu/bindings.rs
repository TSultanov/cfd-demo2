// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: 9fc2787b18a5fdd96e28261020c6f4ef6233840bb06c643d05325597c3f7ebf4

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    DotProduct,
    DotProductPair,
    GeneratedCompressibleApply,
    GeneratedCompressibleAssembly,
    GeneratedCompressibleFluxKt,
    GeneratedCompressibleGradients,
    GeneratedCompressibleUpdate,
    GeneratedCoupledAssemblyMerged,
    GeneratedFluxRhieChow,
    GeneratedIncompressibleMomentum,
    GeneratedPrepareCoupled,
    GeneratedPressureAssembly,
    GeneratedUpdateFieldsFromCoupled,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    Preconditioner,
    Scalars,
    SchurPrecond,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::Amg => amg::create_pipeline_layout(device),
            Self::DotProduct => dot_product::create_pipeline_layout(device),
            Self::DotProductPair => dot_product_pair::create_pipeline_layout(device),
            Self::GeneratedCompressibleApply => {
                generated::compressible_apply::create_pipeline_layout(device)
            }
            Self::GeneratedCompressibleAssembly => {
                generated::compressible_assembly::create_pipeline_layout(device)
            }
            Self::GeneratedCompressibleFluxKt => {
                generated::compressible_flux_kt::create_pipeline_layout(device)
            }
            Self::GeneratedCompressibleGradients => {
                generated::compressible_gradients::create_pipeline_layout(device)
            }
            Self::GeneratedCompressibleUpdate => {
                generated::compressible_update::create_pipeline_layout(device)
            }
            Self::GeneratedCoupledAssemblyMerged => {
                generated::coupled_assembly_merged::create_pipeline_layout(device)
            }
            Self::GeneratedFluxRhieChow => {
                generated::flux_rhie_chow::create_pipeline_layout(device)
            }
            Self::GeneratedIncompressibleMomentum => {
                generated::incompressible_momentum::create_pipeline_layout(device)
            }
            Self::GeneratedPrepareCoupled => {
                generated::prepare_coupled::create_pipeline_layout(device)
            }
            Self::GeneratedPressureAssembly => {
                generated::pressure_assembly::create_pipeline_layout(device)
            }
            Self::GeneratedUpdateFieldsFromCoupled => {
                generated::update_fields_from_coupled::create_pipeline_layout(device)
            }
            Self::GmresCgs => gmres_cgs::create_pipeline_layout(device),
            Self::GmresLogic => gmres_logic::create_pipeline_layout(device),
            Self::GmresOps => gmres_ops::create_pipeline_layout(device),
            Self::LinearSolver => linear_solver::create_pipeline_layout(device),
            Self::Preconditioner => preconditioner::create_pipeline_layout(device),
            Self::Scalars => scalars::create_pipeline_layout(device),
            Self::SchurPrecond => schur_precond::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self {
            Self::Amg => amg::create_shader_module_embed_source(device),
            Self::DotProduct => dot_product::create_shader_module_embed_source(device),
            Self::DotProductPair => dot_product_pair::create_shader_module_embed_source(device),
            Self::GeneratedCompressibleApply => {
                generated::compressible_apply::create_shader_module_embed_source(device)
            }
            Self::GeneratedCompressibleAssembly => {
                generated::compressible_assembly::create_shader_module_embed_source(device)
            }
            Self::GeneratedCompressibleFluxKt => {
                generated::compressible_flux_kt::create_shader_module_embed_source(device)
            }
            Self::GeneratedCompressibleGradients => {
                generated::compressible_gradients::create_shader_module_embed_source(device)
            }
            Self::GeneratedCompressibleUpdate => {
                generated::compressible_update::create_shader_module_embed_source(device)
            }
            Self::GeneratedCoupledAssemblyMerged => {
                generated::coupled_assembly_merged::create_shader_module_embed_source(device)
            }
            Self::GeneratedFluxRhieChow => {
                generated::flux_rhie_chow::create_shader_module_embed_source(device)
            }
            Self::GeneratedIncompressibleMomentum => {
                generated::incompressible_momentum::create_shader_module_embed_source(device)
            }
            Self::GeneratedPrepareCoupled => {
                generated::prepare_coupled::create_shader_module_embed_source(device)
            }
            Self::GeneratedPressureAssembly => {
                generated::pressure_assembly::create_shader_module_embed_source(device)
            }
            Self::GeneratedUpdateFieldsFromCoupled => {
                generated::update_fields_from_coupled::create_shader_module_embed_source(device)
            }
            Self::GmresCgs => gmres_cgs::create_shader_module_embed_source(device),
            Self::GmresLogic => gmres_logic::create_shader_module_embed_source(device),
            Self::GmresOps => gmres_ops::create_shader_module_embed_source(device),
            Self::LinearSolver => linear_solver::create_shader_module_embed_source(device),
            Self::Preconditioner => preconditioner::create_shader_module_embed_source(device),
            Self::Scalars => scalars::create_shader_module_embed_source(device),
            Self::SchurPrecond => schur_precond::create_shader_module_embed_source(device),
        }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 4);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 4);
    };
    const GENERATED_COMPRESSIBLE_APPLY_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_apply::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::compressible_apply::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::compressible_apply::Vector2>() == 8);
    };
    const GENERATED_COMPRESSIBLE_APPLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, stride_x) == 40);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, time_scheme) == 44);
        assert!(
            std::mem::offset_of!(generated::compressible_apply::Constants, inlet_velocity) == 48
        );
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, ramp_time) == 52);
        assert!(std::mem::offset_of!(generated::compressible_apply::Constants, precond_type) == 56);
        assert!(
            std::mem::offset_of!(generated::compressible_apply::Constants, precond_model) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::compressible_apply::Constants,
                precond_theta_floor
            ) == 64
        );
        assert!(std::mem::size_of::<generated::compressible_apply::Constants>() == 68);
    };
    const GENERATED_COMPRESSIBLE_ASSEMBLY_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_assembly::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::compressible_assembly::Vector2>() == 8);
    };
    const GENERATED_COMPRESSIBLE_ASSEMBLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::compressible_assembly::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::compressible_assembly::Constants, inlet_velocity) == 48
        );
        assert!(std::mem::offset_of!(generated::compressible_assembly::Constants, ramp_time) == 52);
        assert!(
            std::mem::offset_of!(generated::compressible_assembly::Constants, precond_type) == 56
        );
        assert!(
            std::mem::offset_of!(generated::compressible_assembly::Constants, precond_model) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::compressible_assembly::Constants,
                precond_theta_floor
            ) == 64
        );
        assert!(std::mem::size_of::<generated::compressible_assembly::Constants>() == 68);
    };
    const GENERATED_COMPRESSIBLE_FLUX_KT_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::compressible_flux_kt::Vector2>() == 8);
    };
    const GENERATED_COMPRESSIBLE_FLUX_KT_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::compressible_flux_kt::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::compressible_flux_kt::Constants, inlet_velocity) == 48
        );
        assert!(std::mem::offset_of!(generated::compressible_flux_kt::Constants, ramp_time) == 52);
        assert!(
            std::mem::offset_of!(generated::compressible_flux_kt::Constants, precond_type) == 56
        );
        assert!(
            std::mem::offset_of!(generated::compressible_flux_kt::Constants, precond_model) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::compressible_flux_kt::Constants,
                precond_theta_floor
            ) == 64
        );
        assert!(std::mem::size_of::<generated::compressible_flux_kt::Constants>() == 68);
    };
    const GENERATED_COMPRESSIBLE_GRADIENTS_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_gradients::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::compressible_gradients::Vector2>() == 8);
    };
    const GENERATED_COMPRESSIBLE_GRADIENTS_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, viscosity) == 16
        );
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, density) == 20);
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, component) == 24
        );
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::compressible_gradients::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, inlet_velocity)
                == 48
        );
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, ramp_time) == 52
        );
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, precond_type) == 56
        );
        assert!(
            std::mem::offset_of!(generated::compressible_gradients::Constants, precond_model) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::compressible_gradients::Constants,
                precond_theta_floor
            ) == 64
        );
        assert!(std::mem::size_of::<generated::compressible_gradients::Constants>() == 68);
    };
    const GENERATED_COMPRESSIBLE_UPDATE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_update::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::compressible_update::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::compressible_update::Vector2>() == 8);
    };
    const GENERATED_COMPRESSIBLE_UPDATE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, stride_x) == 40);
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, time_scheme) == 44);
        assert!(
            std::mem::offset_of!(generated::compressible_update::Constants, inlet_velocity) == 48
        );
        assert!(std::mem::offset_of!(generated::compressible_update::Constants, ramp_time) == 52);
        assert!(
            std::mem::offset_of!(generated::compressible_update::Constants, precond_type) == 56
        );
        assert!(
            std::mem::offset_of!(generated::compressible_update::Constants, precond_model) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::compressible_update::Constants,
                precond_theta_floor
            ) == 64
        );
        assert!(std::mem::size_of::<generated::compressible_update::Constants>() == 68);
    };
    const GENERATED_COUPLED_ASSEMBLY_MERGED_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::coupled_assembly_merged::Vector2>() == 8);
    };
    const GENERATED_COUPLED_ASSEMBLY_MERGED_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::coupled_assembly_merged::Constants, viscosity) == 16
        );
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, density) == 20);
        assert!(
            std::mem::offset_of!(generated::coupled_assembly_merged::Constants, component) == 24
        );
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::coupled_assembly_merged::Constants, alpha_u) == 36);
        assert!(
            std::mem::offset_of!(generated::coupled_assembly_merged::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::coupled_assembly_merged::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::coupled_assembly_merged::Constants,
                inlet_velocity
            ) == 48
        );
        assert!(
            std::mem::offset_of!(generated::coupled_assembly_merged::Constants, ramp_time) == 52
        );
        assert!(std::mem::size_of::<generated::coupled_assembly_merged::Constants>() == 56);
    };
    const GENERATED_FLUX_RHIE_CHOW_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_rhie_chow::Vector2>() == 8);
    };
    const GENERATED_FLUX_RHIE_CHOW_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, stride_x) == 40);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, time_scheme) == 44);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, inlet_velocity) == 48);
        assert!(std::mem::offset_of!(generated::flux_rhie_chow::Constants, ramp_time) == 52);
        assert!(std::mem::size_of::<generated::flux_rhie_chow::Constants>() == 56);
    };
    const GENERATED_PREPARE_COUPLED_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::prepare_coupled::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::prepare_coupled::Vector2>() == 8);
    };
    const GENERATED_PREPARE_COUPLED_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, stride_x) == 40);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, time_scheme) == 44);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, inlet_velocity) == 48);
        assert!(std::mem::offset_of!(generated::prepare_coupled::Constants, ramp_time) == 52);
        assert!(std::mem::size_of::<generated::prepare_coupled::Constants>() == 56);
    };
    const GENERATED_PRESSURE_ASSEMBLY_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::pressure_assembly::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::pressure_assembly::Vector2>() == 8);
    };
    const GENERATED_PRESSURE_ASSEMBLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, time_scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::pressure_assembly::Constants, inlet_velocity) == 36
        );
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, ramp_time) == 40);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, alpha_u) == 44);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, stride_x) == 48);
        assert!(std::mem::offset_of!(generated::pressure_assembly::Constants, padding) == 52);
        assert!(std::mem::size_of::<generated::pressure_assembly::Constants>() == 56);
    };
    const GENERATED_UPDATE_FIELDS_FROM_COUPLED_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::update_fields_from_coupled::Constants, dt) == 0);
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, dt_old) == 4
        );
        assert!(std::mem::offset_of!(generated::update_fields_from_coupled::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::update_fields_from_coupled::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, alpha_p) == 28
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, scheme) == 32
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::update_fields_from_coupled::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::update_fields_from_coupled::Constants,
                inlet_velocity
            ) == 48
        );
        assert!(
            std::mem::offset_of!(generated::update_fields_from_coupled::Constants, ramp_time) == 52
        );
        assert!(std::mem::size_of::<generated::update_fields_from_coupled::Constants>() == 56);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, omega) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 20);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, t_s) == 24);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, t_t) == 28);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 32);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 36);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const PRECONDITIONER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, omega) == 16);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, r0_v) == 20);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, t_s) == 24);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, t_t) == 28);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, r_r) == 32);
        assert!(std::mem::size_of::<preconditioner::GpuScalars>() == 36);
    };
    const PRECONDITIONER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(preconditioner::SolverParams, n) == 0);
        assert!(std::mem::size_of::<preconditioner::SolverParams>() == 4);
    };
    const PRECONDITIONER_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, mode) == 0);
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, _pad0) == 4);
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, _pad1) == 8);
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, _pad2) == 12);
        assert!(std::mem::size_of::<preconditioner::PrecondParams>() == 16);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, omega) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 20);
        assert!(std::mem::offset_of!(scalars::GpuScalars, t_s) == 24);
        assert!(std::mem::offset_of!(scalars::GpuScalars, t_t) == 28);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 32);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 36);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 12);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.coarse_vec]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let i = global_id.x;
    let _e6 = params.n;
    if (i >= _e6) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = values[_e24];
            if (col == i) {
                diag = val;
            } else {
                let _e32 = x[col];
                let _e34 = sigma;
                sigma = (_e34 + (val * _e32));
            }
        }
        continuing {
            let _e37 = k;
            k = (_e37 + 1u);
        }
    }
    let _e39 = diag;
    if (abs(_e39) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e46 = b[i];
    let _e47 = sigma;
    let _e49 = diag;
    let x_new = ((_e46 - _e47) / _e49);
    let _e55 = x[i];
    let _e58 = params.omega;
    x[i] = mix(_e55, x_new, _e58);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let i_1 = global_id_1.x;
    let _e5 = params.n;
    if (i_1 >= _e5) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e16 = k_1;
        if (_e16 < end_1) {
        } else {
            break;
        }
        {
            let _e19 = k_1;
            let coarse_idx = op_col_indices[_e19];
            let _e23 = k_1;
            let val_1 = op_values[_e23];
            let _e29 = coarse_vec[coarse_idx];
            let _e31 = correction;
            correction = (_e31 + (val_1 * _e29));
        }
        continuing {
            let _e34 = k_1;
            k_1 = (_e34 + 1u);
        }
    }
    let _e38 = correction;
    let _e39 = x[i_1];
    x[i_1] = (_e39 + _e38);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let i_2 = global_id_2.x;
    let _e5 = params.n;
    if (i_2 >= _e5) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e16 = k_2;
        if (_e16 < end_2) {
        } else {
            break;
        }
        {
            let _e19 = k_2;
            let fine_idx = op_col_indices[_e19];
            let _e23 = k_2;
            let r_val = op_values[_e23];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e37 = j;
                if (_e37 < a_end) {
                } else {
                    break;
                }
                {
                    let _e40 = j;
                    let _e42 = values[_e40];
                    let _e45 = j;
                    let _e47 = col_indices[_e45];
                    let _e49 = x[_e47];
                    let _e51 = ax;
                    ax = (_e51 + (_e42 * _e49));
                }
                continuing {
                    let _e54 = j;
                    j = (_e54 + 1u);
                }
            }
            let _e58 = b[fine_idx];
            let _e59 = ax;
            let fine_r = (_e58 - _e59);
            let _e63 = sum;
            sum = (_e63 + (r_val * fine_r));
        }
        continuing {
            let _e66 = k_2;
            k_2 = (_e66 + 1u);
        }
    }
    let _e70 = sum;
    coarse_vec[i_2] = _e70;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    let i_3 = global_id_3.x;
    let _e4 = params.n;
    if (i_3 >= _e4) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::compressible_apply::Vector2 {}
    unsafe impl bytemuck::Pod for generated::compressible_apply::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::compressible_apply::Constants {}
    unsafe impl bytemuck::Pod for generated::compressible_apply::Constants {}
    unsafe impl bytemuck::Zeroable for generated::compressible_assembly::Vector2 {}
    unsafe impl bytemuck::Pod for generated::compressible_assembly::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::compressible_assembly::Constants {}
    unsafe impl bytemuck::Pod for generated::compressible_assembly::Constants {}
    unsafe impl bytemuck::Zeroable for generated::compressible_flux_kt::Vector2 {}
    unsafe impl bytemuck::Pod for generated::compressible_flux_kt::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::compressible_flux_kt::Constants {}
    unsafe impl bytemuck::Pod for generated::compressible_flux_kt::Constants {}
    unsafe impl bytemuck::Zeroable for generated::compressible_gradients::Vector2 {}
    unsafe impl bytemuck::Pod for generated::compressible_gradients::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::compressible_gradients::Constants {}
    unsafe impl bytemuck::Pod for generated::compressible_gradients::Constants {}
    unsafe impl bytemuck::Zeroable for generated::compressible_update::Vector2 {}
    unsafe impl bytemuck::Pod for generated::compressible_update::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::compressible_update::Constants {}
    unsafe impl bytemuck::Pod for generated::compressible_update::Constants {}
    unsafe impl bytemuck::Zeroable for generated::coupled_assembly_merged::Vector2 {}
    unsafe impl bytemuck::Pod for generated::coupled_assembly_merged::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::coupled_assembly_merged::Constants {}
    unsafe impl bytemuck::Pod for generated::coupled_assembly_merged::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_rhie_chow::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_rhie_chow::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_rhie_chow::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_rhie_chow::Constants {}
    unsafe impl bytemuck::Zeroable for generated::prepare_coupled::Vector2 {}
    unsafe impl bytemuck::Pod for generated::prepare_coupled::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::prepare_coupled::Constants {}
    unsafe impl bytemuck::Pod for generated::prepare_coupled::Constants {}
    unsafe impl bytemuck::Zeroable for generated::pressure_assembly::Vector2 {}
    unsafe impl bytemuck::Pod for generated::pressure_assembly::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::pressure_assembly::Constants {}
    unsafe impl bytemuck::Pod for generated::pressure_assembly::Constants {}
    unsafe impl bytemuck::Zeroable for generated::update_fields_from_coupled::Constants {}
    unsafe impl bytemuck::Pod for generated::update_fields_from_coupled::Constants {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for preconditioner::GpuScalars {}
    unsafe impl bytemuck::Pod for preconditioner::GpuScalars {}
    unsafe impl bytemuck::Zeroable for preconditioner::SolverParams {}
    unsafe impl bytemuck::Pod for preconditioner::SolverParams {}
    unsafe impl bytemuck::Zeroable for preconditioner::PrecondParams {}
    unsafe impl bytemuck::Pod for preconditioner::PrecondParams {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let idx = global_id.x;
    let lid = local_id.x;
    let _e8 = params.n;
    if (idx < _e8) {
        let _e12 = dot_a[idx];
        let _e15 = dot_b[idx];
        val = (_e12 * _e15);
    }
    let _e20 = val;
    scratch[lid] = _e20;
    workgroupBarrier();
    loop {
        let _e22 = i;
        if (_e22 > 0u) {
        } else {
            break;
        }
        {
            let _e25 = i;
            if (lid < _e25) {
                let _e30 = i;
                let _e33 = scratch[(lid + _e30)];
                let _e34 = scratch[lid];
                scratch[lid] = (_e34 + _e33);
            }
            workgroupBarrier();
        }
        continuing {
            let _e37 = i;
            i = (_e37 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e47 = scratch[0];
        dot_result[group_id.x] = _e47;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let idx = global_id.x;
    let lid = local_id.x;
    let _e8 = params.n;
    if (idx < _e8) {
        let _e12 = dot_a0_[idx];
        let _e15 = dot_b0_[idx];
        val0_ = (_e12 * _e15);
        let _e20 = dot_a1_[idx];
        let _e23 = dot_b1_[idx];
        val1_ = (_e20 * _e23);
    }
    let _e28 = val0_;
    scratch_a[lid] = _e28;
    let _e31 = val1_;
    scratch_b[lid] = _e31;
    workgroupBarrier();
    loop {
        let _e33 = offset;
        if (lid < _e33) {
            let _e38 = offset;
            let _e41 = scratch_a[(lid + _e38)];
            let _e42 = scratch_a[lid];
            scratch_a[lid] = (_e42 + _e41);
            let _e47 = offset;
            let _e50 = scratch_b[(lid + _e47)];
            let _e51 = scratch_b[lid];
            scratch_b[lid] = (_e51 + _e50);
        }
        workgroupBarrier();
        let _e53 = offset;
        if (_e53 == 1u) {
            break;
        }
        let _e56 = offset;
        offset = (_e56 >> 1u);
    }
    if (lid == 0u) {
        let _e67 = scratch_a[0];
        dot_result_a[group_id.x] = _e67;
        let _e73 = scratch_b[0];
        dot_result_b[group_id.x] = _e73;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod compressible_apply {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
            #[doc = "offset: 56, size: 4, type: `u32`"]
            pub precond_type: u32,
            #[doc = "offset: 60, size: 4, type: `u32`"]
            pub precond_model: u32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub precond_theta_floor: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
                precond_type: u32,
                precond_model: u32,
                precond_theta_floor: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                    precond_type,
                    precond_model,
                    precond_theta_floor,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_rho: wgpu::BufferBinding<'a>,
            pub grad_rho_u_x: wgpu::BufferBinding<'a>,
            pub grad_rho_u_y: wgpu::BufferBinding<'a>,
            pub grad_rho_e: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_rho: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_x: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_y: wgpu::BindGroupEntry<'a>,
            pub grad_rho_e: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_rho: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho),
                    },
                    grad_rho_u_x: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_x),
                    },
                    grad_rho_u_y: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_y),
                    },
                    grad_rho_e: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_e),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.grad_rho,
                    self.grad_rho_u_x,
                    self.grad_rho_u_y,
                    self.grad_rho_e,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::compressible_apply::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"grad_rho\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"grad_rho_u_x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"grad_rho_u_y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"grad_rho_e\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"state_iter\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub solution: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub solution: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    solution: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.solution),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.solution]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"solution\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedCompressibleApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("compressible_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<storage> state_old: array<f32>;
@group(0) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;
@group(0) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2_>;
@group(0) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2_>;
@group(0) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2_>;
@group(0) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2_>;
@group(0) @binding(9) 
var<storage> state_iter: array<f32>;
@group(1) @binding(0) 
var<storage> solution: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rho_new: f32;
    var rho_u_new_x: f32;
    var rho_u_new_y: f32;
    var rho_e_new: f32;

    let idx = global_id.x;
    let num_cells = arrayLength((&state));
    if ((idx * 7u) >= num_cells) {
        return;
    }
    let rho_base = state[((idx * 7u) + 0u)];
    let _e20 = state[((idx * 7u) + 1u)];
    let _e27 = state[((idx * 7u) + 2u)];
    let rho_u_base = vec2<f32>(_e20, _e27);
    let rho_e_base = state[((idx * 7u) + 3u)];
    let base = (idx * 4u);
    let delta_rho = solution[(base + 0u)];
    let delta_rho_u_x = solution[(base + 1u)];
    let delta_rho_u_y = solution[(base + 2u)];
    let delta_rho_e = solution[(base + 3u)];
    let relax = constants.alpha_u;
    rho_new = (rho_base + (relax * delta_rho));
    rho_u_new_x = (rho_u_base.x + (relax * delta_rho_u_x));
    rho_u_new_y = (rho_u_base.y + (relax * delta_rho_u_y));
    rho_e_new = (rho_e_base + (relax * delta_rho_e));
    let _e81 = rho_new;
    state[((idx * 7u) + 0u)] = _e81;
    let _e88 = rho_u_new_x;
    state[((idx * 7u) + 1u)] = _e88;
    let _e95 = rho_u_new_y;
    state[((idx * 7u) + 2u)] = _e95;
    let _e102 = rho_e_new;
    state[((idx * 7u) + 3u)] = _e102;
    return;
}
"#;
    }
    pub mod compressible_assembly {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
            #[doc = "offset: 56, size: 4, type: `u32`"]
            pub precond_type: u32,
            #[doc = "offset: 60, size: 4, type: `u32`"]
            pub precond_model: u32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub precond_theta_floor: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
                precond_type: u32,
                precond_model: u32,
                precond_theta_floor: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                    precond_type,
                    precond_model,
                    precond_theta_floor,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleAssembly::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleAssembly::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_rho: wgpu::BufferBinding<'a>,
            pub grad_rho_u_x: wgpu::BufferBinding<'a>,
            pub grad_rho_u_y: wgpu::BufferBinding<'a>,
            pub grad_rho_e: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_rho: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_x: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_y: wgpu::BindGroupEntry<'a>,
            pub grad_rho_e: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_rho: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho),
                    },
                    grad_rho_u_x: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_x),
                    },
                    grad_rho_u_y: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_y),
                    },
                    grad_rho_e: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_e),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.grad_rho,
                    self.grad_rho_u_x,
                    self.grad_rho_u_y,
                    self.grad_rho_e,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleAssembly::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::compressible_assembly::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"grad_rho\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"grad_rho_u_x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"grad_rho_u_y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"grad_rho_e\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"state_iter\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleAssembly::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleAssembly::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleAssembly::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedCompressibleAssembly::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("compressible_assembly.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(8) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(9) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2_>;
@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2_>;
@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2_>;
@group(1) @binding(9) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var diag_00_: f32 = 0f;
    var diag_01_: f32 = 0f;
    var diag_02_: f32 = 0f;
    var diag_03_: f32 = 0f;
    var diag_10_: f32 = 0f;
    var diag_11_: f32 = 0f;
    var diag_12_: f32 = 0f;
    var diag_13_: f32 = 0f;
    var diag_20_: f32 = 0f;
    var diag_21_: f32 = 0f;
    var diag_22_: f32 = 0f;
    var diag_23_: f32 = 0f;
    var diag_30_: f32 = 0f;
    var diag_31_: f32 = 0f;
    var diag_32_: f32 = 0f;
    var diag_33_: f32 = 0f;
    var sum_rho: f32 = 0f;
    var sum_rho_u_x: f32 = 0f;
    var sum_rho_u_y: f32 = 0f;
    var sum_rho_e: f32 = 0f;
    var coeff_time: f32;
    var rhs_time_rho: f32;
    var rhs_time_rho_u_x: f32;
    var rhs_time_rho_u_y: f32;
    var rhs_time_rho_e: f32;
    var coeff_pseudo: f32 = 0f;
    var rhs_pseudo_rho: f32 = 0f;
    var rhs_pseudo_rho_u_x: f32 = 0f;
    var rhs_pseudo_rho_u_y: f32 = 0f;
    var rhs_pseudo_rho_e: f32 = 0f;
    var face_offset: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var center_r: Vector2_;
    var rho_l: f32;
    var rho_u_l: vec2<f32>;
    var rho_e_l: f32;
    var rho_r: f32;
    var rho_u_r: vec2<f32>;
    var rho_e_r: f32;
    var c_l_eff: f32;
    var c_r_eff: f32;
    var flux_rho_u_x: f32;
    var flux_rho_u_y: f32;
    var flux_rho_e: f32;
    var jac_l_00_: f32;
    var jac_l_01_: f32;
    var jac_l_02_: f32;
    var jac_l_03_: f32;
    var jac_r_00_: f32;
    var jac_r_01_: f32;
    var jac_r_02_: f32;
    var jac_r_03_: f32;
    var jac_l_10_: f32;
    var jac_l_11_: f32;
    var jac_l_12_: f32;
    var jac_l_13_: f32;
    var jac_r_10_: f32;
    var jac_r_11_: f32;
    var jac_r_12_: f32;
    var jac_r_13_: f32;
    var jac_l_20_: f32;
    var jac_l_21_: f32;
    var jac_l_22_: f32;
    var jac_l_23_: f32;
    var jac_r_20_: f32;
    var jac_r_21_: f32;
    var jac_r_22_: f32;
    var jac_r_23_: f32;
    var jac_l_30_: f32;
    var jac_l_31_: f32;
    var jac_l_32_: f32;
    var jac_l_33_: f32;
    var jac_r_30_: f32;
    var jac_r_31_: f32;
    var jac_r_32_: f32;
    var jac_r_33_: f32;
    var neighbor_rank: u32;
    var eff_00_: f32;
    var eff_01_: f32;
    var eff_02_: f32;
    var eff_03_: f32;
    var eff_10_: f32;
    var eff_11_: f32;
    var eff_12_: f32;
    var eff_13_: f32;
    var eff_20_: f32;
    var eff_21_: f32;
    var eff_22_: f32;
    var eff_23_: f32;
    var eff_30_: f32;
    var eff_31_: f32;
    var eff_32_: f32;
    var eff_33_: f32;
    var rhs_rho: f32;
    var rhs_rho_u_x: f32;
    var rhs_rho_u_y: f32;
    var rhs_rho_e: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let vol = cell_vols[idx];
    let scalar_offset = scalar_row_offsets[idx];
    let _e27 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e27 - scalar_offset);
    let start_row_0_ = (16u * scalar_offset);
    let start_row_1_ = (start_row_0_ + (4u * num_neighbors));
    let start_row_2_ = (start_row_0_ + (8u * num_neighbors));
    let start_row_3_ = (start_row_0_ + (12u * num_neighbors));
    let scheme_id = constants.scheme;
    let rho = state[((idx * 7u) + 0u)];
    let _e56 = state[((idx * 7u) + 1u)];
    let _e63 = state[((idx * 7u) + 2u)];
    let rho_u = vec2<f32>(_e56, _e63);
    let rho_e = state[((idx * 7u) + 3u)];
    let rho_old = state_old[((idx * 7u) + 0u)];
    let _e85 = state_old[((idx * 7u) + 1u)];
    let _e92 = state_old[((idx * 7u) + 2u)];
    let rho_u_old = vec2<f32>(_e85, _e92);
    let rho_e_old = state_old[((idx * 7u) + 3u)];
    let _e103 = constants.dt;
    coeff_time = (vol / _e103);
    let _e106 = coeff_time;
    rhs_time_rho = (_e106 * rho_old);
    let _e109 = coeff_time;
    rhs_time_rho_u_x = (_e109 * rho_u_old.x);
    let _e113 = coeff_time;
    rhs_time_rho_u_y = (_e113 * rho_u_old.y);
    let _e117 = coeff_time;
    rhs_time_rho_e = (_e117 * rho_e_old);
    let _e122 = constants.dtau;
    if (_e122 > 0f) {
        let rho_iter = state_iter[((idx * 7u) + 0u)];
        let _e138 = state_iter[((idx * 7u) + 1u)];
        let _e145 = state_iter[((idx * 7u) + 2u)];
        let rho_u_iter = vec2<f32>(_e138, _e145);
        let rho_e_iter = state_iter[((idx * 7u) + 3u)];
        let _e156 = constants.dtau;
        coeff_pseudo = (vol / _e156);
        let _e159 = coeff_pseudo;
        rhs_pseudo_rho = (_e159 * rho_iter);
        let _e162 = coeff_pseudo;
        rhs_pseudo_rho_u_x = (_e162 * rho_u_iter.x);
        let _e166 = coeff_pseudo;
        rhs_pseudo_rho_u_y = (_e166 * rho_u_iter.y);
        let _e170 = coeff_pseudo;
        rhs_pseudo_rho_e = (_e170 * rho_e_iter);
    }
    let _e175 = constants.time_scheme;
    if (_e175 == 1u) {
        let dt = constants.dt;
        let dt_old = constants.dt_old;
        let r = (dt / dt_old);
        let rho_old_old = state_old_old[((idx * 7u) + 0u)];
        let _e198 = state_old_old[((idx * 7u) + 1u)];
        let _e205 = state_old_old[((idx * 7u) + 2u)];
        let rho_u_old_old = vec2<f32>(_e198, _e205);
        let rho_e_old_old = state_old_old[((idx * 7u) + 3u)];
        coeff_time = (((vol / dt) * (1f + (2f * r))) / (1f + r));
        let factor_n = (1f + r);
        let factor_nm1_ = ((r * r) / (1f + r));
        rhs_time_rho = ((vol / dt) * ((factor_n * rho_old) - (factor_nm1_ * rho_old_old)));
        rhs_time_rho_u_x = ((vol / dt) * ((factor_n * rho_u_old.x) - (factor_nm1_ * rho_u_old_old.x)));
        rhs_time_rho_u_y = ((vol / dt) * ((factor_n * rho_u_old.y) - (factor_nm1_ * rho_u_old_old.y)));
        rhs_time_rho_e = ((vol / dt) * ((factor_n * rho_e_old) - (factor_nm1_ * rho_e_old_old)));
    }
    face_offset = start;
    loop {
        let _e254 = face_offset;
        if (_e254 < end) {
        } else {
            break;
        }
        {
            let _e257 = face_offset;
            let face_idx = cell_faces[_e257];
            let owner = face_owner[face_idx];
            let neighbor = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let _e274 = face_normals[face_idx];
            normal = _e274;
            let f_center = face_centers[face_idx];
            is_boundary = false;
            other_idx = 0u;
            if (owner != idx) {
                let _e286 = normal.x;
                normal.x = -(_e286);
                let _e290 = normal.y;
                normal.y = -(_e290);
            }
            let rho_l_cell = state[((idx * 7u) + 0u)];
            let _e305 = state[((idx * 7u) + 1u)];
            let _e312 = state[((idx * 7u) + 2u)];
            let rho_u_l_cell = vec2<f32>(_e305, _e312);
            let rho_e_l_cell = state[((idx * 7u) + 3u)];
            rho_l = rho_l_cell;
            rho_u_l = rho_u_l_cell;
            rho_e_l = rho_e_l_cell;
            let _e324 = rho_l;
            rho_r = _e324;
            let _e326 = rho_u_l;
            rho_u_r = _e326;
            let _e328 = rho_e_l;
            rho_e_r = _e328;
            if (neighbor != -1i) {
                let neigh_idx = u32(neighbor);
                other_idx = neigh_idx;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e335 = other_idx;
                let _e337 = cell_centers[_e335];
                center_r = _e337;
                let _e339 = other_idx;
                let rho_neigh = state[((_e339 * 7u) + 0u)];
                let _e347 = other_idx;
                let _e354 = state[((_e347 * 7u) + 1u)];
                let _e355 = other_idx;
                let _e362 = state[((_e355 * 7u) + 2u)];
                let rho_u_neigh = vec2<f32>(_e354, _e362);
                let _e364 = other_idx;
                let rho_e_neigh = state[((_e364 * 7u) + 3u)];
                rho_r = rho_neigh;
                rho_u_r.x = rho_u_neigh.x;
                rho_u_r.y = rho_u_neigh.y;
                rho_e_r = rho_e_neigh;
            } else {
                is_boundary = true;
                other_idx = idx;
                center_r = f_center;
            }
            let _e377 = is_boundary;
            if _e377 {
                if (boundary_type == 1u) {
                    let _e381 = rho_r;
                    let _e384 = constants.inlet_velocity;
                    rho_u_r.x = (_e381 * _e384);
                    rho_u_r.y = 0f;
                } else {
                    if (boundary_type == 3u) {
                        let _e392 = rho_u_l.x;
                        rho_u_r.x = -(_e392);
                        let _e396 = rho_u_l.y;
                        rho_u_r.y = -(_e396);
                    }
                }
            }
            let rho_r_cell = rho_r;
            let rho_u_r_cell = rho_u_r;
            let rho_e_r_cell = rho_e_r;
            let _e401 = is_boundary;
            if (!(_e401) && (scheme_id != 0u)) {
                let r_l_x = (f_center.x - center.x);
                let r_l_y = (f_center.y - center.y);
                let _e414 = center_r.x;
                let r_r_x = (f_center.x - _e414);
                let _e418 = center_r.y;
                let r_r_y = (f_center.y - _e418);
                let inv_rho_l_cell = (1f / max(rho_l_cell, 0.00000001f));
                let u_l_x_cell = (rho_u_l_cell.x * inv_rho_l_cell);
                let u_l_y_cell = (rho_u_l_cell.y * inv_rho_l_cell);
                let u2_l_cell = ((u_l_x_cell * u_l_x_cell) + (u_l_y_cell * u_l_y_cell));
                let p_l_cell = max(0f, (0.4f * (rho_e_l_cell - ((0.5f * rho_l_cell) * u2_l_cell))));
                let inv_rho_r_cell = (1f / max(rho_r_cell, 0.00000001f));
                let u_r_x_cell = (rho_u_r_cell.x * inv_rho_r_cell);
                let u_r_y_cell = (rho_u_r_cell.y * inv_rho_r_cell);
                let u2_r_cell = ((u_r_x_cell * u_r_x_cell) + (u_r_y_cell * u_r_y_cell));
                let p_r_cell = max(0f, (0.4f * (rho_e_r_cell - ((0.5f * rho_r_cell) * u2_r_cell))));
                let grad_rho_l = grad_rho[idx];
                let grad_rho_u_x_l = grad_rho_u_x[idx];
                let grad_rho_u_y_l = grad_rho_u_y[idx];
                let grad_rho_e_l = grad_rho_e[idx];
                let _e471 = other_idx;
                let grad_rho_r = grad_rho[_e471];
                let _e475 = other_idx;
                let grad_rho_u_x_r = grad_rho_u_x[_e475];
                let _e479 = other_idx;
                let grad_rho_u_y_r = grad_rho_u_y[_e479];
                let _e483 = other_idx;
                let grad_rho_e_r = grad_rho_e[_e483];
                let grad_u_x_l_x = ((grad_rho_u_x_l.x - (u_l_x_cell * grad_rho_l.x)) * inv_rho_l_cell);
                let grad_u_x_l_y = ((grad_rho_u_x_l.y - (u_l_x_cell * grad_rho_l.y)) * inv_rho_l_cell);
                let grad_u_y_l_x = ((grad_rho_u_y_l.x - (u_l_y_cell * grad_rho_l.x)) * inv_rho_l_cell);
                let grad_u_y_l_y = ((grad_rho_u_y_l.y - (u_l_y_cell * grad_rho_l.y)) * inv_rho_l_cell);
                let grad_u_x_r_x = ((grad_rho_u_x_r.x - (u_r_x_cell * grad_rho_r.x)) * inv_rho_r_cell);
                let grad_u_x_r_y = ((grad_rho_u_x_r.y - (u_r_x_cell * grad_rho_r.y)) * inv_rho_r_cell);
                let grad_u_y_r_x = ((grad_rho_u_y_r.x - (u_r_y_cell * grad_rho_r.x)) * inv_rho_r_cell);
                let grad_u_y_r_y = ((grad_rho_u_y_r.y - (u_r_y_cell * grad_rho_r.y)) * inv_rho_r_cell);
                let grad_u2_l_x = (((2f * u_l_x_cell) * grad_u_x_l_x) + ((2f * u_l_y_cell) * grad_u_y_l_x));
                let grad_u2_l_y = (((2f * u_l_x_cell) * grad_u_x_l_y) + ((2f * u_l_y_cell) * grad_u_y_l_y));
                let grad_u2_r_x = (((2f * u_r_x_cell) * grad_u_x_r_x) + ((2f * u_r_y_cell) * grad_u_y_r_x));
                let grad_u2_r_y = (((2f * u_r_x_cell) * grad_u_x_r_y) + ((2f * u_r_y_cell) * grad_u_y_r_y));
                let grad_rho_u2_l_x = ((u2_l_cell * grad_rho_l.x) + (rho_l_cell * grad_u2_l_x));
                let grad_rho_u2_l_y = ((u2_l_cell * grad_rho_l.y) + (rho_l_cell * grad_u2_l_y));
                let grad_rho_u2_r_x = ((u2_r_cell * grad_rho_r.x) + (rho_r_cell * grad_u2_r_x));
                let grad_rho_u2_r_y = ((u2_r_cell * grad_rho_r.y) + (rho_r_cell * grad_u2_r_y));
                let grad_p_l_x = (0.4f * (grad_rho_e_l.x - (0.5f * grad_rho_u2_l_x)));
                let grad_p_l_y = (0.4f * (grad_rho_e_l.y - (0.5f * grad_rho_u2_l_y)));
                let grad_p_r_x = (0.4f * (grad_rho_e_r.x - (0.5f * grad_rho_u2_r_x)));
                let grad_p_r_y = (0.4f * (grad_rho_e_r.y - (0.5f * grad_rho_u2_r_y)));
                let diff_rho_l = (rho_r_cell - rho_l_cell);
                let min_diff_rho_l = min(diff_rho_l, 0f);
                let max_diff_rho_l = max(diff_rho_l, 0f);
                let delta_rho_l = ((grad_rho_l.x * r_l_x) + (grad_rho_l.y * r_l_y));
                let delta_rho_l_limited = min(max(delta_rho_l, min_diff_rho_l), max_diff_rho_l);
                let diff_u_l_x = (u_r_x_cell - u_l_x_cell);
                let min_diff_u_l_x = min(diff_u_l_x, 0f);
                let max_diff_u_l_x = max(diff_u_l_x, 0f);
                let delta_u_l_x = ((grad_u_x_l_x * r_l_x) + (grad_u_x_l_y * r_l_y));
                let delta_u_l_x_limited = min(max(delta_u_l_x, min_diff_u_l_x), max_diff_u_l_x);
                let diff_u_l_y = (u_r_y_cell - u_l_y_cell);
                let min_diff_u_l_y = min(diff_u_l_y, 0f);
                let max_diff_u_l_y = max(diff_u_l_y, 0f);
                let delta_u_l_y = ((grad_u_y_l_x * r_l_x) + (grad_u_y_l_y * r_l_y));
                let delta_u_l_y_limited = min(max(delta_u_l_y, min_diff_u_l_y), max_diff_u_l_y);
                let diff_p_l = (p_r_cell - p_l_cell);
                let min_diff_p_l = min(diff_p_l, 0f);
                let max_diff_p_l = max(diff_p_l, 0f);
                let delta_p_l = ((grad_p_l_x * r_l_x) + (grad_p_l_y * r_l_y));
                let delta_p_l_limited = min(max(delta_p_l, min_diff_p_l), max_diff_p_l);
                let rho_l_face = (rho_l_cell + delta_rho_l_limited);
                let u_l_x_face = (u_l_x_cell + delta_u_l_x_limited);
                let u_l_y_face = (u_l_y_cell + delta_u_l_y_limited);
                let p_l_face = (p_l_cell + delta_p_l_limited);
                let diff_rho_r = (rho_l_cell - rho_r_cell);
                let min_diff_rho_r = min(diff_rho_r, 0f);
                let max_diff_rho_r = max(diff_rho_r, 0f);
                let delta_rho_r = ((grad_rho_r.x * r_r_x) + (grad_rho_r.y * r_r_y));
                let delta_rho_r_limited = min(max(delta_rho_r, min_diff_rho_r), max_diff_rho_r);
                let diff_u_r_x = (u_l_x_cell - u_r_x_cell);
                let min_diff_u_r_x = min(diff_u_r_x, 0f);
                let max_diff_u_r_x = max(diff_u_r_x, 0f);
                let delta_u_r_x = ((grad_u_x_r_x * r_r_x) + (grad_u_x_r_y * r_r_y));
                let delta_u_r_x_limited = min(max(delta_u_r_x, min_diff_u_r_x), max_diff_u_r_x);
                let diff_u_r_y = (u_l_y_cell - u_r_y_cell);
                let min_diff_u_r_y = min(diff_u_r_y, 0f);
                let max_diff_u_r_y = max(diff_u_r_y, 0f);
                let delta_u_r_y = ((grad_u_y_r_x * r_r_x) + (grad_u_y_r_y * r_r_y));
                let delta_u_r_y_limited = min(max(delta_u_r_y, min_diff_u_r_y), max_diff_u_r_y);
                let diff_p_r = (p_l_cell - p_r_cell);
                let min_diff_p_r = min(diff_p_r, 0f);
                let max_diff_p_r = max(diff_p_r, 0f);
                let delta_p_r = ((grad_p_r_x * r_r_x) + (grad_p_r_y * r_r_y));
                let delta_p_r_limited = min(max(delta_p_r, min_diff_p_r), max_diff_p_r);
                let rho_r_face = (rho_r_cell + delta_rho_r_limited);
                let u_r_x_face = (u_r_x_cell + delta_u_r_x_limited);
                let u_r_y_face = (u_r_y_cell + delta_u_r_y_limited);
                let p_r_face = (p_r_cell + delta_p_r_limited);
                rho_l = rho_l_face;
                rho_u_l.x = (rho_l_face * u_l_x_face);
                rho_u_l.y = (rho_l_face * u_l_y_face);
                rho_e_l = ((p_l_face / 0.4f) + ((0.5f * rho_l_face) * ((u_l_x_face * u_l_x_face) + (u_l_y_face * u_l_y_face))));
                rho_r = rho_r_face;
                rho_u_r.x = (rho_r_face * u_r_x_face);
                rho_u_r.y = (rho_r_face * u_r_y_face);
                rho_e_r = ((p_r_face / 0.4f) + ((0.5f * rho_r_face) * ((u_r_x_face * u_r_x_face) + (u_r_y_face * u_r_y_face))));
            }
            let _e712 = rho_l;
            let du_ly_drv = (1f / max(_e712, 0.00000001f));
            let _e718 = rho_u_l.x;
            let u_l_x = (_e718 * du_ly_drv);
            let _e721 = rho_u_l.y;
            let u_l_y = (_e721 * du_ly_drv);
            let _e723 = rho_l;
            let ke_l = ((0.5f * _e723) * ((u_l_x * u_l_x) + (u_l_y * u_l_y)));
            let _e730 = rho_e_l;
            let p_l = max(0f, (0.4f * (_e730 - ke_l)));
            let _e737 = normal.x;
            let _e740 = normal.y;
            let u_n_l = ((u_l_x * _e737) + (u_l_y * _e740));
            let c_l = sqrt(((1.4f * p_l) * du_ly_drv));
            let _e747 = rho_r;
            let du_ry_drv = (1f / max(_e747, 0.00000001f));
            let _e753 = rho_u_r.x;
            let u_r_x = (_e753 * du_ry_drv);
            let _e756 = rho_u_r.y;
            let u_r_y = (_e756 * du_ry_drv);
            let _e758 = rho_r;
            let ke_r = ((0.5f * _e758) * ((u_r_x * u_r_x) + (u_r_y * u_r_y)));
            let _e765 = rho_e_r;
            let p_r = max(0f, (0.4f * (_e765 - ke_r)));
            let _e772 = normal.x;
            let _e775 = normal.y;
            let u_n_r = ((u_r_x * _e772) + (u_r_y * _e775));
            let c_r = sqrt(((1.4f * p_r) * du_ry_drv));
            let u_face_x = (0.5f * (u_l_x + u_r_x));
            let u_face_y = (0.5f * (u_l_y + u_r_y));
            let _e789 = normal.x;
            let _e792 = normal.y;
            let u_face_n = ((u_face_x * _e789) + (u_face_y * _e792));
            let c_bar = (0.5f * (c_l + c_r));
            let beta = (abs(u_face_n) / max(c_bar, 0.000001f));
            let mach2_ = (beta * beta);
            c_l_eff = (c_l * beta);
            c_r_eff = (c_r * beta);
            let _e809 = constants.precond_model;
            if (_e809 == 1u) {
                let _e814 = constants.precond_theta_floor;
                let theta = min(1f, max(mach2_, _e814));
                let one_minus_theta = (1f - theta);
                c_l_eff = sqrt((((theta * c_l) * c_l) + ((one_minus_theta * u_n_l) * u_n_l)));
                c_r_eff = sqrt((((theta * c_r) * c_r) + ((one_minus_theta * u_n_r) * u_n_r)));
            }
            let flux_adv = (u_face_n * area);
            let _e834 = center_r.x;
            let dx = (_e834 - center.x);
            let _e838 = center_r.y;
            let dy = (_e838 - center.y);
            let dist = max(sqrt(((dx * dx) + (dy * dy))), 0.000001f);
            let mu = constants.viscosity;
            let _e850 = c_l_eff;
            let _e852 = c_r_eff;
            let a_plus = max(0f, max((u_n_l + _e850), (u_n_r + _e852)));
            let _e857 = c_l_eff;
            let _e859 = c_r_eff;
            let a_minus = min(0f, min((u_n_l - _e857), (u_n_r - _e859)));
            let denom = max((a_plus - a_minus), 0.000001f);
            let a_prod = (a_plus * a_minus);
            let a_pos = (a_plus / denom);
            let a_neg = (1f - a_pos);
            let a_prod_scaled = (a_prod / denom);
            let _e872 = rho_l;
            let flux_rho_l = (_e872 * u_n_l);
            let _e874 = rho_r;
            let flux_rho_r = (_e874 * u_n_r);
            let _e879 = rho_r;
            let _e880 = rho_l;
            let flux_rho = (((a_pos * flux_rho_l) + (a_neg * flux_rho_r)) + (a_prod_scaled * (_e879 - _e880)));
            let _e885 = rho_u_l.x;
            let _e888 = normal.x;
            let flux_rho_u_x_l = ((_e885 * u_n_l) + (p_l * _e888));
            let _e892 = rho_u_r.x;
            let _e895 = normal.x;
            let flux_rho_u_x_r = ((_e892 * u_n_r) + (p_r * _e895));
            let _e902 = rho_u_r.x;
            let _e904 = rho_u_l.x;
            flux_rho_u_x = (((a_pos * flux_rho_u_x_l) + (a_neg * flux_rho_u_x_r)) + (a_prod_scaled * (_e902 - _e904)));
            let _e910 = rho_u_l.y;
            let _e913 = normal.y;
            let flux_rho_u_y_l = ((_e910 * u_n_l) + (p_l * _e913));
            let _e917 = rho_u_r.y;
            let _e920 = normal.y;
            let flux_rho_u_y_r = ((_e917 * u_n_r) + (p_r * _e920));
            let _e927 = rho_u_r.y;
            let _e929 = rho_u_l.y;
            flux_rho_u_y = (((a_pos * flux_rho_u_y_l) + (a_neg * flux_rho_u_y_r)) + (a_prod_scaled * (_e927 - _e929)));
            let diff_u_x = ((-(mu) * (u_r_x - u_l_x)) / dist);
            let diff_u_y = ((-(mu) * (u_r_y - u_l_y)) / dist);
            let _e942 = flux_rho_u_x;
            flux_rho_u_x = (_e942 + diff_u_x);
            let _e944 = flux_rho_u_y;
            flux_rho_u_y = (_e944 + diff_u_y);
            let _e946 = rho_e_l;
            let flux_rho_e_l = ((_e946 + p_l) * u_n_l);
            let _e949 = rho_e_r;
            let flux_rho_e_r = ((_e949 + p_r) * u_n_r);
            let _e955 = rho_e_r;
            let _e956 = rho_e_l;
            flux_rho_e = (((a_pos * flux_rho_e_l) + (a_neg * flux_rho_e_r)) + (a_prod_scaled * (_e955 - _e956)));
            let _e961 = flux_rho_e;
            flux_rho_e = ((_e961 + (diff_u_x * u_face_x)) + (diff_u_y * u_face_y));
            let _e968 = sum_rho;
            sum_rho = (_e968 + (flux_rho * area));
            let _e971 = flux_rho_u_x;
            let _e973 = sum_rho_u_x;
            sum_rho_u_x = (_e973 + (_e971 * area));
            let _e976 = flux_rho_u_y;
            let _e978 = sum_rho_u_y;
            sum_rho_u_y = (_e978 + (_e976 * area));
            let _e981 = flux_rho_e;
            let _e983 = sum_rho_e;
            sum_rho_e = (_e983 + (_e981 * area));
            let q_l = ((u_l_x * u_l_x) + (u_l_y * u_l_y));
            let dp_drho_l = (0.2f * q_l);
            let dp_dru_l = (-0.4f * u_l_x);
            let dp_drv_l = (-0.4f * u_l_y);
            let _e994 = rho_e_l;
            let H_l = ((_e994 + p_l) * du_ly_drv);
            let q_r = ((u_r_x * u_r_x) + (u_r_y * u_r_y));
            let dp_drho_r = (0.2f * q_r);
            let dp_dru_r = (-0.4f * u_r_x);
            let dp_drv_r = (-0.4f * u_r_y);
            let _e1006 = rho_e_r;
            let H_r = ((_e1006 + p_r) * du_ry_drv);
            let a_l = (a_plus / denom);
            let a_r = (-(a_minus) / denom);
            jac_l_00_ = -(a_prod_scaled);
            let _e1015 = normal.x;
            jac_l_01_ = (a_l * _e1015);
            let _e1019 = normal.y;
            jac_l_02_ = (a_l * _e1019);
            jac_l_03_ = 0f;
            jac_r_00_ = a_prod_scaled;
            let _e1026 = normal.x;
            jac_r_01_ = (a_r * _e1026);
            let _e1030 = normal.y;
            jac_r_02_ = (a_r * _e1030);
            jac_r_03_ = 0f;
            let _e1038 = normal.x;
            let A_l_10_ = ((-(u_l_x) * u_n_l) + (dp_drho_l * _e1038));
            let _e1042 = normal.x;
            let _e1046 = normal.x;
            let A_l_11_ = ((u_n_l + (u_l_x * _e1042)) + (dp_dru_l * _e1046));
            let _e1050 = normal.y;
            let _e1053 = normal.x;
            let A_l_12_ = ((u_l_x * _e1050) + (dp_drv_l * _e1053));
            let _e1058 = normal.x;
            let A_l_13_ = (0.4f * _e1058);
            let _e1063 = normal.y;
            let A_l_20_ = ((-(u_l_y) * u_n_l) + (dp_drho_l * _e1063));
            let _e1067 = normal.x;
            let _e1070 = normal.y;
            let A_l_21_ = ((u_l_y * _e1067) + (dp_dru_l * _e1070));
            let _e1074 = normal.y;
            let _e1078 = normal.y;
            let A_l_22_ = ((u_n_l + (u_l_y * _e1074)) + (dp_drv_l * _e1078));
            let _e1082 = normal.y;
            let A_l_23_ = (0.4f * _e1082);
            let A_l_30_ = ((-(H_l) * u_n_l) + (dp_drho_l * u_n_l));
            let _e1089 = normal.x;
            let A_l_31_ = ((H_l * _e1089) + (dp_dru_l * u_n_l));
            let _e1094 = normal.y;
            let A_l_32_ = ((H_l * _e1094) + (dp_drv_l * u_n_l));
            let A_l_33_ = (1.4f * u_n_l);
            let _e1103 = normal.x;
            let A_r_10_ = ((-(u_r_x) * u_n_r) + (dp_drho_r * _e1103));
            let _e1107 = normal.x;
            let _e1111 = normal.x;
            let A_r_11_ = ((u_n_r + (u_r_x * _e1107)) + (dp_dru_r * _e1111));
            let _e1115 = normal.y;
            let _e1118 = normal.x;
            let A_r_12_ = ((u_r_x * _e1115) + (dp_drv_r * _e1118));
            let _e1123 = normal.x;
            let A_r_13_ = (0.4f * _e1123);
            let _e1128 = normal.y;
            let A_r_20_ = ((-(u_r_y) * u_n_r) + (dp_drho_r * _e1128));
            let _e1132 = normal.x;
            let _e1135 = normal.y;
            let A_r_21_ = ((u_r_y * _e1132) + (dp_dru_r * _e1135));
            let _e1139 = normal.y;
            let _e1143 = normal.y;
            let A_r_22_ = ((u_n_r + (u_r_y * _e1139)) + (dp_drv_r * _e1143));
            let _e1147 = normal.y;
            let A_r_23_ = (0.4f * _e1147);
            let A_r_30_ = ((-(H_r) * u_n_r) + (dp_drho_r * u_n_r));
            let _e1154 = normal.x;
            let A_r_31_ = ((H_r * _e1154) + (dp_dru_r * u_n_r));
            let _e1159 = normal.y;
            let A_r_32_ = ((H_r * _e1159) + (dp_drv_r * u_n_r));
            let A_r_33_ = (1.4f * u_n_r);
            jac_l_10_ = (a_l * A_l_10_);
            jac_l_11_ = ((a_l * A_l_11_) - a_prod_scaled);
            jac_l_12_ = (a_l * A_l_12_);
            jac_l_13_ = (a_l * A_l_13_);
            jac_r_10_ = (a_r * A_r_10_);
            jac_r_11_ = ((a_r * A_r_11_) + a_prod_scaled);
            jac_r_12_ = (a_r * A_r_12_);
            jac_r_13_ = (a_r * A_r_13_);
            jac_l_20_ = (a_l * A_l_20_);
            jac_l_21_ = (a_l * A_l_21_);
            jac_l_22_ = ((a_l * A_l_22_) - a_prod_scaled);
            jac_l_23_ = (a_l * A_l_23_);
            jac_r_20_ = (a_r * A_r_20_);
            jac_r_21_ = (a_r * A_r_21_);
            jac_r_22_ = ((a_r * A_r_22_) + a_prod_scaled);
            jac_r_23_ = (a_r * A_r_23_);
            jac_l_30_ = (a_l * A_l_30_);
            jac_l_31_ = (a_l * A_l_31_);
            jac_l_32_ = (a_l * A_l_32_);
            jac_l_33_ = ((a_l * A_l_33_) - a_prod_scaled);
            jac_r_30_ = (a_r * A_r_30_);
            jac_r_31_ = (a_r * A_r_31_);
            jac_r_32_ = (a_r * A_r_32_);
            jac_r_33_ = ((a_r * A_r_33_) + a_prod_scaled);
            let mu_over_dist = (mu / dist);
            let du_lx_drho = (-(u_l_x) * du_ly_drv);
            let du_ly_drho = (-(u_l_y) * du_ly_drv);
            let du_rx_drho = (-(u_r_x) * du_ry_drv);
            let du_ry_drho = (-(u_r_y) * du_ry_drv);
            let d_diff_x_l_rho = (mu_over_dist * du_lx_drho);
            let d_diff_x_l_ru = (mu_over_dist * du_ly_drv);
            let d_diff_y_l_rho = (mu_over_dist * du_ly_drho);
            let d_diff_y_l_rv = (mu_over_dist * du_ly_drv);
            let d_diff_x_r_rho = (-(mu_over_dist) * du_rx_drho);
            let d_diff_x_r_ru = (-(mu_over_dist) * du_ry_drv);
            let d_diff_y_r_rho = (-(mu_over_dist) * du_ry_drho);
            let d_diff_y_r_rv = (-(mu_over_dist) * du_ry_drv);
            let _e1240 = jac_l_10_;
            jac_l_10_ = (_e1240 + d_diff_x_l_rho);
            let _e1242 = jac_l_11_;
            jac_l_11_ = (_e1242 + d_diff_x_l_ru);
            let _e1245 = jac_l_12_;
            jac_l_12_ = (_e1245 + 0f);
            let _e1248 = jac_l_13_;
            jac_l_13_ = (_e1248 + 0f);
            let _e1250 = jac_l_20_;
            jac_l_20_ = (_e1250 + d_diff_y_l_rho);
            let _e1253 = jac_l_21_;
            jac_l_21_ = (_e1253 + 0f);
            let _e1255 = jac_l_22_;
            jac_l_22_ = (_e1255 + d_diff_y_l_rv);
            let _e1258 = jac_l_23_;
            jac_l_23_ = (_e1258 + 0f);
            let _e1260 = jac_r_10_;
            jac_r_10_ = (_e1260 + d_diff_x_r_rho);
            let _e1262 = jac_r_11_;
            jac_r_11_ = (_e1262 + d_diff_x_r_ru);
            let _e1265 = jac_r_12_;
            jac_r_12_ = (_e1265 + 0f);
            let _e1268 = jac_r_13_;
            jac_r_13_ = (_e1268 + 0f);
            let _e1270 = jac_r_20_;
            jac_r_20_ = (_e1270 + d_diff_y_r_rho);
            let _e1273 = jac_r_21_;
            jac_r_21_ = (_e1273 + 0f);
            let _e1275 = jac_r_22_;
            jac_r_22_ = (_e1275 + d_diff_y_r_rv);
            let _e1278 = jac_r_23_;
            jac_r_23_ = (_e1278 + 0f);
            let du_face_x_l_rho = (0.5f * du_lx_drho);
            let du_face_x_l_ru = (0.5f * du_ly_drv);
            let du_face_y_l_rho = (0.5f * du_ly_drho);
            let du_face_y_l_rv = (0.5f * du_ly_drv);
            let du_face_x_r_rho = (0.5f * du_rx_drho);
            let du_face_x_r_ru = (0.5f * du_ry_drv);
            let du_face_y_r_rho = (0.5f * du_ry_drho);
            let du_face_y_r_rv = (0.5f * du_ry_drv);
            let d_e_visc_l_rho = ((((d_diff_x_l_rho * u_face_x) + (diff_u_x * du_face_x_l_rho)) + (d_diff_y_l_rho * u_face_y)) + (diff_u_y * du_face_y_l_rho));
            let d_e_visc_l_ru = ((((d_diff_x_l_ru * u_face_x) + (diff_u_x * du_face_x_l_ru)) + (0f * u_face_y)) + (diff_u_y * 0f));
            let d_e_visc_l_rv = ((((0f * u_face_x) + (diff_u_x * 0f)) + (d_diff_y_l_rv * u_face_y)) + (diff_u_y * du_face_y_l_rv));
            let d_e_visc_l_re = ((((0f * u_face_x) + (diff_u_x * 0f)) + (0f * u_face_y)) + (diff_u_y * 0f));
            let d_e_visc_r_rho = ((((d_diff_x_r_rho * u_face_x) + (diff_u_x * du_face_x_r_rho)) + (d_diff_y_r_rho * u_face_y)) + (diff_u_y * du_face_y_r_rho));
            let d_e_visc_r_ru = ((((d_diff_x_r_ru * u_face_x) + (diff_u_x * du_face_x_r_ru)) + (0f * u_face_y)) + (diff_u_y * 0f));
            let d_e_visc_r_rv = ((((0f * u_face_x) + (diff_u_x * 0f)) + (d_diff_y_r_rv * u_face_y)) + (diff_u_y * du_face_y_r_rv));
            let d_e_visc_r_re = ((((0f * u_face_x) + (diff_u_x * 0f)) + (0f * u_face_y)) + (diff_u_y * 0f));
            let _e1360 = jac_l_30_;
            jac_l_30_ = (_e1360 + d_e_visc_l_rho);
            let _e1362 = jac_l_31_;
            jac_l_31_ = (_e1362 + d_e_visc_l_ru);
            let _e1364 = jac_l_32_;
            jac_l_32_ = (_e1364 + d_e_visc_l_rv);
            let _e1366 = jac_l_33_;
            jac_l_33_ = (_e1366 + d_e_visc_l_re);
            let _e1368 = jac_r_30_;
            jac_r_30_ = (_e1368 + d_e_visc_r_rho);
            let _e1370 = jac_r_31_;
            jac_r_31_ = (_e1370 + d_e_visc_r_ru);
            let _e1372 = jac_r_32_;
            jac_r_32_ = (_e1372 + d_e_visc_r_rv);
            let _e1374 = jac_r_33_;
            jac_r_33_ = (_e1374 + d_e_visc_r_re);
            let _e1376 = is_boundary;
            if !(_e1376) {
                let _e1379 = face_offset;
                let scalar_mat_idx = cell_face_matrix_indices[_e1379];
                neighbor_rank = 0u;
                if (scalar_mat_idx != 4294967295u) {
                    neighbor_rank = (scalar_mat_idx - scalar_offset);
                } else {
                    neighbor_rank = (scalar_mat_idx - scalar_offset);
                }
                let _e1389 = neighbor_rank;
                let base_0_ = (start_row_0_ + (4u * _e1389));
                let _e1393 = neighbor_rank;
                let base_1_ = (start_row_1_ + (4u * _e1393));
                let _e1397 = neighbor_rank;
                let base_2_ = (start_row_2_ + (4u * _e1397));
                let _e1401 = neighbor_rank;
                let base_3_ = (start_row_3_ + (4u * _e1401));
                let _e1408 = jac_r_00_;
                matrix_values[(base_0_ + 0u)] = (_e1408 * area);
                let _e1414 = jac_r_01_;
                matrix_values[(base_0_ + 1u)] = (_e1414 * area);
                let _e1420 = jac_r_02_;
                matrix_values[(base_0_ + 2u)] = (_e1420 * area);
                let _e1426 = jac_r_03_;
                matrix_values[(base_0_ + 3u)] = (_e1426 * area);
                let _e1432 = jac_r_10_;
                matrix_values[(base_1_ + 0u)] = (_e1432 * area);
                let _e1438 = jac_r_11_;
                matrix_values[(base_1_ + 1u)] = (_e1438 * area);
                let _e1444 = jac_r_12_;
                matrix_values[(base_1_ + 2u)] = (_e1444 * area);
                let _e1450 = jac_r_13_;
                matrix_values[(base_1_ + 3u)] = (_e1450 * area);
                let _e1456 = jac_r_20_;
                matrix_values[(base_2_ + 0u)] = (_e1456 * area);
                let _e1462 = jac_r_21_;
                matrix_values[(base_2_ + 1u)] = (_e1462 * area);
                let _e1468 = jac_r_22_;
                matrix_values[(base_2_ + 2u)] = (_e1468 * area);
                let _e1474 = jac_r_23_;
                matrix_values[(base_2_ + 3u)] = (_e1474 * area);
                let _e1480 = jac_r_30_;
                matrix_values[(base_3_ + 0u)] = (_e1480 * area);
                let _e1486 = jac_r_31_;
                matrix_values[(base_3_ + 1u)] = (_e1486 * area);
                let _e1492 = jac_r_32_;
                matrix_values[(base_3_ + 2u)] = (_e1492 * area);
                let _e1498 = jac_r_33_;
                matrix_values[(base_3_ + 3u)] = (_e1498 * area);
                let _e1501 = jac_l_00_;
                let _e1503 = diag_00_;
                diag_00_ = (_e1503 + (_e1501 * area));
                let _e1506 = jac_l_01_;
                let _e1508 = diag_01_;
                diag_01_ = (_e1508 + (_e1506 * area));
                let _e1511 = jac_l_02_;
                let _e1513 = diag_02_;
                diag_02_ = (_e1513 + (_e1511 * area));
                let _e1516 = jac_l_03_;
                let _e1518 = diag_03_;
                diag_03_ = (_e1518 + (_e1516 * area));
                let _e1521 = jac_l_10_;
                let _e1523 = diag_10_;
                diag_10_ = (_e1523 + (_e1521 * area));
                let _e1526 = jac_l_11_;
                let _e1528 = diag_11_;
                diag_11_ = (_e1528 + (_e1526 * area));
                let _e1531 = jac_l_12_;
                let _e1533 = diag_12_;
                diag_12_ = (_e1533 + (_e1531 * area));
                let _e1536 = jac_l_13_;
                let _e1538 = diag_13_;
                diag_13_ = (_e1538 + (_e1536 * area));
                let _e1541 = jac_l_20_;
                let _e1543 = diag_20_;
                diag_20_ = (_e1543 + (_e1541 * area));
                let _e1546 = jac_l_21_;
                let _e1548 = diag_21_;
                diag_21_ = (_e1548 + (_e1546 * area));
                let _e1551 = jac_l_22_;
                let _e1553 = diag_22_;
                diag_22_ = (_e1553 + (_e1551 * area));
                let _e1556 = jac_l_23_;
                let _e1558 = diag_23_;
                diag_23_ = (_e1558 + (_e1556 * area));
                let _e1561 = jac_l_30_;
                let _e1563 = diag_30_;
                diag_30_ = (_e1563 + (_e1561 * area));
                let _e1566 = jac_l_31_;
                let _e1568 = diag_31_;
                diag_31_ = (_e1568 + (_e1566 * area));
                let _e1571 = jac_l_32_;
                let _e1573 = diag_32_;
                diag_32_ = (_e1573 + (_e1571 * area));
                let _e1576 = jac_l_33_;
                let _e1578 = diag_33_;
                diag_33_ = (_e1578 + (_e1576 * area));
            } else {
                let _e1580 = jac_l_00_;
                let _e1581 = jac_r_00_;
                eff_00_ = (_e1580 + _e1581);
                let _e1584 = jac_l_01_;
                let _e1585 = jac_r_01_;
                eff_01_ = (_e1584 + _e1585);
                let _e1588 = jac_l_02_;
                let _e1589 = jac_r_02_;
                eff_02_ = (_e1588 + _e1589);
                let _e1592 = jac_l_03_;
                let _e1593 = jac_r_03_;
                eff_03_ = (_e1592 + _e1593);
                let _e1596 = jac_l_10_;
                let _e1597 = jac_r_10_;
                eff_10_ = (_e1596 + _e1597);
                let _e1600 = jac_l_11_;
                let _e1601 = jac_r_11_;
                eff_11_ = (_e1600 + _e1601);
                let _e1604 = jac_l_12_;
                let _e1605 = jac_r_12_;
                eff_12_ = (_e1604 + _e1605);
                let _e1608 = jac_l_13_;
                let _e1609 = jac_r_13_;
                eff_13_ = (_e1608 + _e1609);
                let _e1612 = jac_l_20_;
                let _e1613 = jac_r_20_;
                eff_20_ = (_e1612 + _e1613);
                let _e1616 = jac_l_21_;
                let _e1617 = jac_r_21_;
                eff_21_ = (_e1616 + _e1617);
                let _e1620 = jac_l_22_;
                let _e1621 = jac_r_22_;
                eff_22_ = (_e1620 + _e1621);
                let _e1624 = jac_l_23_;
                let _e1625 = jac_r_23_;
                eff_23_ = (_e1624 + _e1625);
                let _e1628 = jac_l_30_;
                let _e1629 = jac_r_30_;
                eff_30_ = (_e1628 + _e1629);
                let _e1632 = jac_l_31_;
                let _e1633 = jac_r_31_;
                eff_31_ = (_e1632 + _e1633);
                let _e1636 = jac_l_32_;
                let _e1637 = jac_r_32_;
                eff_32_ = (_e1636 + _e1637);
                let _e1640 = jac_l_33_;
                let _e1641 = jac_r_33_;
                eff_33_ = (_e1640 + _e1641);
                if (boundary_type == 1u) {
                    let _e1646 = jac_l_00_;
                    let _e1647 = jac_r_00_;
                    let _e1649 = jac_r_01_;
                    let _e1652 = constants.inlet_velocity;
                    eff_00_ = ((_e1646 + _e1647) + (_e1649 * _e1652));
                    let _e1655 = jac_l_01_;
                    eff_01_ = _e1655;
                    let _e1656 = jac_l_02_;
                    eff_02_ = _e1656;
                    let _e1657 = jac_l_03_;
                    let _e1658 = jac_r_03_;
                    eff_03_ = (_e1657 + _e1658);
                    let _e1660 = jac_l_10_;
                    let _e1661 = jac_r_10_;
                    let _e1663 = jac_r_11_;
                    let _e1666 = constants.inlet_velocity;
                    eff_10_ = ((_e1660 + _e1661) + (_e1663 * _e1666));
                    let _e1669 = jac_l_11_;
                    eff_11_ = _e1669;
                    let _e1670 = jac_l_12_;
                    eff_12_ = _e1670;
                    let _e1671 = jac_l_13_;
                    let _e1672 = jac_r_13_;
                    eff_13_ = (_e1671 + _e1672);
                    let _e1674 = jac_l_20_;
                    let _e1675 = jac_r_20_;
                    let _e1677 = jac_r_21_;
                    let _e1680 = constants.inlet_velocity;
                    eff_20_ = ((_e1674 + _e1675) + (_e1677 * _e1680));
                    let _e1683 = jac_l_21_;
                    eff_21_ = _e1683;
                    let _e1684 = jac_l_22_;
                    eff_22_ = _e1684;
                    let _e1685 = jac_l_23_;
                    let _e1686 = jac_r_23_;
                    eff_23_ = (_e1685 + _e1686);
                    let _e1688 = jac_l_30_;
                    let _e1689 = jac_r_30_;
                    let _e1691 = jac_r_31_;
                    let _e1694 = constants.inlet_velocity;
                    eff_30_ = ((_e1688 + _e1689) + (_e1691 * _e1694));
                    let _e1697 = jac_l_31_;
                    eff_31_ = _e1697;
                    let _e1698 = jac_l_32_;
                    eff_32_ = _e1698;
                    let _e1699 = jac_l_33_;
                    let _e1700 = jac_r_33_;
                    eff_33_ = (_e1699 + _e1700);
                } else {
                    if (boundary_type == 3u) {
                        let _e1704 = jac_l_00_;
                        let _e1705 = jac_r_00_;
                        eff_00_ = (_e1704 + _e1705);
                        let _e1707 = jac_l_01_;
                        let _e1708 = jac_r_01_;
                        eff_01_ = (_e1707 - _e1708);
                        let _e1710 = jac_l_02_;
                        let _e1711 = jac_r_02_;
                        eff_02_ = (_e1710 - _e1711);
                        let _e1713 = jac_l_03_;
                        let _e1714 = jac_r_03_;
                        eff_03_ = (_e1713 + _e1714);
                        let _e1716 = jac_l_10_;
                        let _e1717 = jac_r_10_;
                        eff_10_ = (_e1716 + _e1717);
                        let _e1719 = jac_l_11_;
                        let _e1720 = jac_r_11_;
                        eff_11_ = (_e1719 - _e1720);
                        let _e1722 = jac_l_12_;
                        let _e1723 = jac_r_12_;
                        eff_12_ = (_e1722 - _e1723);
                        let _e1725 = jac_l_13_;
                        let _e1726 = jac_r_13_;
                        eff_13_ = (_e1725 + _e1726);
                        let _e1728 = jac_l_20_;
                        let _e1729 = jac_r_20_;
                        eff_20_ = (_e1728 + _e1729);
                        let _e1731 = jac_l_21_;
                        let _e1732 = jac_r_21_;
                        eff_21_ = (_e1731 - _e1732);
                        let _e1734 = jac_l_22_;
                        let _e1735 = jac_r_22_;
                        eff_22_ = (_e1734 - _e1735);
                        let _e1737 = jac_l_23_;
                        let _e1738 = jac_r_23_;
                        eff_23_ = (_e1737 + _e1738);
                        let _e1740 = jac_l_30_;
                        let _e1741 = jac_r_30_;
                        eff_30_ = (_e1740 + _e1741);
                        let _e1743 = jac_l_31_;
                        let _e1744 = jac_r_31_;
                        eff_31_ = (_e1743 - _e1744);
                        let _e1746 = jac_l_32_;
                        let _e1747 = jac_r_32_;
                        eff_32_ = (_e1746 - _e1747);
                        let _e1749 = jac_l_33_;
                        let _e1750 = jac_r_33_;
                        eff_33_ = (_e1749 + _e1750);
                    }
                }
                let _e1752 = eff_00_;
                let _e1754 = diag_00_;
                diag_00_ = (_e1754 + (_e1752 * area));
                let _e1756 = eff_01_;
                let _e1758 = diag_01_;
                diag_01_ = (_e1758 + (_e1756 * area));
                let _e1760 = eff_02_;
                let _e1762 = diag_02_;
                diag_02_ = (_e1762 + (_e1760 * area));
                let _e1764 = eff_03_;
                let _e1766 = diag_03_;
                diag_03_ = (_e1766 + (_e1764 * area));
                let _e1768 = eff_10_;
                let _e1770 = diag_10_;
                diag_10_ = (_e1770 + (_e1768 * area));
                let _e1772 = eff_11_;
                let _e1774 = diag_11_;
                diag_11_ = (_e1774 + (_e1772 * area));
                let _e1776 = eff_12_;
                let _e1778 = diag_12_;
                diag_12_ = (_e1778 + (_e1776 * area));
                let _e1780 = eff_13_;
                let _e1782 = diag_13_;
                diag_13_ = (_e1782 + (_e1780 * area));
                let _e1784 = eff_20_;
                let _e1786 = diag_20_;
                diag_20_ = (_e1786 + (_e1784 * area));
                let _e1788 = eff_21_;
                let _e1790 = diag_21_;
                diag_21_ = (_e1790 + (_e1788 * area));
                let _e1792 = eff_22_;
                let _e1794 = diag_22_;
                diag_22_ = (_e1794 + (_e1792 * area));
                let _e1796 = eff_23_;
                let _e1798 = diag_23_;
                diag_23_ = (_e1798 + (_e1796 * area));
                let _e1800 = eff_30_;
                let _e1802 = diag_30_;
                diag_30_ = (_e1802 + (_e1800 * area));
                let _e1804 = eff_31_;
                let _e1806 = diag_31_;
                diag_31_ = (_e1806 + (_e1804 * area));
                let _e1808 = eff_32_;
                let _e1810 = diag_32_;
                diag_32_ = (_e1810 + (_e1808 * area));
                let _e1812 = eff_33_;
                let _e1814 = diag_33_;
                diag_33_ = (_e1814 + (_e1812 * area));
            }
        }
        continuing {
            let _e1817 = face_offset;
            face_offset = (_e1817 + 1u);
        }
    }
    let _e1819 = rhs_time_rho;
    let _e1820 = rhs_pseudo_rho;
    let _e1822 = coeff_time;
    let _e1823 = coeff_pseudo;
    let _e1827 = sum_rho;
    rhs_rho = (((_e1819 + _e1820) - ((_e1822 + _e1823) * rho)) - _e1827);
    let _e1830 = rhs_time_rho_u_x;
    let _e1831 = rhs_pseudo_rho_u_x;
    let _e1833 = coeff_time;
    let _e1834 = coeff_pseudo;
    let _e1839 = sum_rho_u_x;
    rhs_rho_u_x = (((_e1830 + _e1831) - ((_e1833 + _e1834) * rho_u.x)) - _e1839);
    let _e1842 = rhs_time_rho_u_y;
    let _e1843 = rhs_pseudo_rho_u_y;
    let _e1845 = coeff_time;
    let _e1846 = coeff_pseudo;
    let _e1851 = sum_rho_u_y;
    rhs_rho_u_y = (((_e1842 + _e1843) - ((_e1845 + _e1846) * rho_u.y)) - _e1851);
    let _e1854 = rhs_time_rho_e;
    let _e1855 = rhs_pseudo_rho_e;
    let _e1857 = coeff_time;
    let _e1858 = coeff_pseudo;
    let _e1862 = sum_rho_e;
    rhs_rho_e = (((_e1854 + _e1855) - ((_e1857 + _e1858) * rho_e)) - _e1862);
    let _e1865 = coeff_time;
    let _e1866 = diag_00_;
    diag_00_ = (_e1866 + _e1865);
    let _e1868 = coeff_time;
    let _e1869 = diag_11_;
    diag_11_ = (_e1869 + _e1868);
    let _e1871 = coeff_time;
    let _e1872 = diag_22_;
    diag_22_ = (_e1872 + _e1871);
    let _e1874 = coeff_time;
    let _e1875 = diag_33_;
    diag_33_ = (_e1875 + _e1874);
    let _e1877 = coeff_pseudo;
    let _e1878 = diag_00_;
    diag_00_ = (_e1878 + _e1877);
    let _e1880 = coeff_pseudo;
    let _e1881 = diag_11_;
    diag_11_ = (_e1881 + _e1880);
    let _e1883 = coeff_pseudo;
    let _e1884 = diag_22_;
    diag_22_ = (_e1884 + _e1883);
    let _e1886 = coeff_pseudo;
    let _e1887 = diag_33_;
    diag_33_ = (_e1887 + _e1886);
    let scalar_diag_idx = diagonal_indices[idx];
    let diag_rank = (scalar_diag_idx - scalar_offset);
    let diag_base_0_ = (start_row_0_ + (4u * diag_rank));
    let diag_base_1_ = (start_row_1_ + (4u * diag_rank));
    let diag_base_2_ = (start_row_2_ + (4u * diag_rank));
    let diag_base_3_ = (start_row_3_ + (4u * diag_rank));
    let _e1909 = diag_00_;
    matrix_values[(diag_base_0_ + 0u)] = _e1909;
    let _e1914 = diag_01_;
    matrix_values[(diag_base_0_ + 1u)] = _e1914;
    let _e1919 = diag_02_;
    matrix_values[(diag_base_0_ + 2u)] = _e1919;
    let _e1924 = diag_03_;
    matrix_values[(diag_base_0_ + 3u)] = _e1924;
    let _e1929 = diag_10_;
    matrix_values[(diag_base_1_ + 0u)] = _e1929;
    let _e1934 = diag_11_;
    matrix_values[(diag_base_1_ + 1u)] = _e1934;
    let _e1939 = diag_12_;
    matrix_values[(diag_base_1_ + 2u)] = _e1939;
    let _e1944 = diag_13_;
    matrix_values[(diag_base_1_ + 3u)] = _e1944;
    let _e1949 = diag_20_;
    matrix_values[(diag_base_2_ + 0u)] = _e1949;
    let _e1954 = diag_21_;
    matrix_values[(diag_base_2_ + 1u)] = _e1954;
    let _e1959 = diag_22_;
    matrix_values[(diag_base_2_ + 2u)] = _e1959;
    let _e1964 = diag_23_;
    matrix_values[(diag_base_2_ + 3u)] = _e1964;
    let _e1969 = diag_30_;
    matrix_values[(diag_base_3_ + 0u)] = _e1969;
    let _e1974 = diag_31_;
    matrix_values[(diag_base_3_ + 1u)] = _e1974;
    let _e1979 = diag_32_;
    matrix_values[(diag_base_3_ + 2u)] = _e1979;
    let _e1984 = diag_33_;
    matrix_values[(diag_base_3_ + 3u)] = _e1984;
    let _e1991 = rhs_rho;
    rhs[((4u * idx) + 0u)] = _e1991;
    let _e1998 = rhs_rho_u_x;
    rhs[((4u * idx) + 1u)] = _e1998;
    let _e2005 = rhs_rho_u_y;
    rhs[((4u * idx) + 2u)] = _e2005;
    let _e2012 = rhs_rho_e;
    rhs[((4u * idx) + 3u)] = _e2012;
    return;
}
"#;
    }
    pub mod compressible_flux_kt {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
            #[doc = "offset: 56, size: 4, type: `u32`"]
            pub precond_type: u32,
            #[doc = "offset: 60, size: 4, type: `u32`"]
            pub precond_model: u32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub precond_theta_floor: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
                precond_type: u32,
                precond_model: u32,
                precond_theta_floor: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                    precond_type,
                    precond_model,
                    precond_theta_floor,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleFluxKt::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleFluxKt::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_rho: wgpu::BufferBinding<'a>,
            pub grad_rho_u_x: wgpu::BufferBinding<'a>,
            pub grad_rho_u_y: wgpu::BufferBinding<'a>,
            pub grad_rho_e: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_rho: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_x: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_y: wgpu::BindGroupEntry<'a>,
            pub grad_rho_e: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_rho: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho),
                    },
                    grad_rho_u_x: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_x),
                    },
                    grad_rho_u_y: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_y),
                    },
                    grad_rho_e: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_e),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.grad_rho,
                    self.grad_rho_u_x,
                    self.grad_rho_u_y,
                    self.grad_rho_e,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleFluxKt::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::compressible_flux_kt::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"grad_rho\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"grad_rho_u_x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"grad_rho_u_y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"grad_rho_e\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"state_iter\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleFluxKt::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedCompressibleFluxKt::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("compressible_flux_kt.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(8) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(9) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2_>;
@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2_>;
@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2_>;
@group(1) @binding(9) 
var<storage> state_iter: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var normal: Vector2_;
    var is_boundary: bool = false;
    var other_idx: u32;
    var rho_l: f32;
    var rho_u_l: vec2<f32>;
    var rho_e_l: f32;
    var rho_r: f32;
    var rho_u_r: vec2<f32>;
    var rho_e_r: f32;
    var center_r: Vector2_;
    var c_l_eff: f32;
    var c_r_eff: f32;
    var flux_rho_u_x: f32;
    var flux_rho_u_y: f32;
    var flux_rho_e: f32;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let center_owner = cell_centers[owner];
    let _e32 = face_normals[idx];
    normal = _e32;
    other_idx = owner;
    let rho_l_cell = state_old[((owner * 7u) + 0u)];
    let _e48 = state_old[((owner * 7u) + 1u)];
    let _e55 = state_old[((owner * 7u) + 2u)];
    let rho_u_l_cell = vec2<f32>(_e48, _e55);
    let rho_e_l_cell = state_old[((owner * 7u) + 3u)];
    rho_l = rho_l_cell;
    rho_u_l = rho_u_l_cell;
    rho_e_l = rho_e_l_cell;
    let _e67 = rho_l;
    rho_r = _e67;
    let _e69 = rho_u_l;
    rho_u_r = _e69;
    let _e71 = rho_e_l;
    rho_e_r = _e71;
    center_r = face_center;
    if (neighbor != -1i) {
        let neigh_idx = u32(neighbor);
        other_idx = neigh_idx;
        let rho_neigh = state_old[((neigh_idx * 7u) + 0u)];
        let _e90 = state_old[((neigh_idx * 7u) + 1u)];
        let _e97 = state_old[((neigh_idx * 7u) + 2u)];
        let rho_u_neigh = vec2<f32>(_e90, _e97);
        let rho_e_neigh = state_old[((neigh_idx * 7u) + 3u)];
        rho_r = rho_neigh;
        rho_u_r.x = rho_u_neigh.x;
        rho_u_r.y = rho_u_neigh.y;
        rho_e_r = rho_e_neigh;
        let _e112 = cell_centers[neigh_idx];
        center_r = _e112;
    } else {
        is_boundary = true;
        if (boundary_type == 1u) {
            let _e118 = rho_r;
            let _e121 = constants.inlet_velocity;
            rho_u_r.x = (_e118 * _e121);
            rho_u_r.y = 0f;
        } else {
            if (boundary_type == 3u) {
                let _e129 = rho_u_l.x;
                rho_u_r.x = -(_e129);
                let _e133 = rho_u_l.y;
                rho_u_r.y = -(_e133);
            }
        }
    }
    let rho_r_cell = rho_r;
    let rho_u_r_cell = rho_u_r;
    let rho_e_r_cell = rho_e_r;
    let _e138 = is_boundary;
    let _e142 = constants.scheme;
    if (!(_e138) && (_e142 != 0u)) {
        let r_l_x = (face_center.x - center_owner.x);
        let r_l_y = (face_center.y - center_owner.y);
        let _e154 = center_r.x;
        let r_r_x = (face_center.x - _e154);
        let _e158 = center_r.y;
        let r_r_y = (face_center.y - _e158);
        let inv_rho_l_cell = (1f / max(rho_l_cell, 0.00000001f));
        let u_l_x_cell = (rho_u_l_cell.x * inv_rho_l_cell);
        let u_l_y_cell = (rho_u_l_cell.y * inv_rho_l_cell);
        let u2_l_cell = ((u_l_x_cell * u_l_x_cell) + (u_l_y_cell * u_l_y_cell));
        let p_l_cell = max(0f, (0.4f * (rho_e_l_cell - ((0.5f * rho_l_cell) * u2_l_cell))));
        let inv_rho_r_cell = (1f / max(rho_r_cell, 0.00000001f));
        let u_r_x_cell = (rho_u_r_cell.x * inv_rho_r_cell);
        let u_r_y_cell = (rho_u_r_cell.y * inv_rho_r_cell);
        let u2_r_cell = ((u_r_x_cell * u_r_x_cell) + (u_r_y_cell * u_r_y_cell));
        let p_r_cell = max(0f, (0.4f * (rho_e_r_cell - ((0.5f * rho_r_cell) * u2_r_cell))));
        let grad_rho_l = grad_rho[owner];
        let grad_rho_u_x_l = grad_rho_u_x[owner];
        let grad_rho_u_y_l = grad_rho_u_y[owner];
        let grad_rho_e_l = grad_rho_e[owner];
        let _e211 = other_idx;
        let grad_rho_r = grad_rho[_e211];
        let _e215 = other_idx;
        let grad_rho_u_x_r = grad_rho_u_x[_e215];
        let _e219 = other_idx;
        let grad_rho_u_y_r = grad_rho_u_y[_e219];
        let _e223 = other_idx;
        let grad_rho_e_r = grad_rho_e[_e223];
        let grad_u_x_l_x = ((grad_rho_u_x_l.x - (u_l_x_cell * grad_rho_l.x)) * inv_rho_l_cell);
        let grad_u_x_l_y = ((grad_rho_u_x_l.y - (u_l_x_cell * grad_rho_l.y)) * inv_rho_l_cell);
        let grad_u_y_l_x = ((grad_rho_u_y_l.x - (u_l_y_cell * grad_rho_l.x)) * inv_rho_l_cell);
        let grad_u_y_l_y = ((grad_rho_u_y_l.y - (u_l_y_cell * grad_rho_l.y)) * inv_rho_l_cell);
        let grad_u_x_r_x = ((grad_rho_u_x_r.x - (u_r_x_cell * grad_rho_r.x)) * inv_rho_r_cell);
        let grad_u_x_r_y = ((grad_rho_u_x_r.y - (u_r_x_cell * grad_rho_r.y)) * inv_rho_r_cell);
        let grad_u_y_r_x = ((grad_rho_u_y_r.x - (u_r_y_cell * grad_rho_r.x)) * inv_rho_r_cell);
        let grad_u_y_r_y = ((grad_rho_u_y_r.y - (u_r_y_cell * grad_rho_r.y)) * inv_rho_r_cell);
        let grad_u2_l_x = (((2f * u_l_x_cell) * grad_u_x_l_x) + ((2f * u_l_y_cell) * grad_u_y_l_x));
        let grad_u2_l_y = (((2f * u_l_x_cell) * grad_u_x_l_y) + ((2f * u_l_y_cell) * grad_u_y_l_y));
        let grad_u2_r_x = (((2f * u_r_x_cell) * grad_u_x_r_x) + ((2f * u_r_y_cell) * grad_u_y_r_x));
        let grad_u2_r_y = (((2f * u_r_x_cell) * grad_u_x_r_y) + ((2f * u_r_y_cell) * grad_u_y_r_y));
        let grad_rho_u2_l_x = ((u2_l_cell * grad_rho_l.x) + (rho_l_cell * grad_u2_l_x));
        let grad_rho_u2_l_y = ((u2_l_cell * grad_rho_l.y) + (rho_l_cell * grad_u2_l_y));
        let grad_rho_u2_r_x = ((u2_r_cell * grad_rho_r.x) + (rho_r_cell * grad_u2_r_x));
        let grad_rho_u2_r_y = ((u2_r_cell * grad_rho_r.y) + (rho_r_cell * grad_u2_r_y));
        let grad_p_l_x = (0.4f * (grad_rho_e_l.x - (0.5f * grad_rho_u2_l_x)));
        let grad_p_l_y = (0.4f * (grad_rho_e_l.y - (0.5f * grad_rho_u2_l_y)));
        let grad_p_r_x = (0.4f * (grad_rho_e_r.x - (0.5f * grad_rho_u2_r_x)));
        let grad_p_r_y = (0.4f * (grad_rho_e_r.y - (0.5f * grad_rho_u2_r_y)));
        let diff_rho_l = (rho_r_cell - rho_l_cell);
        let min_diff_rho_l = min(diff_rho_l, 0f);
        let max_diff_rho_l = max(diff_rho_l, 0f);
        let delta_rho_l = ((grad_rho_l.x * r_l_x) + (grad_rho_l.y * r_l_y));
        let delta_rho_l_limited = min(max(delta_rho_l, min_diff_rho_l), max_diff_rho_l);
        let diff_u_l_x = (u_r_x_cell - u_l_x_cell);
        let min_diff_u_l_x = min(diff_u_l_x, 0f);
        let max_diff_u_l_x = max(diff_u_l_x, 0f);
        let delta_u_l_x = ((grad_u_x_l_x * r_l_x) + (grad_u_x_l_y * r_l_y));
        let delta_u_l_x_limited = min(max(delta_u_l_x, min_diff_u_l_x), max_diff_u_l_x);
        let diff_u_l_y = (u_r_y_cell - u_l_y_cell);
        let min_diff_u_l_y = min(diff_u_l_y, 0f);
        let max_diff_u_l_y = max(diff_u_l_y, 0f);
        let delta_u_l_y = ((grad_u_y_l_x * r_l_x) + (grad_u_y_l_y * r_l_y));
        let delta_u_l_y_limited = min(max(delta_u_l_y, min_diff_u_l_y), max_diff_u_l_y);
        let diff_p_l = (p_r_cell - p_l_cell);
        let min_diff_p_l = min(diff_p_l, 0f);
        let max_diff_p_l = max(diff_p_l, 0f);
        let delta_p_l = ((grad_p_l_x * r_l_x) + (grad_p_l_y * r_l_y));
        let delta_p_l_limited = min(max(delta_p_l, min_diff_p_l), max_diff_p_l);
        let rho_l_face = (rho_l_cell + delta_rho_l_limited);
        let u_l_x_face = (u_l_x_cell + delta_u_l_x_limited);
        let u_l_y_face = (u_l_y_cell + delta_u_l_y_limited);
        let p_l_face = (p_l_cell + delta_p_l_limited);
        let diff_rho_r = (rho_l_cell - rho_r_cell);
        let min_diff_rho_r = min(diff_rho_r, 0f);
        let max_diff_rho_r = max(diff_rho_r, 0f);
        let delta_rho_r = ((grad_rho_r.x * r_r_x) + (grad_rho_r.y * r_r_y));
        let delta_rho_r_limited = min(max(delta_rho_r, min_diff_rho_r), max_diff_rho_r);
        let diff_u_r_x = (u_l_x_cell - u_r_x_cell);
        let min_diff_u_r_x = min(diff_u_r_x, 0f);
        let max_diff_u_r_x = max(diff_u_r_x, 0f);
        let delta_u_r_x = ((grad_u_x_r_x * r_r_x) + (grad_u_x_r_y * r_r_y));
        let delta_u_r_x_limited = min(max(delta_u_r_x, min_diff_u_r_x), max_diff_u_r_x);
        let diff_u_r_y = (u_l_y_cell - u_r_y_cell);
        let min_diff_u_r_y = min(diff_u_r_y, 0f);
        let max_diff_u_r_y = max(diff_u_r_y, 0f);
        let delta_u_r_y = ((grad_u_y_r_x * r_r_x) + (grad_u_y_r_y * r_r_y));
        let delta_u_r_y_limited = min(max(delta_u_r_y, min_diff_u_r_y), max_diff_u_r_y);
        let diff_p_r = (p_l_cell - p_r_cell);
        let min_diff_p_r = min(diff_p_r, 0f);
        let max_diff_p_r = max(diff_p_r, 0f);
        let delta_p_r = ((grad_p_r_x * r_r_x) + (grad_p_r_y * r_r_y));
        let delta_p_r_limited = min(max(delta_p_r, min_diff_p_r), max_diff_p_r);
        let rho_r_face = (rho_r_cell + delta_rho_r_limited);
        let u_r_x_face = (u_r_x_cell + delta_u_r_x_limited);
        let u_r_y_face = (u_r_y_cell + delta_u_r_y_limited);
        let p_r_face = (p_r_cell + delta_p_r_limited);
        rho_l = rho_l_face;
        rho_u_l.x = (rho_l_face * u_l_x_face);
        rho_u_l.y = (rho_l_face * u_l_y_face);
        rho_e_l = ((p_l_face / 0.4f) + ((0.5f * rho_l_face) * ((u_l_x_face * u_l_x_face) + (u_l_y_face * u_l_y_face))));
        rho_r = rho_r_face;
        rho_u_r.x = (rho_r_face * u_r_x_face);
        rho_u_r.y = (rho_r_face * u_r_y_face);
        rho_e_r = ((p_r_face / 0.4f) + ((0.5f * rho_r_face) * ((u_r_x_face * u_r_x_face) + (u_r_y_face * u_r_y_face))));
    }
    let _e452 = rho_l;
    let inv_rho_l = (1f / max(_e452, 0.00000001f));
    let _e458 = rho_u_l.x;
    let u_l_x = (_e458 * inv_rho_l);
    let _e461 = rho_u_l.y;
    let u_l_y = (_e461 * inv_rho_l);
    let _e463 = rho_l;
    let ke_l = ((0.5f * _e463) * ((u_l_x * u_l_x) + (u_l_y * u_l_y)));
    let _e470 = rho_e_l;
    let p_l = max(0f, (0.4f * (_e470 - ke_l)));
    let _e477 = normal.x;
    let _e480 = normal.y;
    let u_n_l = ((u_l_x * _e477) + (u_l_y * _e480));
    let c_l = sqrt(((1.4f * p_l) * inv_rho_l));
    let _e487 = rho_r;
    let inv_rho_r = (1f / max(_e487, 0.00000001f));
    let _e493 = rho_u_r.x;
    let u_r_x = (_e493 * inv_rho_r);
    let _e496 = rho_u_r.y;
    let u_r_y = (_e496 * inv_rho_r);
    let _e498 = rho_r;
    let ke_r = ((0.5f * _e498) * ((u_r_x * u_r_x) + (u_r_y * u_r_y)));
    let _e505 = rho_e_r;
    let p_r = max(0f, (0.4f * (_e505 - ke_r)));
    let _e512 = normal.x;
    let _e515 = normal.y;
    let u_n_r = ((u_r_x * _e512) + (u_r_y * _e515));
    let c_r = sqrt(((1.4f * p_r) * inv_rho_r));
    let u_face_x = (0.5f * (u_l_x + u_r_x));
    let u_face_y = (0.5f * (u_l_y + u_r_y));
    let _e529 = normal.x;
    let _e532 = normal.y;
    let u_face_n = ((u_face_x * _e529) + (u_face_y * _e532));
    let c_bar = (0.5f * (c_l + c_r));
    let beta = (abs(u_face_n) / max(c_bar, 0.000001f));
    let mach2_ = (beta * beta);
    c_l_eff = (c_l * beta);
    c_r_eff = (c_r * beta);
    let _e549 = constants.precond_model;
    if (_e549 == 1u) {
        let _e554 = constants.precond_theta_floor;
        let theta = min(1f, max(mach2_, _e554));
        let one_minus_theta = (1f - theta);
        c_l_eff = sqrt((((theta * c_l) * c_l) + ((one_minus_theta * u_n_l) * u_n_l)));
        c_r_eff = sqrt((((theta * c_r) * c_r) + ((one_minus_theta * u_n_r) * u_n_r)));
    }
    let _e573 = center_r.x;
    let dx = (_e573 - center_owner.x);
    let _e577 = center_r.y;
    let dy = (_e577 - center_owner.y);
    let dist = max(sqrt(((dx * dx) + (dy * dy))), 0.000001f);
    let mu = constants.viscosity;
    let _e589 = c_l_eff;
    let _e591 = c_r_eff;
    let a_plus = max(0f, max((u_n_l + _e589), (u_n_r + _e591)));
    let _e596 = c_l_eff;
    let _e598 = c_r_eff;
    let a_minus = min(0f, min((u_n_l - _e596), (u_n_r - _e598)));
    let denom = max((a_plus - a_minus), 0.000001f);
    let a_prod = (a_plus * a_minus);
    let a_pos = (a_plus / denom);
    let a_neg = (1f - a_pos);
    let a_prod_scaled = (a_prod / denom);
    let _e611 = rho_l;
    let flux_rho_l = (_e611 * u_n_l);
    let _e613 = rho_r;
    let flux_rho_r = (_e613 * u_n_r);
    let _e618 = rho_r;
    let _e619 = rho_l;
    let flux_rho = (((a_pos * flux_rho_l) + (a_neg * flux_rho_r)) + (a_prod_scaled * (_e618 - _e619)));
    let _e624 = rho_u_l.x;
    let _e627 = normal.x;
    let flux_rho_u_x_l = ((_e624 * u_n_l) + (p_l * _e627));
    let _e631 = rho_u_r.x;
    let _e634 = normal.x;
    let flux_rho_u_x_r = ((_e631 * u_n_r) + (p_r * _e634));
    let _e641 = rho_u_r.x;
    let _e643 = rho_u_l.x;
    flux_rho_u_x = (((a_pos * flux_rho_u_x_l) + (a_neg * flux_rho_u_x_r)) + (a_prod_scaled * (_e641 - _e643)));
    let _e649 = rho_u_l.y;
    let _e652 = normal.y;
    let flux_rho_u_y_l = ((_e649 * u_n_l) + (p_l * _e652));
    let _e656 = rho_u_r.y;
    let _e659 = normal.y;
    let flux_rho_u_y_r = ((_e656 * u_n_r) + (p_r * _e659));
    let _e666 = rho_u_r.y;
    let _e668 = rho_u_l.y;
    flux_rho_u_y = (((a_pos * flux_rho_u_y_l) + (a_neg * flux_rho_u_y_r)) + (a_prod_scaled * (_e666 - _e668)));
    let diff_u_x = ((-(mu) * (u_r_x - u_l_x)) / dist);
    let diff_u_y = ((-(mu) * (u_r_y - u_l_y)) / dist);
    let _e681 = flux_rho_u_x;
    flux_rho_u_x = (_e681 + diff_u_x);
    let _e683 = flux_rho_u_y;
    flux_rho_u_y = (_e683 + diff_u_y);
    let _e685 = rho_e_l;
    let flux_rho_e_l = ((_e685 + p_l) * u_n_l);
    let _e688 = rho_e_r;
    let flux_rho_e_r = ((_e688 + p_r) * u_n_r);
    let _e694 = rho_e_r;
    let _e695 = rho_e_l;
    flux_rho_e = (((a_pos * flux_rho_e_l) + (a_neg * flux_rho_e_r)) + (a_prod_scaled * (_e694 - _e695)));
    let _e700 = flux_rho_e;
    flux_rho_e = ((_e700 + (diff_u_x * u_face_x)) + (diff_u_y * u_face_y));
    let base = (idx * 4u);
    fluxes[(base + 0u)] = (flux_rho * area);
    let _e716 = flux_rho_u_x;
    fluxes[(base + 1u)] = (_e716 * area);
    let _e722 = flux_rho_u_y;
    fluxes[(base + 2u)] = (_e722 * area);
    let _e728 = flux_rho_e;
    fluxes[(base + 3u)] = (_e728 * area);
    return;
}
"#;
    }
    pub mod compressible_gradients {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
            #[doc = "offset: 56, size: 4, type: `u32`"]
            pub precond_type: u32,
            #[doc = "offset: 60, size: 4, type: `u32`"]
            pub precond_model: u32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub precond_theta_floor: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
                precond_type: u32,
                precond_model: u32,
                precond_theta_floor: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                    precond_type,
                    precond_model,
                    precond_theta_floor,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleGradients::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleGradients::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_rho: wgpu::BufferBinding<'a>,
            pub grad_rho_u_x: wgpu::BufferBinding<'a>,
            pub grad_rho_u_y: wgpu::BufferBinding<'a>,
            pub grad_rho_e: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_rho: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_x: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_y: wgpu::BindGroupEntry<'a>,
            pub grad_rho_e: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_rho: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho),
                    },
                    grad_rho_u_x: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_x),
                    },
                    grad_rho_u_y: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_y),
                    },
                    grad_rho_e: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_e),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.grad_rho,
                    self.grad_rho_u_x,
                    self.grad_rho_u_y,
                    self.grad_rho_e,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleGradients::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::compressible_gradients::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"grad_rho\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"grad_rho_u_x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"grad_rho_u_y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"grad_rho_e\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"state_iter\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleGradients::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedCompressibleGradients::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("compressible_gradients.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(8) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(9) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2_>;
@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2_>;
@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2_>;
@group(1) @binding(9) 
var<storage> state_iter: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_rho_accum: Vector2_ = Vector2_(0f, 0f);
    var grad_rho_u_x_accum: Vector2_ = Vector2_(0f, 0f);
    var grad_rho_u_y_accum: Vector2_ = Vector2_(0f, 0f);
    var grad_rho_e_accum: Vector2_ = Vector2_(0f, 0f);
    var k: u32;
    var normal: Vector2_;
    var rho_r: f32;
    var rho_u_r: vec2<f32>;
    var rho_e_r: f32;
    var other_idx: u32;
    var rho_face: f32;
    var rho_u_face_x: f32;
    var rho_u_face_y: f32;
    var rho_e_face: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let rho_l = state[((idx * 7u) + 0u)];
    let _e34 = state[((idx * 7u) + 1u)];
    let _e41 = state[((idx * 7u) + 2u)];
    let rho_u_l = vec2<f32>(_e34, _e41);
    let rho_e_l = state[((idx * 7u) + 3u)];
    k = start;
    loop {
        let _e51 = k;
        if (_e51 < end) {
        } else {
            break;
        }
        {
            let _e54 = k;
            let face_idx = cell_faces[_e54];
            let owner = face_owner[face_idx];
            let neighbor = face_neighbor[face_idx];
            let area = face_areas[face_idx];
            let _e68 = face_normals[face_idx];
            normal = _e68;
            if (owner != idx) {
                let _e73 = normal.x;
                normal.x = -(_e73);
                let _e77 = normal.y;
                normal.y = -(_e77);
            }
            rho_r = rho_l;
            rho_u_r = rho_u_l;
            rho_e_r = rho_e_l;
            if (neighbor != -1i) {
                other_idx = u32(neighbor);
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e87 = other_idx;
                let rho_neigh = state[((_e87 * 7u) + 0u)];
                let _e95 = other_idx;
                let _e102 = state[((_e95 * 7u) + 1u)];
                let _e103 = other_idx;
                let _e110 = state[((_e103 * 7u) + 2u)];
                let rho_u_neigh = vec2<f32>(_e102, _e110);
                let _e112 = other_idx;
                let rho_e_neigh = state[((_e112 * 7u) + 3u)];
                rho_r = rho_neigh;
                rho_u_r.x = rho_u_neigh.x;
                rho_u_r.y = rho_u_neigh.y;
                rho_e_r = rho_e_neigh;
            }
            rho_face = rho_l;
            rho_u_face_x = rho_u_l.x;
            rho_u_face_y = rho_u_l.y;
            rho_e_face = rho_e_l;
            if (neighbor != -1i) {
                let _e132 = rho_r;
                rho_face = (0.5f * (rho_l + _e132));
                let _e138 = rho_u_r.x;
                rho_u_face_x = (0.5f * (rho_u_l.x + _e138));
                let _e144 = rho_u_r.y;
                rho_u_face_y = (0.5f * (rho_u_l.y + _e144));
                let _e148 = rho_e_r;
                rho_e_face = (0.5f * (rho_e_l + _e148));
            }
            let _e154 = rho_face;
            let _e156 = normal.x;
            let _e159 = grad_rho_accum.x;
            grad_rho_accum.x = (_e159 + ((_e154 * _e156) * area));
            let _e162 = rho_face;
            let _e164 = normal.y;
            let _e167 = grad_rho_accum.y;
            grad_rho_accum.y = (_e167 + ((_e162 * _e164) * area));
            let _e171 = rho_u_face_x;
            let _e173 = normal.x;
            let _e176 = grad_rho_u_x_accum.x;
            grad_rho_u_x_accum.x = (_e176 + ((_e171 * _e173) * area));
            let _e179 = rho_u_face_x;
            let _e181 = normal.y;
            let _e184 = grad_rho_u_x_accum.y;
            grad_rho_u_x_accum.y = (_e184 + ((_e179 * _e181) * area));
            let _e188 = rho_u_face_y;
            let _e190 = normal.x;
            let _e193 = grad_rho_u_y_accum.x;
            grad_rho_u_y_accum.x = (_e193 + ((_e188 * _e190) * area));
            let _e196 = rho_u_face_y;
            let _e198 = normal.y;
            let _e201 = grad_rho_u_y_accum.y;
            grad_rho_u_y_accum.y = (_e201 + ((_e196 * _e198) * area));
            let _e205 = rho_e_face;
            let _e207 = normal.x;
            let _e210 = grad_rho_e_accum.x;
            grad_rho_e_accum.x = (_e210 + ((_e205 * _e207) * area));
            let _e213 = rho_e_face;
            let _e215 = normal.y;
            let _e218 = grad_rho_e_accum.y;
            grad_rho_e_accum.y = (_e218 + ((_e213 * _e215) * area));
        }
        continuing {
            let _e221 = k;
            k = (_e221 + 1u);
        }
    }
    let _e225 = grad_rho_accum.x;
    grad_rho_accum.x = (_e225 / vol);
    let _e229 = grad_rho_accum.y;
    grad_rho_accum.y = (_e229 / vol);
    let _e233 = grad_rho_u_x_accum.x;
    grad_rho_u_x_accum.x = (_e233 / vol);
    let _e237 = grad_rho_u_x_accum.y;
    grad_rho_u_x_accum.y = (_e237 / vol);
    let _e241 = grad_rho_u_y_accum.x;
    grad_rho_u_y_accum.x = (_e241 / vol);
    let _e245 = grad_rho_u_y_accum.y;
    grad_rho_u_y_accum.y = (_e245 / vol);
    let _e249 = grad_rho_e_accum.x;
    grad_rho_e_accum.x = (_e249 / vol);
    let _e253 = grad_rho_e_accum.y;
    grad_rho_e_accum.y = (_e253 / vol);
    let _e257 = grad_rho_accum;
    grad_rho[idx] = _e257;
    let _e260 = grad_rho_u_x_accum;
    grad_rho_u_x[idx] = _e260;
    let _e263 = grad_rho_u_y_accum;
    grad_rho_u_y[idx] = _e263;
    let _e266 = grad_rho_e_accum;
    grad_rho_e[idx] = _e266;
    return;
}
"#;
    }
    pub mod compressible_update {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
            #[doc = "offset: 56, size: 4, type: `u32`"]
            pub precond_type: u32,
            #[doc = "offset: 60, size: 4, type: `u32`"]
            pub precond_model: u32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub precond_theta_floor: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
                precond_type: u32,
                precond_model: u32,
                precond_theta_floor: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                    precond_type,
                    precond_model,
                    precond_theta_floor,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_rho: wgpu::BufferBinding<'a>,
            pub grad_rho_u_x: wgpu::BufferBinding<'a>,
            pub grad_rho_u_y: wgpu::BufferBinding<'a>,
            pub grad_rho_e: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_rho: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_x: wgpu::BindGroupEntry<'a>,
            pub grad_rho_u_y: wgpu::BindGroupEntry<'a>,
            pub grad_rho_e: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_rho: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho),
                    },
                    grad_rho_u_x: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_x),
                    },
                    grad_rho_u_y: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_u_y),
                    },
                    grad_rho_e: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.grad_rho_e),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 9,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.grad_rho,
                    self.grad_rho_u_x,
                    self.grad_rho_u_y,
                    self.grad_rho_e,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCompressibleUpdate::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::compressible_update::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"grad_rho\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"grad_rho_u_x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"grad_rho_u_y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"grad_rho_e\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(9): \"state_iter\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 9,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCompressibleUpdate::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedCompressibleUpdate::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("compressible_update.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<storage> state_old: array<f32>;
@group(0) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;
@group(0) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2_>;
@group(0) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2_>;
@group(0) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2_>;
@group(0) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2_>;
@group(0) @binding(9) 
var<storage> state_iter: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = arrayLength((&state));
    if ((idx * 7u) >= num_cells) {
        return;
    }
    let rho = state[((idx * 7u) + 0u)];
    let _e20 = state[((idx * 7u) + 1u)];
    let _e27 = state[((idx * 7u) + 2u)];
    let rho_u = vec2<f32>(_e20, _e27);
    let rho_e = state[((idx * 7u) + 3u)];
    let inv_rho = (1f / max(rho, 0.00000001f));
    let u_x = (rho_u.x * inv_rho);
    let u_y = (rho_u.y * inv_rho);
    let ke = ((0.5f * rho) * ((u_x * u_x) + (u_y * u_y)));
    let p_val = max(0f, (0.4f * (rho_e - ke)));
    state[((idx * 7u) + 5u)] = u_x;
    state[((idx * 7u) + 6u)] = u_y;
    state[((idx * 7u) + 4u)] = p_val;
    return;
}
"#;
    }
    pub mod coupled_assembly_merged {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCoupledAssemblyMerged::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCoupledAssemblyMerged::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCoupledAssemblyMerged::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::coupled_assembly_merged::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCoupledAssemblyMerged::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub grad_u: wgpu::BufferBinding<'a>,
            pub grad_v: wgpu::BufferBinding<'a>,
            pub scalar_matrix_values: wgpu::BufferBinding<'a>,
            pub diag_u_inv: wgpu::BufferBinding<'a>,
            pub diag_v_inv: wgpu::BufferBinding<'a>,
            pub diag_p_inv: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub grad_u: wgpu::BindGroupEntry<'a>,
            pub grad_v: wgpu::BindGroupEntry<'a>,
            pub scalar_matrix_values: wgpu::BindGroupEntry<'a>,
            pub diag_u_inv: wgpu::BindGroupEntry<'a>,
            pub diag_v_inv: wgpu::BindGroupEntry<'a>,
            pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    grad_u: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.grad_u),
                    },
                    grad_v: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_v),
                    },
                    scalar_matrix_values: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.scalar_matrix_values),
                    },
                    diag_u_inv: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                    },
                    diag_v_inv: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                    },
                    diag_p_inv: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.matrix_values,
                    self.rhs,
                    self.scalar_row_offsets,
                    self.grad_u,
                    self.grad_v,
                    self.scalar_matrix_values,
                    self.diag_u_inv,
                    self.diag_v_inv,
                    self.diag_p_inv,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedCoupledAssemblyMerged::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"grad_u\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"grad_v\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"scalar_matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"diag_u_inv\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"diag_v_inv\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"diag_p_inv\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedCoupledAssemblyMerged::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedCoupledAssemblyMerged::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("coupled_assembly_merged.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(2) @binding(3) 
var<storage, read_write> grad_u: array<Vector2_>;
@group(2) @binding(4) 
var<storage, read_write> grad_v: array<Vector2_>;
@group(2) @binding(5) 
var<storage, read_write> scalar_matrix_values: array<f32>;
@group(2) @binding(6) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(7) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(8) 
var<storage, read_write> diag_p_inv: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn term_ddt_U_upwind(vol: f32, rho: f32, dt: f32, dt_old: f32, time_scheme: u32, phi_n: vec2<f32>, phi_nm1_: vec2<f32>) -> vec3<f32> {
    var diag: f32;
    var rhs_x: f32;
    var rhs_y: f32;

    let base_coeff = ((rho * vol) / dt);
    diag = base_coeff;
    rhs_x = (base_coeff * phi_n.x);
    rhs_y = (base_coeff * phi_n.y);
    if (time_scheme == 1u) {
        let r = (dt / dt_old);
        diag = ((((rho * vol) / dt) * (1f + (2f * r))) / (1f + r));
        let factor_n = (1f + r);
        let factor_nm1_ = ((r * r) / (1f + r));
        rhs_x = (((rho * vol) / dt) * ((factor_n * phi_n.x) - (factor_nm1_ * phi_nm1_.x)));
        rhs_y = (((rho * vol) / dt) * ((factor_n * phi_n.y) - (factor_nm1_ * phi_nm1_.y)));
    }
    let _e51 = diag;
    let _e52 = rhs_x;
    let _e53 = rhs_y;
    return vec3<f32>(_e51, _e52, _e53);
}

fn codegen_conv_coeff(flux: f32) -> vec2<f32> {
    var conv_coeff_diag: f32 = 0f;
    var conv_coeff_off: f32 = 0f;

    if (flux > 0f) {
        conv_coeff_diag = flux;
    } else {
        conv_coeff_off = flux;
    }
    let _e6 = conv_coeff_diag;
    let _e7 = conv_coeff_off;
    return vec2<f32>(_e6, _e7);
}

fn term_div_phi_U_upwind(flux_1: f32, phi_own: vec2<f32>, phi_neigh: vec2<f32>, grad_own_u: vec2<f32>, grad_own_v: vec2<f32>, grad_neigh_u: vec2<f32>, grad_neigh_v: vec2<f32>, r_upwind: vec2<f32>, r_downwind: vec2<f32>, r_cd: vec2<f32>) -> vec4<f32> {
    var phi_upwind: vec2<f32>;
    var phi_ho: vec2<f32>;

    let _e1 = codegen_conv_coeff(flux_1);
    let diag_coeff = _e1.x;
    let off_coeff = _e1.y;
    phi_upwind = phi_own;
    phi_ho = phi_own;
    if (flux_1 <= 0f) {
        phi_upwind = phi_neigh;
        phi_ho = phi_neigh;
    }
    let _e11 = phi_ho.x;
    let _e13 = phi_upwind.x;
    let rhs_corr_x = (flux_1 * (_e11 - _e13));
    let _e17 = phi_ho.y;
    let _e19 = phi_upwind.y;
    let rhs_corr_y = (flux_1 * (_e17 - _e19));
    return vec4<f32>(diag_coeff, off_coeff, rhs_corr_x, rhs_corr_y);
}

fn term_laplacian_U_upwind(mu: f32, area: f32, dist: f32) -> vec2<f32> {
    let coeff = ((mu * area) / dist);
    return vec2<f32>(coeff, -(coeff));
}

fn term_grad_p_upwind(area_1: f32, normal_1: vec2<f32>, lambda_1: f32) -> vec4<f32> {
    let force_x = (area_1 * normal_1.x);
    let force_y = (area_1 * normal_1.y);
    let off_u = ((1f - lambda_1) * force_x);
    let off_v = ((1f - lambda_1) * force_y);
    let diag_u_1 = (lambda_1 * force_x);
    let diag_v_1 = (lambda_1 * force_y);
    return vec4<f32>(off_u, off_v, diag_u_1, diag_v_1);
}

fn codegen_assemble_U() {
    let _e11 = term_ddt_U_upwind(1f, 1f, 1f, 1f, 0u, vec2<f32>(0f, 0f), vec2<f32>(0f, 0f));
    let _e40 = term_div_phi_U_upwind(0f, vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f));
    let _e44 = term_laplacian_U_upwind(1f, 1f, 1f);
    let _e50 = term_grad_p_upwind(1f, vec2<f32>(0f, 0f), 0.5f);
    return;
}

fn term_laplacian_p_upwind(mu_1: f32, area_2: f32, dist_1: f32) -> vec2<f32> {
    let coeff_1 = ((mu_1 * area_2) / dist_1);
    return vec2<f32>(coeff_1, -(coeff_1));
}

fn codegen_assemble_p() {
    let _e3 = term_laplacian_p_upwind(1f, 1f, 1f);
    return;
}

fn codegen_diff_coeff(mu_2: f32, area_3: f32, dist_2: f32) -> f32 {
    return ((mu_2 * area_3) / dist_2);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var diag_u: f32 = 0f;
    var diag_v: f32 = 0f;
    var diag_p: f32 = 0f;
    var sum_diag_up: f32 = 0f;
    var sum_diag_vp: f32 = 0f;
    var sum_diag_pu: f32 = 0f;
    var sum_diag_pv: f32 = 0f;
    var sum_diag_pp: f32 = 0f;
    var rhs_u: f32 = 0f;
    var rhs_v: f32 = 0f;
    var rhs_p: f32 = 0f;
    var scalar_diag_p: f32 = 0f;
    var coeff_time: f32;
    var rhs_time_u: f32;
    var rhs_time_v: f32;
    var k: u32;
    var normal: Vector2_;
    var normal_sign: f32;
    var other_center: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var d_p_neigh: f32;
    var neighbor_rank: u32;
    var phi_upwind_u: f32;
    var phi_ho_u: f32;
    var phi_upwind_v: f32;
    var phi_ho_v: f32;
    var lambda: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol_1 = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e27 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e27 - scalar_offset);
    let start_row_0_ = (9u * scalar_offset);
    let start_row_1_ = (start_row_0_ + (3u * num_neighbors));
    let start_row_2_ = (start_row_0_ + (6u * num_neighbors));
    let _e43 = state_old[((idx * 8u) + 0u)];
    let _e50 = state_old[((idx * 8u) + 1u)];
    let u_n = vec2<f32>(_e43, _e50);
    let rho_1 = constants.density;
    let _e58 = constants.dt;
    coeff_time = ((vol_1 * rho_1) / _e58);
    let _e61 = coeff_time;
    rhs_time_u = (_e61 * u_n.x);
    let _e65 = coeff_time;
    rhs_time_v = (_e65 * u_n.y);
    let _e71 = constants.time_scheme;
    if (_e71 == 1u) {
        let dt_1 = constants.dt;
        let dt_old_1 = constants.dt_old;
        let r_1 = (dt_1 / dt_old_1);
        let _e87 = state_old_old[((idx * 8u) + 0u)];
        let _e94 = state_old_old[((idx * 8u) + 1u)];
        let u_nm1_ = vec2<f32>(_e87, _e94);
        coeff_time = ((((vol_1 * rho_1) / dt_1) * (1f + (2f * r_1))) / (1f + r_1));
        let factor_n_1 = (1f + r_1);
        let factor_nm1_1 = ((r_1 * r_1) / (1f + r_1));
        rhs_time_u = (((vol_1 * rho_1) / dt_1) * ((factor_n_1 * u_n.x) - (factor_nm1_1 * u_nm1_.x)));
        rhs_time_v = (((vol_1 * rho_1) / dt_1) * ((factor_n_1 * u_n.y) - (factor_nm1_1 * u_nm1_.y)));
    }
    let _e129 = coeff_time;
    let _e130 = diag_u;
    diag_u = (_e130 + _e129);
    let _e133 = coeff_time;
    let _e134 = diag_v;
    diag_v = (_e134 + _e133);
    let _e137 = rhs_time_u;
    let _e138 = rhs_u;
    rhs_u = (_e138 + _e137);
    let _e141 = rhs_time_v;
    let _e142 = rhs_v;
    rhs_v = (_e142 + _e141);
    k = start;
    loop {
        let _e145 = k;
        if (_e145 < end) {
        } else {
            break;
        }
        {
            let _e148 = k;
            let face_idx = cell_faces[_e148];
            let owner = face_owner[face_idx];
            let neigh_idx = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let _e162 = face_normals[face_idx];
            normal = _e162;
            let area_4 = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            normal_sign = 1f;
            if (owner != idx) {
                let _e175 = normal.x;
                normal.x = -(_e175);
                let _e179 = normal.y;
                normal.y = -(_e179);
                normal_sign = -1f;
            }
            let _e184 = fluxes[face_idx];
            let _e185 = normal_sign;
            let flux_2 = (_e184 * _e185);
            is_boundary = false;
            other_idx = 0u;
            d_p_neigh = 0f;
            if (neigh_idx != -1i) {
                other_idx = u32(neigh_idx);
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e198 = other_idx;
                let _e200 = cell_centers[_e198];
                other_center = _e200;
                let _e202 = other_idx;
                let _e209 = state[((_e202 * 8u) + 3u)];
                d_p_neigh = _e209;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
                let _e217 = state[((idx * 8u) + 3u)];
                d_p_neigh = _e217;
            }
            let _e219 = other_center.x;
            let d_vec_x = (_e219 - center.x);
            let _e223 = other_center.y;
            let d_vec_y = (_e223 - center.y);
            let _e227 = normal.x;
            let _e230 = normal.y;
            let dist_proj = abs(((d_vec_x * _e227) + (d_vec_y * _e230)));
            let dist_3 = max(dist_proj, 0.000001f);
            let _e238 = constants.viscosity;
            let _e239 = codegen_diff_coeff(_e238, area_4, dist_3);
            let _e240 = codegen_conv_coeff(flux_2);
            let conv_coeff_diag_1 = _e240.x;
            let conv_coeff_off_1 = _e240.y;
            let _e244 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e244];
            neighbor_rank = 0u;
            if (scalar_mat_idx != 4294967295u) {
                neighbor_rank = (scalar_mat_idx - scalar_offset);
            } else {
                neighbor_rank = (scalar_mat_idx - scalar_offset);
            }
            let _e254 = neighbor_rank;
            let idx_0_0_ = ((start_row_0_ + (3u * _e254)) + 0u);
            let _e260 = neighbor_rank;
            let idx_0_1_ = ((start_row_0_ + (3u * _e260)) + 1u);
            let _e266 = neighbor_rank;
            let idx_0_2_ = ((start_row_0_ + (3u * _e266)) + 2u);
            let _e272 = neighbor_rank;
            let idx_1_0_ = ((start_row_1_ + (3u * _e272)) + 0u);
            let _e278 = neighbor_rank;
            let idx_1_1_ = ((start_row_1_ + (3u * _e278)) + 1u);
            let _e284 = neighbor_rank;
            let idx_1_2_ = ((start_row_1_ + (3u * _e284)) + 2u);
            let _e290 = neighbor_rank;
            let idx_2_0_ = ((start_row_2_ + (3u * _e290)) + 0u);
            let _e296 = neighbor_rank;
            let idx_2_1_ = ((start_row_2_ + (3u * _e296)) + 1u);
            let _e302 = neighbor_rank;
            let idx_2_2_ = ((start_row_2_ + (3u * _e302)) + 2u);
            let _e307 = is_boundary;
            if !(_e307) {
                let coeff_2 = (-(_e239) + conv_coeff_off_1);
                matrix_values[idx_0_0_] = coeff_2;
                matrix_values[idx_0_1_] = 0f;
                matrix_values[idx_1_0_] = 0f;
                matrix_values[idx_1_1_] = coeff_2;
                let _e322 = diag_u;
                diag_u = (_e322 + (_e239 + conv_coeff_diag_1));
                let _e325 = diag_v;
                diag_v = (_e325 + (_e239 + conv_coeff_diag_1));
                if (0u != 0u) {
                    let _e336 = state[((idx * 8u) + 0u)];
                    let _e343 = state[((idx * 8u) + 1u)];
                    let u_own = vec2<f32>(_e336, _e343);
                    let _e345 = other_idx;
                    let _e352 = state[((_e345 * 8u) + 0u)];
                    let _e353 = other_idx;
                    let _e360 = state[((_e353 * 8u) + 1u)];
                    let u_neigh = vec2<f32>(_e352, _e360);
                    phi_upwind_u = u_own.x;
                    if (flux_2 < 0f) {
                        phi_upwind_u = u_neigh.x;
                    }
                    let _e367 = phi_upwind_u;
                    phi_ho_u = _e367;
                    if (0u == 1u) {
                        if (flux_2 > 0f) {
                            let r_u_x = (f_center.x - center.x);
                            let r_u_y = (f_center.y - center.y);
                            let _e383 = grad_u[idx].x;
                            let _e389 = grad_u[idx].y;
                            phi_ho_u = ((u_own.x + (_e383 * r_u_x)) + (_e389 * r_u_y));
                        } else {
                            let _e394 = other_center.x;
                            let r_u_x_1 = (f_center.x - _e394);
                            let _e398 = other_center.y;
                            let r_u_y_1 = (f_center.y - _e398);
                            let _e402 = other_idx;
                            let _e405 = grad_u[_e402].x;
                            let _e409 = other_idx;
                            let _e412 = grad_u[_e409].y;
                            phi_ho_u = ((u_neigh.x + (_e405 * r_u_x_1)) + (_e412 * r_u_y_1));
                        }
                    } else {
                        if (0u == 2u) {
                            if (flux_2 > 0f) {
                                let _e420 = other_center.x;
                                let d_cd_u_x = (_e420 - center.x);
                                let _e424 = other_center.y;
                                let d_cd_u_y = (_e424 - center.y);
                                let _e430 = grad_u[idx].x;
                                let _e435 = grad_u[idx].y;
                                let grad_term_u = ((_e430 * d_cd_u_x) + (_e435 * d_cd_u_y));
                                phi_ho_u = (((0.625f * u_own.x) + (0.375f * u_neigh.x)) + (0.125f * grad_term_u));
                            } else {
                                let _e450 = other_center.x;
                                let d_cd_u_x_1 = (center.x - _e450);
                                let _e454 = other_center.y;
                                let d_cd_u_y_1 = (center.y - _e454);
                                let _e457 = other_idx;
                                let _e460 = grad_u[_e457].x;
                                let _e463 = other_idx;
                                let _e466 = grad_u[_e463].y;
                                let grad_term_u_1 = ((_e460 * d_cd_u_x_1) + (_e466 * d_cd_u_y_1));
                                phi_ho_u = (((0.625f * u_neigh.x) + (0.375f * u_own.x)) + (0.125f * grad_term_u_1));
                            }
                        }
                    }
                    phi_upwind_v = u_own.y;
                    if (flux_2 < 0f) {
                        phi_upwind_v = u_neigh.y;
                    }
                    let _e484 = phi_upwind_v;
                    phi_ho_v = _e484;
                    if (0u == 1u) {
                        if (flux_2 > 0f) {
                            let r_v_x = (f_center.x - center.x);
                            let r_v_y = (f_center.y - center.y);
                            let _e500 = grad_v[idx].x;
                            let _e506 = grad_v[idx].y;
                            phi_ho_v = ((u_own.y + (_e500 * r_v_x)) + (_e506 * r_v_y));
                        } else {
                            let _e511 = other_center.x;
                            let r_v_x_1 = (f_center.x - _e511);
                            let _e515 = other_center.y;
                            let r_v_y_1 = (f_center.y - _e515);
                            let _e519 = other_idx;
                            let _e522 = grad_v[_e519].x;
                            let _e526 = other_idx;
                            let _e529 = grad_v[_e526].y;
                            phi_ho_v = ((u_neigh.y + (_e522 * r_v_x_1)) + (_e529 * r_v_y_1));
                        }
                    } else {
                        if (0u == 2u) {
                            if (flux_2 > 0f) {
                                let _e537 = other_center.x;
                                let d_cd_v_x = (_e537 - center.x);
                                let _e541 = other_center.y;
                                let d_cd_v_y = (_e541 - center.y);
                                let _e547 = grad_v[idx].x;
                                let _e552 = grad_v[idx].y;
                                let grad_term_v = ((_e547 * d_cd_v_x) + (_e552 * d_cd_v_y));
                                phi_ho_v = (((0.625f * u_own.y) + (0.375f * u_neigh.y)) + (0.125f * grad_term_v));
                            } else {
                                let _e567 = other_center.x;
                                let d_cd_v_x_1 = (center.x - _e567);
                                let _e571 = other_center.y;
                                let d_cd_v_y_1 = (center.y - _e571);
                                let _e574 = other_idx;
                                let _e577 = grad_v[_e574].x;
                                let _e580 = other_idx;
                                let _e583 = grad_v[_e580].y;
                                let grad_term_v_1 = ((_e577 * d_cd_v_x_1) + (_e583 * d_cd_v_y_1));
                                phi_ho_v = (((0.625f * u_neigh.y) + (0.375f * u_own.y)) + (0.125f * grad_term_v_1));
                            }
                        }
                    }
                    let _e596 = phi_ho_u;
                    let _e597 = phi_upwind_u;
                    let correction_u = (flux_2 * (_e596 - _e597));
                    let _e600 = phi_ho_v;
                    let _e601 = phi_upwind_v;
                    let correction_v = (flux_2 * (_e600 - _e601));
                    let _e604 = rhs_u;
                    rhs_u = (_e604 - correction_u);
                    let _e606 = rhs_v;
                    rhs_v = (_e606 - correction_v);
                }
                let d_own = distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y));
                let _e616 = other_center.x;
                let _e618 = other_center.y;
                let d_neigh = distance(vec2<f32>(_e616, _e618), vec2<f32>(f_center.x, f_center.y));
                let total_dist = (d_own + d_neigh);
                lambda = 0.5f;
                if (total_dist > 0.000001f) {
                    lambda = (d_neigh / total_dist);
                }
                let _e631 = normal.x;
                let pg_force_x = (area_4 * _e631);
                let _e634 = normal.y;
                let pg_force_y = (area_4 * _e634);
                let _e638 = lambda;
                matrix_values[idx_0_2_] = ((1f - _e638) * pg_force_x);
                let _e644 = lambda;
                matrix_values[idx_1_2_] = ((1f - _e644) * pg_force_y);
                let _e649 = lambda;
                let _e651 = sum_diag_up;
                sum_diag_up = (_e651 + (_e649 * pg_force_x));
                let _e654 = lambda;
                let _e656 = sum_diag_vp;
                sum_diag_vp = (_e656 + (_e654 * pg_force_y));
                let _e659 = normal.x;
                let div_coeff_x = (_e659 * area_4);
                let _e662 = normal.y;
                let div_coeff_y = (_e662 * area_4);
                let _e666 = lambda;
                matrix_values[idx_2_0_] = ((1f - _e666) * div_coeff_x);
                let _e672 = lambda;
                matrix_values[idx_2_1_] = ((1f - _e672) * div_coeff_y);
                let _e677 = lambda;
                let _e679 = sum_diag_pu;
                sum_diag_pu = (_e679 + (_e677 * div_coeff_x));
                let _e682 = lambda;
                let _e684 = sum_diag_pv;
                sum_diag_pv = (_e684 + (_e682 * div_coeff_y));
                let d_p_own = state[((idx * 8u) + 3u)];
                let _e693 = lambda;
                let _e695 = lambda;
                let _e698 = d_p_neigh;
                let d_p_face = ((_e693 * d_p_own) + ((1f - _e695) * _e698));
                let _e703 = constants.density;
                let _e704 = lambda;
                let _e711 = state[((idx * 8u) + 3u)];
                let _e713 = lambda;
                let _e716 = other_idx;
                let _e723 = state[((_e716 * 8u) + 3u)];
                let pressure_coeff_face = (_e703 * ((_e704 * _e711) + ((1f - _e713) * _e723)));
                let lapl_coeff = ((pressure_coeff_face * area_4) / dist_3);
                matrix_values[idx_2_2_] = -(lapl_coeff);
                let _e733 = sum_diag_pp;
                sum_diag_pp = (_e733 + lapl_coeff);
                let scalar_coeff = ((pressure_coeff_face * area_4) / dist_3);
                if (scalar_mat_idx != 4294967295u) {
                    scalar_matrix_values[scalar_mat_idx] = -(scalar_coeff);
                }
                let _e743 = scalar_diag_p;
                scalar_diag_p = (_e743 + scalar_coeff);
            } else {
                if (boundary_type == 1u) {
                    let _e749 = constants.ramp_time;
                    let _e752 = constants.time;
                    let ramp = smoothstep(0f, _e749, _e752);
                    let _e757 = constants.inlet_velocity;
                    let u_bc_x = (_e757 * ramp);
                    let _e759 = diag_u;
                    diag_u = (_e759 + _e239);
                    let _e761 = diag_v;
                    diag_v = (_e761 + _e239);
                    let _e764 = rhs_u;
                    rhs_u = (_e764 + (_e239 * u_bc_x));
                    let _e768 = rhs_v;
                    rhs_v = (_e768 + (_e239 * 0f));
                    if (flux_2 > 0f) {
                        let _e772 = diag_u;
                        diag_u = (_e772 + flux_2);
                        let _e774 = diag_v;
                        diag_v = (_e774 + flux_2);
                    } else {
                        let _e777 = rhs_u;
                        rhs_u = (_e777 - (flux_2 * u_bc_x));
                        let _e780 = rhs_v;
                        rhs_v = (_e780 - (flux_2 * 0f));
                    }
                    let _e783 = normal.x;
                    let pg_force_x_1 = (area_4 * _e783);
                    let _e786 = normal.y;
                    let pg_force_y_1 = (area_4 * _e786);
                    let _e788 = sum_diag_up;
                    sum_diag_up = (_e788 + pg_force_x_1);
                    let _e790 = sum_diag_vp;
                    sum_diag_vp = (_e790 + pg_force_y_1);
                    let _e793 = normal.x;
                    let _e796 = normal.y;
                    let flux_bc = (((u_bc_x * _e793) + (0f * _e796)) * area_4);
                    let _e801 = rhs_p;
                    rhs_p = (_e801 - flux_bc);
                } else {
                    if (boundary_type == 3u) {
                        let _e805 = diag_u;
                        diag_u = (_e805 + _e239);
                        let _e807 = diag_v;
                        diag_v = (_e807 + _e239);
                        let _e810 = normal.x;
                        let pg_force_x_2 = (area_4 * _e810);
                        let _e813 = normal.y;
                        let pg_force_y_2 = (area_4 * _e813);
                        let _e815 = sum_diag_up;
                        sum_diag_up = (_e815 + pg_force_x_2);
                        let _e817 = sum_diag_vp;
                        sum_diag_vp = (_e817 + pg_force_y_2);
                    } else {
                        if (boundary_type == 2u) {
                            if (flux_2 > 0f) {
                                let _e823 = diag_u;
                                diag_u = (_e823 + flux_2);
                                let _e825 = diag_v;
                                diag_v = (_e825 + flux_2);
                            }
                            let _e828 = normal.x;
                            let div_coeff_x_1 = (_e828 * area_4);
                            let _e831 = normal.y;
                            let div_coeff_y_1 = (_e831 * area_4);
                            let _e833 = sum_diag_pu;
                            sum_diag_pu = (_e833 + div_coeff_x_1);
                            let _e835 = sum_diag_pv;
                            sum_diag_pv = (_e835 + div_coeff_y_1);
                            let d_p_own_1 = state[((idx * 8u) + 3u)];
                            let _e846 = constants.density;
                            let _e853 = state[((idx * 8u) + 3u)];
                            let pressure_coeff_cell = (_e846 * _e853);
                            let lapl_coeff_1 = ((pressure_coeff_cell * area_4) / dist_3);
                            let _e857 = sum_diag_pp;
                            sum_diag_pp = (_e857 + lapl_coeff_1);
                            let scalar_coeff_1 = ((pressure_coeff_cell * area_4) / dist_3);
                            let _e861 = scalar_diag_p;
                            scalar_diag_p = (_e861 + scalar_coeff_1);
                        }
                    }
                }
            }
        }
        continuing {
            let _e864 = k;
            k = (_e864 + 1u);
        }
    }
    let scalar_diag_idx = diagonal_indices[idx];
    let diag_rank = (scalar_diag_idx - scalar_offset);
    let d_0_0_ = ((start_row_0_ + (3u * diag_rank)) + 0u);
    let d_0_1_ = ((start_row_0_ + (3u * diag_rank)) + 1u);
    let d_0_2_ = ((start_row_0_ + (3u * diag_rank)) + 2u);
    let d_1_0_ = ((start_row_1_ + (3u * diag_rank)) + 0u);
    let d_1_1_ = ((start_row_1_ + (3u * diag_rank)) + 1u);
    let d_1_2_ = ((start_row_1_ + (3u * diag_rank)) + 2u);
    let d_2_0_ = ((start_row_2_ + (3u * diag_rank)) + 0u);
    let d_2_1_ = ((start_row_2_ + (3u * diag_rank)) + 1u);
    let d_2_2_ = ((start_row_2_ + (3u * diag_rank)) + 2u);
    let _e917 = diag_u;
    matrix_values[d_0_0_] = _e917;
    matrix_values[d_0_1_] = 0f;
    let _e923 = sum_diag_up;
    matrix_values[d_0_2_] = _e923;
    matrix_values[d_1_0_] = 0f;
    let _e929 = diag_v;
    matrix_values[d_1_1_] = _e929;
    let _e932 = sum_diag_vp;
    matrix_values[d_1_2_] = _e932;
    let _e935 = sum_diag_pu;
    matrix_values[d_2_0_] = _e935;
    let _e938 = sum_diag_pv;
    matrix_values[d_2_1_] = _e938;
    let _e942 = diag_p;
    let _e943 = sum_diag_pp;
    matrix_values[d_2_2_] = (_e942 + _e943);
    let _e951 = rhs_u;
    rhs[((3u * idx) + 0u)] = _e951;
    let _e958 = rhs_v;
    rhs[((3u * idx) + 1u)] = _e958;
    let _e965 = rhs_p;
    rhs[((3u * idx) + 2u)] = _e965;
    let _e968 = scalar_diag_p;
    scalar_matrix_values[scalar_diag_idx] = _e968;
    let _e971 = diag_u;
    let _e972 = safe_inverse(_e971);
    diag_u_inv[idx] = _e972;
    let _e975 = diag_v;
    let _e976 = safe_inverse(_e975);
    diag_v_inv[idx] = _e976;
    let _e979 = scalar_diag_p;
    let _e980 = safe_inverse(_e979);
    diag_p_inv[idx] = _e980;
    return;
}
"#;
    }
    pub mod flux_rhie_chow {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxRhieChow::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxRhieChow::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxRhieChow::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_rhie_chow::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxRhieChow::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxRhieChow::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_rhie_chow.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var normal: Vector2_;
    var u_face: vec2<f32>;
    var d_p_face: f32;
    var grad_p_avg: vec2<f32>;
    var rho_face: f32;
    var lambda: f32 = 0.5f;
    var u_central: vec2<f32>;
    var rc_term: f32 = 0f;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e30 = face_normals[idx];
    normal = _e30;
    let c_owner = cell_centers[owner];
    let dx_vec = (face_center.x - c_owner.x);
    let dy_vec = (face_center.y - c_owner.y);
    let _e42 = normal.x;
    let _e45 = normal.y;
    if (((dx_vec * _e42) + (dy_vec * _e45)) < 0f) {
        let _e52 = normal.x;
        normal.x = -(_e52);
        let _e56 = normal.y;
        normal.y = -(_e56);
    }
    let _e64 = state[((owner * 8u) + 0u)];
    let _e71 = state[((owner * 8u) + 1u)];
    u_face = vec2<f32>(_e64, _e71);
    let _e80 = state[((owner * 8u) + 3u)];
    d_p_face = _e80;
    let _e88 = state[((owner * 8u) + 4u)];
    let _e95 = state[((owner * 8u) + 5u)];
    grad_p_avg = vec2<f32>(_e88, _e95);
    let _e100 = constants.density;
    rho_face = _e100;
    if (neighbor != -1i) {
        let neigh_idx = u32(neighbor);
        let _e111 = state[((neigh_idx * 8u) + 0u)];
        let _e118 = state[((neigh_idx * 8u) + 1u)];
        let u_neigh = vec2<f32>(_e111, _e118);
        let d_p_neigh = state[((neigh_idx * 8u) + 3u)];
        let _e133 = state[((neigh_idx * 8u) + 4u)];
        let _e140 = state[((neigh_idx * 8u) + 5u)];
        let grad_p_neigh = vec2<f32>(_e133, _e140);
        let c_neigh = cell_centers[neigh_idx];
        let d_own = distance(vec2<f32>(c_owner.x, c_owner.y), vec2<f32>(face_center.x, face_center.y));
        let d_neigh = distance(vec2<f32>(c_neigh.x, c_neigh.y), vec2<f32>(face_center.x, face_center.y));
        let total_dist = (d_own + d_neigh);
        if (total_dist > 0.000001f) {
            lambda = (d_neigh / total_dist);
        }
        let _e166 = constants.density;
        rho_face = _e166;
        let _e167 = u_face;
        u_central = _e167;
        let _e170 = lambda;
        let _e172 = u_face.x;
        let _e174 = lambda;
        u_central.x = ((_e170 * _e172) + ((1f - _e174) * u_neigh.x));
        let _e181 = lambda;
        let _e183 = u_face.y;
        let _e185 = lambda;
        u_central.y = ((_e181 * _e183) + ((1f - _e185) * u_neigh.y));
        let _e191 = u_central;
        u_face = _e191;
        let _e192 = lambda;
        let _e193 = d_p_face;
        let _e195 = lambda;
        d_p_face = ((_e192 * _e193) + ((1f - _e195) * d_p_neigh));
        let _e201 = lambda;
        let _e203 = grad_p_avg.x;
        let _e205 = lambda;
        grad_p_avg.x = ((_e201 * _e203) + ((1f - _e205) * grad_p_neigh.x));
        let _e212 = lambda;
        let _e214 = grad_p_avg.y;
        let _e216 = lambda;
        grad_p_avg.y = ((_e212 * _e214) + ((1f - _e216) * grad_p_neigh.y));
        let dx = (c_neigh.x - c_owner.x);
        let dy = (c_neigh.y - c_owner.y);
        let _e229 = normal.x;
        let _e232 = normal.y;
        let dist_proj = abs(((dx * _e229) + (dy * _e232)));
        let dist = max(dist_proj, 0.000001f);
        let p_own = state[((owner * 8u) + 2u)];
        let p_neigh = state[((neigh_idx * 8u) + 2u)];
        let _e253 = grad_p_avg.x;
        let _e255 = normal.x;
        let _e258 = grad_p_avg.y;
        let _e260 = normal.y;
        let grad_p_n = ((_e253 * _e255) + (_e258 * _e260));
        let p_grad_f = ((p_neigh - p_own) / dist);
        let _e265 = d_p_face;
        let rc_term_1 = ((_e265 * area) * (grad_p_n - p_grad_f));
        let _e270 = u_face.x;
        let _e272 = normal.x;
        let _e275 = u_face.y;
        let _e277 = normal.y;
        let u_n = ((_e270 * _e272) + (_e275 * _e277));
        let _e282 = rho_face;
        fluxes[idx] = (_e282 * ((u_n * area) + rc_term_1));
        return;
    } else {
        if (boundary_type == 1u) {
            let _e290 = constants.ramp_time;
            let _e293 = constants.time;
            let ramp = smoothstep(0f, _e290, _e293);
            let _e298 = constants.inlet_velocity;
            let u_bc = Vector2_((_e298 * ramp), 0f);
            let _e304 = rho_face;
            let _e307 = normal.x;
            let _e311 = normal.y;
            fluxes[idx] = ((_e304 * ((u_bc.x * _e307) + (u_bc.y * _e311))) * area);
            return;
        } else {
            if (boundary_type == 3u) {
                fluxes[idx] = 0f;
                return;
            } else {
                if (boundary_type == 2u) {
                    let _e324 = u_face.x;
                    let _e326 = normal.x;
                    let _e329 = u_face.y;
                    let _e331 = normal.y;
                    let u_n_1 = ((_e324 * _e326) + (_e329 * _e331));
                    let dist_face = distance(vec2<f32>(c_owner.x, c_owner.y), vec2<f32>(face_center.x, face_center.y));
                    if (dist_face > 0.000001f) {
                        rc_term = 0f;
                    }
                    let _e345 = rho_face;
                    let _e347 = rc_term;
                    let raw_flux = (_e345 * ((u_n_1 * area) + _e347));
                    fluxes[idx] = max(0f, raw_flux);
                    return;
                } else {
                    fluxes[idx] = 0f;
                    return;
                }
            }
        }
    }
}
"#;
    }
    pub mod incompressible_momentum {
        use super::{_root, _root::*};
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 0],
            ) -> [wgpu::BindGroupLayout; 0] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
fn term_ddt_U_upwind(vol: f32, rho: f32, dt: f32, dt_old: f32, time_scheme: u32, phi_n: vec2<f32>, phi_nm1_: vec2<f32>) -> vec3<f32> {
    var diag: f32;
    var rhs_x: f32;
    var rhs_y: f32;

    let base_coeff = ((rho * vol) / dt);
    diag = base_coeff;
    rhs_x = (base_coeff * phi_n.x);
    rhs_y = (base_coeff * phi_n.y);
    if (time_scheme == 1u) {
        let r = (dt / dt_old);
        diag = ((((rho * vol) / dt) * (1f + (2f * r))) / (1f + r));
        let factor_n = (1f + r);
        let factor_nm1_ = ((r * r) / (1f + r));
        rhs_x = (((rho * vol) / dt) * ((factor_n * phi_n.x) - (factor_nm1_ * phi_nm1_.x)));
        rhs_y = (((rho * vol) / dt) * ((factor_n * phi_n.y) - (factor_nm1_ * phi_nm1_.y)));
    }
    let _e51 = diag;
    let _e52 = rhs_x;
    let _e53 = rhs_y;
    return vec3<f32>(_e51, _e52, _e53);
}

fn codegen_conv_coeff(flux: f32) -> vec2<f32> {
    var conv_coeff_diag: f32 = 0f;
    var conv_coeff_off: f32 = 0f;

    if (flux > 0f) {
        conv_coeff_diag = flux;
    } else {
        conv_coeff_off = flux;
    }
    let _e6 = conv_coeff_diag;
    let _e7 = conv_coeff_off;
    return vec2<f32>(_e6, _e7);
}

fn term_div_phi_U_upwind(flux_1: f32, phi_own: vec2<f32>, phi_neigh: vec2<f32>, grad_own_u: vec2<f32>, grad_own_v: vec2<f32>, grad_neigh_u: vec2<f32>, grad_neigh_v: vec2<f32>, r_upwind: vec2<f32>, r_downwind: vec2<f32>, r_cd: vec2<f32>) -> vec4<f32> {
    var phi_upwind: vec2<f32>;
    var phi_ho: vec2<f32>;

    let _e1 = codegen_conv_coeff(flux_1);
    let diag_coeff = _e1.x;
    let off_coeff = _e1.y;
    phi_upwind = phi_own;
    phi_ho = phi_own;
    if (flux_1 <= 0f) {
        phi_upwind = phi_neigh;
        phi_ho = phi_neigh;
    }
    let _e11 = phi_ho.x;
    let _e13 = phi_upwind.x;
    let rhs_corr_x = (flux_1 * (_e11 - _e13));
    let _e17 = phi_ho.y;
    let _e19 = phi_upwind.y;
    let rhs_corr_y = (flux_1 * (_e17 - _e19));
    return vec4<f32>(diag_coeff, off_coeff, rhs_corr_x, rhs_corr_y);
}

fn term_laplacian_U_upwind(mu: f32, area: f32, dist: f32) -> vec2<f32> {
    let coeff = ((mu * area) / dist);
    return vec2<f32>(coeff, -(coeff));
}

fn term_grad_p_upwind(area_1: f32, normal: vec2<f32>, lambda: f32) -> vec4<f32> {
    let force_x = (area_1 * normal.x);
    let force_y = (area_1 * normal.y);
    let off_u = ((1f - lambda) * force_x);
    let off_v = ((1f - lambda) * force_y);
    let diag_u = (lambda * force_x);
    let diag_v = (lambda * force_y);
    return vec4<f32>(off_u, off_v, diag_u, diag_v);
}

fn assemble_U() {
    let _e11 = term_ddt_U_upwind(1f, 1f, 1f, 1f, 0u, vec2<f32>(0f, 0f), vec2<f32>(0f, 0f));
    let _e40 = term_div_phi_U_upwind(0f, vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f), vec2<f32>(0f, 0f));
    let _e44 = term_laplacian_U_upwind(1f, 1f, 1f);
    let _e50 = term_grad_p_upwind(1f, vec2<f32>(0f, 0f), 0.5f);
    return;
}

fn term_laplacian_p_upwind(mu_1: f32, area_2: f32, dist_1: f32) -> vec2<f32> {
    let coeff_1 = ((mu_1 * area_2) / dist_1);
    return vec2<f32>(coeff_1, -(coeff_1));
}

fn assemble_p() {
    let _e3 = term_laplacian_p_upwind(1f, 1f, 1f);
    return;
}

fn main() {
    assemble_U();
    assemble_p();
    return;
}

fn codegen_diff_coeff(mu_2: f32, area_3: f32, dist_2: f32) -> f32 {
    return ((mu_2 * area_3) / dist_2);
}

"#;
    }
    pub mod prepare_coupled {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedPrepareCoupled::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPrepareCoupled::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedPrepareCoupled::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::prepare_coupled::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPrepareCoupled::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub grad_u: wgpu::BufferBinding<'a>,
            pub grad_v: wgpu::BufferBinding<'a>,
            pub scalar_matrix_values: wgpu::BufferBinding<'a>,
            pub diag_u_inv: wgpu::BufferBinding<'a>,
            pub diag_v_inv: wgpu::BufferBinding<'a>,
            pub diag_p_inv: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub grad_u: wgpu::BindGroupEntry<'a>,
            pub grad_v: wgpu::BindGroupEntry<'a>,
            pub scalar_matrix_values: wgpu::BindGroupEntry<'a>,
            pub diag_u_inv: wgpu::BindGroupEntry<'a>,
            pub diag_v_inv: wgpu::BindGroupEntry<'a>,
            pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    grad_u: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.grad_u),
                    },
                    grad_v: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_v),
                    },
                    scalar_matrix_values: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.scalar_matrix_values),
                    },
                    diag_u_inv: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                    },
                    diag_v_inv: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                    },
                    diag_p_inv: wgpu::BindGroupEntry {
                        binding: 8,
                        resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.matrix_values,
                    self.rhs,
                    self.scalar_row_offsets,
                    self.grad_u,
                    self.grad_v,
                    self.scalar_matrix_values,
                    self.diag_u_inv,
                    self.diag_v_inv,
                    self.diag_p_inv,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedPrepareCoupled::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"grad_u\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"grad_v\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"scalar_matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"diag_u_inv\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"diag_v_inv\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(8): \"diag_p_inv\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 8,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPrepareCoupled::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPrepareCoupled::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("prepare_coupled.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(2) @binding(3) 
var<storage, read_write> grad_u: array<Vector2_>;
@group(2) @binding(4) 
var<storage, read_write> grad_v: array<Vector2_>;
@group(2) @binding(5) 
var<storage, read_write> scalar_matrix_values: array<f32>;
@group(2) @binding(6) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(7) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(8) 
var<storage, read_write> diag_p_inv: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var diag_coeff: f32 = 0f;
    var time_coeff: f32;
    var grad_p_accum: Vector2_ = Vector2_(0f, 0f);
    var g_u: Vector2_ = Vector2_(0f, 0f);
    var g_v: Vector2_ = Vector2_(0f, 0f);
    var k: u32;
    var normal: Vector2_;
    var normal_sign: f32;
    var normal_flux: Vector2_;
    var flux: f32;
    var rho_face: f32;
    var lambda: f32;
    var flux_out: f32;
    var other_center: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var conv_coeff_diag: f32;
    var lambda_p: f32;
    var val_f_p: f32;
    var val_f_u: f32;
    var val_f_v: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let _e27 = state_old[((idx * 8u) + 0u)];
    let _e34 = state_old[((idx * 8u) + 1u)];
    let u_n_val = vec2<f32>(_e27, _e34);
    let rho_cell = constants.density;
    let _e42 = constants.dt;
    time_coeff = ((vol * rho_cell) / _e42);
    let _e47 = constants.time_scheme;
    if (_e47 == 1u) {
        let dt = constants.dt;
        let dt_old = constants.dt_old;
        let r = (dt / dt_old);
        time_coeff = ((((vol * rho_cell) / dt) * (1f + (2f * r))) / (1f + r));
    }
    let _e68 = time_coeff;
    let _e69 = diag_coeff;
    diag_coeff = (_e69 + _e68);
    let val_c_p = state[((idx * 8u) + 2u)];
    let _e84 = state[((idx * 8u) + 0u)];
    let _e91 = state[((idx * 8u) + 1u)];
    let u_val = vec2<f32>(_e84, _e91);
    let val_c_u = u_val.x;
    let val_c_v = u_val.y;
    k = start;
    loop {
        let _e96 = k;
        if (_e96 < end) {
        } else {
            break;
        }
        {
            let _e99 = k;
            let face_idx = cell_faces[_e99];
            let owner = face_owner[face_idx];
            let neigh_idx = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let _e113 = face_normals[face_idx];
            normal = _e113;
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            normal_sign = 1f;
            if (owner != idx) {
                let _e126 = normal.x;
                normal.x = -(_e126);
                let _e130 = normal.y;
                normal.y = -(_e130);
                normal_sign = -1f;
            }
            let c_owner = cell_centers[owner];
            let _e138 = face_normals[face_idx];
            normal_flux = _e138;
            let dx_vec = (f_center.x - c_owner.x);
            let dy_vec = (f_center.y - c_owner.y);
            let _e147 = normal_flux.x;
            let _e150 = normal_flux.y;
            if (((dx_vec * _e147) + (dy_vec * _e150)) < 0f) {
                let _e157 = normal_flux.x;
                normal_flux.x = -(_e157);
                let _e161 = normal_flux.y;
                normal_flux.y = -(_e161);
            }
            flux = 0f;
            rho_face = rho_cell;
            if (neigh_idx != -1i) {
                let n_idx = u32(neigh_idx);
                let c_neigh = cell_centers[n_idx];
                let _e178 = state[((owner * 8u) + 0u)];
                let _e185 = state[((owner * 8u) + 1u)];
                let u_own = vec2<f32>(_e178, _e185);
                let _e193 = state[((n_idx * 8u) + 0u)];
                let _e200 = state[((n_idx * 8u) + 1u)];
                let u_ngh = vec2<f32>(_e193, _e200);
                let dp_own = state[((owner * 8u) + 3u)];
                let dp_ngh = state[((n_idx * 8u) + 3u)];
                let _e222 = state[((owner * 8u) + 4u)];
                let _e229 = state[((owner * 8u) + 5u)];
                let gp_own = vec2<f32>(_e222, _e229);
                let _e237 = state[((n_idx * 8u) + 4u)];
                let _e244 = state[((n_idx * 8u) + 5u)];
                let gp_ngh = vec2<f32>(_e237, _e244);
                let p_own = state[((owner * 8u) + 2u)];
                let p_ngh = state[((n_idx * 8u) + 2u)];
                let d_own = distance(vec2<f32>(c_owner.x, c_owner.y), vec2<f32>(f_center.x, f_center.y));
                let d_ngh = distance(vec2<f32>(c_neigh.x, c_neigh.y), vec2<f32>(f_center.x, f_center.y));
                let total_dist = (d_own + d_ngh);
                lambda = 0.5f;
                if (total_dist > 0.000001f) {
                    lambda = (d_ngh / total_dist);
                }
                let _e282 = constants.density;
                rho_face = _e282;
                let _e283 = lambda;
                let _e286 = lambda;
                let u_face_x = ((_e283 * u_own.x) + ((1f - _e286) * u_ngh.x));
                let _e292 = lambda;
                let _e295 = lambda;
                let u_face_y = ((_e292 * u_own.y) + ((1f - _e295) * u_ngh.y));
                let _e301 = lambda;
                let _e303 = lambda;
                let dp_face = ((_e301 * dp_own) + ((1f - _e303) * dp_ngh));
                let _e308 = lambda;
                let _e311 = lambda;
                let gp_face_x = ((_e308 * gp_own.x) + ((1f - _e311) * gp_ngh.x));
                let _e317 = lambda;
                let _e320 = lambda;
                let gp_face_y = ((_e317 * gp_own.y) + ((1f - _e320) * gp_ngh.y));
                let dx = (c_neigh.x - c_owner.x);
                let dy = (c_neigh.y - c_owner.y);
                let _e333 = normal_flux.x;
                let _e336 = normal_flux.y;
                let dist_proj = abs(((dx * _e333) + (dy * _e336)));
                let dist = max(dist_proj, 0.000001f);
                let _e343 = normal_flux.x;
                let _e346 = normal_flux.y;
                let grad_p_n = ((gp_face_x * _e343) + (gp_face_y * _e346));
                let p_grad_f = ((p_ngh - p_own) / dist);
                let rc_term = ((dp_face * area) * (grad_p_n - p_grad_f));
                let _e355 = normal_flux.x;
                let _e358 = normal_flux.y;
                let u_n = ((u_face_x * _e355) + (u_face_y * _e358));
                let _e361 = rho_face;
                flux = (_e361 * ((u_n * area) + rc_term));
            } else {
                if (boundary_type == 1u) {
                    let _e369 = constants.ramp_time;
                    let _e372 = constants.time;
                    let ramp = smoothstep(0f, _e369, _e372);
                    let _e377 = constants.inlet_velocity;
                    let u_bc = Vector2_((_e377 * ramp), 0f);
                    let _e381 = rho_face;
                    let _e384 = normal_flux.x;
                    let _e388 = normal_flux.y;
                    flux = ((_e381 * ((u_bc.x * _e384) + (u_bc.y * _e388))) * area);
                } else {
                    if (boundary_type == 3u) {
                        flux = 0f;
                    } else {
                        if (boundary_type == 2u) {
                            let _e404 = state[((owner * 8u) + 0u)];
                            let _e411 = state[((owner * 8u) + 1u)];
                            let u_own_1 = vec2<f32>(_e404, _e411);
                            let _e415 = normal_flux.x;
                            let _e419 = normal_flux.y;
                            let u_n_1 = ((u_own_1.x * _e415) + (u_own_1.y * _e419));
                            let _e422 = rho_face;
                            let raw_flux = ((_e422 * u_n_1) * area);
                            flux = max(0f, raw_flux);
                        }
                    }
                }
            }
            if (owner == idx) {
                let _e430 = flux;
                fluxes[face_idx] = _e430;
            }
            let _e431 = flux;
            flux_out = _e431;
            if (owner != idx) {
                let _e434 = flux;
                flux_out = -(_e434);
            }
            is_boundary = false;
            other_idx = 0u;
            if (neigh_idx != -1i) {
                other_idx = u32(neigh_idx);
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e445 = other_idx;
                let _e447 = cell_centers[_e445];
                other_center = _e447;
            } else {
                is_boundary = true;
                other_center = f_center;
            }
            let _e451 = other_center.x;
            let d_vec_x = (_e451 - center.x);
            let _e455 = other_center.y;
            let d_vec_y = (_e455 - center.y);
            let dist_1 = sqrt(((d_vec_x * d_vec_x) + (d_vec_y * d_vec_y)));
            let _e464 = constants.viscosity;
            let diff_coeff = ((_e464 * area) / dist_1);
            conv_coeff_diag = 0f;
            let _e469 = flux_out;
            if (_e469 > 0f) {
                let _e472 = flux_out;
                conv_coeff_diag = _e472;
            }
            let _e473 = is_boundary;
            if !(_e473) {
                let _e475 = conv_coeff_diag;
                let _e477 = diag_coeff;
                diag_coeff = (_e477 + (diff_coeff + _e475));
            } else {
                if (boundary_type == 1u) {
                    let _e481 = diag_coeff;
                    diag_coeff = (_e481 + diff_coeff);
                    let _e483 = flux_out;
                    if (_e483 > 0f) {
                        let _e486 = flux_out;
                        let _e487 = diag_coeff;
                        diag_coeff = (_e487 + _e486);
                    }
                } else {
                    if (boundary_type == 3u) {
                        let _e491 = diag_coeff;
                        diag_coeff = (_e491 + diff_coeff);
                        let _e493 = flux_out;
                        if (_e493 > 0f) {
                            let _e496 = flux_out;
                            let _e497 = diag_coeff;
                            diag_coeff = (_e497 + _e496);
                        }
                    } else {
                        if (boundary_type == 2u) {
                            let _e501 = flux_out;
                            if (_e501 > 0f) {
                                let _e504 = flux_out;
                                let _e505 = diag_coeff;
                                diag_coeff = (_e505 + _e504);
                            }
                        }
                    }
                }
            }
            let _e507 = is_boundary;
            if !(_e507) {
                let d_c = distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y));
                let _e517 = other_center.x;
                let _e519 = other_center.y;
                let d_o = distance(vec2<f32>(_e517, _e519), vec2<f32>(f_center.x, f_center.y));
                let total_dist_p = (d_c + d_o);
                lambda_p = 0.5f;
                if (total_dist_p > 0.000001f) {
                    lambda_p = (d_o / total_dist_p);
                }
                let _e531 = other_idx;
                let val_other_p = state[((_e531 * 8u) + 2u)];
                let _e539 = lambda_p;
                let _e541 = lambda_p;
                let val_f_p_1 = ((_e539 * val_c_p) + ((1f - _e541) * val_other_p));
                let _e549 = normal.x;
                let _e552 = grad_p_accum.x;
                grad_p_accum.x = (_e552 + ((val_f_p_1 * _e549) * area));
                let _e556 = normal.y;
                let _e559 = grad_p_accum.y;
                grad_p_accum.y = (_e559 + ((val_f_p_1 * _e556) * area));
            } else {
                val_f_p = val_c_p;
                if (boundary_type == 2u) {
                    val_f_p = 0f;
                }
                let _e566 = val_f_p;
                let _e568 = normal.x;
                let _e571 = grad_p_accum.x;
                grad_p_accum.x = (_e571 + ((_e566 * _e568) * area));
                let _e574 = val_f_p;
                let _e576 = normal.y;
                let _e579 = grad_p_accum.y;
                grad_p_accum.y = (_e579 + ((_e574 * _e576) * area));
            }
            val_f_u = 0f;
            val_f_v = 0f;
            let _e585 = is_boundary;
            if !(_e585) {
                let _e587 = other_idx;
                let _e594 = state[((_e587 * 8u) + 0u)];
                let _e595 = other_idx;
                let _e602 = state[((_e595 * 8u) + 1u)];
                let u_other = vec2<f32>(_e594, _e602);
                let val_other_u = u_other.x;
                let val_other_v = u_other.y;
                let d_c_1 = distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y));
                let _e614 = other_center.x;
                let _e616 = other_center.y;
                let d_o_1 = distance(vec2<f32>(_e614, _e616), vec2<f32>(f_center.x, f_center.y));
                let total_dist_1 = (d_c_1 + d_o_1);
                if (total_dist_1 > 0.000001f) {
                    let lambda_1 = (d_o_1 / total_dist_1);
                    val_f_u = ((lambda_1 * val_c_u) + ((1f - lambda_1) * val_other_u));
                    val_f_v = ((lambda_1 * val_c_v) + ((1f - lambda_1) * val_other_v));
                } else {
                    val_f_u = (0.5f * (val_c_u + val_other_u));
                    val_f_v = (0.5f * (val_c_v + val_other_v));
                }
            } else {
                if (boundary_type == 1u) {
                    let _e646 = constants.ramp_time;
                    let _e649 = constants.time;
                    let ramp_1 = smoothstep(0f, _e646, _e649);
                    let _e654 = constants.inlet_velocity;
                    val_f_u = (_e654 * ramp_1);
                    val_f_v = 0f;
                } else {
                    if (boundary_type == 3u) {
                        val_f_u = 0f;
                        val_f_v = 0f;
                    } else {
                        val_f_u = val_c_u;
                        val_f_v = val_c_v;
                    }
                }
            }
            let _e663 = val_f_u;
            let _e665 = normal.x;
            let _e668 = g_u.x;
            g_u.x = (_e668 + ((_e663 * _e665) * area));
            let _e671 = val_f_u;
            let _e673 = normal.y;
            let _e676 = g_u.y;
            g_u.y = (_e676 + ((_e671 * _e673) * area));
            let _e680 = val_f_v;
            let _e682 = normal.x;
            let _e685 = g_v.x;
            g_v.x = (_e685 + ((_e680 * _e682) * area));
            let _e688 = val_f_v;
            let _e690 = normal.y;
            let _e693 = g_v.y;
            g_v.y = (_e693 + ((_e688 * _e690) * area));
        }
        continuing {
            let _e696 = k;
            k = (_e696 + 1u);
        }
    }
    let _e698 = diag_coeff;
    if (abs(_e698) > 0.00000000000000000001f) {
        let _e708 = diag_coeff;
        state[((idx * 8u) + 3u)] = (vol / _e708);
    } else {
        state[((idx * 8u) + 3u)] = 0f;
    }
    let _e719 = grad_p_accum.x;
    grad_p_accum.x = (_e719 / vol);
    let _e723 = grad_p_accum.y;
    grad_p_accum.y = (_e723 / vol);
    let _e732 = grad_p_accum.x;
    state[((idx * 8u) + 4u)] = _e732;
    let _e740 = grad_p_accum.y;
    state[((idx * 8u) + 5u)] = _e740;
    let _e743 = g_u.x;
    g_u.x = (_e743 / vol);
    let _e747 = g_u.y;
    g_u.y = (_e747 / vol);
    let _e751 = g_v.x;
    g_v.x = (_e751 / vol);
    let _e755 = g_v.y;
    g_v.y = (_e755 / vol);
    let _e759 = g_u;
    grad_u[idx] = _e759;
    let _e762 = g_v;
    grad_v[idx] = _e762;
    return;
}
"#;
    }
    pub mod pressure_assembly {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 40, size: 4, type: `f32`"]
            pub ramp_time: f32,
            #[doc = "offset: 44, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 48, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 52, size: 4, type: `u32`"]
            pub padding: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
                alpha_u: f32,
                stride_x: u32,
                padding: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                    alpha_u,
                    stride_x,
                    padding,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedPressureAssembly::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPressureAssembly::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedPressureAssembly::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::pressure_assembly::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPressureAssembly::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.matrix_values, self.rhs]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedPressureAssembly::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPressureAssembly::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPressureAssembly::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("pressure_assembly.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    alpha_u: f32,
    stride_x: u32,
    padding: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var diag_coeff: f32 = 0f;
    var rhs_val: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var normal_sign: f32;
    var other_center: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var d_p_neigh: f32;
    var other_idx_1: u32;
    var lambda: f32;
    var k_scale: f32;
    var other_idx_p: u32;
    var interp_f: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    k = start;
    loop {
        let _e21 = k;
        if (_e21 < end) {
        } else {
            break;
        }
        {
            let _e24 = k;
            let face_idx = cell_faces[_e24];
            let owner = face_owner[face_idx];
            let neigh_idx = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let _e38 = face_normals[face_idx];
            normal = _e38;
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let c_owner = cell_centers[owner];
            let dx_vec = (f_center.x - c_owner.x);
            let dy_vec = (f_center.y - c_owner.y);
            let _e56 = normal.x;
            let _e59 = normal.y;
            if (((dx_vec * _e56) + (dy_vec * _e59)) < 0f) {
                let _e66 = normal.x;
                normal.x = -(_e66);
                let _e70 = normal.y;
                normal.y = -(_e70);
            }
            normal_sign = 1f;
            if (owner != idx) {
                let _e77 = normal.x;
                normal.x = -(_e77);
                let _e81 = normal.y;
                normal.y = -(_e81);
                normal_sign = -1f;
            }
            let _e86 = fluxes[face_idx];
            let _e87 = normal_sign;
            let flux = (_e86 * _e87);
            let _e90 = rhs_val;
            rhs_val = (_e90 - flux);
            is_boundary = false;
            other_idx = idx;
            d_p_neigh = 0f;
            if (neigh_idx != -1i) {
                other_idx_1 = u32(neigh_idx);
                if (owner != idx) {
                    other_idx_1 = owner;
                }
                let _e103 = other_idx_1;
                let _e105 = cell_centers[_e103];
                other_center = _e105;
                let _e107 = other_idx_1;
                let _e114 = state[((_e107 * 8u) + 3u)];
                d_p_neigh = _e114;
            } else {
                is_boundary = true;
                other_center = f_center;
                let _e122 = state[((idx * 8u) + 3u)];
                d_p_neigh = _e122;
            }
            let _e123 = is_boundary;
            if !(_e123) {
                let _e126 = other_center.x;
                let d_vec_x = (_e126 - center.x);
                let _e130 = other_center.y;
                let d_vec_y = (_e130 - center.y);
                let dist = sqrt(((d_vec_x * d_vec_x) + (d_vec_y * d_vec_y)));
                let d_own = distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y));
                let _e145 = other_center.x;
                let _e147 = other_center.y;
                let d_neigh = distance(vec2<f32>(_e145, _e147), vec2<f32>(f_center.x, f_center.y));
                let total_dist = (d_own + d_neigh);
                lambda = 0.5f;
                if (total_dist > 0.000001f) {
                    lambda = (d_neigh / total_dist);
                }
                let d_p_own = state[((idx * 8u) + 3u)];
                let _e166 = lambda;
                let _e168 = lambda;
                let _e171 = d_p_neigh;
                let d_p_face = ((_e166 * d_p_own) + ((1f - _e168) * _e171));
                let _e176 = constants.density;
                let _e177 = lambda;
                let _e184 = state[((idx * 8u) + 3u)];
                let _e186 = lambda;
                let _e189 = other_idx;
                let _e196 = state[((_e189 * 8u) + 3u)];
                let pressure_coeff_face = (_e176 * ((_e177 * _e184) + ((1f - _e186) * _e196)));
                let coeff = ((pressure_coeff_face * area) / dist);
                let _e203 = k;
                let mat_idx = cell_face_matrix_indices[_e203];
                if (mat_idx != 4294967295u) {
                    matrix_values[mat_idx] = -(coeff);
                }
                let _e212 = diag_coeff;
                diag_coeff = (_e212 + coeff);
                let _e215 = normal.x;
                let s_x = (_e215 * area);
                let _e218 = normal.y;
                let s_y = (_e218 * area);
                let k_x_raw = (s_x - ((d_vec_x * area) / dist));
                let k_y_raw = (s_y - ((d_vec_y * area) / dist));
                let k_mag = sqrt(((k_x_raw * k_x_raw) + (k_y_raw * k_y_raw)));
                let k_limit = (0.5f * area);
                k_scale = 1f;
                if (k_mag > k_limit) {
                    k_scale = (k_limit / k_mag);
                }
                let _e236 = k_scale;
                let k_x = (k_x_raw * _e236);
                let _e238 = k_scale;
                let k_y = (k_y_raw * _e238);
                other_idx_p = u32(neigh_idx);
                if (owner != idx) {
                    other_idx_p = owner;
                }
                let _e249 = state[((idx * 8u) + 4u)];
                let _e256 = state[((idx * 8u) + 5u)];
                let grad_p_own = vec2<f32>(_e249, _e256);
                let _e258 = other_idx_p;
                let _e265 = state[((_e258 * 8u) + 4u)];
                let _e266 = other_idx_p;
                let _e273 = state[((_e266 * 8u) + 5u)];
                let grad_p_neigh = vec2<f32>(_e265, _e273);
                interp_f = 0.5f;
                if (total_dist > 0.000001f) {
                    interp_f = (d_own / total_dist);
                }
                let _e281 = interp_f;
                let grad_p_f_x = (grad_p_own.x + (_e281 * (grad_p_neigh.x - grad_p_own.x)));
                let _e288 = interp_f;
                let grad_p_f_y = (grad_p_own.y + (_e288 * (grad_p_neigh.y - grad_p_own.y)));
                let correction_flux = ((0.5f * pressure_coeff_face) * ((grad_p_f_x * k_x) + (grad_p_f_y * k_y)));
                let _e300 = rhs_val;
                rhs_val = (_e300 - correction_flux);
            } else {
                if (boundary_type == 2u) {
                    let dx = (center.x - f_center.x);
                    let dy = (center.y - f_center.y);
                    let dist_1 = sqrt(((dx * dx) + (dy * dy)));
                    let d_p_own_1 = state[((idx * 8u) + 3u)];
                    let _e323 = constants.density;
                    let _e330 = state[((idx * 8u) + 3u)];
                    let pressure_coeff_cell = (_e323 * _e330);
                    let coeff_1 = ((pressure_coeff_cell * area) / dist_1);
                    let _e334 = diag_coeff;
                    diag_coeff = (_e334 + coeff_1);
                }
            }
        }
        continuing {
            let _e337 = k;
            k = (_e337 + 1u);
        }
    }
    let diag_idx = diagonal_indices[idx];
    let _e344 = diag_coeff;
    matrix_values[diag_idx] = _e344;
    let _e347 = rhs_val;
    rhs[idx] = _e347;
    return;
}
"#;
    }
    pub mod update_fields_from_coupled {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub inlet_velocity: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub ramp_time: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                inlet_velocity: f32,
                ramp_time: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    inlet_velocity,
                    ramp_time,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedUpdateFieldsFromCoupled::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::update_fields_from_coupled::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedUpdateFieldsFromCoupled::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub max_diff_result: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub max_diff_result: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    max_diff_result: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.max_diff_result),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.x, self.max_diff_result]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedUpdateFieldsFromCoupled::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"max_diff_result\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedUpdateFieldsFromCoupled::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedUpdateFieldsFromCoupled::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("update_fields_from_coupled.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<storage> state_old: array<f32>;
@group(0) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> max_diff_result: array<atomic<u32>>;
var<workgroup> shared_max_u: array<f32, 64>;
var<workgroup> shared_max_p: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) wg_id: vec3<u32>) {
    var diff_u: f32 = 0f;
    var diff_p: f32 = 0f;
    var stride: u32 = 32u;

    let idx = global_id.x;
    let lid = local_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx < num_cells) {
        let u_new_val = x[((3u * idx) + 0u)];
        let v_new_val = x[((3u * idx) + 1u)];
        let p_new_val = x[((3u * idx) + 2u)];
        let _e38 = state[((idx * 8u) + 0u)];
        let _e45 = state[((idx * 8u) + 1u)];
        let u_old_val = vec2<f32>(_e38, _e45);
        let p_old_val = state[((idx * 8u) + 2u)];
        let alpha_u = constants.alpha_u;
        let alpha_p = constants.alpha_p;
        let u_updated_x = (u_old_val.x + (alpha_u * (u_new_val - u_old_val.x)));
        let u_updated_y = (u_old_val.y + (alpha_u * (v_new_val - u_old_val.y)));
        let p_updated = (p_old_val + (alpha_p * (p_new_val - p_old_val)));
        state[((idx * 8u) + 0u)] = u_updated_x;
        state[((idx * 8u) + 1u)] = u_updated_y;
        state[((idx * 8u) + 2u)] = p_updated;
        diff_u = max(abs((u_updated_x - u_old_val.x)), abs((u_updated_y - u_old_val.y)));
        diff_p = abs((p_updated - p_old_val));
    }
    let _e104 = diff_u;
    shared_max_u[lid] = _e104;
    let _e107 = diff_p;
    shared_max_p[lid] = _e107;
    workgroupBarrier();
    loop {
        let _e109 = stride;
        if (_e109 > 0u) {
        } else {
            break;
        }
        {
            let _e112 = stride;
            if (lid < _e112) {
                let _e118 = shared_max_u[lid];
                let _e120 = stride;
                let _e123 = shared_max_u[(lid + _e120)];
                shared_max_u[lid] = max(_e118, _e123);
                let _e129 = shared_max_p[lid];
                let _e131 = stride;
                let _e134 = shared_max_p[(lid + _e131)];
                shared_max_p[lid] = max(_e129, _e134);
            }
            workgroupBarrier();
        }
        continuing {
            let _e136 = stride;
            stride = (_e136 / 2u);
        }
    }
    if (lid == 0u) {
        let _e145 = shared_max_u[0];
        let _e147 = atomicMax((&max_diff_result[0]), bitcast<u32>(_e145));
        let _e152 = shared_max_p[0];
        let _e154 = atomicMax((&max_diff_result[1]), bitcast<u32>(_e152));
        return;
    } else {
        return;
    }
}
"#;
    }
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_groups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let idx = global_id.x;
    let j = params.num_iters;
    let n = params.n;
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e21 = b_w[idx];
        w_val = _e21;
    }
    loop {
        let _e24 = i;
        if (_e24 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e30 = i;
                if (_e30 <= j) {
                    let _e34 = i;
                    let _e38 = b_basis[((_e34 * stride_words) + idx)];
                    v.x = _e38;
                }
                let _e39 = i;
                if ((_e39 + 1u) <= j) {
                    let _e44 = i;
                    let _e51 = b_basis[(((_e44 + 1u) * stride_words) + idx)];
                    v.y = _e51;
                }
                let _e52 = i;
                if ((_e52 + 2u) <= j) {
                    let _e57 = i;
                    let _e64 = b_basis[(((_e57 + 2u) * stride_words) + idx)];
                    v.z = _e64;
                }
                let _e65 = i;
                if ((_e65 + 3u) <= j) {
                    let _e70 = i;
                    let _e77 = b_basis[(((_e70 + 3u) * stride_words) + idx)];
                    v.w = _e77;
                }
            }
            let _e78 = v;
            let _e79 = w_val;
            let prod = (_e78 * _e79);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e96 = sdata_vec4_[(local_id.x + 32u)];
                let _e97 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e97 + _e96);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e110 = sdata_vec4_[(local_id.x + 16u)];
                let _e111 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e111 + _e110);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e124 = sdata_vec4_[(local_id.x + 8u)];
                let _e125 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e125 + _e124);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e138 = sdata_vec4_[(local_id.x + 4u)];
                let _e139 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e139 + _e138);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e152 = sdata_vec4_[(local_id.x + 2u)];
                let _e153 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e153 + _e152);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e166 = sdata_vec4_[(local_id.x + 1u)];
                let _e167 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e167 + _e166);
                let sum_1 = sdata_vec4_[0];
                let _e172 = i;
                if (_e172 <= j) {
                    let _e177 = i;
                    b_dot_partial[((_e177 * num_groups.x) + group_id.x)] = sum_1.x;
                }
                let _e184 = i;
                if ((_e184 + 1u) <= j) {
                    let _e188 = i;
                    b_dot_partial[(((_e188 + 1u) * num_groups.x) + group_id.x)] = sum_1.y;
                }
                let _e198 = i;
                if ((_e198 + 2u) <= j) {
                    let _e202 = i;
                    b_dot_partial[(((_e202 + 2u) * num_groups.x) + group_id.x)] = sum_1.z;
                }
                let _e212 = i;
                if ((_e212 + 3u) <= j) {
                    let _e216 = i;
                    b_dot_partial[(((_e216 + 3u) * num_groups.x) + group_id.x)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e227 = i;
            i = (_e227 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e8 = params.n;
    let num_groups_n = ((_e8 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e16 = k;
        if (_e16 < num_groups_n) {
        } else {
            break;
        }
        {
            let _e21 = k;
            let _e24 = b_dot_partial[((i_2 * num_groups_n) + _e21)];
            let _e25 = sum;
            sum = (_e25 + _e24);
        }
        continuing {
            let _e28 = k;
            k = (_e28 + 64u);
        }
    }
    let _e33 = sum;
    sdata[local_id_1.x] = _e33;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e45 = sdata[(local_id_1.x + 32u)];
        let _e46 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e46 + _e45);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e59 = sdata[(local_id_1.x + 16u)];
        let _e60 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e60 + _e59);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e73 = sdata[(local_id_1.x + 8u)];
        let _e74 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e74 + _e73);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e87 = sdata[(local_id_1.x + 4u)];
        let _e88 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e88 + _e87);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e101 = sdata[(local_id_1.x + 2u)];
        let _e102 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e102 + _e101);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e115 = sdata[(local_id_1.x + 1u)];
        let _e116 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e116 + _e115);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e129 = sdata[0];
        b_hessenberg[h_idx] = _e129;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let idx_1 = global_id_2.x;
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e23 = i_1;
        if (_e23 <= j_2) {
        } else {
            break;
        }
        {
            let _e25 = i_1;
            if (_e25 <= j_2) {
                let _e31 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e31)];
                let _e36 = i_1;
                let v_val = b_basis[((_e36 * stride_words_1) + idx_1)];
                let _e43 = correction;
                correction = (_e43 + (h_val * v_val));
            }
            let _e45 = i_1;
            if ((_e45 + 1u) <= j_2) {
                let _e52 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e52 + 1u))];
                let _e59 = i_1;
                let v_val_1 = b_basis[(((_e59 + 1u) * stride_words_1) + idx_1)];
                let _e68 = correction;
                correction = (_e68 + (h_val_1 * v_val_1));
            }
            let _e70 = i_1;
            if ((_e70 + 2u) <= j_2) {
                let _e77 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e77 + 2u))];
                let _e84 = i_1;
                let v_val_2 = b_basis[(((_e84 + 2u) * stride_words_1) + idx_1)];
                let _e93 = correction;
                correction = (_e93 + (h_val_2 * v_val_2));
            }
            let _e95 = i_1;
            if ((_e95 + 3u) <= j_2) {
                let _e102 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e102 + 3u))];
                let _e109 = i_1;
                let v_val_3 = b_basis[(((_e109 + 3u) * stride_words_1) + idx_1)];
                let _e118 = correction;
                correction = (_e118 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e121 = i_1;
            i_1 = (_e121 + 4u);
        }
    }
    let _e127 = b_w[idx_1];
    let _e128 = correction;
    b_w[idx_1] = (_e127 - _e128);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.iter_params, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let j_1 = iter_params.current_idx;
    loop {
        let _e7 = i;
        if (_e7 < j_1) {
        } else {
            break;
        }
        {
            let _e9 = i;
            let _e10 = h_idx(_e9, j_1);
            let _e11 = i;
            let _e14 = h_idx((_e11 + 1u), j_1);
            let h_ij = hessenberg[_e10];
            let h_i1j = hessenberg[_e14];
            let _e22 = i;
            let cs = givens[_e22];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e10] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e14] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e39 = i;
            i = (_e39 + 1u);
        }
    }
    let _e41 = h_idx(j_1, j_1);
    let _e44 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e41];
    let h_j1j = hessenberg[_e44];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e56 = rho;
    if (abs(_e56) > 0.00000000000000000001f) {
        let _e60 = rho;
        c = (h_jj / _e60);
        let _e63 = rho;
        s = (h_j1j / _e63);
    }
    let _e68 = c;
    let _e69 = s;
    givens[j_1] = vec2<f32>(_e68, _e69);
    let _e73 = rho;
    hessenberg[_e41] = _e73;
    hessenberg[_e44] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e87 = c;
    let _e89 = s;
    g_rhs[j_1] = ((_e87 * g_j) + (_e89 * g_j1_));
    let _e96 = s;
    let _e99 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e96) * g_j) + (_e99 * g_j1_));
    let _e108 = g_rhs[(j_1 + 1u)];
    scalars[0] = abs(_e108);
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let k = iter_params.current_idx;
    loop {
        let _e5 = loop_i;
        if (_e5 < k) {
        } else {
            break;
        }
        {
            let _e9 = loop_i;
            let i_1 = ((k - 1u) - _e9);
            let _e13 = g_rhs[i_1];
            sum = _e13;
            j = (i_1 + 1u);
            loop {
                let _e18 = j;
                if (_e18 < k) {
                } else {
                    break;
                }
                {
                    let _e20 = j;
                    let _e21 = h_idx(i_1, _e20);
                    let _e24 = hessenberg[_e21];
                    let _e26 = j;
                    let _e28 = y_sol[_e26];
                    let _e30 = sum;
                    sum = (_e30 - (_e24 * _e28));
                }
                continuing {
                    let _e33 = j;
                    j = (_e33 + 1u);
                }
            }
            let _e35 = h_idx(i_1, i_1);
            let diag = hessenberg[_e35];
            if (abs(diag) > 0.000000000001f) {
                let _e44 = sum;
                y_sol[i_1] = (_e44 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e50 = loop_i;
            loop_i = (_e50 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn get_global_index(global_id_12: vec3<u32>) -> u32 {
    let _e5 = params.dispatch_x;
    return (global_id_12.x + (global_id_12.y * _e5));
}

fn get_workgroup_index(wg_id_2: vec3<u32>) -> u32 {
    let _e2 = params.dispatch_x;
    let dispatch_wg_x = (_e2 / 64u);
    return (wg_id_2.x + (wg_id_2.y * dispatch_wg_x));
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e2 = get_global_index(global_id);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let start = row_offsets[_e2];
    let end = row_offsets[(_e2 + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col = col_indices[_e19];
            let _e23 = k;
            let val = matrix_values[_e23];
            let _e29 = vec_x[col];
            let _e31 = sum;
            sum = (_e31 + (val * _e29));
        }
        continuing {
            let _e34 = k;
            k = (_e34 + 1u);
        }
    }
    let _e38 = sum;
    vec_y[_e2] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    let _e1 = get_global_index(global_id_1);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha = scalars[0];
    let _e13 = vec_x[_e1];
    let _e17 = vec_y[_e1];
    vec_y[_e1] = ((alpha * _e13) + _e17);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let _e1 = get_global_index(global_id_2);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let _e9 = iter_params.current_idx;
    let alpha_1 = y_sol[_e9];
    let _e16 = vec_x[_e1];
    let _e20 = vec_y[_e1];
    vec_y[_e1] = ((alpha_1 * _e16) + _e20);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    let _e1 = get_global_index(global_id_3);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e16 = vec_x[_e1];
    let _e20 = vec_y[_e1];
    vec_z[_e1] = ((alpha_2 * _e16) + (beta * _e20));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>) {
    let _e1 = get_global_index(global_id_4);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e13 = vec_x[_e1];
    vec_y[_e1] = (alpha_3 * _e13);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>) {
    let _e1 = get_global_index(global_id_5);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e13 = vec_y[_e1];
    vec_y[_e1] = (alpha_4 * _e13);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>) {
    let _e1 = get_global_index(global_id_6);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let _e10 = vec_x[_e1];
    vec_y[_e1] = _e10;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) wg_id: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e3 = get_global_index(global_id_7);
    let lid = local_id.x;
    let _e7 = get_workgroup_index(wg_id);
    let _e10 = params.n;
    if (_e3 < _e10) {
        let _e14 = vec_x[_e3];
        let _e17 = vec_y[_e3];
        local_sum = (_e14 * _e17);
    }
    let _e22 = local_sum;
    partial_sums[lid] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = stride;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = stride;
            if (lid < _e27) {
                let _e32 = stride;
                let _e35 = partial_sums[(lid + _e32)];
                let _e36 = partial_sums[lid];
                partial_sums[lid] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = stride;
            stride = (_e39 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e47 = partial_sums[0];
        vec_z[_e7] = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) wg_id_1: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e3 = get_global_index(global_id_8);
    let lid_1 = local_id_1.x;
    let _e7 = get_workgroup_index(wg_id_1);
    let _e10 = params.n;
    if (_e3 < _e10) {
        let val_1 = vec_x[_e3];
        local_sum_1 = (val_1 * val_1);
    }
    let _e19 = local_sum_1;
    partial_sums[lid_1] = _e19;
    workgroupBarrier();
    loop {
        let _e21 = stride_1;
        if (_e21 > 0u) {
        } else {
            break;
        }
        {
            let _e24 = stride_1;
            if (lid_1 < _e24) {
                let _e29 = stride_1;
                let _e32 = partial_sums[(lid_1 + _e29)];
                let _e33 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e33 + _e32);
            }
            workgroupBarrier();
        }
        continuing {
            let _e36 = stride_1;
            stride_1 = (_e36 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e44 = partial_sums[0];
        vec_z[_e7] = _e44;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>) {
    let _e1 = get_global_index(global_id_9);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let h = scalars[0];
    let _e13 = vec_y[_e1];
    let _e16 = vec_x[_e1];
    vec_y[_e1] = (_e13 - (h * _e16));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let num_partials_1 = params.n;
    loop {
        let _e6 = i_1;
        if (_e6 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e10 = i_1;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum_1;
            total_sum_1 = (_e13 + _e12);
        }
        continuing {
            let _e16 = i_1;
            i_1 = (_e16 + 1u);
        }
    }
    let _e18 = total_sum_1;
    let norm = sqrt(_e18);
    let _e23 = iter_params.current_idx;
    hessenberg[_e23] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 24, size: 4, type: `f32`"]
        pub t_s: f32,
        #[doc = "offset: 28, size: 4, type: `f32`"]
        pub t_t: f32,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            omega: f32,
            r0_v: f32,
            t_s: f32,
            t_t: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                omega,
                r0_v,
                t_s,
                t_t,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SPMV_S_T_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_s_t_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_s_t"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_s_t"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const BICGSTAB_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_bicgstab_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline bicgstab_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("bicgstab_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const BICGSTAB_UPDATE_S_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_bicgstab_update_s_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline bicgstab_update_s"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("bicgstab_update_s"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const BICGSTAB_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_bicgstab_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline bicgstab_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("bicgstab_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_SPMV_S_T: &str = "spmv_s_t";
    pub const ENTRY_BICGSTAB_UPDATE_P: &str = "bicgstab_update_p";
    pub const ENTRY_BICGSTAB_UPDATE_S: &str = "bicgstab_update_s";
    pub const ENTRY_BICGSTAB_UPDATE_X_R: &str = "bicgstab_update_x_r";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
        pub s: wgpu::BufferBinding<'a>,
        pub t: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
        pub s: wgpu::BindGroupEntry<'a>,
        pub t: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
                s: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.s),
                },
                t: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.t),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [self.x, self.r, self.p, self.v, self.s, self.t]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"s\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"t\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    omega: f32,
    r0_v: f32,
    t_s: f32,
    t_t: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> s: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> t: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let row = global_id.x;
    let _e5 = params.n;
    if (row >= _e5) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col = col_indices[_e19];
            let _e23 = k;
            let val = matrix_values[_e23];
            let _e29 = p[col];
            let _e31 = sum;
            sum = (_e31 + (val * _e29));
        }
        continuing {
            let _e34 = k;
            k = (_e34 + 1u);
        }
    }
    let _e38 = sum;
    v[row] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_s_t(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var sum_1: f32 = 0f;
    var k_1: u32;

    let row_1 = global_id_1.x;
    let _e5 = params.n;
    if (row_1 >= _e5) {
        return;
    }
    let start_1 = row_offsets[row_1];
    let end_1 = row_offsets[(row_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e16 = k_1;
        if (_e16 < end_1) {
        } else {
            break;
        }
        {
            let _e19 = k_1;
            let col_1 = col_indices[_e19];
            let _e23 = k_1;
            let val_1 = matrix_values[_e23];
            let _e29 = s[col_1];
            let _e31 = sum_1;
            sum_1 = (_e31 + (val_1 * _e29));
        }
        continuing {
            let _e34 = k_1;
            k_1 = (_e34 + 1u);
        }
    }
    let _e38 = sum_1;
    t[row_1] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn bicgstab_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var beta: f32 = 0f;

    let idx = global_id_2.x;
    let _e5 = scalars.omega;
    let _e11 = scalars.rho_old;
    if ((abs(_e5) >= 0.00000000000000000001f) && (abs(_e11) >= 0.00000000000000000001f)) {
        let _e18 = scalars.rho_new;
        let _e21 = scalars.rho_old;
        let _e25 = scalars.alpha;
        let _e28 = scalars.omega;
        beta = ((_e18 / _e21) * (_e25 / _e28));
    }
    if (global_id_2.x == 0u) {
        let _e37 = beta;
        scalars.beta = _e37;
    }
    let _e40 = params.n;
    if (idx >= _e40) {
        return;
    }
    let _e46 = r[idx];
    let _e47 = beta;
    let _e50 = p[idx];
    let _e53 = scalars.omega;
    let _e56 = v[idx];
    p[idx] = (_e46 + (_e47 * (_e50 - (_e53 * _e56))));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn bicgstab_update_s(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    var alpha: f32 = 0f;

    let idx_1 = global_id_3.x;
    let _e5 = scalars.r0_v;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.rho_new;
        let _e14 = scalars.r0_v;
        alpha = (_e11 / _e14);
    }
    if (global_id_3.x == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (idx_1 >= _e25) {
        return;
    }
    let _e31 = r[idx_1];
    let _e32 = alpha;
    let _e35 = v[idx_1];
    s[idx_1] = (_e31 - (_e32 * _e35));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn bicgstab_update_x_r(@builtin(global_invocation_id) global_id_4: vec3<u32>) {
    var omega: f32 = 0f;

    let idx_2 = global_id_4.x;
    let _e5 = scalars.t_t;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.t_s;
        let _e14 = scalars.t_t;
        omega = (_e11 / _e14);
    }
    if (global_id_4.x == 0u) {
        let _e22 = omega;
        scalars.omega = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (idx_2 >= _e30) {
        return;
    }
    let alpha_2 = scalars.alpha;
    let _e39 = p[idx_2];
    let _e41 = omega;
    let _e44 = s[idx_2];
    let _e47 = x[idx_2];
    x[idx_2] = (_e47 + ((alpha_2 * _e39) + (_e41 * _e44)));
    let _e53 = s[idx_2];
    let _e54 = omega;
    let _e57 = t[idx_2];
    r[idx_2] = (_e53 - (_e54 * _e57));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_5: vec3<u32>) {
    var alpha_1: f32 = 0f;

    let idx_3 = global_id_5.x;
    let _e5 = scalars.r0_v;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.rho_old;
        let _e14 = scalars.r0_v;
        alpha_1 = (_e11 / _e14);
    }
    if (global_id_5.x == 0u) {
        let _e22 = alpha_1;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (idx_3 >= _e25) {
        return;
    }
    let _e29 = alpha_1;
    let _e32 = p[idx_3];
    let _e34 = x[idx_3];
    x[idx_3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha_1;
    let _e41 = v[idx_3];
    let _e43 = r[idx_3];
    r[idx_3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_6: vec3<u32>) {
    var beta_1: f32 = 0f;

    let idx_4 = global_id_6.x;
    let _e5 = scalars.rho_old;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.rho_new;
        let _e14 = scalars.rho_old;
        beta_1 = (_e11 / _e14);
    }
    if (global_id_6.x == 0u) {
        let _e22 = beta_1;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (idx_4 >= _e30) {
        return;
    }
    let _e36 = r[idx_4];
    let _e37 = beta_1;
    let _e40 = p[idx_4];
    p[idx_4] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod preconditioner {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 24, size: 4, type: `f32`"]
        pub t_s: f32,
        #[doc = "offset: 28, size: 4, type: `f32`"]
        pub t_t: f32,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            omega: f32,
            r0_v: f32,
            t_s: f32,
            t_t: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                omega,
                r0_v,
                t_s,
                t_t,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub mode: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PrecondParams {
        pub const fn new(mode: u32, _pad0: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                mode,
                _pad0,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_SCHUR_RHS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_schur_rhs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_schur_rhs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_schur_rhs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINALIZE_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_finalize_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finalize_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finalize_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SPMV_PHAT_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_phat_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_phat_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_phat_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SPMV_SHAT_T_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_shat_t_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_shat_t"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_shat_t"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_SCHUR_RHS: &str = "build_schur_rhs";
    pub const ENTRY_FINALIZE_PRECOND: &str = "finalize_precond";
    pub const ENTRY_SPMV_PHAT_V: &str = "spmv_phat_v";
    pub const ENTRY_SPMV_SHAT_T: &str = "spmv_shat_t";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
        pub s: wgpu::BufferBinding<'a>,
        pub t: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
        pub s: wgpu::BindGroupEntry<'a>,
        pub t: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
                s: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.s),
                },
                t: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.t),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [self.x, self.r, self.p, self.v, self.s, self.t]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Preconditioner::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"s\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"t\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Preconditioner::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Preconditioner::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::preconditioner::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::preconditioner::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Preconditioner::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
        pub p_hat: wgpu::BufferBinding<'a>,
        pub s_hat: wgpu::BufferBinding<'a>,
        pub precond_rhs: wgpu::BufferBinding<'a>,
        pub precond_params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
        pub p_hat: wgpu::BindGroupEntry<'a>,
        pub s_hat: wgpu::BindGroupEntry<'a>,
        pub precond_rhs: wgpu::BindGroupEntry<'a>,
        pub precond_params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
                p_hat: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_hat),
                },
                s_hat: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.s_hat),
                },
                precond_rhs: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.precond_rhs),
                },
                precond_params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.precond_params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.block_inv,
                self.p_hat,
                self.s_hat,
                self.precond_rhs,
                self.precond_params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Preconditioner::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_hat\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"s_hat\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"precond_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"precond_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::preconditioner::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Preconditioner::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 3],
        ) -> [wgpu::BindGroupLayout; 3] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Preconditioner::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("preconditioner.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    omega: f32,
    r0_v: f32,
    t_s: f32,
    t_t: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

struct PrecondParams {
    mode: u32,
    _pad0_: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> s: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> t: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> p_hat: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> s_hat: array<f32>;
@group(2) @binding(3) 
var<storage, read_write> precond_rhs: array<f32>;
@group(2) @binding(4) 
var<uniform> precond_params: PrecondParams;

fn use_s_mode() -> bool {
    let _e2 = precond_params.mode;
    return (_e2 == 1u);
}

fn read_search_vector(idx: u32) -> f32 {
    let _e0 = use_s_mode();
    if _e0 {
        let _e4 = s[idx];
        return _e4;
    }
    let _e7 = p[idx];
    return _e7;
}

fn write_hat(idx_1: u32, value: f32) {
    let _e0 = use_s_mode();
    if _e0 {
        s_hat[idx_1] = value;
        return;
    } else {
        p_hat[idx_1] = value;
        return;
    }
}

fn read_hat(idx_2: u32) -> f32 {
    let _e0 = use_s_mode();
    if _e0 {
        let _e4 = s_hat[idx_2];
        return _e4;
    }
    let _e7 = p_hat[idx_2];
    return _e7;
}

fn write_rhs(idx_3: u32, value_1: f32) {
    precond_rhs[idx_3] = value_1;
    return;
}

fn get_matrix_value(row: u32, col: u32) -> f32 {
    var value_2: f32 = 0f;
    var k_5: u32;

    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k_5 = start;
    loop {
        let _e11 = k_5;
        if (_e11 < end) {
        } else {
            break;
        }
        {
            let _e15 = k_5;
            let _e17 = col_indices[_e15];
            if (_e17 == col) {
                let _e20 = k_5;
                let _e22 = matrix_values[_e20];
                value_2 = _e22;
                break;
            }
        }
        continuing {
            let _e25 = k_5;
            k_5 = (_e25 + 1u);
        }
    }
    let _e27 = value_2;
    return _e27;
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 10000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_schur_rhs(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rhs: f32;
    var k: u32;

    let total_unknowns = params.n;
    if (total_unknowns < 3u) {
        return;
    }
    let num_cells = (total_unknowns / 3u);
    let cell = global_id.x;
    if (cell >= num_cells) {
        return;
    }
    let base = (cell * 3u);
    let row_1 = (base + 2u);
    let _e14 = read_search_vector(row_1);
    rhs = _e14;
    let start_1 = row_offsets[row_1];
    let end_1 = row_offsets[(row_1 + 1u)];
    k = start_1;
    loop {
        let _e25 = k;
        if (_e25 < end_1) {
        } else {
            break;
        }
        {
            let _e28 = k;
            let col_1 = col_indices[_e28];
            if ((col_1 % 3u) != 2u) {
                let _e36 = k;
                let _e38 = matrix_values[_e36];
                let _e39 = read_hat(col_1);
                let _e41 = rhs;
                rhs = (_e41 - (_e38 * _e39));
            }
        }
        continuing {
            let _e44 = k;
            k = (_e44 + 1u);
        }
    }
    write_rhs((base + 0u), 0f);
    write_rhs((base + 1u), 0f);
    let _e54 = rhs;
    write_rhs((base + 2u), _e54);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn finalize_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var vel_u: f32;
    var vel_v: f32;
    var k_1: u32;
    var k_2: u32;

    let total_unknowns_1 = params.n;
    if (total_unknowns_1 < 3u) {
        return;
    }
    let num_cells_1 = (total_unknowns_1 / 3u);
    let cell_1 = global_id_1.x;
    if (cell_1 >= num_cells_1) {
        return;
    }
    let base_1 = (cell_1 * 3u);
    let offset = (cell_1 * 9u);
    let row_u = (base_1 + 0u);
    let row_v = (base_1 + 1u);
    let _e18 = read_hat(row_u);
    vel_u = _e18;
    let _e20 = read_hat(row_v);
    vel_v = _e20;
    let inv_u = block_inv[(offset + 0u)];
    let inv_v = block_inv[(offset + 4u)];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e41 = k_1;
        if (_e41 < end_u) {
        } else {
            break;
        }
        {
            let _e44 = k_1;
            let col_2 = col_indices[_e44];
            if ((col_2 % 3u) == 2u) {
                let _e52 = k_1;
                let _e54 = matrix_values[_e52];
                let _e56 = read_hat(col_2);
                let _e58 = vel_u;
                vel_u = (_e58 - ((inv_u * _e54) * _e56));
            }
        }
        continuing {
            let _e61 = k_1;
            k_1 = (_e61 + 1u);
        }
    }
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e72 = k_2;
        if (_e72 < end_v) {
        } else {
            break;
        }
        {
            let _e75 = k_2;
            let col_3 = col_indices[_e75];
            if ((col_3 % 3u) == 2u) {
                let _e83 = k_2;
                let _e85 = matrix_values[_e83];
                let _e87 = read_hat(col_3);
                let _e89 = vel_v;
                vel_v = (_e89 - ((inv_v * _e85) * _e87));
            }
        }
        continuing {
            let _e92 = k_2;
            k_2 = (_e92 + 1u);
        }
    }
    let _e94 = vel_u;
    write_hat(row_u, _e94);
    let _e95 = vel_v;
    write_hat(row_v, _e95);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_phat_v(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_3: u32;

    let row_2 = global_id_2.x;
    let _e5 = params.n;
    if (row_2 >= _e5) {
        return;
    }
    let start_2 = row_offsets[row_2];
    let end_2 = row_offsets[(row_2 + 1u)];
    k_3 = start_2;
    loop {
        let _e16 = k_3;
        if (_e16 < end_2) {
        } else {
            break;
        }
        {
            let _e19 = k_3;
            let col_4 = col_indices[_e19];
            let _e23 = k_3;
            let val_1 = matrix_values[_e23];
            let _e29 = p_hat[col_4];
            let _e31 = sum;
            sum = (_e31 + (val_1 * _e29));
        }
        continuing {
            let _e34 = k_3;
            k_3 = (_e34 + 1u);
        }
    }
    let _e38 = sum;
    v[row_2] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_shat_t(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    var sum_1: f32 = 0f;
    var k_4: u32;

    let row_3 = global_id_3.x;
    let _e5 = params.n;
    if (row_3 >= _e5) {
        return;
    }
    let start_3 = row_offsets[row_3];
    let end_3 = row_offsets[(row_3 + 1u)];
    k_4 = start_3;
    loop {
        let _e16 = k_4;
        if (_e16 < end_3) {
        } else {
            break;
        }
        {
            let _e19 = k_4;
            let col_5 = col_indices[_e19];
            let _e23 = k_4;
            let val_2 = matrix_values[_e23];
            let _e29 = s_hat[col_5];
            let _e31 = sum_1;
            sum_1 = (_e31 + (val_2 * _e29));
        }
        continuing {
            let _e34 = k_4;
            k_4 = (_e34 + 1u);
        }
    }
    let _e38 = sum_1;
    t[row_3] = _e38;
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 24, size: 4, type: `f32`"]
        pub t_s: f32,
        #[doc = "offset: 28, size: 4, type: `f32`"]
        pub t_t: f32,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            omega: f32,
            r0_v: f32,
            t_s: f32,
            t_t: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                omega,
                r0_v,
                t_s,
                t_t,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_T_S_T_T_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_t_s_t_t_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_t_s_t_t"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_t_s_t_t"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_SCALARS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_init_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_RHO_OLD_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_rho_old_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_rho_old"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_rho_old"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_CG_ALPHA_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_cg_alpha_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_cg_alpha"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_cg_alpha"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_CG_BETA_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_cg_beta_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_cg_beta"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_cg_beta"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_REDUCE_T_S_T_T: &str = "reduce_t_s_t_t";
    pub const ENTRY_INIT_SCALARS: &str = "init_scalars";
    pub const ENTRY_UPDATE_RHO_OLD: &str = "update_rho_old";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    pub const ENTRY_UPDATE_CG_ALPHA: &str = "update_cg_alpha";
    pub const ENTRY_UPDATE_CG_BETA: &str = "update_cg_beta";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    omega: f32,
    r0_v: f32,
    t_s: f32,
    t_t: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_t_s_t_t(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum1_1: f32 = 0f;
    var sum2_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_1;
            sum1_1 = (_e15 + _e14);
            let _e19 = i_4;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_1;
            sum2_1 = (_e22 + _e21);
        }
        continuing {
            let _e25 = i_4;
            i_4 = (_e25 + 64u);
        }
    }
    let _e29 = sum1_1;
    scratch1_[lid_2] = _e29;
    let _e32 = sum2_1;
    scratch2_[lid_2] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_5;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_5;
            if (lid_2 < _e37) {
                let _e42 = i_5;
                let _e45 = scratch1_[(lid_2 + _e42)];
                let _e46 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e46 + _e45);
                let _e51 = i_5;
                let _e54 = scratch2_[(lid_2 + _e51)];
                let _e55 = scratch2_[lid_2];
                scratch2_[lid_2] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_5;
            i_5 = (_e58 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e66 = scratch1_[0];
        scalars.t_s = _e66;
        let _e71 = scratch2_[0];
        scalars.t_t = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn init_scalars() {
    scalars.rho_old = 1f;
    scalars.alpha = 1f;
    scalars.omega = 1f;
    scalars.beta = 0f;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn update_rho_old() {
    let _e4 = scalars.rho_new;
    scalars.rho_old = _e4;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_3: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_6: u32;
    var i_7: u32 = 32u;

    let n_3 = params.num_groups;
    let lid_3 = local_id_3.x;
    i_6 = lid_3;
    loop {
        let _e8 = i_6;
        if (_e8 < n_3) {
        } else {
            break;
        }
        {
            let _e12 = i_6;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_6;
            i_6 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_3] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_7;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_7;
            if (lid_3 < _e27) {
                let _e32 = i_7;
                let _e35 = scratch1_[(lid_3 + _e32)];
                let _e36 = scratch1_[lid_3];
                scratch1_[lid_3] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_7;
            i_7 = (_e39 >> 1u);
        }
    }
    if (lid_3 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn update_cg_alpha() {
    let _e2 = scalars.r0_v;
    if (abs(_e2) < 0.00000000000000000001f) {
        scalars.alpha = 0f;
        return;
    } else {
        let _e13 = scalars.rho_old;
        let _e16 = scalars.r0_v;
        scalars.alpha = (_e13 / _e16);
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn update_cg_beta() {
    let _e2 = scalars.rho_old;
    if (abs(_e2) < 0.00000000000000000001f) {
        scalars.beta = 0f;
        return;
    } else {
        let _e13 = scalars.rho_new;
        let _e16 = scalars.rho_old;
        scalars.beta = (_e13 / _e16);
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
    }
    impl PrecondParams {
        pub const fn new(n: u32, num_cells: u32, omega: f32) -> Self {
            Self {
                n,
                num_cells,
                omega,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
}

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let cell = global_id.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let start = p_row_offsets[cell];
    let end = p_row_offsets[(cell + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col_cell = p_col_indices[_e19];
            if (col_cell != cell) {
                let _e24 = k;
                let _e26 = p_matrix_values[_e24];
                let _e30 = p_sol[col_cell];
                let _e32 = sigma;
                sigma = (_e32 + (_e26 * _e30));
            }
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let d_inv = diag_p_inv[cell];
    let rhs = temp_p[cell];
    let _e43 = sigma;
    let hat_x = (d_inv * (rhs - _e43));
    let x_prev = p_prev[cell];
    let _e51 = params.omega;
    let x_new = mix(x_prev, hat_x, _e51);
    p_prev[cell] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let cell_1 = global_id_1.x;
    let _e5 = params.num_cells;
    if (cell_1 >= _e5) {
        return;
    }
    let base = (cell_1 * 3u);
    let row_u = (base + 0u);
    let row_v = (base + 1u);
    let p_val = p_sol[cell_1];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e25 = k_1;
        if (_e25 < end_u) {
        } else {
            break;
        }
        {
            let _e28 = k_1;
            let col = col_indices[_e28];
            if ((col % 3u) == 2u) {
                let p_cell = (col / 3u);
                let _e38 = k_1;
                let _e40 = matrix_values[_e38];
                let _e44 = p_sol[p_cell];
                let _e46 = correction_u;
                correction_u = (_e46 + (_e40 * _e44));
            }
        }
        continuing {
            let _e49 = k_1;
            k_1 = (_e49 + 1u);
        }
    }
    let _e55 = diag_u_inv[cell_1];
    let _e56 = correction_u;
    let _e58 = z_out[row_u];
    z_out[row_u] = (_e58 - (_e55 * _e56));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e69 = k_2;
        if (_e69 < end_v) {
        } else {
            break;
        }
        {
            let _e72 = k_2;
            let col_1 = col_indices[_e72];
            if ((col_1 % 3u) == 2u) {
                let p_cell_1 = (col_1 / 3u);
                let _e82 = k_2;
                let _e84 = matrix_values[_e82];
                let _e88 = p_sol[p_cell_1];
                let _e90 = correction_v;
                correction_v = (_e90 + (_e84 * _e88));
            }
        }
        continuing {
            let _e93 = k_2;
            k_2 = (_e93 + 1u);
        }
    }
    let _e99 = diag_v_inv[cell_1];
    let _e100 = correction_v;
    let _e102 = z_out[row_v];
    z_out[row_v] = (_e102 - (_e99 * _e100));
    z_out[(base + 2u)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let cell_2 = global_id_2.x;
    let _e4 = params.num_cells;
    if (cell_2 >= _e4) {
        return;
    }
    let base_1 = (cell_2 * 3u);
    let r_u = r_in[(base_1 + 0u)];
    let r_v = r_in[(base_1 + 1u)];
    let _e24 = diag_u_inv[cell_2];
    z_out[(base_1 + 0u)] = (_e24 * r_u);
    let _e32 = diag_v_inv[cell_2];
    z_out[(base_1 + 1u)] = (_e32 * r_v);
    z_out[(base_1 + 2u)] = 0f;
    let row_p = (base_1 + 2u);
    let _e43 = r_in[row_p];
    rhs_p = _e43;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e54 = k_3;
        if (_e54 < end_1) {
        } else {
            break;
        }
        {
            let _e57 = k_3;
            let col_2 = col_indices[_e57];
            let rem = (col_2 % 3u);
            z_val = 0f;
            if (rem == 0u) {
                let c = (col_2 / 3u);
                let _e70 = r_in[col_2];
                let _e73 = diag_u_inv[c];
                z_val = (_e70 * _e73);
            } else {
                if (rem == 1u) {
                    let c_1 = (col_2 / 3u);
                    let _e81 = r_in[col_2];
                    let _e84 = diag_v_inv[c_1];
                    z_val = (_e81 * _e84);
                }
            }
            let _e87 = k_3;
            let _e89 = matrix_values[_e87];
            let _e90 = z_val;
            let _e92 = rhs_p;
            rhs_p = (_e92 - (_e89 * _e90));
        }
        continuing {
            let _e95 = k_3;
            k_3 = (_e95 + 1u);
        }
    }
    let _e99 = rhs_p;
    temp_p[cell_2] = _e99;
    let _e104 = diag_p_inv[cell_2];
    let _e105 = rhs_p;
    p_sol[cell_2] = (_e104 * _e105);
    p_prev[cell_2] = 0f;
    return;
}
"#;
}
