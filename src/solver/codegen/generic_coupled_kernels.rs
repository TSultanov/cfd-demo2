use std::collections::HashMap;

use super::dsl as typed;
use super::state_access::state_component;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::codegen::ir::{DiscreteOpKind, DiscreteSystem};
use crate::solver::codegen::primitive_expr::lower_primitive_expr;
use crate::solver::gpu::enums::GpuBcKind;
use crate::solver::gpu::enums::TimeScheme;
use crate::solver::ir::{Coefficient, Discretization, StateLayout};
use crate::solver::shared::PrimitiveExpr;

pub fn generate_generic_coupled_assembly_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    needs_gradients: bool,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (generic_coupled_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_assembly_items(needs_gradients));
    module.push(Item::Function(main_assembly_fn(system, layout)));
    module.to_wgsl()
}

pub fn generate_generic_coupled_update_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    primitives: &[(String, PrimitiveExpr)],
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (generic_coupled_update)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_update_items());
    module.push(Item::Function(main_update_fn(system, layout, primitives)));
    module.to_wgsl()
}

pub fn generate_generic_coupled_apply_wgsl() -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (generic_coupled_apply)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_apply_items());
    module.push(Item::Function(main_apply_fn()));
    module.to_wgsl()
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn base_mesh_items() -> Vec<Item> {
    vec![
        Item::Struct(vector2_struct()),
        Item::Struct(constants_struct()),
        Item::Comment("Group 0: Mesh".to_string()),
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
    ]
}

fn base_state_items(needs_gradients: bool) -> Vec<Item> {
    let mut items = vec![
        Item::Comment("Group 1: Fields".to_string()),
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 3),
    ];
    if needs_gradients {
        items.push(storage_var(
            "grad_state",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            4,
            AccessMode::Read,
        ));
    }
    items
}

fn base_assembly_items(needs_gradients: bool) -> Vec<Item> {
    let mut items = Vec::new();
    items.extend(base_mesh_items());
    items.extend(base_state_items(needs_gradients));
    items.push(Item::Comment(
        "Group 2: Solver (block CSR values + RHS)".to_string(),
    ));
    items.push(storage_var(
        "matrix_values",
        Type::array(Type::F32),
        2,
        0,
        AccessMode::ReadWrite,
    ));
    items.push(storage_var(
        "rhs",
        Type::array(Type::F32),
        2,
        1,
        AccessMode::ReadWrite,
    ));
    items.push(storage_var(
        "scalar_row_offsets",
        Type::array(Type::U32),
        2,
        2,
        AccessMode::Read,
    ));
    items.push(Item::Comment(
        "Group 3: Boundary conditions (per boundary type Ã— unknown)".to_string(),
    ));
    items.push(storage_var(
        "bc_kind",
        Type::array(Type::U32),
        3,
        0,
        AccessMode::Read,
    ));
    items.push(storage_var(
        "bc_value",
        Type::array(Type::F32),
        3,
        1,
        AccessMode::Read,
    ));
    items
}

fn base_update_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Fields".to_string()));
    items.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        0,
        AccessMode::ReadWrite,
    ));
    items.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        1,
    ));
    items.push(Item::Comment("Group 1: Solution".to_string()));
    items.push(storage_var(
        "x",
        Type::array(Type::F32),
        1,
        0,
        AccessMode::Read,
    ));
    items
}

fn base_apply_items() -> Vec<Item> {
    vec![
        Item::Comment("Group 0: CSR matrix".to_string()),
        storage_var(
            "row_offsets",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "col_indices",
            Type::array(Type::U32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        Item::Comment("Group 1: vectors".to_string()),
        storage_var("x", Type::array(Type::F32), 1, 0, AccessMode::Read),
        storage_var("y", Type::array(Type::F32), 1, 1, AccessMode::ReadWrite),
    ]
}

fn coupled_unknown_components(
    system: &DiscreteSystem,
) -> Vec<(crate::solver::ir::FieldRef, u32)> {
    let mut out = Vec::new();
    for equation in &system.equations {
        let count = equation.target.kind().component_count() as u32;
        for component in 0..count {
            out.push((equation.target, component));
        }
    }
    out
}

fn coupled_offsets(system: &DiscreteSystem) -> HashMap<String, u32> {
    let mut offsets = HashMap::new();
    let mut current = 0u32;
    for equation in &system.equations {
        offsets.insert(equation.target.name().to_string(), current);
        current += equation.target.kind().component_count() as u32;
    }
    offsets
}

fn coefficient_value_expr(
    layout: &StateLayout,
    coeff: Option<&Coefficient>,
    idx_ident: &str,
    default: Expr,
) -> Expr {
    match coeff {
        None => default,
        Some(Coefficient::Constant { value, .. }) => (*value as f32).into(),
        Some(Coefficient::Field(field)) => {
            let name = field.name();
            if name == "rho" {
                Expr::ident("constants").field("density")
            } else if name == "mu" {
                Expr::ident("constants").field("viscosity")
            } else if layout.offset_for(name).is_some() {
                state_component(layout, "state", idx_ident, name, 0)
            } else {
                default
            }
        }
        Some(Coefficient::Product(lhs, rhs)) => {
            coefficient_value_expr(layout, Some(lhs), idx_ident, default.clone())
                * coefficient_value_expr(layout, Some(rhs), idx_ident, default)
        }
    }
}

fn main_assembly_fn(system: &DiscreteSystem, layout: &StateLayout) -> Function {
    let _stride = layout.stride();
    let unknowns = coupled_unknown_components(system);
    let coupled_stride = unknowns.len() as u32;
    let block_stride = coupled_stride * coupled_stride;
    let offsets = coupled_offsets(system);

    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let block_shape = typed::BlockShape::new(coupled_stride as u8, coupled_stride as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx") + 1u32)
            - Expr::ident("scalar_offset"),
    ));

    // start_row_i = scalar_offset * block_stride + num_neighbors * coupled_stride * i
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::ident("scalar_offset") * block_stride,
    ));
    for row in 1..coupled_stride {
        let name = format!("start_row_{row}");
        stmts.push(dsl::let_expr(
            &name,
            Expr::ident("start_row_0") + Expr::ident("num_neighbors") * coupled_stride * row,
        ));
    }

    // Clear all block entries for this cell's rows.
    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("rank", 0u32),
        Expr::ident("rank").lt(Expr::ident("num_neighbors")),
        dsl::for_step_increment_expr(Expr::ident("rank")),
        dsl::block(dsl::for_each_mat_entry_block(
            coupled_stride as usize,
            |r, c| {
                vec![dsl::assign_expr(
                    block_matrix
                        .entry(&Expr::ident("rank"), r as u8, c as u8)
                        .expr,
                    0.0,
                )]
            },
        )),
    ));

    // diag_i / rhs_i accumulators
    for i in 0..coupled_stride {
        let diag_name = format!("diag_{i}");
        stmts.push(dsl::var_typed_expr(&diag_name, Type::F32, Some(0.0.into())));
        let rhs_name = format!("rhs_{i}");
        stmts.push(dsl::var_typed_expr(&rhs_name, Type::F32, Some(0.0.into())));
    }

    // Time derivative contributions (implicit only).
    for equation in &system.equations {
        let Some(ddt_op) = equation.ops.iter().find(|op| {
            op.kind == DiscreteOpKind::TimeDerivative
                && op.discretization == Discretization::Implicit
        }) else {
            continue;
        };

        let base_offset = *offsets
            .get(equation.target.name())
            .expect("missing target offset");
        let rho_expr = coefficient_value_expr(layout, ddt_op.coeff.as_ref(), "idx", 1.0.into());
        let base_coeff = Expr::ident("vol") * rho_expr / Expr::ident("constants").field("dt");

        let dt = Expr::ident("constants").field("dt");
        let dt_old = Expr::ident("constants").field("dt_old");
        let time_scheme =
            typed::EnumExpr::<TimeScheme>::from_expr(Expr::ident("constants").field("time_scheme"));

        for component in 0..equation.target.kind().component_count() as u32 {
            let u_idx = base_offset + component;
            let phi_n = state_component(
                layout,
                "state_old",
                "idx",
                equation.target.name(),
                component,
            );
            let phi_nm1 = state_component(
                layout,
                "state_old_old",
                "idx",
                equation.target.name(),
                component,
            );

            // Default BDF1
            stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(format!("diag_{u_idx}")),
                base_coeff.clone(),
            ));
            stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(format!("rhs_{u_idx}")),
                base_coeff.clone() * phi_n.clone(),
            ));

            // Optional BDF2.
            stmts.push(dsl::if_block_expr(
                time_scheme.eq(TimeScheme::BDF2),
                dsl::block(vec![
                    dsl::let_expr("r", dt.clone() / dt_old.clone()),
                    dsl::let_expr(
                        "diag_bdf2",
                        base_coeff.clone() * (Expr::ident("r") * 2.0 + 1.0)
                            / (Expr::ident("r") + 1.0),
                    ),
                    dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
                    dsl::let_expr(
                        "factor_nm1",
                        (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
                    ),
                    dsl::assign_expr(
                        Expr::ident(format!("diag_{u_idx}")),
                        Expr::ident(format!("diag_{u_idx}")) - base_coeff.clone()
                            + Expr::ident("diag_bdf2"),
                    ),
                    dsl::assign_expr(
                        Expr::ident(format!("rhs_{u_idx}")),
                        Expr::ident(format!("rhs_{u_idx}")) - base_coeff.clone() * phi_n.clone()
                            + base_coeff.clone()
                                * (Expr::ident("factor_n") * phi_n
                                    - Expr::ident("factor_nm1") * phi_nm1),
                    ),
                ]),
                None,
            ));
        }
    }

    // Face loop for diffusion contributions (implicit only).
    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neighbor_raw",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "boundary_type",
            dsl::array_access("face_boundary", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "f_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::var_typed_expr(
            "normal",
            Type::Custom("Vector2".to_string()),
            Some(dsl::array_access("face_normals", Expr::ident("face_idx"))),
        ));
        body.push(dsl::var_typed_expr(
            "is_boundary",
            Type::Bool,
            Some(false.into()),
        ));
        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center",
            Type::Custom("Vector2".to_string()),
            None,
        ));

        // Make normal outward from `idx`.
        body.push(dsl::if_block_expr(
            Expr::ident("owner").ne(Expr::ident("idx")),
            dsl::block(vec![
                dsl::assign_expr(
                    Expr::ident("normal").field("x"),
                    -Expr::ident("normal").field("x"),
                ),
                dsl::assign_expr(
                    Expr::ident("normal").field("y"),
                    -Expr::ident("normal").field("y"),
                ),
            ]),
            None,
        ));

        let interior_block = dsl::block(vec![
            dsl::let_expr(
                "neighbor",
                Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
            ),
            dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
            dsl::if_block_expr(
                Expr::ident("owner").ne(Expr::ident("idx")),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("other_idx"),
                    Expr::ident("owner"),
                )]),
                None,
            ),
            dsl::assign_expr(
                Expr::ident("other_center"),
                dsl::array_access("cell_centers", Expr::ident("other_idx")),
            ),
        ]);

        let boundary_block = dsl::block(vec![
            dsl::assign_expr(Expr::ident("is_boundary"), true),
            dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("idx")),
            dsl::assign_expr(Expr::ident("other_center"), Expr::ident("f_center")),
        ]);

        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            interior_block,
            Some(boundary_block),
        ));

        body.push(dsl::let_expr(
            "dx",
            Expr::ident("other_center").field("x") - Expr::ident("center").field("x"),
        ));
        body.push(dsl::let_expr(
            "dy",
            Expr::ident("other_center").field("y") - Expr::ident("center").field("y"),
        ));
        body.push(dsl::let_expr(
            "dist_proj",
            dsl::abs(
                Expr::ident("dx") * Expr::ident("normal").field("x")
                    + Expr::ident("dy") * Expr::ident("normal").field("y"),
            ),
        ));
        body.push(dsl::let_expr(
            "dist_euc",
            dsl::sqrt(
                Expr::ident("dx") * Expr::ident("dx") + Expr::ident("dy") * Expr::ident("dy"),
            ),
        ));
        body.push(dsl::var_typed_expr(
            "dist",
            Type::F32,
            Some(dsl::max("dist_euc", 1e-6)),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("dist_proj").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("dist"),
                Expr::ident("dist_proj"),
            )]),
            None,
        ));

        body.push(dsl::let_expr(
            "scalar_mat_idx",
            dsl::array_access("cell_face_matrix_indices", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ));

        // Diffusion contributions per equation.
        for equation in &system.equations {
            let Some(diff_op) = equation.ops.iter().find(|op| {
                op.kind == DiscreteOpKind::Diffusion
                    && op.discretization == Discretization::Implicit
            }) else {
                continue;
            };

            let base_offset = *offsets
                .get(equation.target.name())
                .expect("missing target offset");

            let kappa = coefficient_value_expr(layout, diff_op.coeff.as_ref(), "idx", 1.0.into());

            let diff_coeff_name = format!("diff_coeff_{}", equation.target.name());
            body.push(dsl::let_expr(
                &diff_coeff_name,
                kappa.clone() * Expr::ident("area") / Expr::ident("dist"),
            ));

            for component in 0..equation.target.kind().component_count() as u32 {
                let u_idx = base_offset + component;
                let bc_table_idx = Expr::ident("boundary_type") * coupled_stride + u_idx;
                let bc_kind_expr = typed::EnumExpr::<GpuBcKind>::from_expr(dsl::array_access(
                    "bc_kind",
                    bc_table_idx,
                ));
                let bc_value_expr = dsl::array_access("bc_value", bc_table_idx);

                let interior_contrib = dsl::block(vec![
                    dsl::assign_op_expr(
                        AssignOp::Add,
                        Expr::ident(format!("diag_{u_idx}")),
                        Expr::ident(&diff_coeff_name),
                    ),
                    dsl::assign_op_expr(
                        AssignOp::Sub,
                        block_matrix
                            .entry(&Expr::ident("neighbor_rank"), u_idx as u8, u_idx as u8)
                            .expr,
                        Expr::ident(&diff_coeff_name),
                    ),
                ]);

                let neumann_rhs = -(kappa.clone() * Expr::ident("area") * bc_value_expr.clone());
                let boundary_contrib = dsl::block(vec![dsl::if_block_expr(
                    bc_kind_expr.eq(GpuBcKind::Dirichlet),
                    dsl::block(vec![
                        dsl::assign_op_expr(
                            AssignOp::Add,
                            Expr::ident(format!("diag_{u_idx}")),
                            Expr::ident(&diff_coeff_name),
                        ),
                        dsl::assign_op_expr(
                            AssignOp::Add,
                            Expr::ident(format!("rhs_{u_idx}")),
                            Expr::ident(&diff_coeff_name) * bc_value_expr.clone(),
                        ),
                    ]),
                    Some(dsl::block(vec![dsl::if_block_expr(
                        bc_kind_expr.eq(GpuBcKind::Neumann),
                        dsl::block(vec![dsl::assign_op_expr(
                            AssignOp::Add,
                            Expr::ident(format!("rhs_{u_idx}")),
                            neumann_rhs,
                        )]),
                        None,
                    )])),
                )]);

                body.push(dsl::if_block_expr(
                    !Expr::ident("is_boundary"),
                    interior_contrib,
                    Some(boundary_contrib),
                ));
            }
        }

        body
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(face_loop_body),
    ));

    // Write diagonal block and RHS.
    stmts.push(dsl::let_expr(
        "diag_rank",
        dsl::array_access("diagonal_indices", Expr::ident("idx")) - Expr::ident("scalar_offset"),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    for i in 0..coupled_stride {
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            diag_entry.entry(i as u8, i as u8).expr,
            Expr::ident(format!("diag_{i}")),
        ));
        stmts.push(dsl::assign_expr(
            dsl::array_access_linear("rhs", Expr::ident("idx"), coupled_stride, i),
            Expr::ident(format!("rhs_{i}")),
        ));
    }

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}

fn resolve_state_offset(layout: &StateLayout, name: &str) -> Option<u32> {
    if let Some(offset) = layout.offset_for(name) {
        return Some(offset);
    }
    let (base, component) = name.rsplit_once('_')?;
    let component = match component {
        "x" => 0,
        "y" => 1,
        "z" => 2,
        _ => return None,
    };
    layout.component_offset(base, component)
}

fn main_update_fn(system: &DiscreteSystem, layout: &StateLayout, primitives: &[(String, PrimitiveExpr)]) -> Function {
    let stride = layout.stride();
    let unknowns = coupled_unknown_components(system);
    let coupled_stride = unknowns.len() as u32;

    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()]) / stride,
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    for (u_idx, (field, component)) in unknowns.iter().enumerate() {
        let target = state_component(layout, "state", "idx", field.name(), *component);
        let value = dsl::array_access_linear("x", Expr::ident("idx"), coupled_stride, u_idx as u32);
        stmts.push(dsl::assign_expr(target, value));
    }

     // Optional primitive recovery (derived primitives from conserved state).
     //
     // This is intentionally emitted inside the model-specific update kernel to avoid
     // additional per-model registry plumbing.
     if !primitives.is_empty() {
         let cell_idx = Expr::ident("idx");
         for (name, expr) in primitives {
             let Some(offset) = resolve_state_offset(layout, name) else {
                 continue;
             };
            let value = lower_primitive_expr(expr, layout, cell_idx.clone(), "state");
            let target = dsl::array_access_linear("state", Expr::ident("idx"), stride, offset);
            stmts.push(dsl::assign_expr(target, value));
         }
     }

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}

fn main_apply_fn() -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr("row", Expr::ident("global_id").field("x")));
    stmts.push(dsl::let_expr(
        "n",
        Expr::call_named("arrayLength", vec![Expr::ident("row_offsets").addr_of()]) - 1u32,
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("row").ge(Expr::ident("n")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("row_offsets", Expr::ident("row")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("row_offsets", Expr::ident("row") + 1u32),
    ));
    stmts.push(dsl::var_typed_expr("sum", Type::F32, Some(0.0.into())));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(vec![
            dsl::let_expr("col", dsl::array_access("col_indices", Expr::ident("k"))),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum"),
                dsl::array_access("matrix_values", Expr::ident("k"))
                    * dsl::array_access("x", Expr::ident("col")),
            ),
        ]),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access("y", Expr::ident("row")),
        Expr::ident("sum"),
    ));

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}
