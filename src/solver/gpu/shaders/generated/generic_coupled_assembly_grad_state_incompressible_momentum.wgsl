// GENERATED BY CFD2 CODEGEN (unified_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<uniform> constants: Constants;

@group(1) @binding(4) 
var<storage, read> grad_state: array<Vector2>;

@group(1) @binding(5) 
var<storage, read_write> fluxes: array<f32>;

// Group 2: Solver (block CSR values + RHS)

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

// Group 3: Boundary conditions (per face x unknown)

@group(3) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(3) @binding(1) 
var<storage, read> bc_value: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let scalar_offset = scalar_row_offsets[idx];
    let diag_rank = diagonal_indices[idx] - scalar_offset;
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = scalar_offset * 9u;
    let start_row_1 = start_row_0 + num_neighbors * 3u * 1u;
    let start_row_2 = start_row_0 + num_neighbors * 3u * 2u;
    for (var rank = 0u; rank < num_neighbors; rank++) {
        matrix_values[start_row_0 + rank * 3u + 0u] = 0.0;
        matrix_values[start_row_0 + rank * 3u + 1u] = 0.0;
        matrix_values[start_row_0 + rank * 3u + 2u] = 0.0;
        matrix_values[start_row_1 + rank * 3u + 0u] = 0.0;
        matrix_values[start_row_1 + rank * 3u + 1u] = 0.0;
        matrix_values[start_row_1 + rank * 3u + 2u] = 0.0;
        matrix_values[start_row_2 + rank * 3u + 0u] = 0.0;
        matrix_values[start_row_2 + rank * 3u + 1u] = 0.0;
        matrix_values[start_row_2 + rank * 3u + 2u] = 0.0;
    }
    var diag_0: f32 = 0.0;
    var rhs_0: f32 = 0.0;
    var diag_1: f32 = 0.0;
    var rhs_1: f32 = 0.0;
    var diag_2: f32 = 0.0;
    var rhs_2: f32 = 0.0;
    diag_0 += vol * constants.density / constants.dt;
    rhs_0 += vol * constants.density / constants.dt * state_old[idx * 8u + 0u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * constants.density / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_0 = diag_0 - vol * constants.density / constants.dt + diag_bdf2;
        rhs_0 = rhs_0 - vol * constants.density / constants.dt * state_old[idx * 8u + 0u] + vol * constants.density / constants.dt * (factor_n * state_old[idx * 8u + 0u] - factor_nm1 * state_old_old[idx * 8u + 0u]);
    }
    diag_1 += vol * constants.density / constants.dt;
    rhs_1 += vol * constants.density / constants.dt * state_old[idx * 8u + 1u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * constants.density / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_1 = diag_1 - vol * constants.density / constants.dt + diag_bdf2;
        rhs_1 = rhs_1 - vol * constants.density / constants.dt * state_old[idx * 8u + 1u] + vol * constants.density / constants.dt * (factor_n * state_old[idx * 8u + 1u] - factor_nm1 * state_old_old[idx * 8u + 1u]);
    }
    for (var k = start; k < end; k++) {
        let face_idx = cell_faces[k];
        let owner = face_owner[face_idx];
        let neighbor_raw = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        let f_center = face_centers[face_idx];
        var normal: Vector2 = face_normals[face_idx];
        var is_boundary: bool = false;
        var other_idx: u32 = idx;
        var other_center: Vector2;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        if (neighbor_raw != -1) {
            let neighbor = u32(neighbor_raw);
            other_idx = neighbor;
            if (owner != idx) {
                other_idx = owner;
            }
            other_center = cell_centers[other_idx];
        } else {
            is_boundary = true;
            other_idx = idx;
            other_center = f_center;
        }
        let dx = other_center.x - center.x;
        let dy = other_center.y - center.y;
        let dist_proj = abs(dx * normal.x + dy * normal.y);
        let dist_euc = sqrt(dx * dx + dy * dy);
        var dist: f32 = max(dist_euc, 0.000001);
        if (dist_proj > 0.000001) {
            dist = dist_proj;
        }
        let scalar_mat_idx = cell_face_matrix_indices[k];
        let neighbor_rank = scalar_mat_idx - scalar_offset;
        let diff_coeff_U = constants.viscosity * area / dist;
        if (!is_boundary) {
            diag_0 += diff_coeff_U;
            matrix_values[start_row_0 + neighbor_rank * 3u + 0u] -= diff_coeff_U;
        } else {
            if (bc_kind[face_idx * 3u + 0u] == 1u) {
                diag_0 += diff_coeff_U;
                rhs_0 += diff_coeff_U * bc_value[face_idx * 3u + 0u];
            } else {
                if (bc_kind[face_idx * 3u + 0u] == 2u) {
                    rhs_0 += -(constants.viscosity * area * bc_value[face_idx * 3u + 0u]);
                }
            }
        }
        if (!is_boundary) {
            diag_1 += diff_coeff_U;
            matrix_values[start_row_1 + neighbor_rank * 3u + 1u] -= diff_coeff_U;
        } else {
            if (bc_kind[face_idx * 3u + 1u] == 1u) {
                diag_1 += diff_coeff_U;
                rhs_1 += diff_coeff_U * bc_value[face_idx * 3u + 1u];
            } else {
                if (bc_kind[face_idx * 3u + 1u] == 2u) {
                    rhs_1 += -(constants.viscosity * area * bc_value[face_idx * 3u + 1u]);
                }
            }
        }
        var phi_0: f32 = fluxes[face_idx * 3u + 0u];
        if (owner != idx) {
            phi_0 -= phi_0 * 2.0;
        }
        if (!is_boundary) {
            diag_0 += max(phi_0, 0.0);
            matrix_values[start_row_0 + neighbor_rank * 3u + 0u] += min(phi_0, 0.0);
            rhs_0 -= phi_0 * (select(select(select(select(select(select(select(state[idx * 8u + 0u], state[other_idx * 8u + 0u], phi_0 < 0.0), select(state[other_idx * 8u + 0u] + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), state[idx * 8u + 0u] + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), phi_0 > 0.0), constants.scheme == 1u), select(state[other_idx * 8u + 0u] + state[other_idx * 8u + 0u] * 0.625 + state[idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 0u], state[idx * 8u + 0u] + state[idx * 8u + 0u] * 0.625 + state[other_idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 0u], phi_0 > 0.0), constants.scheme == 2u), select(state[other_idx * 8u + 0u] + min(max(dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), min(state[idx * 8u + 0u] - state[other_idx * 8u + 0u], 0.0)), max(state[idx * 8u + 0u] - state[other_idx * 8u + 0u], 0.0)), state[idx * 8u + 0u] + min(max(dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), min(state[other_idx * 8u + 0u] - state[idx * 8u + 0u], 0.0)), max(state[other_idx * 8u + 0u] - state[idx * 8u + 0u], 0.0)), phi_0 > 0.0), constants.scheme == 3u), select(state[other_idx * 8u + 0u] + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)) * abs(state[idx * 8u + 0u] - state[other_idx * 8u + 0u]) / max(abs(state[idx * 8u + 0u] - state[other_idx * 8u + 0u]), abs(dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y))) + 0.00000001) * max((state[idx * 8u + 0u] - state[other_idx * 8u + 0u]) * dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), 0.0) / max(abs((state[idx * 8u + 0u] - state[other_idx * 8u + 0u]) * dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y))), 0.00000001), state[idx * 8u + 0u] + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)) * abs(state[other_idx * 8u + 0u] - state[idx * 8u + 0u]) / max(abs(state[other_idx * 8u + 0u] - state[idx * 8u + 0u]), abs(dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) + 0.00000001) * max((state[other_idx * 8u + 0u] - state[idx * 8u + 0u]) * dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), 0.0) / max(abs((state[other_idx * 8u + 0u] - state[idx * 8u + 0u]) * dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), 0.00000001), phi_0 > 0.0), constants.scheme == 4u), select(state[other_idx * 8u + 0u] + min(max(state[other_idx * 8u + 0u] * 0.625 + state[idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 0u], min(state[idx * 8u + 0u] - state[other_idx * 8u + 0u], 0.0)), max(state[idx * 8u + 0u] - state[other_idx * 8u + 0u], 0.0)), state[idx * 8u + 0u] + min(max(state[idx * 8u + 0u] * 0.625 + state[other_idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 0u], min(state[other_idx * 8u + 0u] - state[idx * 8u + 0u], 0.0)), max(state[other_idx * 8u + 0u] - state[idx * 8u + 0u], 0.0)), phi_0 > 0.0), constants.scheme == 5u), select(state[other_idx * 8u + 0u] + (state[other_idx * 8u + 0u] * 0.625 + state[idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 0u]) * abs(state[idx * 8u + 0u] - state[other_idx * 8u + 0u]) / max(abs(state[idx * 8u + 0u] - state[other_idx * 8u + 0u]), abs(state[other_idx * 8u + 0u] * 0.625 + state[idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 0u]) + 0.00000001) * max((state[idx * 8u + 0u] - state[other_idx * 8u + 0u]) * (state[other_idx * 8u + 0u] * 0.625 + state[idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 0u]), 0.0) / max(abs((state[idx * 8u + 0u] - state[other_idx * 8u + 0u]) * (state[other_idx * 8u + 0u] * 0.625 + state[idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 0u].x, grad_state[other_idx * 8u + 0u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 0u])), 0.00000001), state[idx * 8u + 0u] + (state[idx * 8u + 0u] * 0.625 + state[other_idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 0u]) * abs(state[other_idx * 8u + 0u] - state[idx * 8u + 0u]) / max(abs(state[other_idx * 8u + 0u] - state[idx * 8u + 0u]), abs(state[idx * 8u + 0u] * 0.625 + state[other_idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 0u]) + 0.00000001) * max((state[other_idx * 8u + 0u] - state[idx * 8u + 0u]) * (state[idx * 8u + 0u] * 0.625 + state[other_idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 0u]), 0.0) / max(abs((state[other_idx * 8u + 0u] - state[idx * 8u + 0u]) * (state[idx * 8u + 0u] * 0.625 + state[other_idx * 8u + 0u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 0u].x, grad_state[idx * 8u + 0u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 0u])), 0.00000001), phi_0 > 0.0), constants.scheme == 6u) - select(state[idx * 8u + 0u], state[other_idx * 8u + 0u], phi_0 < 0.0));
        } else {
            if (bc_kind[face_idx * 3u + 0u] == 1u) {
                diag_0 += max(phi_0, 0.0);
                rhs_0 -= min(phi_0, 0.0) * bc_value[face_idx * 3u + 0u];
            } else {
                diag_0 += phi_0;
            }
        }
        var phi_1: f32 = fluxes[face_idx * 3u + 1u];
        if (owner != idx) {
            phi_1 -= phi_1 * 2.0;
        }
        if (!is_boundary) {
            diag_1 += max(phi_1, 0.0);
            matrix_values[start_row_1 + neighbor_rank * 3u + 1u] += min(phi_1, 0.0);
            rhs_1 -= phi_1 * (select(select(select(select(select(select(select(state[idx * 8u + 1u], state[other_idx * 8u + 1u], phi_1 < 0.0), select(state[other_idx * 8u + 1u] + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), state[idx * 8u + 1u] + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), phi_1 > 0.0), constants.scheme == 1u), select(state[other_idx * 8u + 1u] + state[other_idx * 8u + 1u] * 0.625 + state[idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 1u], state[idx * 8u + 1u] + state[idx * 8u + 1u] * 0.625 + state[other_idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 1u], phi_1 > 0.0), constants.scheme == 2u), select(state[other_idx * 8u + 1u] + min(max(dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), min(state[idx * 8u + 1u] - state[other_idx * 8u + 1u], 0.0)), max(state[idx * 8u + 1u] - state[other_idx * 8u + 1u], 0.0)), state[idx * 8u + 1u] + min(max(dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), min(state[other_idx * 8u + 1u] - state[idx * 8u + 1u], 0.0)), max(state[other_idx * 8u + 1u] - state[idx * 8u + 1u], 0.0)), phi_1 > 0.0), constants.scheme == 3u), select(state[other_idx * 8u + 1u] + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)) * abs(state[idx * 8u + 1u] - state[other_idx * 8u + 1u]) / max(abs(state[idx * 8u + 1u] - state[other_idx * 8u + 1u]), abs(dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y))) + 0.00000001) * max((state[idx * 8u + 1u] - state[other_idx * 8u + 1u]) * dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), 0.0) / max(abs((state[idx * 8u + 1u] - state[other_idx * 8u + 1u]) * dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y))), 0.00000001), state[idx * 8u + 1u] + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)) * abs(state[other_idx * 8u + 1u] - state[idx * 8u + 1u]) / max(abs(state[other_idx * 8u + 1u] - state[idx * 8u + 1u]), abs(dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) + 0.00000001) * max((state[other_idx * 8u + 1u] - state[idx * 8u + 1u]) * dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), 0.0) / max(abs((state[other_idx * 8u + 1u] - state[idx * 8u + 1u]) * dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), 0.00000001), phi_1 > 0.0), constants.scheme == 4u), select(state[other_idx * 8u + 1u] + min(max(state[other_idx * 8u + 1u] * 0.625 + state[idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 1u], min(state[idx * 8u + 1u] - state[other_idx * 8u + 1u], 0.0)), max(state[idx * 8u + 1u] - state[other_idx * 8u + 1u], 0.0)), state[idx * 8u + 1u] + min(max(state[idx * 8u + 1u] * 0.625 + state[other_idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 1u], min(state[other_idx * 8u + 1u] - state[idx * 8u + 1u], 0.0)), max(state[other_idx * 8u + 1u] - state[idx * 8u + 1u], 0.0)), phi_1 > 0.0), constants.scheme == 5u), select(state[other_idx * 8u + 1u] + (state[other_idx * 8u + 1u] * 0.625 + state[idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 1u]) * abs(state[idx * 8u + 1u] - state[other_idx * 8u + 1u]) / max(abs(state[idx * 8u + 1u] - state[other_idx * 8u + 1u]), abs(state[other_idx * 8u + 1u] * 0.625 + state[idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 1u]) + 0.00000001) * max((state[idx * 8u + 1u] - state[other_idx * 8u + 1u]) * (state[other_idx * 8u + 1u] * 0.625 + state[idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 1u]), 0.0) / max(abs((state[idx * 8u + 1u] - state[other_idx * 8u + 1u]) * (state[other_idx * 8u + 1u] * 0.625 + state[idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[other_idx * 8u + 1u].x, grad_state[other_idx * 8u + 1u].y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125 - state[other_idx * 8u + 1u])), 0.00000001), state[idx * 8u + 1u] + (state[idx * 8u + 1u] * 0.625 + state[other_idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 1u]) * abs(state[other_idx * 8u + 1u] - state[idx * 8u + 1u]) / max(abs(state[other_idx * 8u + 1u] - state[idx * 8u + 1u]), abs(state[idx * 8u + 1u] * 0.625 + state[other_idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 1u]) + 0.00000001) * max((state[other_idx * 8u + 1u] - state[idx * 8u + 1u]) * (state[idx * 8u + 1u] * 0.625 + state[other_idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 1u]), 0.0) / max(abs((state[other_idx * 8u + 1u] - state[idx * 8u + 1u]) * (state[idx * 8u + 1u] * 0.625 + state[other_idx * 8u + 1u] * 0.375 + dot(vec2<f32>(grad_state[idx * 8u + 1u].x, grad_state[idx * 8u + 1u].y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125 - state[idx * 8u + 1u])), 0.00000001), phi_1 > 0.0), constants.scheme == 6u) - select(state[idx * 8u + 1u], state[other_idx * 8u + 1u], phi_1 < 0.0));
        } else {
            if (bc_kind[face_idx * 3u + 1u] == 1u) {
                diag_1 += max(phi_1, 0.0);
                rhs_1 -= min(phi_1, 0.0) * bc_value[face_idx * 3u + 1u];
            } else {
                diag_1 += phi_1;
            }
        }
        matrix_values[start_row_0 + diag_rank * 3u + 2u] += 1.0 * 0.5 * area * normal.x;
        matrix_values[start_row_0 + neighbor_rank * 3u + 2u] += 1.0 * 0.5 * area * normal.x;
        matrix_values[start_row_1 + diag_rank * 3u + 2u] += 1.0 * 0.5 * area * normal.y;
        matrix_values[start_row_1 + neighbor_rank * 3u + 2u] += 1.0 * 0.5 * area * normal.y;
        let diff_coeff_p = constants.density * state[idx * 8u + 3u] * area / dist;
        if (!is_boundary) {
            diag_2 += diff_coeff_p;
            matrix_values[start_row_2 + neighbor_rank * 3u + 2u] -= diff_coeff_p;
        } else {
            if (bc_kind[face_idx * 3u + 2u] == 1u) {
                diag_2 += diff_coeff_p;
                rhs_2 += diff_coeff_p * bc_value[face_idx * 3u + 2u];
            } else {
                if (bc_kind[face_idx * 3u + 2u] == 2u) {
                    rhs_2 += -(constants.density * state[idx * 8u + 3u] * area * bc_value[face_idx * 3u + 2u]);
                }
            }
        }
        var phi_2: f32 = fluxes[face_idx * 3u + 2u];
        if (owner != idx) {
            phi_2 -= phi_2 * 2.0;
        }
        rhs_2 -= phi_2;
    }
    matrix_values[start_row_0 + diag_rank * 3u + 0u] += diag_0;
    rhs[idx * 3u + 0u] = rhs_0;
    matrix_values[start_row_1 + diag_rank * 3u + 1u] += diag_1;
    rhs[idx * 3u + 1u] = rhs_1;
    matrix_values[start_row_2 + diag_rank * 3u + 2u] += diag_2;
    rhs[idx * 3u + 2u] = rhs_2;
}
