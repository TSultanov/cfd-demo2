// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: 55d6c8799d410505d92f25b14b70c8284f683b47c2c95724b9babc0751850a0c

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    AmgPack,
    BlockPrecond,
    DotProduct,
    DotProductPair,
    GeneratedDpInitIncompressibleMomentum,
    GeneratedDpUpdateFromDiagIncompressibleMomentum,
    GeneratedFluxModuleCompressible,
    GeneratedFluxModuleGradientsCompressible,
    GeneratedFluxModuleGradientsIncompressibleMomentum,
    GeneratedFluxModuleIncompressibleMomentum,
    GeneratedGenericCoupledApply,
    GeneratedGenericCoupledAssemblyCompressible,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateCompressible,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum,
    GeneratedGenericCoupledAssemblyIncompressibleMomentum,
    GeneratedGenericCoupledUpdateCompressible,
    GeneratedGenericCoupledUpdateGenericDiffusionDemo,
    GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledUpdateIncompressibleMomentum,
    GeneratedPackedStateGradientsCompressible,
    GeneratedPackedStateGradientsGenericDiffusionDemo,
    GeneratedPackedStateGradientsGenericDiffusionDemoNeumann,
    GeneratedPackedStateGradientsIncompressibleMomentum,
    GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum,
    GeneratedRhieChowGradPUpdateIncompressibleMomentum,
    GeneratedRhieChowStoreGradPIncompressibleMomentum,
    GenericCoupledSchurSetup,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    OuterConvergence,
    Scalars,
    SchurPrecond,
    SchurPrecondGeneric,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self { Self :: Amg => amg :: create_pipeline_layout (device) , Self :: AmgPack => amg_pack :: create_pipeline_layout (device) , Self :: BlockPrecond => block_precond :: create_pipeline_layout (device) , Self :: DotProduct => dot_product :: create_pipeline_layout (device) , Self :: DotProductPair => dot_product_pair :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentum => generated :: dp_init_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => generated :: dp_update_from_diag_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleCompressible => generated :: flux_module_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsCompressible => generated :: flux_module_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => generated :: flux_module_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentum => generated :: flux_module_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledApply => generated :: generic_coupled_apply :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyCompressible => generated :: generic_coupled_assembly_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => generated :: generic_coupled_assembly_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => generated :: generic_coupled_assembly_grad_state_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => generated :: generic_coupled_assembly_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateCompressible => generated :: generic_coupled_update_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => generated :: generic_coupled_update_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => generated :: generic_coupled_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsCompressible => generated :: packed_state_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => generated :: packed_state_gradients_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => generated :: packed_state_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum => generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowGradPUpdateIncompressibleMomentum => generated :: rhie_chow_grad_p_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowStoreGradPIncompressibleMomentum => generated :: rhie_chow_store_grad_p_incompressible_momentum :: create_pipeline_layout (device) , Self :: GenericCoupledSchurSetup => generic_coupled_schur_setup :: create_pipeline_layout (device) , Self :: GmresCgs => gmres_cgs :: create_pipeline_layout (device) , Self :: GmresLogic => gmres_logic :: create_pipeline_layout (device) , Self :: GmresOps => gmres_ops :: create_pipeline_layout (device) , Self :: LinearSolver => linear_solver :: create_pipeline_layout (device) , Self :: OuterConvergence => outer_convergence :: create_pipeline_layout (device) , Self :: Scalars => scalars :: create_pipeline_layout (device) , Self :: SchurPrecond => schur_precond :: create_pipeline_layout (device) , Self :: SchurPrecondGeneric => schur_precond_generic :: create_pipeline_layout (device) , }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self { Self :: Amg => { amg :: create_shader_module_embed_source (device) } , Self :: AmgPack => { amg_pack :: create_shader_module_embed_source (device) } , Self :: BlockPrecond => { block_precond :: create_shader_module_embed_source (device) } , Self :: DotProduct => { dot_product :: create_shader_module_embed_source (device) } , Self :: DotProductPair => { dot_product_pair :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentum => { generated :: dp_init_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => { generated :: dp_update_from_diag_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleCompressible => { generated :: flux_module_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsCompressible => { generated :: flux_module_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => { generated :: flux_module_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentum => { generated :: flux_module_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledApply => { generated :: generic_coupled_apply :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyCompressible => { generated :: generic_coupled_assembly_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => { generated :: generic_coupled_assembly_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => { generated :: generic_coupled_assembly_grad_state_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => { generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => { generated :: generic_coupled_assembly_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateCompressible => { generated :: generic_coupled_update_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => { generated :: generic_coupled_update_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => { generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => { generated :: generic_coupled_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsCompressible => { generated :: packed_state_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => { generated :: packed_state_gradients_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => { generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => { generated :: packed_state_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum => { generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowGradPUpdateIncompressibleMomentum => { generated :: rhie_chow_grad_p_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowStoreGradPIncompressibleMomentum => { generated :: rhie_chow_store_grad_p_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GenericCoupledSchurSetup => { generic_coupled_schur_setup :: create_shader_module_embed_source (device) } , Self :: GmresCgs => { gmres_cgs :: create_shader_module_embed_source (device) } , Self :: GmresLogic => { gmres_logic :: create_shader_module_embed_source (device) } , Self :: GmresOps => { gmres_ops :: create_shader_module_embed_source (device) } , Self :: LinearSolver => { linear_solver :: create_shader_module_embed_source (device) } , Self :: OuterConvergence => { outer_convergence :: create_shader_module_embed_source (device) } , Self :: Scalars => { scalars :: create_shader_module_embed_source (device) } , Self :: SchurPrecond => { schur_precond :: create_shader_module_embed_source (device) } , Self :: SchurPrecondGeneric => { schur_precond_generic :: create_shader_module_embed_source (device) } , }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const AMG_PACK_PACK_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg_pack::PackParams, num_cells) == 0);
        assert!(std::mem::offset_of!(amg_pack::PackParams, component) == 4);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad1) == 8);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad2) == 12);
        assert!(std::mem::size_of::<amg_pack::PackParams>() == 16);
    };
    const BLOCK_PRECOND_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(block_precond::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(block_precond::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<block_precond::GmresParams>() == 32);
    };
    const BLOCK_PRECOND_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(block_precond::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<block_precond::IterParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 16);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 16);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dtau) == 8
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, time) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(std::mem::size_of::<generated::dp_init_incompressible_momentum::Constants>() == 48);
    };
    const GENERATED_DP_UPDATE_FROM_DIAG_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::dp_update_from_diag_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_module_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_p) == 28
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gamma) == 48
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gm1) == 52
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_p_offset)
                == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::Constants>() == 72);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_LOW_MACH_PARAMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, model) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                theta_floor
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                pressure_coupling_alpha
            ) == 8
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, _pad0) == 12
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::LowMachParams>() == 16);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Vector2, y) == 4
        );
        assert!(std::mem::size_of::<generated::flux_module_gradients_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_compressible::Constants>() == 48
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Vector2>() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_APPLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, time_scheme) == 44
        );
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gamma) == 48);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gm1) == 52);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_p_offset) == 64
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_theta_ref) == 68
        );
        assert!(std::mem::size_of::<generated::generic_coupled_apply::Constants>() == 72);
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Vector2>() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Constants>()
                == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_grad_state_compressible::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , x) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , y) == 4) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 > () == 8) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_compressible::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Vector2>() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Constants>() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_RHIE_CHOW_CORRECT_VELOCITY_DELTA_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERATED_RHIE_CHOW_GRAD_P_UPDATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_RHIE_CHOW_GRAD_P_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERATED_RHIE_CHOW_STORE_GRAD_P_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::rhie_chow_store_grad_p_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERIC_COUPLED_SCHUR_SETUP_SETUP_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, num_cells) == 0);
        assert!(
            std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, unknowns_per_cell) == 4
        );
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, p) == 8);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u_len) == 12);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u0123) == 16);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u4567) == 32);
        assert!(std::mem::size_of::<generic_coupled_schur_setup::SetupParams>() == 48);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 24);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const OUTER_CONVERGENCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::Params, num_cells) == 0);
        assert!(std::mem::offset_of!(outer_convergence::Params, stride) == 4);
        assert!(std::mem::offset_of!(outer_convergence::Params, num_targets) == 8);
        assert!(std::mem::offset_of!(outer_convergence::Params, _pad0) == 12);
        assert!(std::mem::size_of::<outer_convergence::Params>() == 16);
    };
    const OUTER_CONVERGENCE_TARGET_DESC_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, offsets) == 0);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, num_comps) == 16);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, _pad0) == 20);
        assert!(std::mem::size_of::<outer_convergence::TargetDesc>() == 32);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 24);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, unknowns_per_cell) == 12);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u0) == 16);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u1) == 20);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, p) == 24);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, _pad0) == 28);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 32);
    };
    const SCHUR_PRECOND_GENERIC_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, omega) == 8);
        assert!(
            std::mem::offset_of!(schur_precond_generic::PrecondParams, unknowns_per_cell) == 12
        );
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, p) == 16);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u_len) == 20);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad0) == 24);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad1) == 28);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u0123) == 32);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u4567) == 48);
        assert!(std::mem::size_of::<schur_precond_generic::PrecondParams>() == 64);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.coarse_vec]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let stride_x = (num_workgroups.x * 64u);
    let i = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.n;
    if (i >= _e13) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e24 = k;
        if (_e24 < end) {
        } else {
            break;
        }
        {
            let _e27 = k;
            let col = col_indices[_e27];
            let _e31 = k;
            let val = values[_e31];
            if (col == i) {
                diag = val;
            } else {
                let _e39 = x[col];
                let _e41 = sigma;
                sigma = (_e41 + (val * _e39));
            }
        }
        continuing {
            let _e44 = k;
            k = (_e44 + 1u);
        }
    }
    let _e46 = diag;
    if (abs(_e46) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e53 = b[i];
    let _e54 = sigma;
    let _e56 = diag;
    let x_new = ((_e53 - _e54) / _e56);
    let _e62 = x[i];
    let _e65 = params.omega;
    x[i] = mix(_e62, x_new, _e65);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let i_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.n;
    if (i_1 >= _e12) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e23 = k_1;
        if (_e23 < end_1) {
        } else {
            break;
        }
        {
            let _e26 = k_1;
            let coarse_idx = op_col_indices[_e26];
            let _e30 = k_1;
            let val_1 = op_values[_e30];
            let _e36 = coarse_vec[coarse_idx];
            let _e38 = correction;
            correction = (_e38 + (val_1 * _e36));
        }
        continuing {
            let _e41 = k_1;
            k_1 = (_e41 + 1u);
        }
    }
    let _e45 = correction;
    let _e46 = x[i_1];
    x[i_1] = (_e46 + _e45);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let stride_x_2 = (num_workgroups_2.x * 64u);
    let i_2 = ((global_id_2.y * stride_x_2) + global_id_2.x);
    let _e12 = params.n;
    if (i_2 >= _e12) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e23 = k_2;
        if (_e23 < end_2) {
        } else {
            break;
        }
        {
            let _e26 = k_2;
            let fine_idx = op_col_indices[_e26];
            let _e30 = k_2;
            let r_val = op_values[_e30];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e44 = j;
                if (_e44 < a_end) {
                } else {
                    break;
                }
                {
                    let _e47 = j;
                    let _e49 = values[_e47];
                    let _e52 = j;
                    let _e54 = col_indices[_e52];
                    let _e56 = x[_e54];
                    let _e58 = ax;
                    ax = (_e58 + (_e49 * _e56));
                }
                continuing {
                    let _e61 = j;
                    j = (_e61 + 1u);
                }
            }
            let _e65 = b[fine_idx];
            let _e66 = ax;
            let fine_r = (_e65 - _e66);
            let _e70 = sum;
            sum = (_e70 + (r_val * fine_r));
        }
        continuing {
            let _e73 = k_2;
            k_2 = (_e73 + 1u);
        }
    }
    let _e77 = sum;
    coarse_vec[i_2] = _e77;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let stride_x_3 = (num_workgroups_3.x * 64u);
    let i_3 = ((global_id_3.y * stride_x_3) + global_id_3.x);
    let _e11 = params.n;
    if (i_3 >= _e11) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for amg_pack::PackParams {}
    unsafe impl bytemuck::Pod for amg_pack::PackParams {}
    unsafe impl bytemuck::Zeroable for block_precond::GmresParams {}
    unsafe impl bytemuck::Pod for block_precond::GmresParams {}
    unsafe impl bytemuck::Zeroable for block_precond::IterParams {}
    unsafe impl bytemuck::Pod for block_precond::IterParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::dp_update_from_diag_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::dp_update_from_diag_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_grad_state_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_store_grad_p_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::rhie_chow_store_grad_p_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Pod for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for outer_convergence::Params {}
    unsafe impl bytemuck::Pod for outer_convergence::Params {}
    unsafe impl bytemuck::Zeroable for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Pod for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Zeroable for schur_precond_generic::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond_generic::PrecondParams {}
}
pub mod amg_pack {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PackParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub component: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PackParams {
        pub const fn new(num_cells: u32, component: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                num_cells,
                component,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const PACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_pack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline pack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("pack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UNPACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_unpack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline unpack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("unpack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_PACK_COMPONENT: &str = "pack_component";
    pub const ENTRY_UNPACK_COMPONENT: &str = "unpack_component";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input_buf: wgpu::BufferBinding<'a>,
        pub output_buf: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input_buf: wgpu::BindGroupEntry<'a>,
        pub output_buf: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input_buf: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input_buf),
                },
                output_buf: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.output_buf),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.input_buf, self.output_buf]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"output_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg_pack::PackParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AmgPack::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg_pack.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PackParams {
    num_cells: u32,
    component: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> input_buf: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> output_buf: array<f32>;
@group(1) @binding(0) 
var<uniform> params: PackParams;

@compute @workgroup_size(64, 1, 1) 
fn pack_component(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let _e11 = params.num_cells;
    if (idx >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base = ((idx * 4u) + _e17);
    let _e23 = input_buf[base];
    output_buf[idx] = _e23;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn unpack_component(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let stride_x_1 = (num_workgroups_1.x * 64u);
    let idx_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e11 = params.num_cells;
    if (idx_1 >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base_1 = ((idx_1 * 4u) + _e17);
    let _e23 = input_buf[idx_1];
    output_buf[base_1] = _e23;
    return;
}
"#;
}
pub mod block_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const MAX_BLOCK: u32 = 16u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_BLOCK_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_block_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_block_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_block_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_BLOCK_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_block_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_block_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_block_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_BLOCK_INV: &str = "build_block_inv";
    pub const ENTRY_APPLY_BLOCK_PRECOND: &str = "apply_block_precond";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.block_inv]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("BlockPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("block_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const MAX_BLOCK: u32 = 16u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

fn swap_rows(a_1: ptr<function, array<array<f32, 16>, 16>>, b: ptr<function, array<array<f32, 16>, 16>>, r0_: u32, r1_: u32, n: u32) {
    var c_6: u32 = 0u;

    if (r0_ == r1_) {
        return;
    }
    loop {
        let _e6 = c_6;
        if (_e6 < n) {
        } else {
            break;
        }
        {
            let _e10 = c_6;
            let tmp = (*a_1)[r0_][_e10];
            let _e14 = c_6;
            let _e17 = c_6;
            let _e19 = (*a_1)[r1_][_e17];
            (*a_1)[r0_][_e14] = _e19;
            let _e21 = c_6;
            (*a_1)[r1_][_e21] = tmp;
            let _e25 = c_6;
            let tmp_b = (*b)[r0_][_e25];
            let _e29 = c_6;
            let _e32 = c_6;
            let _e34 = (*b)[r1_][_e32];
            (*b)[r0_][_e29] = _e34;
            let _e36 = c_6;
            (*b)[r1_][_e36] = tmp_b;
        }
        continuing {
            let _e38 = c_6;
            c_6 = (_e38 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn build_block_inv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var a: array<array<f32, 16>, 16>;
    var inv: array<array<f32, 16>, 16>;
    var diag_orig: array<f32, 16>;
    var r: u32 = 0u;
    var c: u32;
    var k: u32;
    var singular: bool = false;
    var i: u32 = 0u;
    var pivot: u32;
    var pivot_val: f32;
    var r_1: u32;
    var piv: f32;
    var c_1: u32;
    var r_2: u32;
    var c_2: u32;
    var r_3: u32 = 0u;
    var c_3: u32;
    var r_4: u32 = 0u;
    var c_4: u32;

    let stride_x = (num_workgroups.x * 64u);
    let cell = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.num_cells;
    if (cell >= _e13) {
        return;
    }
    let _e17 = params.num_cells;
    if (_e17 == 0u) {
        return;
    }
    let _e22 = params.n;
    let _e25 = params.num_cells;
    let b_1 = (_e22 / _e25);
    if ((b_1 == 0u) || (b_1 > MAX_BLOCK)) {
        return;
    }
    let base = (cell * b_1);
    loop {
        let _e34 = r;
        if (_e34 < b_1) {
        } else {
            break;
        }
        {
            c = 0u;
            loop {
                let _e38 = c;
                if (_e38 < b_1) {
                } else {
                    break;
                }
                {
                    let _e41 = r;
                    let _e43 = c;
                    a[_e41][_e43] = 0f;
                    let _e47 = r;
                    let _e49 = c;
                    inv[_e47][_e49] = 0f;
                }
                continuing {
                    let _e52 = c;
                    c = (_e52 + 1u);
                }
            }
            let _e55 = r;
            let row = (base + _e55);
            let start = row_offsets[row];
            let end = row_offsets[(row + 1u)];
            k = start;
            loop {
                let _e66 = k;
                if (_e66 < end) {
                } else {
                    break;
                }
                {
                    let _e69 = k;
                    let col = col_indices[_e69];
                    if ((col >= base) && (col < (base + b_1))) {
                        let local = (col - base);
                        let _e77 = r;
                        let _e81 = k;
                        let _e83 = matrix_values[_e81];
                        a[_e77][local] = _e83;
                    }
                }
                continuing {
                    let _e84 = k;
                    k = (_e84 + 1u);
                }
            }
            let _e87 = r;
            let _e89 = r;
            inv[_e87][_e89] = 1f;
            let _e93 = r;
            let _e95 = r;
            let _e97 = r;
            let _e99 = a[_e95][_e97];
            diag_orig[_e93] = _e99;
        }
        continuing {
            let _e100 = r;
            r = (_e100 + 1u);
        }
    }
    loop {
        let _e104 = i;
        if (_e104 < b_1) {
        } else {
            break;
        }
        {
            let _e106 = i;
            pivot = _e106;
            let _e108 = i;
            let _e110 = i;
            let _e112 = a[_e108][_e110];
            pivot_val = abs(_e112);
            let _e115 = i;
            r_1 = (_e115 + 1u);
            loop {
                let _e119 = r_1;
                if (_e119 < b_1) {
                } else {
                    break;
                }
                {
                    let _e121 = r_1;
                    let _e123 = i;
                    let _e125 = a[_e121][_e123];
                    let val_1 = abs(_e125);
                    let _e127 = pivot_val;
                    if (val_1 > _e127) {
                        pivot_val = val_1;
                        let _e129 = r_1;
                        pivot = _e129;
                    }
                }
                continuing {
                    let _e130 = r_1;
                    r_1 = (_e130 + 1u);
                }
            }
            let _e133 = pivot_val;
            if (_e133 < 0.000000000001f) {
                singular = true;
            }
            let _e138 = i;
            let _e139 = pivot;
            swap_rows((&a), (&inv), _e138, _e139, b_1);
            let _e140 = i;
            let _e142 = i;
            let _e144 = a[_e140][_e142];
            piv = _e144;
            let _e146 = piv;
            if (abs(_e146) < 0.000000000001f) {
                let _e150 = piv;
                piv = select(0.000000000001f, -0.000000000001f, (_e150 < 0f));
            }
            let _e156 = piv;
            let inv_piv = (1f / _e156);
            c_1 = 0u;
            loop {
                let _e161 = c_1;
                if (_e161 < b_1) {
                } else {
                    break;
                }
                {
                    let _e163 = i;
                    let _e165 = c_1;
                    let _e167 = i;
                    let _e169 = c_1;
                    let _e171 = a[_e167][_e169];
                    a[_e163][_e165] = (_e171 * inv_piv);
                    let _e173 = i;
                    let _e175 = c_1;
                    let _e177 = i;
                    let _e179 = c_1;
                    let _e181 = inv[_e177][_e179];
                    inv[_e173][_e175] = (_e181 * inv_piv);
                }
                continuing {
                    let _e183 = c_1;
                    c_1 = (_e183 + 1u);
                }
            }
            r_2 = 0u;
            loop {
                let _e188 = r_2;
                if (_e188 < b_1) {
                } else {
                    break;
                }
                {
                    let _e190 = r_2;
                    let _e191 = i;
                    if (_e190 == _e191) {
                        continue;
                    }
                    let _e193 = r_2;
                    let _e195 = i;
                    let factor = a[_e193][_e195];
                    c_2 = 0u;
                    loop {
                        let _e200 = c_2;
                        if (_e200 < b_1) {
                        } else {
                            break;
                        }
                        {
                            let _e202 = r_2;
                            let _e204 = c_2;
                            let _e206 = r_2;
                            let _e208 = c_2;
                            let _e210 = a[_e206][_e208];
                            let _e211 = i;
                            let _e213 = c_2;
                            let _e215 = a[_e211][_e213];
                            a[_e202][_e204] = (_e210 - (factor * _e215));
                            let _e218 = r_2;
                            let _e220 = c_2;
                            let _e222 = r_2;
                            let _e224 = c_2;
                            let _e226 = inv[_e222][_e224];
                            let _e227 = i;
                            let _e229 = c_2;
                            let _e231 = inv[_e227][_e229];
                            inv[_e218][_e220] = (_e226 - (factor * _e231));
                        }
                        continuing {
                            let _e234 = c_2;
                            c_2 = (_e234 + 1u);
                        }
                    }
                }
                continuing {
                    let _e237 = r_2;
                    r_2 = (_e237 + 1u);
                }
            }
        }
        continuing {
            let _e240 = i;
            i = (_e240 + 1u);
        }
    }
    let _e243 = singular;
    if _e243 {
        loop {
            let _e245 = r_3;
            if (_e245 < b_1) {
            } else {
                break;
            }
            {
                c_3 = 0u;
                loop {
                    let _e249 = c_3;
                    if (_e249 < b_1) {
                    } else {
                        break;
                    }
                    {
                        let _e251 = r_3;
                        let _e253 = c_3;
                        inv[_e251][_e253] = 0f;
                    }
                    continuing {
                        let _e256 = c_3;
                        c_3 = (_e256 + 1u);
                    }
                }
                let _e259 = r_3;
                let _e261 = r_3;
                let _e263 = r_3;
                let _e265 = diag_orig[_e263];
                let _e266 = safe_inverse(_e265);
                inv[_e259][_e261] = _e266;
            }
            continuing {
                let _e267 = r_3;
                r_3 = (_e267 + 1u);
            }
        }
    }
    let offset = (cell * (b_1 * b_1));
    loop {
        let _e273 = r_4;
        if (_e273 < b_1) {
        } else {
            break;
        }
        {
            c_4 = 0u;
            loop {
                let _e277 = c_4;
                if (_e277 < b_1) {
                } else {
                    break;
                }
                {
                    let _e280 = r_4;
                    let _e283 = c_4;
                    let _e286 = r_4;
                    let _e288 = c_4;
                    let _e290 = inv[_e286][_e288];
                    block_inv[((offset + (_e280 * b_1)) + _e283)] = _e290;
                }
                continuing {
                    let _e291 = c_4;
                    c_4 = (_e291 + 1u);
                }
            }
        }
        continuing {
            let _e294 = r_4;
            r_4 = (_e294 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_block_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var r_5: u32 = 0u;
    var sum: f32;
    var c_5: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let cell_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.num_cells;
    if (cell_1 >= _e12) {
        return;
    }
    let _e16 = params.num_cells;
    if (_e16 == 0u) {
        return;
    }
    let _e21 = params.n;
    let _e24 = params.num_cells;
    let b_2 = (_e21 / _e24);
    if ((b_2 == 0u) || (b_2 > MAX_BLOCK)) {
        return;
    }
    let base_1 = (cell_1 * b_2);
    let offset_1 = (cell_1 * (b_2 * b_2));
    loop {
        let _e35 = r_5;
        if (_e35 < b_2) {
        } else {
            break;
        }
        {
            sum = 0f;
            c_5 = 0u;
            loop {
                let _e41 = c_5;
                if (_e41 < b_2) {
                } else {
                    break;
                }
                {
                    let _e44 = r_5;
                    let _e47 = c_5;
                    let _e50 = block_inv[((offset_1 + (_e44 * b_2)) + _e47)];
                    let _e52 = c_5;
                    let _e55 = vec_x[(base_1 + _e52)];
                    let _e57 = sum;
                    sum = (_e57 + (_e50 * _e55));
                }
                continuing {
                    let _e59 = c_5;
                    c_5 = (_e59 + 1u);
                }
            }
            let _e63 = r_5;
            let _e66 = sum;
            vec_y[(base_1 + _e63)] = _e66;
        }
        continuing {
            let _e67 = r_5;
            r_5 = (_e67 + 1u);
        }
    }
    return;
}
"#;
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a[idx];
        let _e22 = dot_b[idx];
        val = (_e19 * _e22);
    }
    let _e27 = val;
    scratch[lid] = _e27;
    workgroupBarrier();
    loop {
        let _e29 = i;
        if (_e29 > 0u) {
        } else {
            break;
        }
        {
            let _e32 = i;
            if (lid < _e32) {
                let _e37 = i;
                let _e40 = scratch[(lid + _e37)];
                let _e41 = scratch[lid];
                scratch[lid] = (_e41 + _e40);
            }
            workgroupBarrier();
        }
        continuing {
            let _e44 = i;
            i = (_e44 >> 1u);
        }
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e56 = params.num_groups;
        if (group_flat < _e56) {
            let _e62 = scratch[0];
            dot_result[group_flat] = _e62;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a0_[idx];
        let _e22 = dot_b0_[idx];
        val0_ = (_e19 * _e22);
        let _e27 = dot_a1_[idx];
        let _e30 = dot_b1_[idx];
        val1_ = (_e27 * _e30);
    }
    let _e35 = val0_;
    scratch_a[lid] = _e35;
    let _e38 = val1_;
    scratch_b[lid] = _e38;
    workgroupBarrier();
    loop {
        let _e40 = offset;
        if (lid < _e40) {
            let _e45 = offset;
            let _e48 = scratch_a[(lid + _e45)];
            let _e49 = scratch_a[lid];
            scratch_a[lid] = (_e49 + _e48);
            let _e54 = offset;
            let _e57 = scratch_b[(lid + _e54)];
            let _e58 = scratch_b[lid];
            scratch_b[lid] = (_e58 + _e57);
        }
        workgroupBarrier();
        let _e60 = offset;
        if (_e60 == 1u) {
            break;
        }
        let _e63 = offset;
        offset = (_e63 >> 1u);
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e76 = params.num_groups;
        if (group_flat < _e76) {
            let _e82 = scratch_a[0];
            dot_result_a[group_flat] = _e82;
            let _e87 = scratch_b[0];
            dot_result_b[group_flat] = _e87;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod dp_init_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedDpInitIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::dp_init_incompressible_momentum::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = cell_vols[idx];
    let vol = max(_e25, 0.000000000001f);
    let _e30 = constants.alpha_u;
    let d_p = ((_e30 * dt) / rho);
    state[((idx * 8u) + 3u)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: dp_update_from_diag_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = constants.alpha_u;
    let d_p = ((_e25 * dt) / rho);
    state[((idx * 8u) + 3u)] = d_p;
    return;
}
"#;
    }
    pub mod flux_module_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct LowMachParams {
            #[doc = "offset: 0, size: 4, type: `u32`"]
            pub model: u32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub theta_floor: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub pressure_coupling_alpha: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub _pad0: f32,
        }
        impl LowMachParams {
            pub const fn new(
                model: u32,
                theta_floor: f32,
                pressure_coupling_alpha: f32,
                _pad0: f32,
            ) -> Self {
                Self {
                    model,
                    theta_floor,
                    pressure_coupling_alpha,
                    _pad0,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub low_mach_params: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub low_mach_params: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    low_mach_params: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.low_mach_params),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.low_mach_params,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"low_mach_params\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::LowMachParams,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0_: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var a_plus: f32;
    var a_minus: f32;
    var u_l_0_: f32;
    var u_r_0_: f32;
    var f_l_0_: f32;
    var f_r_0_: f32;
    var u_l_1_: f32;
    var u_r_1_: f32;
    var f_l_1_: f32;
    var f_r_1_: f32;
    var u_l_2_: f32;
    var u_r_2_: f32;
    var f_l_2_: f32;
    var f_r_2_: f32;
    var u_l_3_: f32;
    var u_r_3_: f32;
    var f_l_3_: f32;
    var f_r_3_: f32;
    var u_l_4_: f32 = 0f;
    var u_r_4_: f32 = 0f;
    var f_l_4_: f32 = 0f;
    var f_r_4_: f32 = 0f;
    var u_l_5_: f32 = 0f;
    var u_r_5_: f32 = 0f;
    var f_l_5_: f32 = 0f;
    var f_r_5_: f32 = 0f;
    var u_l_6_: f32 = 0f;
    var u_r_6_: f32 = 0f;
    var f_l_6_: f32 = 0f;
    var f_r_6_: f32 = 0f;
    var u_l_7_: f32 = 0f;
    var u_r_7_: f32 = 0f;
    var f_l_7_: f32 = 0f;
    var f_r_7_: f32 = 0f;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e37 = face_normals[idx].x;
    let _e41 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e37, _e41);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e54 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e54) < 0f) {
        let _e58 = normal_vec;
        normal_vec = -(_e58);
    }
    let _e61 = neigh_idx;
    let c_neigh = cell_centers[_e61];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let _e70 = normal_vec;
    let d_own_1 = abs(dot((face_center_vec - c_owner_vec), _e70));
    let _e73 = c_neigh_vec;
    let _e75 = normal_vec;
    let d_neigh = abs(dot((_e73 - face_center_vec), _e75));
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e83 = lambda;
    let lambda_other = (1f - _e83);
    let _e86 = c_neigh_vec;
    let d_vec = (_e86 - c_owner_vec);
    let _e88 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e88));
    let dist = max(dist_proj, 0.000001f);
    let _e99 = state[((owner_1 * 22u) + 9u)];
    let _e106 = state[((owner_1 * 22u) + 9u)];
    let _e113 = bc_kind[((idx * 8u) + 7u)];
    let _e120 = bc_value[((idx * 8u) + 7u)];
    let _e121 = bc_neighbor_scalar(_e99, _e106, _e113, _e120, d_own_1, is_boundary_1);
    let s_own_grad_T_x = state[((owner_1 * 22u) + 16u)];
    let s_own_grad_T_y = state[((owner_1 * 22u) + 17u)];
    let s_own_grad_rho_x = state[((owner_1 * 22u) + 12u)];
    let s_own_grad_rho_y = state[((owner_1 * 22u) + 13u)];
    let s_own_grad_rho_u_x_x = state[((owner_1 * 22u) + 3u)];
    let s_own_grad_rho_u_x_y = state[((owner_1 * 22u) + 4u)];
    let s_own_grad_rho_u_y_x = state[((owner_1 * 22u) + 5u)];
    let s_own_grad_rho_u_y_y = state[((owner_1 * 22u) + 6u)];
    let s_own_grad_u_x_x = state[((owner_1 * 22u) + 18u)];
    let s_own_grad_u_x_y = state[((owner_1 * 22u) + 19u)];
    let s_own_grad_u_y_x = state[((owner_1 * 22u) + 20u)];
    let s_own_grad_u_y_y = state[((owner_1 * 22u) + 21u)];
    let _e212 = state[((owner_1 * 22u) + 0u)];
    let _e219 = state[((owner_1 * 22u) + 0u)];
    let _e226 = bc_kind[((idx * 8u) + 0u)];
    let _e233 = bc_value[((idx * 8u) + 0u)];
    let _e234 = bc_neighbor_scalar(_e212, _e219, _e226, _e233, d_own_1, is_boundary_1);
    let _e241 = state[((owner_1 * 22u) + 1u)];
    let _e248 = state[((owner_1 * 22u) + 1u)];
    let _e255 = bc_kind[((idx * 8u) + 1u)];
    let _e262 = bc_value[((idx * 8u) + 1u)];
    let _e263 = bc_neighbor_scalar(_e241, _e248, _e255, _e262, d_own_1, is_boundary_1);
    let _e270 = state[((owner_1 * 22u) + 1u)];
    let _e277 = state[((owner_1 * 22u) + 1u)];
    let _e279 = normal_vec.x;
    let _e287 = state[((owner_1 * 22u) + 2u)];
    let _e289 = normal_vec.y;
    let _e293 = normal_vec.x;
    let _cse_1992_ = select(_e263, (_e270 - (((_e277 * _e279) + (_e287 * _e289)) * _e293)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e309 = state[((owner_1 * 22u) + 2u)];
    let _e316 = state[((owner_1 * 22u) + 2u)];
    let _e323 = bc_kind[((idx * 8u) + 2u)];
    let _e330 = bc_value[((idx * 8u) + 2u)];
    let _e331 = bc_neighbor_scalar(_e309, _e316, _e323, _e330, d_own_1, is_boundary_1);
    let _e338 = state[((owner_1 * 22u) + 2u)];
    let _e345 = state[((owner_1 * 22u) + 1u)];
    let _e347 = normal_vec.x;
    let _e355 = state[((owner_1 * 22u) + 2u)];
    let _e357 = normal_vec.y;
    let _e361 = normal_vec.y;
    let _cse_1931_ = select(_e331, (_e338 - (((_e345 * _e347) + (_e355 * _e357)) * _e361)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e377 = state[((owner_1 * 22u) + 10u)];
    let _e384 = state[((owner_1 * 22u) + 10u)];
    let _e391 = bc_kind[((idx * 8u) + 4u)];
    let _e398 = bc_value[((idx * 8u) + 4u)];
    let _e399 = bc_neighbor_scalar(_e377, _e384, _e391, _e398, d_own_1, is_boundary_1);
    let _e406 = state[((owner_1 * 22u) + 10u)];
    let _e413 = state[((owner_1 * 22u) + 10u)];
    let _e415 = normal_vec.x;
    let _e423 = state[((owner_1 * 22u) + 11u)];
    let _e425 = normal_vec.y;
    let _e429 = normal_vec.x;
    let _cse_1276_ = select(_e399, (_e406 - (((_e413 * _e415) + (_e423 * _e425)) * _e429)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e445 = state[((owner_1 * 22u) + 11u)];
    let _e452 = state[((owner_1 * 22u) + 11u)];
    let _e459 = bc_kind[((idx * 8u) + 5u)];
    let _e466 = bc_value[((idx * 8u) + 5u)];
    let _e467 = bc_neighbor_scalar(_e445, _e452, _e459, _e466, d_own_1, is_boundary_1);
    let _e474 = state[((owner_1 * 22u) + 11u)];
    let _e481 = state[((owner_1 * 22u) + 10u)];
    let _e483 = normal_vec.x;
    let _e491 = state[((owner_1 * 22u) + 11u)];
    let _e493 = normal_vec.y;
    let _e497 = normal_vec.y;
    let _cse_1392_ = select(_e467, (_e474 - (((_e481 * _e483) + (_e491 * _e493)) * _e497)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e507 = neigh_idx;
    let _e514 = state[((_e507 * 22u) + 9u)];
    let _e521 = state[((owner_1 * 22u) + 9u)];
    let _e528 = bc_kind[((idx * 8u) + 7u)];
    let _e535 = bc_value[((idx * 8u) + 7u)];
    let _e536 = bc_neighbor_scalar(_e514, _e521, _e528, _e535, d_own_1, is_boundary_1);
    let _e537 = neigh_idx;
    let _e544 = state[((_e537 * 22u) + 16u)];
    let _e551 = state[((owner_1 * 22u) + 16u)];
    let s_neigh_grad_T_x = select(_e544, _e551, is_boundary_1);
    let _e553 = neigh_idx;
    let _e560 = state[((_e553 * 22u) + 17u)];
    let _e567 = state[((owner_1 * 22u) + 17u)];
    let s_neigh_grad_T_y = select(_e560, _e567, is_boundary_1);
    let _e569 = neigh_idx;
    let _e576 = state[((_e569 * 22u) + 12u)];
    let _e583 = state[((owner_1 * 22u) + 12u)];
    let s_neigh_grad_rho_x = select(_e576, _e583, is_boundary_1);
    let _e585 = neigh_idx;
    let _e592 = state[((_e585 * 22u) + 13u)];
    let _e599 = state[((owner_1 * 22u) + 13u)];
    let s_neigh_grad_rho_y = select(_e592, _e599, is_boundary_1);
    let _e601 = neigh_idx;
    let _e608 = state[((_e601 * 22u) + 3u)];
    let _e615 = state[((owner_1 * 22u) + 3u)];
    let s_neigh_grad_rho_u_x_x = select(_e608, _e615, is_boundary_1);
    let _e617 = neigh_idx;
    let _e624 = state[((_e617 * 22u) + 4u)];
    let _e631 = state[((owner_1 * 22u) + 4u)];
    let s_neigh_grad_rho_u_x_y = select(_e624, _e631, is_boundary_1);
    let _e633 = neigh_idx;
    let _e640 = state[((_e633 * 22u) + 5u)];
    let _e647 = state[((owner_1 * 22u) + 5u)];
    let s_neigh_grad_rho_u_y_x = select(_e640, _e647, is_boundary_1);
    let _e649 = neigh_idx;
    let _e656 = state[((_e649 * 22u) + 6u)];
    let _e663 = state[((owner_1 * 22u) + 6u)];
    let s_neigh_grad_rho_u_y_y = select(_e656, _e663, is_boundary_1);
    let _e665 = neigh_idx;
    let _e672 = state[((_e665 * 22u) + 18u)];
    let _e679 = state[((owner_1 * 22u) + 18u)];
    let s_neigh_grad_u_x_x = select(_e672, _e679, is_boundary_1);
    let _e681 = neigh_idx;
    let _e688 = state[((_e681 * 22u) + 19u)];
    let _e695 = state[((owner_1 * 22u) + 19u)];
    let s_neigh_grad_u_x_y = select(_e688, _e695, is_boundary_1);
    let _e697 = neigh_idx;
    let _e704 = state[((_e697 * 22u) + 20u)];
    let _e711 = state[((owner_1 * 22u) + 20u)];
    let s_neigh_grad_u_y_x = select(_e704, _e711, is_boundary_1);
    let _e713 = neigh_idx;
    let _e720 = state[((_e713 * 22u) + 21u)];
    let _e727 = state[((owner_1 * 22u) + 21u)];
    let s_neigh_grad_u_y_y = select(_e720, _e727, is_boundary_1);
    let _e729 = neigh_idx;
    let _e736 = state[((_e729 * 22u) + 0u)];
    let _e743 = state[((owner_1 * 22u) + 0u)];
    let _e750 = bc_kind[((idx * 8u) + 0u)];
    let _e757 = bc_value[((idx * 8u) + 0u)];
    let _e758 = bc_neighbor_scalar(_e736, _e743, _e750, _e757, d_own_1, is_boundary_1);
    let _e759 = neigh_idx;
    let _e766 = state[((_e759 * 22u) + 1u)];
    let _e773 = state[((owner_1 * 22u) + 1u)];
    let _e780 = bc_kind[((idx * 8u) + 1u)];
    let _e787 = bc_value[((idx * 8u) + 1u)];
    let _e788 = bc_neighbor_scalar(_e766, _e773, _e780, _e787, d_own_1, is_boundary_1);
    let _e795 = state[((owner_1 * 22u) + 1u)];
    let _e802 = state[((owner_1 * 22u) + 1u)];
    let _e804 = normal_vec.x;
    let _e812 = state[((owner_1 * 22u) + 2u)];
    let _e814 = normal_vec.y;
    let _e818 = normal_vec.x;
    let _cse_1929_ = select(_e788, (_e795 - (((_e802 * _e804) + (_e812 * _e814)) * _e818)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e828 = neigh_idx;
    let _e835 = state[((_e828 * 22u) + 2u)];
    let _e842 = state[((owner_1 * 22u) + 2u)];
    let _e849 = bc_kind[((idx * 8u) + 2u)];
    let _e856 = bc_value[((idx * 8u) + 2u)];
    let _e857 = bc_neighbor_scalar(_e835, _e842, _e849, _e856, d_own_1, is_boundary_1);
    let _e864 = state[((owner_1 * 22u) + 2u)];
    let _e871 = state[((owner_1 * 22u) + 1u)];
    let _e873 = normal_vec.x;
    let _e881 = state[((owner_1 * 22u) + 2u)];
    let _e883 = normal_vec.y;
    let _e887 = normal_vec.y;
    let _cse_1933_ = select(_e857, (_e864 - (((_e871 * _e873) + (_e881 * _e883)) * _e887)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _cse_2_ = vec2<f32>(_cse_1992_, _cse_1931_);
    let _cse_1_ = ((_cse_2_ * 1f) / vec2(_e234));
    let _e902 = normal_vec;
    let _cse_0_ = dot(_cse_1_, _e902);
    let _e906 = low_mach_params.model;
    let _cse_12_ = (f32(_e906) - 2f);
    let _cse_11_ = abs(_cse_12_);
    let _cse_10_ = (1f - _cse_11_);
    let _cse_9_ = max(0f, _cse_10_);
    let _e917 = constants.eos_r;
    let _cse_16_ = ((_e234 * _e917) * _e121);
    let _e922 = constants.eos_gamma;
    let _cse_15_ = (_e922 * _cse_16_);
    let _cse_14_ = (_cse_15_ / _e234);
    let _e927 = constants.eos_dp_drho;
    let _cse_13_ = (_cse_14_ + _e927);
    let _cse_8_ = (_cse_9_ * _cse_13_);
    let _e932 = low_mach_params.model;
    let _cse_21_ = f32(_e932);
    let _cse_20_ = abs(_cse_21_);
    let _cse_19_ = (1f - _cse_20_);
    let _cse_18_ = max(0f, _cse_19_);
    let _cse_23_ = (_cse_0_ * _cse_0_);
    let _cse_22_ = min(_cse_23_, _cse_13_);
    let _cse_17_ = (_cse_18_ * _cse_22_);
    let _cse_7_ = (_cse_8_ + _cse_17_);
    let _e945 = low_mach_params.model;
    let _cse_28_ = (f32(_e945) - 1f);
    let _cse_27_ = abs(_cse_28_);
    let _cse_26_ = (1f - _cse_27_);
    let _cse_25_ = max(0f, _cse_26_);
    let _e956 = low_mach_params.theta_floor;
    let _cse_31_ = (_e956 * _cse_13_);
    let _cse_30_ = max(_cse_23_, _cse_31_);
    let _cse_29_ = min(_cse_30_, _cse_13_);
    let _cse_24_ = (_cse_25_ * _cse_29_);
    let _cse_6_ = (_cse_7_ + _cse_24_);
    let _cse_5_ = sqrt(_cse_6_);
    let _cse_34_ = vec2<f32>(_cse_1929_, _cse_1933_);
    let _cse_33_ = ((_cse_34_ * 1f) / vec2(_e758));
    let _e968 = normal_vec;
    let _cse_32_ = dot(_cse_33_, _e968);
    let _e972 = constants.eos_r;
    let _cse_44_ = ((_e758 * _e972) * _e536);
    let _e977 = constants.eos_gamma;
    let _cse_43_ = (_e977 * _cse_44_);
    let _cse_42_ = (_cse_43_ / _e758);
    let _e982 = constants.eos_dp_drho;
    let _cse_41_ = (_cse_42_ + _e982);
    let _cse_40_ = (_cse_9_ * _cse_41_);
    let _cse_47_ = (_cse_32_ * _cse_32_);
    let _cse_46_ = min(_cse_47_, _cse_41_);
    let _cse_45_ = (_cse_18_ * _cse_46_);
    let _cse_39_ = (_cse_40_ + _cse_45_);
    let _e991 = low_mach_params.theta_floor;
    let _cse_51_ = (_e991 * _cse_41_);
    let _cse_50_ = max(_cse_47_, _cse_51_);
    let _cse_49_ = min(_cse_50_, _cse_41_);
    let _cse_48_ = (_cse_25_ * _cse_49_);
    let _cse_38_ = (_cse_39_ + _cse_48_);
    let _cse_37_ = sqrt(_cse_38_);
    a_plus = max(0f, max((_cse_0_ + _cse_5_), (_cse_32_ + _cse_37_)));
    a_minus = min(0f, min((_cse_0_ - _cse_5_), (_cse_32_ - _cse_37_)));
    let _e1012 = constants.scheme;
    if ((_e1012 == 1u) && !(is_boundary_1)) {
        let _cse_57_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_55_ = (_cse_1992_ + _cse_57_);
        let _cse_60_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_58_ = (_cse_1931_ + _cse_60_);
        let _cse_54_ = vec2<f32>(_cse_55_, _cse_58_);
        let _cse_63_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_62_ = (_e234 + _cse_63_);
        let _cse_61_ = (1f / _cse_62_);
        let _cse_53_ = (_cse_54_ * _cse_61_);
        let _e1033 = normal_vec;
        let _cse_52_ = dot(_cse_53_, _e1033);
        let _e1037 = constants.eos_r;
        let _cse_72_ = (_cse_62_ * _e1037);
        let _cse_74_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_73_ = (_e121 + _cse_74_);
        let _cse_71_ = (_cse_72_ * _cse_73_);
        let _e1046 = constants.eos_gamma;
        let _cse_70_ = (_e1046 * _cse_71_);
        let _cse_69_ = (_cse_70_ / _cse_62_);
        let _e1051 = constants.eos_dp_drho;
        let _cse_68_ = (_cse_69_ + _e1051);
        let _e1055 = low_mach_params.model;
        let _cse_67_ = (max(0f, (1f - abs((f32(_e1055) - 2f)))) * _cse_68_);
        let _cse_77_ = (_cse_52_ * _cse_52_);
        let _cse_76_ = min(_cse_77_, _cse_68_);
        let _e1069 = low_mach_params.model;
        let _cse_75_ = (max(0f, (1f - abs(f32(_e1069)))) * _cse_76_);
        let _cse_66_ = (_cse_67_ + _cse_75_);
        let _e1080 = low_mach_params.theta_floor;
        let _cse_81_ = (_e1080 * _cse_68_);
        let _cse_80_ = max(_cse_77_, _cse_81_);
        let _cse_79_ = min(_cse_80_, _cse_68_);
        let _e1086 = low_mach_params.model;
        let _cse_78_ = (max(0f, (1f - abs((f32(_e1086) - 1f)))) * _cse_79_);
        let _cse_65_ = (_cse_66_ + _cse_78_);
        let _cse_64_ = sqrt(_cse_65_);
        let _cse_88_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_87_ = dot(_cse_88_, (face_center_vec - c_neigh_cell_vec));
        let _cse_85_ = (_cse_1929_ + _cse_87_);
        let _cse_92_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_91_ = dot(_cse_92_, (face_center_vec - c_neigh_cell_vec));
        let _cse_89_ = (_cse_1933_ + _cse_91_);
        let _cse_84_ = vec2<f32>(_cse_85_, _cse_89_);
        let _cse_96_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_95_ = dot(_cse_96_, (face_center_vec - c_neigh_cell_vec));
        let _cse_94_ = (_e758 + _cse_95_);
        let _cse_93_ = (1f / _cse_94_);
        let _cse_83_ = (_cse_84_ * _cse_93_);
        let _e1126 = normal_vec;
        let _cse_82_ = dot(_cse_83_, _e1126);
        let _e1130 = constants.eos_r;
        let _cse_105_ = (_cse_94_ * _e1130);
        let _cse_108_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_107_ = dot(_cse_108_, (face_center_vec - c_neigh_cell_vec));
        let _cse_106_ = (_e536 + _cse_107_);
        let _cse_104_ = (_cse_105_ * _cse_106_);
        let _e1143 = constants.eos_gamma;
        let _cse_103_ = (_e1143 * _cse_104_);
        let _cse_102_ = (_cse_103_ / _cse_94_);
        let _e1148 = constants.eos_dp_drho;
        let _cse_101_ = (_cse_102_ + _e1148);
        let _e1152 = low_mach_params.model;
        let _cse_100_ = (max(0f, (1f - abs((f32(_e1152) - 2f)))) * _cse_101_);
        let _cse_111_ = (_cse_82_ * _cse_82_);
        let _cse_110_ = min(_cse_111_, _cse_101_);
        let _e1166 = low_mach_params.model;
        let _cse_109_ = (max(0f, (1f - abs(f32(_e1166)))) * _cse_110_);
        let _cse_99_ = (_cse_100_ + _cse_109_);
        let _e1177 = low_mach_params.theta_floor;
        let _cse_115_ = (_e1177 * _cse_101_);
        let _cse_114_ = max(_cse_111_, _cse_115_);
        let _cse_113_ = min(_cse_114_, _cse_101_);
        let _e1183 = low_mach_params.model;
        let _cse_112_ = (max(0f, (1f - abs((f32(_e1183) - 1f)))) * _cse_113_);
        let _cse_98_ = (_cse_99_ + _cse_112_);
        let _cse_97_ = sqrt(_cse_98_);
        a_plus = max(0f, max((_cse_52_ + _cse_64_), (_cse_82_ + _cse_97_)));
        a_minus = min(0f, min((_cse_52_ - _cse_64_), (_cse_82_ - _cse_97_)));
    }
    let _e1207 = constants.scheme;
    if ((_e1207 == 2u) && !(is_boundary_1)) {
        let _cse_123_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_122_ = (_cse_123_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_121_ = (_cse_122_ - _cse_1992_);
        let _cse_119_ = (_cse_1992_ + _cse_121_);
        let _cse_129_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_128_ = (_cse_129_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_127_ = (_cse_128_ - _cse_1931_);
        let _cse_125_ = (_cse_1931_ + _cse_127_);
        let _cse_118_ = vec2<f32>(_cse_119_, _cse_125_);
        let _cse_136_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_135_ = (_cse_136_ * 0.125f);
        let _cse_134_ = (((_e234 * 0.625f) + (_e758 * 0.375f)) + _cse_135_);
        let _cse_133_ = (_cse_134_ - _e234);
        let _cse_132_ = (_e234 + _cse_133_);
        let _cse_131_ = (1f / _cse_132_);
        let _cse_117_ = (_cse_118_ * _cse_131_);
        let _e1255 = normal_vec;
        let _cse_116_ = dot(_cse_117_, _e1255);
        let _e1259 = constants.eos_r;
        let _cse_143_ = ((_cse_132_ * _e1259) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121));
        let _e1277 = constants.eos_gamma;
        let _cse_142_ = (_e1277 * _cse_143_);
        let _cse_141_ = (_cse_142_ / _cse_132_);
        let _e1282 = constants.eos_dp_drho;
        let _cse_140_ = (_cse_141_ + _e1282);
        let _cse_146_ = (_cse_116_ * _cse_116_);
        let _cse_145_ = min(_cse_146_, _cse_140_);
        let _e1288 = low_mach_params.model;
        let _cse_144_ = (max(0f, (1f - abs(f32(_e1288)))) * _cse_145_);
        let _e1298 = low_mach_params.model;
        let _cse_139_ = ((max(0f, (1f - abs((f32(_e1298) - 2f)))) * _cse_140_) + _cse_144_);
        let _e1311 = low_mach_params.theta_floor;
        let _cse_149_ = max(_cse_146_, (_e1311 * _cse_140_));
        let _cse_148_ = min(_cse_149_, _cse_140_);
        let _e1317 = low_mach_params.model;
        let _cse_147_ = (max(0f, (1f - abs((f32(_e1317) - 1f)))) * _cse_148_);
        let _cse_138_ = (_cse_139_ + _cse_147_);
        let _cse_137_ = sqrt(_cse_138_);
        let _cse_155_ = (((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_154_ = (_cse_155_ - _cse_1929_);
        let _cse_153_ = (_cse_1929_ + _cse_154_);
        let _cse_158_ = (((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_157_ = (_cse_158_ - _cse_1933_);
        let _cse_156_ = (_cse_1933_ + _cse_157_);
        let _cse_152_ = vec2<f32>(_cse_153_, _cse_156_);
        let _cse_165_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_164_ = dot(_cse_165_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_163_ = (_cse_164_ * 0.125f);
        let _cse_162_ = (((_e758 * 0.625f) + (_e234 * 0.375f)) + _cse_163_);
        let _cse_161_ = (_cse_162_ - _e758);
        let _cse_160_ = (_e758 + _cse_161_);
        let _cse_159_ = (1f / _cse_160_);
        let _cse_151_ = (_cse_152_ * _cse_159_);
        let _e1384 = normal_vec;
        let _cse_150_ = dot(_cse_151_, _e1384);
        let _e1388 = constants.eos_r;
        let _cse_173_ = (_cse_160_ * _e1388);
        let _cse_172_ = (_cse_173_ * ((((_e536 + (_e536 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536));
        let _e1410 = constants.eos_gamma;
        let _cse_171_ = (_e1410 * _cse_172_);
        let _cse_170_ = (_cse_171_ / _cse_160_);
        let _e1415 = constants.eos_dp_drho;
        let _cse_169_ = (_cse_170_ + _e1415);
        let _cse_176_ = (_cse_150_ * _cse_150_);
        let _cse_175_ = min(_cse_176_, _cse_169_);
        let _e1421 = low_mach_params.model;
        let _cse_174_ = (max(0f, (1f - abs(f32(_e1421)))) * _cse_175_);
        let _e1431 = low_mach_params.model;
        let _cse_168_ = ((max(0f, (1f - abs((f32(_e1431) - 2f)))) * _cse_169_) + _cse_174_);
        let _e1444 = low_mach_params.theta_floor;
        let _cse_179_ = max(_cse_176_, (_e1444 * _cse_169_));
        let _cse_178_ = min(_cse_179_, _cse_169_);
        let _e1450 = low_mach_params.model;
        let _cse_177_ = (max(0f, (1f - abs((f32(_e1450) - 1f)))) * _cse_178_);
        let _cse_167_ = (_cse_168_ + _cse_177_);
        let _cse_166_ = sqrt(_cse_167_);
        a_plus = max(0f, max((_cse_116_ + _cse_137_), (_cse_150_ + _cse_166_)));
        a_minus = min(0f, min((_cse_116_ - _cse_137_), (_cse_150_ - _cse_166_)));
    }
    let _e1474 = constants.scheme;
    if ((_e1474 == 3u) && !(is_boundary_1)) {
        let _cse_187_ = (_cse_1929_ - _cse_1992_);
        let _cse_186_ = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), min(_cse_187_, 0f));
        let _cse_185_ = min(_cse_186_, max(_cse_187_, 0f));
        let _cse_183_ = (_cse_1992_ + _cse_185_);
        let _cse_193_ = (_cse_1933_ - _cse_1931_);
        let _cse_192_ = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), min(_cse_193_, 0f));
        let _cse_191_ = min(_cse_192_, max(_cse_193_, 0f));
        let _cse_189_ = (_cse_1931_ + _cse_191_);
        let _cse_182_ = vec2<f32>(_cse_183_, _cse_189_);
        let _cse_198_ = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e758 - _e234), 0f));
        let _cse_197_ = min(_cse_198_, max((_e758 - _e234), 0f));
        let _cse_196_ = (_e234 + _cse_197_);
        let _cse_195_ = (1f / _cse_196_);
        let _cse_181_ = (_cse_182_ * _cse_195_);
        let _e1517 = normal_vec;
        let _cse_180_ = dot(_cse_181_, _e1517);
        let _e1521 = constants.eos_r;
        let _cse_205_ = ((_cse_196_ * _e1521) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f))));
        let _e1538 = constants.eos_gamma;
        let _cse_204_ = (_e1538 * _cse_205_);
        let _cse_203_ = (_cse_204_ / _cse_196_);
        let _e1543 = constants.eos_dp_drho;
        let _cse_202_ = (_cse_203_ + _e1543);
        let _cse_208_ = (_cse_180_ * _cse_180_);
        let _cse_207_ = min(_cse_208_, _cse_202_);
        let _e1549 = low_mach_params.model;
        let _cse_206_ = (max(0f, (1f - abs(f32(_e1549)))) * _cse_207_);
        let _e1559 = low_mach_params.model;
        let _cse_201_ = ((max(0f, (1f - abs((f32(_e1559) - 2f)))) * _cse_202_) + _cse_206_);
        let _e1572 = low_mach_params.theta_floor;
        let _cse_211_ = max(_cse_208_, (_e1572 * _cse_202_));
        let _cse_210_ = min(_cse_211_, _cse_202_);
        let _e1578 = low_mach_params.model;
        let _cse_209_ = (max(0f, (1f - abs((f32(_e1578) - 1f)))) * _cse_210_);
        let _cse_200_ = (_cse_201_ + _cse_209_);
        let _cse_199_ = sqrt(_cse_200_);
        let _cse_218_ = (_cse_1992_ - _cse_1929_);
        let _cse_217_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_218_, 0f));
        let _cse_216_ = min(_cse_217_, max(_cse_218_, 0f));
        let _cse_215_ = (_cse_1929_ + _cse_216_);
        let _cse_222_ = (_cse_1931_ - _cse_1933_);
        let _cse_221_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_222_, 0f));
        let _cse_220_ = min(_cse_221_, max(_cse_222_, 0f));
        let _cse_219_ = (_cse_1933_ + _cse_220_);
        let _cse_214_ = vec2<f32>(_cse_215_, _cse_219_);
        let _cse_228_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_227_ = dot(_cse_228_, (face_center_vec - c_neigh_cell_vec));
        let _cse_226_ = max(_cse_227_, min((_e234 - _e758), 0f));
        let _cse_225_ = min(_cse_226_, max((_e234 - _e758), 0f));
        let _cse_224_ = (_e758 + _cse_225_);
        let _cse_223_ = (1f / _cse_224_);
        let _cse_213_ = (_cse_214_ * _cse_223_);
        let _e1640 = normal_vec;
        let _cse_212_ = dot(_cse_213_, _e1640);
        let _e1644 = constants.eos_r;
        let _cse_236_ = (_cse_224_ * _e1644);
        let _cse_237_ = (_e536 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f)));
        let _cse_235_ = (_cse_236_ * _cse_237_);
        let _e1665 = constants.eos_gamma;
        let _cse_234_ = (_e1665 * _cse_235_);
        let _cse_233_ = (_cse_234_ / _cse_224_);
        let _e1670 = constants.eos_dp_drho;
        let _cse_232_ = (_cse_233_ + _e1670);
        let _cse_240_ = (_cse_212_ * _cse_212_);
        let _cse_239_ = min(_cse_240_, _cse_232_);
        let _e1676 = low_mach_params.model;
        let _cse_238_ = (max(0f, (1f - abs(f32(_e1676)))) * _cse_239_);
        let _e1686 = low_mach_params.model;
        let _cse_231_ = ((max(0f, (1f - abs((f32(_e1686) - 2f)))) * _cse_232_) + _cse_238_);
        let _e1699 = low_mach_params.theta_floor;
        let _cse_243_ = max(_cse_240_, (_e1699 * _cse_232_));
        let _cse_242_ = min(_cse_243_, _cse_232_);
        let _e1705 = low_mach_params.model;
        let _cse_241_ = (max(0f, (1f - abs((f32(_e1705) - 1f)))) * _cse_242_);
        let _cse_230_ = (_cse_231_ + _cse_241_);
        let _cse_229_ = sqrt(_cse_230_);
        a_plus = max(0f, max((_cse_180_ + _cse_199_), (_cse_212_ + _cse_229_)));
        a_minus = min(0f, min((_cse_180_ - _cse_199_), (_cse_212_ - _cse_229_)));
    }
    let _e1729 = constants.scheme;
    if ((_e1729 == 4u) && !(is_boundary_1)) {
        let _cse_248_ = (vec2<f32>(_cse_1929_, _cse_1933_) - vec2<f32>(_cse_1992_, _cse_1931_));
        let _cse_257_ = dot(_cse_248_, _cse_248_);
        let _cse_259_ = (_cse_257_ * _cse_257_);
        let _cse_258_ = (_cse_259_ + 0.000000000000000000000000000001f);
        let _cse_256_ = ((dot(_cse_248_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_257_) / _cse_258_);
        let _cse_255_ = (2f * _cse_256_);
        let _cse_254_ = (_cse_255_ - 1f);
        let _cse_253_ = min(_cse_254_, 1999f);
        let _cse_252_ = max(-2001f, _cse_253_);
        let _cse_260_ = abs(_cse_252_);
        let _cse_251_ = (_cse_252_ + _cse_260_);
        let _cse_250_ = (_cse_251_ / (1f + _cse_260_));
        let _cse_249_ = (_cse_250_ * lambda_other);
        let _cse_247_ = (_cse_248_ * _cse_249_);
        let _cse_246_ = (vec2<f32>(_cse_1992_, _cse_1931_) + _cse_247_);
        let _cse_267_ = ((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f);
        let _cse_266_ = min(_cse_267_, 1999f);
        let _cse_265_ = max(-2001f, _cse_266_);
        let _cse_264_ = ((_cse_265_ + abs(_cse_265_)) / (1f + abs(_cse_265_)));
        let _cse_263_ = (_cse_264_ * lambda_other);
        let _cse_262_ = (_cse_263_ * (_e758 - _e234));
        let _cse_261_ = (_e234 + _cse_262_);
        let _cse_245_ = ((_cse_246_ * 1f) / vec2(_cse_261_));
        let _e1801 = normal_vec;
        let _cse_244_ = dot(_cse_245_, _e1801);
        let _e1805 = constants.eos_gamma;
        let _e1809 = constants.eos_r;
        let _cse_271_ = ((((_e1805 * _cse_261_) * _e1809) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / _cse_261_);
        let _e1882 = constants.eos_dp_drho;
        let _cse_270_ = (_cse_271_ + _e1882);
        let _cse_272_ = (_cse_244_ * _cse_244_);
        let _e1887 = low_mach_params.model;
        let _e1899 = low_mach_params.model;
        let _e1911 = low_mach_params.model;
        let _e1922 = low_mach_params.theta_floor;
        let _cse_269_ = (((max(0f, (1f - abs((f32(_e1887) - 2f)))) * _cse_270_) + (max(0f, (1f - abs(f32(_e1899)))) * min(_cse_272_, _cse_270_))) + (max(0f, (1f - abs((f32(_e1911) - 1f)))) * min(max(_cse_272_, (_e1922 * _cse_270_)), _cse_270_)));
        let _cse_268_ = sqrt(_cse_269_);
        let _cse_285_ = (dot(_cse_248_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))))) * _cse_257_);
        let _cse_284_ = (_cse_285_ / _cse_258_);
        let _cse_283_ = (2f * _cse_284_);
        let _cse_282_ = (_cse_283_ - 1f);
        let _cse_281_ = min(_cse_282_, 1999f);
        let _cse_280_ = max(-2001f, _cse_281_);
        let _cse_286_ = abs(_cse_280_);
        let _cse_279_ = (_cse_280_ + _cse_286_);
        let _cse_278_ = (_cse_279_ / (1f + _cse_286_));
        let _e1960 = lambda;
        let _cse_277_ = (_cse_278_ * _e1960);
        let _cse_276_ = (_cse_248_ * _cse_277_);
        let _cse_275_ = (vec2<f32>(_cse_1929_, _cse_1933_) - _cse_276_);
        let _cse_296_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f));
        let _cse_295_ = (2f * _cse_296_);
        let _cse_294_ = (_cse_295_ - 1f);
        let _cse_293_ = min(_cse_294_, 1999f);
        let _cse_292_ = max(-2001f, _cse_293_);
        let _cse_297_ = abs(_cse_292_);
        let _cse_291_ = (_cse_292_ + _cse_297_);
        let _cse_290_ = (_cse_291_ / (1f + _cse_297_));
        let _e1993 = lambda;
        let _cse_289_ = (_cse_290_ * _e1993);
        let _cse_288_ = (_cse_289_ * (_e758 - _e234));
        let _cse_287_ = (_e758 - _cse_288_);
        let _cse_274_ = ((_cse_275_ * 1f) / vec2(_cse_287_));
        let _e2002 = normal_vec;
        let _cse_273_ = dot(_cse_274_, _e2002);
        let _e2006 = constants.eos_r;
        let _e2083 = lambda;
        let _cse_304_ = ((_cse_287_ * _e2006) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e2083) * (_e536 - _e121))));
        let _e2091 = constants.eos_gamma;
        let _cse_303_ = (_e2091 * _cse_304_);
        let _cse_302_ = (_cse_303_ / _cse_287_);
        let _e2096 = constants.eos_dp_drho;
        let _cse_301_ = (_cse_302_ + _e2096);
        let _cse_305_ = (_cse_273_ * _cse_273_);
        let _e2101 = low_mach_params.model;
        let _e2113 = low_mach_params.model;
        let _cse_300_ = ((max(0f, (1f - abs((f32(_e2101) - 2f)))) * _cse_301_) + (max(0f, (1f - abs(f32(_e2113)))) * min(_cse_305_, _cse_301_)));
        let _e2125 = low_mach_params.theta_floor;
        let _cse_307_ = min(max(_cse_305_, (_e2125 * _cse_301_)), _cse_301_);
        let _e2131 = low_mach_params.model;
        let _cse_306_ = (max(0f, (1f - abs((f32(_e2131) - 1f)))) * _cse_307_);
        let _cse_299_ = (_cse_300_ + _cse_306_);
        let _cse_298_ = sqrt(_cse_299_);
        a_plus = max(0f, max((_cse_244_ + _cse_268_), (_cse_273_ + _cse_298_)));
        a_minus = min(0f, min((_cse_244_ - _cse_268_), (_cse_273_ - _cse_298_)));
    }
    let _e2155 = constants.scheme;
    if ((_e2155 == 5u) && !(is_boundary_1)) {
        let _cse_315_ = ((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_);
        let _cse_314_ = max(_cse_315_, min((_cse_1929_ - _cse_1992_), 0f));
        let _cse_313_ = min(_cse_314_, max((_cse_1929_ - _cse_1992_), 0f));
        let _cse_311_ = (_cse_1992_ + _cse_313_);
        let _cse_321_ = ((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_);
        let _cse_320_ = max(_cse_321_, min((_cse_1933_ - _cse_1931_), 0f));
        let _cse_319_ = min(_cse_320_, max((_cse_1933_ - _cse_1931_), 0f));
        let _cse_317_ = (_cse_1931_ + _cse_319_);
        let _cse_310_ = vec2<f32>(_cse_311_, _cse_317_);
        let _cse_327_ = (((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_326_ = (_cse_327_ - _e234);
        let _cse_325_ = max(_cse_326_, min((_e758 - _e234), 0f));
        let _cse_324_ = min(_cse_325_, max((_e758 - _e234), 0f));
        let _cse_323_ = (_e234 + _cse_324_);
        let _cse_309_ = ((_cse_310_ * 1f) / vec2(_cse_323_));
        let _e2228 = normal_vec;
        let _cse_308_ = dot(_cse_309_, _e2228);
        let _e2232 = constants.eos_r;
        let _cse_334_ = ((_cse_323_ * _e2232) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f))));
        let _e2258 = constants.eos_gamma;
        let _cse_333_ = (_e2258 * _cse_334_);
        let _cse_332_ = (_cse_333_ / _cse_323_);
        let _e2263 = constants.eos_dp_drho;
        let _cse_331_ = (_cse_332_ + _e2263);
        let _cse_337_ = (_cse_308_ * _cse_308_);
        let _cse_336_ = min(_cse_337_, _cse_331_);
        let _e2269 = low_mach_params.model;
        let _cse_335_ = (max(0f, (1f - abs(f32(_e2269)))) * _cse_336_);
        let _e2279 = low_mach_params.model;
        let _cse_330_ = ((max(0f, (1f - abs((f32(_e2279) - 2f)))) * _cse_331_) + _cse_335_);
        let _e2292 = low_mach_params.theta_floor;
        let _cse_340_ = max(_cse_337_, (_e2292 * _cse_331_));
        let _cse_339_ = min(_cse_340_, _cse_331_);
        let _e2298 = low_mach_params.model;
        let _cse_338_ = (max(0f, (1f - abs((f32(_e2298) - 1f)))) * _cse_339_);
        let _cse_329_ = (_cse_330_ + _cse_338_);
        let _cse_328_ = sqrt(_cse_329_);
        let _cse_347_ = ((((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1929_);
        let _cse_346_ = max(_cse_347_, min((_cse_1992_ - _cse_1929_), 0f));
        let _cse_345_ = min(_cse_346_, max((_cse_1992_ - _cse_1929_), 0f));
        let _cse_344_ = (_cse_1929_ + _cse_345_);
        let _cse_351_ = ((((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1933_);
        let _cse_350_ = max(_cse_351_, min((_cse_1931_ - _cse_1933_), 0f));
        let _cse_349_ = min(_cse_350_, max((_cse_1931_ - _cse_1933_), 0f));
        let _cse_348_ = (_cse_1933_ + _cse_349_);
        let _cse_343_ = vec2<f32>(_cse_344_, _cse_348_);
        let _cse_358_ = (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_357_ = (((_e758 * 0.625f) + (_e234 * 0.375f)) + _cse_358_);
        let _cse_356_ = (_cse_357_ - _e758);
        let _cse_355_ = max(_cse_356_, min((_e234 - _e758), 0f));
        let _cse_354_ = min(_cse_355_, max((_e234 - _e758), 0f));
        let _cse_353_ = (_e758 + _cse_354_);
        let _cse_352_ = (1f / _cse_353_);
        let _cse_342_ = (_cse_343_ * _cse_352_);
        let _e2389 = normal_vec;
        let _cse_341_ = dot(_cse_342_, _e2389);
        let _e2393 = constants.eos_r;
        let _cse_365_ = ((_cse_353_ * _e2393) * (_e536 + min(max(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f))));
        let _e2423 = constants.eos_gamma;
        let _cse_364_ = (_e2423 * _cse_365_);
        let _cse_363_ = (_cse_364_ / _cse_353_);
        let _e2428 = constants.eos_dp_drho;
        let _cse_362_ = (_cse_363_ + _e2428);
        let _cse_368_ = (_cse_341_ * _cse_341_);
        let _cse_367_ = min(_cse_368_, _cse_362_);
        let _e2434 = low_mach_params.model;
        let _cse_366_ = (max(0f, (1f - abs(f32(_e2434)))) * _cse_367_);
        let _e2444 = low_mach_params.model;
        let _cse_361_ = ((max(0f, (1f - abs((f32(_e2444) - 2f)))) * _cse_362_) + _cse_366_);
        let _e2457 = low_mach_params.theta_floor;
        let _cse_371_ = max(_cse_368_, (_e2457 * _cse_362_));
        let _cse_370_ = min(_cse_371_, _cse_362_);
        let _e2463 = low_mach_params.model;
        let _cse_369_ = (max(0f, (1f - abs((f32(_e2463) - 1f)))) * _cse_370_);
        let _cse_360_ = (_cse_361_ + _cse_369_);
        let _cse_359_ = sqrt(_cse_360_);
        a_plus = max(0f, max((_cse_308_ + _cse_328_), (_cse_341_ + _cse_359_)));
        a_minus = min(0f, min((_cse_308_ - _cse_328_), (_cse_341_ - _cse_359_)));
    }
    let _e2487 = constants.scheme;
    if ((_e2487 == 6u) && !(is_boundary_1)) {
        let _cse_378_ = ((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_);
        let _cse_377_ = ((((_cse_378_ * abs((_cse_1929_ - _cse_1992_))) / max(abs((_cse_1929_ - _cse_1992_)), (abs(_cse_378_) + 0.00000001f))) * max(((_cse_1929_ - _cse_1992_) * _cse_378_), 0f)) / max(abs(((_cse_1929_ - _cse_1992_) * _cse_378_)), 0.00000001f));
        let _cse_375_ = (_cse_1992_ + _cse_377_);
        let _cse_383_ = ((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_);
        let _cse_382_ = ((((_cse_383_ * abs((_cse_1933_ - _cse_1931_))) / max(abs((_cse_1933_ - _cse_1931_)), (abs(_cse_383_) + 0.00000001f))) * max(((_cse_1933_ - _cse_1931_) * _cse_383_), 0f)) / max(abs(((_cse_1933_ - _cse_1931_) * _cse_383_)), 0.00000001f));
        let _cse_380_ = (_cse_1931_ + _cse_382_);
        let _cse_374_ = vec2<f32>(_cse_375_, _cse_380_);
        let _cse_389_ = (((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_388_ = (_cse_389_ - _e234);
        let _cse_387_ = ((_cse_388_ * abs((_e758 - _e234))) / max(abs((_e758 - _e234)), (abs(_cse_388_) + 0.00000001f)));
        let _cse_386_ = ((_cse_387_ * max(((_e758 - _e234) * _cse_388_), 0f)) / max(abs(((_e758 - _e234) * _cse_388_)), 0.00000001f));
        let _cse_385_ = (_e234 + _cse_386_);
        let _cse_373_ = ((_cse_374_ * 1f) / vec2(_cse_385_));
        let _e2599 = normal_vec;
        let _cse_372_ = dot(_cse_373_, _e2599);
        let _e2603 = constants.eos_r;
        let _cse_396_ = ((_cse_385_ * _e2603) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f))));
        let _e2678 = constants.eos_gamma;
        let _cse_395_ = (_e2678 * _cse_396_);
        let _cse_394_ = (_cse_395_ / _cse_385_);
        let _e2683 = constants.eos_dp_drho;
        let _cse_393_ = (_cse_394_ + _e2683);
        let _cse_399_ = (_cse_372_ * _cse_372_);
        let _cse_398_ = min(_cse_399_, _cse_393_);
        let _e2689 = low_mach_params.model;
        let _cse_397_ = (max(0f, (1f - abs(f32(_e2689)))) * _cse_398_);
        let _e2699 = low_mach_params.model;
        let _cse_392_ = ((max(0f, (1f - abs((f32(_e2699) - 2f)))) * _cse_393_) + _cse_397_);
        let _e2712 = low_mach_params.theta_floor;
        let _cse_402_ = max(_cse_399_, (_e2712 * _cse_393_));
        let _cse_401_ = min(_cse_402_, _cse_393_);
        let _e2718 = low_mach_params.model;
        let _cse_400_ = (max(0f, (1f - abs((f32(_e2718) - 1f)))) * _cse_401_);
        let _cse_391_ = (_cse_392_ + _cse_400_);
        let _cse_390_ = sqrt(_cse_391_);
        let _cse_409_ = (((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_408_ = (_cse_409_ - _cse_1929_);
        let _cse_407_ = ((((_cse_408_ * abs((_cse_1992_ - _cse_1929_))) / max(abs((_cse_1992_ - _cse_1929_)), (abs(_cse_408_) + 0.00000001f))) * max(((_cse_1992_ - _cse_1929_) * _cse_408_), 0f)) / max(abs(((_cse_1992_ - _cse_1929_) * _cse_408_)), 0.00000001f));
        let _cse_406_ = (_cse_1929_ + _cse_407_);
        let _cse_413_ = (((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_412_ = (_cse_413_ - _cse_1933_);
        let _cse_411_ = ((((_cse_412_ * abs((_cse_1931_ - _cse_1933_))) / max(abs((_cse_1931_ - _cse_1933_)), (abs(_cse_412_) + 0.00000001f))) * max(((_cse_1931_ - _cse_1933_) * _cse_412_), 0f)) / max(abs(((_cse_1931_ - _cse_1933_) * _cse_412_)), 0.00000001f));
        let _cse_410_ = (_cse_1933_ + _cse_411_);
        let _cse_405_ = vec2<f32>(_cse_406_, _cse_410_);
        let _cse_420_ = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_419_ = (_cse_420_ * 0.125f);
        let _cse_418_ = (((_e758 * 0.625f) + (_e234 * 0.375f)) + _cse_419_);
        let _cse_417_ = (_cse_418_ - _e758);
        let _cse_416_ = ((_cse_417_ * abs((_e234 - _e758))) / max(abs((_e234 - _e758)), (abs(_cse_417_) + 0.00000001f)));
        let _cse_422_ = ((_e234 - _e758) * _cse_417_);
        let _cse_421_ = (max(_cse_422_, 0f) / max(abs(_cse_422_), 0.00000001f));
        let _cse_415_ = (_cse_416_ * _cse_421_);
        let _cse_414_ = (_e758 + _cse_415_);
        let _cse_404_ = ((_cse_405_ * 1f) / vec2(_cse_414_));
        let _e2847 = normal_vec;
        let _cse_403_ = dot(_cse_404_, _e2847);
        let _e2851 = constants.eos_r;
        let _cse_429_ = ((_cse_414_ * _e2851) * (_e536 + ((((((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536) * abs((_e121 - _e536))) / max(abs((_e121 - _e536)), (abs(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)) + 0.00000001f))) * max(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)), 0f)) / max(abs(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536))), 0.00000001f))));
        let _e2942 = constants.eos_gamma;
        let _cse_428_ = (_e2942 * _cse_429_);
        let _cse_427_ = (_cse_428_ / _cse_414_);
        let _e2947 = constants.eos_dp_drho;
        let _cse_426_ = (_cse_427_ + _e2947);
        let _cse_432_ = (_cse_403_ * _cse_403_);
        let _cse_431_ = min(_cse_432_, _cse_426_);
        let _e2953 = low_mach_params.model;
        let _cse_430_ = (max(0f, (1f - abs(f32(_e2953)))) * _cse_431_);
        let _e2963 = low_mach_params.model;
        let _cse_425_ = ((max(0f, (1f - abs((f32(_e2963) - 2f)))) * _cse_426_) + _cse_430_);
        let _e2976 = low_mach_params.theta_floor;
        let _cse_435_ = max(_cse_432_, (_e2976 * _cse_426_));
        let _cse_434_ = min(_cse_435_, _cse_426_);
        let _e2982 = low_mach_params.model;
        let _cse_433_ = (max(0f, (1f - abs((f32(_e2982) - 1f)))) * _cse_434_);
        let _cse_424_ = (_cse_425_ + _cse_433_);
        let _cse_423_ = sqrt(_cse_424_);
        a_plus = max(0f, max((_cse_372_ + _cse_390_), (_cse_403_ + _cse_423_)));
        a_minus = min(0f, min((_cse_372_ - _cse_390_), (_cse_403_ - _cse_423_)));
    }
    let _e3004 = a_plus;
    let _e3005 = a_minus;
    let denom = max((_e3004 - _e3005), 0.000001f);
    let _e3011 = low_mach_params.model;
    let _cse_441_ = (f32(_e3011) - 2f);
    let _cse_440_ = abs(_cse_441_);
    let _cse_439_ = (1f - _cse_440_);
    let _cse_438_ = max(0f, _cse_439_);
    let _cse_437_ = (1f - _cse_438_);
    let _e3024 = low_mach_params.pressure_coupling_alpha;
    let _cse_436_ = (_cse_437_ * _e3024);
    let _e3028 = constants.eos_r;
    let _cse_442_ = ((_e234 * _e3028) * _e121);
    let _e3033 = constants.eos_r;
    let _cse_443_ = ((_e758 * _e3033) * _e536);
    let _e3039 = constants.eos_gamma;
    let _e3044 = constants.eos_dp_drho;
    u_l_0_ = (_e234 + ((_cse_436_ * _cse_442_) / max((((_e3039 * _cse_442_) / _e234) + _e3044), 0.000000000001f)));
    let _e3054 = constants.eos_gamma;
    let _e3059 = constants.eos_dp_drho;
    u_r_0_ = (_e758 + ((_cse_436_ * _cse_443_) / max((((_e3054 * _cse_443_) / _e758) + _e3059), 0.000000000001f)));
    let _e3071 = normal_vec;
    f_l_0_ = (_e234 * dot(((vec2<f32>(_cse_1992_, _cse_1931_) * 1f) / vec2(_e234)), _e3071));
    let _e3080 = normal_vec;
    f_r_0_ = (_e758 * dot(((vec2<f32>(_cse_1929_, _cse_1933_) * 1f) / vec2(_e758)), _e3080));
    let _e3086 = constants.scheme;
    if ((_e3086 == 1u) && !(is_boundary_1)) {
        let _cse_445_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_444_ = (_e234 + _cse_445_);
        let _e3097 = low_mach_params.model;
        let _cse_451_ = (f32(_e3097) - 2f);
        let _cse_450_ = abs(_cse_451_);
        let _cse_449_ = (1f - _cse_450_);
        let _cse_448_ = max(0f, _cse_449_);
        let _cse_447_ = (1f - _cse_448_);
        let _e3110 = low_mach_params.pressure_coupling_alpha;
        let _cse_446_ = (_cse_447_ * _e3110);
        let _e3114 = constants.eos_r;
        let _cse_453_ = (_cse_444_ * _e3114);
        let _cse_455_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_454_ = (_e121 + _cse_455_);
        let _cse_452_ = (_cse_453_ * _cse_454_);
        let _cse_458_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_457_ = dot(_cse_458_, (face_center_vec - c_neigh_cell_vec));
        let _cse_456_ = (_e758 + _cse_457_);
        let _e3131 = constants.eos_r;
        let _cse_460_ = (_cse_456_ * _e3131);
        let _cse_463_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_462_ = dot(_cse_463_, (face_center_vec - c_neigh_cell_vec));
        let _cse_461_ = (_e536 + _cse_462_);
        let _cse_459_ = (_cse_460_ * _cse_461_);
        let _e3145 = constants.eos_gamma;
        let _e3150 = constants.eos_dp_drho;
        u_l_0_ = (_cse_444_ + ((_cse_446_ * _cse_452_) / max((((_e3145 * _cse_452_) / _cse_444_) + _e3150), 0.000000000001f)));
        let _e3159 = constants.eos_gamma;
        let _e3164 = constants.eos_dp_drho;
        u_r_0_ = (_cse_456_ + ((_cse_446_ * _cse_459_) / max((((_e3159 * _cse_459_) / _cse_456_) + _e3164), 0.000000000001f)));
        let _e3183 = normal_vec;
        f_l_0_ = (_cse_444_ * dot(((vec2<f32>((_cse_1992_ + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec))), (_cse_1931_ + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)))) * 1f) / vec2(_cse_444_)), _e3183));
        let _e3207 = normal_vec;
        f_r_0_ = (_cse_456_ * dot(((vec2<f32>((_cse_1929_ + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec))), (_cse_1933_ + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)))) * 1f) / vec2(_cse_456_)), _e3207));
    }
    let _e3212 = constants.scheme;
    if ((_e3212 == 2u) && !(is_boundary_1)) {
        let _cse_467_ = ((_e234 * 0.625f) + (_e758 * 0.375f));
        let _cse_469_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_468_ = (_cse_469_ * 0.125f);
        let _cse_466_ = (_cse_467_ + _cse_468_);
        let _cse_465_ = (_cse_466_ - _e234);
        let _cse_464_ = (_e234 + _cse_465_);
        let _e3232 = low_mach_params.model;
        let _cse_475_ = (f32(_e3232) - 2f);
        let _cse_474_ = abs(_cse_475_);
        let _cse_473_ = (1f - _cse_474_);
        let _cse_472_ = max(0f, _cse_473_);
        let _cse_471_ = (1f - _cse_472_);
        let _e3245 = low_mach_params.pressure_coupling_alpha;
        let _cse_470_ = (_cse_471_ * _e3245);
        let _e3249 = constants.eos_r;
        let _cse_477_ = (_cse_464_ * _e3249);
        let _cse_481_ = ((_e121 * 0.625f) + (_e536 * 0.375f));
        let _cse_483_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_482_ = (_cse_483_ * 0.125f);
        let _cse_480_ = (_cse_481_ + _cse_482_);
        let _cse_479_ = (_cse_480_ - _e121);
        let _cse_478_ = (_e121 + _cse_479_);
        let _cse_476_ = (_cse_477_ * _cse_478_);
        let _cse_487_ = ((_e758 * 0.625f) + (_e234 * 0.375f));
        let _cse_490_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_489_ = dot(_cse_490_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_488_ = (_cse_489_ * 0.125f);
        let _cse_486_ = (_cse_487_ + _cse_488_);
        let _cse_485_ = (_cse_486_ - _e758);
        let _cse_484_ = (_e758 + _cse_485_);
        let _e3284 = constants.eos_r;
        let _cse_492_ = (_cse_484_ * _e3284);
        let _cse_496_ = ((_e536 * 0.625f) + (_e121 * 0.375f));
        let _cse_499_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_498_ = dot(_cse_499_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_497_ = (_cse_498_ * 0.125f);
        let _cse_495_ = (_cse_496_ + _cse_497_);
        let _cse_494_ = (_cse_495_ - _e536);
        let _cse_493_ = (_e536 + _cse_494_);
        let _cse_491_ = (_cse_492_ * _cse_493_);
        let _e3307 = constants.eos_gamma;
        let _e3312 = constants.eos_dp_drho;
        u_l_0_ = (_cse_464_ + ((_cse_470_ * _cse_476_) / max((((_e3307 * _cse_476_) / _cse_464_) + _e3312), 0.000000000001f)));
        let _e3321 = constants.eos_gamma;
        let _e3326 = constants.eos_dp_drho;
        u_r_0_ = (_cse_484_ + ((_cse_470_ * _cse_491_) / max((((_e3321 * _cse_491_) / _cse_484_) + _e3326), 0.000000000001f)));
        let _e3363 = normal_vec;
        f_l_0_ = (_cse_464_ * dot(((vec2<f32>(((((_cse_1992_ + (_cse_1992_ * 0.625f)) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_), ((((_cse_1931_ + (_cse_1931_ * 0.625f)) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_)) * 1f) / vec2(_cse_464_)), _e3363));
        let _e3405 = normal_vec;
        f_r_0_ = (_cse_484_ * dot(((vec2<f32>(((((_cse_1929_ + (_cse_1929_ * 0.625f)) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1929_), ((((_cse_1933_ + (_cse_1933_ * 0.625f)) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1933_)) * 1f) / vec2(_cse_484_)), _e3405));
    }
    let _e3410 = constants.scheme;
    if ((_e3410 == 3u) && !(is_boundary_1)) {
        let _cse_507_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_508_ = min((_e758 - _e234), 0f);
        let _cse_506_ = max(_cse_507_, _cse_508_);
        let _cse_509_ = max((_e758 - _e234), 0f);
        let _cse_505_ = min(_cse_506_, _cse_509_);
        let _cse_504_ = (_e234 + _cse_505_);
        let _e3429 = low_mach_params.model;
        let _cse_515_ = (f32(_e3429) - 2f);
        let _cse_514_ = abs(_cse_515_);
        let _cse_513_ = (1f - _cse_514_);
        let _cse_512_ = max(0f, _cse_513_);
        let _cse_511_ = (1f - _cse_512_);
        let _e3442 = low_mach_params.pressure_coupling_alpha;
        let _cse_510_ = (_cse_511_ * _e3442);
        let _e3446 = constants.eos_r;
        let _cse_517_ = (_cse_504_ * _e3446);
        let _cse_521_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_522_ = min((_e536 - _e121), 0f);
        let _cse_520_ = max(_cse_521_, _cse_522_);
        let _cse_523_ = max((_e536 - _e121), 0f);
        let _cse_519_ = min(_cse_520_, _cse_523_);
        let _cse_518_ = (_e121 + _cse_519_);
        let _cse_516_ = (_cse_517_ * _cse_518_);
        let _cse_528_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_527_ = dot(_cse_528_, (face_center_vec - c_neigh_cell_vec));
        let _cse_529_ = min((_e234 - _e758), 0f);
        let _cse_526_ = max(_cse_527_, _cse_529_);
        let _cse_530_ = max((_e234 - _e758), 0f);
        let _cse_525_ = min(_cse_526_, _cse_530_);
        let _cse_524_ = (_e758 + _cse_525_);
        let _e3479 = constants.eos_r;
        let _cse_532_ = (_cse_524_ * _e3479);
        let _cse_537_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_536_ = dot(_cse_537_, (face_center_vec - c_neigh_cell_vec));
        let _cse_538_ = min((_e121 - _e536), 0f);
        let _cse_535_ = max(_cse_536_, _cse_538_);
        let _cse_539_ = max((_e121 - _e536), 0f);
        let _cse_534_ = min(_cse_535_, _cse_539_);
        let _cse_533_ = (_e536 + _cse_534_);
        let _cse_531_ = (_cse_532_ * _cse_533_);
        let _cse_541_ = (_cse_1929_ - _cse_1992_);
        let _cse_544_ = (_cse_1933_ - _cse_1931_);
        let _cse_546_ = (_cse_1992_ - _cse_1929_);
        let _cse_547_ = (_cse_1931_ - _cse_1933_);
        let _e3505 = constants.eos_gamma;
        let _e3510 = constants.eos_dp_drho;
        u_l_0_ = (_cse_504_ + ((_cse_510_ * _cse_516_) / max((((_e3505 * _cse_516_) / _cse_504_) + _e3510), 0.000000000001f)));
        let _e3519 = constants.eos_gamma;
        let _e3524 = constants.eos_dp_drho;
        u_r_0_ = (_cse_524_ + ((_cse_510_ * _cse_531_) / max((((_e3519 * _cse_531_) / _cse_524_) + _e3524), 0.000000000001f)));
        let _e3555 = normal_vec;
        f_l_0_ = (_cse_504_ * dot(((vec2<f32>((_cse_1992_ + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), min(_cse_541_, 0f)), max(_cse_541_, 0f))), (_cse_1931_ + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), min(_cse_544_, 0f)), max(_cse_544_, 0f)))) * 1f) / vec2(_cse_504_)), _e3555));
        let _e3591 = normal_vec;
        f_r_0_ = (_cse_524_ * dot(((vec2<f32>((_cse_1929_ + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_546_, 0f)), max(_cse_546_, 0f))), (_cse_1933_ + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_547_, 0f)), max(_cse_547_, 0f)))) * 1f) / vec2(_cse_524_)), _e3591));
    }
    let _e3596 = constants.scheme;
    if ((_e3596 == 4u) && !(is_boundary_1)) {
        let _cse_559_ = dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y));
        let _cse_558_ = (_cse_559_ * (_e758 - _e234));
        let _cse_561_ = ((_e758 - _e234) * (_e758 - _e234));
        let _cse_560_ = (_cse_561_ + 0.000000000000000000000000000001f);
        let _cse_557_ = (_cse_558_ / _cse_560_);
        let _cse_556_ = (2f * _cse_557_);
        let _cse_555_ = (_cse_556_ - 1f);
        let _cse_554_ = min(_cse_555_, 1999f);
        let _cse_553_ = max(-2001f, _cse_554_);
        let _cse_562_ = abs(_cse_553_);
        let _cse_552_ = (_cse_553_ + _cse_562_);
        let _cse_563_ = (1f + _cse_562_);
        let _cse_551_ = (_cse_552_ / _cse_563_);
        let _cse_550_ = (_cse_551_ * lambda_other);
        let _cse_549_ = (_cse_550_ * (_e758 - _e234));
        let _cse_548_ = (_e234 + _cse_549_);
        let _cse_568_ = (((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f));
        let _cse_567_ = (_cse_568_ - 1f);
        let _cse_566_ = min(_cse_567_, 1999f);
        let _cse_565_ = max(-2001f, _cse_566_);
        let _e3650 = constants.eos_r;
        let _cse_564_ = ((_cse_548_ * _e3650) * (_e121 + ((((_cse_565_ + abs(_cse_565_)) / (1f + abs(_cse_565_))) * lambda_other) * (_e536 - _e121))));
        let _cse_581_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_580_ = dot((c_neigh_cell_vec - c_owner_vec), _cse_581_);
        let _cse_579_ = (_cse_580_ * (_e758 - _e234));
        let _cse_578_ = (_cse_579_ / _cse_560_);
        let _cse_577_ = (2f * _cse_578_);
        let _cse_576_ = (_cse_577_ - 1f);
        let _cse_575_ = min(_cse_576_, 1999f);
        let _cse_574_ = max(-2001f, _cse_575_);
        let _cse_582_ = abs(_cse_574_);
        let _cse_573_ = (_cse_574_ + _cse_582_);
        let _cse_583_ = (1f + _cse_582_);
        let _cse_572_ = (_cse_573_ / _cse_583_);
        let _e3686 = lambda;
        let _cse_571_ = (_cse_572_ * _e3686);
        let _cse_570_ = (_cse_571_ * (_e758 - _e234));
        let _cse_569_ = (_e758 - _cse_570_);
        let _e3693 = constants.eos_r;
        let _cse_585_ = (_cse_569_ * _e3693);
        let _cse_594_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f));
        let _cse_593_ = (2f * _cse_594_);
        let _cse_592_ = (_cse_593_ - 1f);
        let _cse_591_ = min(_cse_592_, 1999f);
        let _cse_590_ = max(-2001f, _cse_591_);
        let _cse_595_ = abs(_cse_590_);
        let _cse_589_ = ((_cse_590_ + _cse_595_) / (1f + _cse_595_));
        let _e3723 = lambda;
        let _cse_588_ = (_cse_589_ * _e3723);
        let _cse_587_ = (_cse_588_ * (_e536 - _e121));
        let _cse_586_ = (_e536 - _cse_587_);
        let _cse_584_ = (_cse_585_ * _cse_586_);
        let _cse_596_ = (vec2<f32>(_cse_1929_, _cse_1933_) - vec2<f32>(_cse_1992_, _cse_1931_));
        let _cse_602_ = dot(_cse_596_, _cse_596_);
        let _cse_604_ = (_cse_602_ * _cse_602_);
        let _cse_603_ = (_cse_604_ + 0.000000000000000000000000000001f);
        let _cse_601_ = ((dot(_cse_596_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_602_) / _cse_603_);
        let _cse_600_ = (2f * _cse_601_);
        let _cse_599_ = (_cse_600_ - 1f);
        let _cse_598_ = min(_cse_599_, 1999f);
        let _cse_597_ = max(-2001f, _cse_598_);
        let _cse_610_ = (dot(_cse_596_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))))) * _cse_602_);
        let _cse_609_ = (_cse_610_ / _cse_603_);
        let _cse_608_ = (2f * _cse_609_);
        let _cse_607_ = (_cse_608_ - 1f);
        let _cse_606_ = min(_cse_607_, 1999f);
        let _cse_605_ = max(-2001f, _cse_606_);
        let _cse_611_ = abs(_cse_605_);
        let _e3783 = low_mach_params.model;
        let _e3796 = low_mach_params.pressure_coupling_alpha;
        let _e3801 = constants.eos_gamma;
        let _e3806 = constants.eos_dp_drho;
        u_l_0_ = (_cse_548_ + ((((1f - max(0f, (1f - abs((f32(_e3783) - 2f))))) * _e3796) * _cse_564_) / max((((_e3801 * _cse_564_) / _cse_548_) + _e3806), 0.000000000001f)));
        let _e3814 = low_mach_params.model;
        let _e3827 = low_mach_params.pressure_coupling_alpha;
        let _e3832 = constants.eos_gamma;
        let _e3837 = constants.eos_dp_drho;
        u_r_0_ = (_cse_569_ + ((((1f - max(0f, (1f - abs((f32(_e3814) - 2f))))) * _e3827) * _cse_584_) / max((((_e3832 * _cse_584_) / _cse_569_) + _e3837), 0.000000000001f)));
        let _e3858 = normal_vec;
        f_l_0_ = (_cse_548_ * dot((((vec2<f32>(_cse_1992_, _cse_1931_) + (((_cse_596_ * (_cse_597_ + abs(_cse_597_))) / vec2((1f + abs(_cse_597_)))) * lambda_other)) * 1f) / vec2(_cse_548_)), _e3858));
        let _e3868 = lambda;
        let _e3875 = normal_vec;
        f_r_0_ = (_cse_569_ * dot((((vec2<f32>(_cse_1929_, _cse_1933_) - (((_cse_596_ * (_cse_605_ + _cse_611_)) / vec2((1f + _cse_611_))) * _e3868)) * 1f) / vec2(_cse_569_)), _e3875));
    }
    let _e3880 = constants.scheme;
    if ((_e3880 == 5u) && !(is_boundary_1)) {
        let _cse_617_ = ((_e234 * 0.625f) + (_e758 * 0.375f));
        let _cse_619_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_618_ = (_cse_619_ * 0.125f);
        let _cse_616_ = (_cse_617_ + _cse_618_);
        let _cse_615_ = (_cse_616_ - _e234);
        let _cse_620_ = min((_e758 - _e234), 0f);
        let _cse_614_ = max(_cse_615_, _cse_620_);
        let _cse_621_ = max((_e758 - _e234), 0f);
        let _cse_613_ = min(_cse_614_, _cse_621_);
        let _cse_612_ = (_e234 + _cse_613_);
        let _e3908 = low_mach_params.model;
        let _cse_627_ = (f32(_e3908) - 2f);
        let _cse_626_ = abs(_cse_627_);
        let _cse_625_ = (1f - _cse_626_);
        let _cse_624_ = max(0f, _cse_625_);
        let _cse_623_ = (1f - _cse_624_);
        let _e3921 = low_mach_params.pressure_coupling_alpha;
        let _cse_622_ = (_cse_623_ * _e3921);
        let _e3925 = constants.eos_r;
        let _cse_629_ = (_cse_612_ * _e3925);
        let _cse_635_ = ((_e121 * 0.625f) + (_e536 * 0.375f));
        let _cse_637_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_636_ = (_cse_637_ * 0.125f);
        let _cse_634_ = (_cse_635_ + _cse_636_);
        let _cse_633_ = (_cse_634_ - _e121);
        let _cse_638_ = min((_e536 - _e121), 0f);
        let _cse_632_ = max(_cse_633_, _cse_638_);
        let _cse_639_ = max((_e536 - _e121), 0f);
        let _cse_631_ = min(_cse_632_, _cse_639_);
        let _cse_630_ = (_e121 + _cse_631_);
        let _cse_628_ = (_cse_629_ * _cse_630_);
        let _cse_645_ = ((_e758 * 0.625f) + (_e234 * 0.375f));
        let _cse_648_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_647_ = dot(_cse_648_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_646_ = (_cse_647_ * 0.125f);
        let _cse_644_ = (_cse_645_ + _cse_646_);
        let _cse_643_ = (_cse_644_ - _e758);
        let _cse_649_ = min((_e234 - _e758), 0f);
        let _cse_642_ = max(_cse_643_, _cse_649_);
        let _cse_650_ = max((_e234 - _e758), 0f);
        let _cse_641_ = min(_cse_642_, _cse_650_);
        let _cse_640_ = (_e758 + _cse_641_);
        let _e3976 = constants.eos_r;
        let _cse_652_ = (_cse_640_ * _e3976);
        let _cse_658_ = ((_e536 * 0.625f) + (_e121 * 0.375f));
        let _cse_661_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_660_ = dot(_cse_661_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_659_ = (_cse_660_ * 0.125f);
        let _cse_657_ = (_cse_658_ + _cse_659_);
        let _cse_656_ = (_cse_657_ - _e536);
        let _cse_662_ = min((_e121 - _e536), 0f);
        let _cse_655_ = max(_cse_656_, _cse_662_);
        let _cse_663_ = max((_e121 - _e536), 0f);
        let _cse_654_ = min(_cse_655_, _cse_663_);
        let _cse_653_ = (_e536 + _cse_654_);
        let _cse_651_ = (_cse_652_ * _cse_653_);
        let _cse_666_ = (_cse_1929_ - _cse_1992_);
        let _cse_669_ = (_cse_1933_ - _cse_1931_);
        let _cse_670_ = (_cse_1992_ - _cse_1929_);
        let _cse_671_ = (_cse_1931_ - _cse_1933_);
        let _e4011 = constants.eos_gamma;
        let _e4016 = constants.eos_dp_drho;
        u_l_0_ = (_cse_612_ + ((_cse_622_ * _cse_628_) / max((((_e4011 * _cse_628_) / _cse_612_) + _e4016), 0.000000000001f)));
        let _e4025 = constants.eos_gamma;
        let _e4030 = constants.eos_dp_drho;
        u_r_0_ = (_cse_640_ + ((_cse_622_ * _cse_651_) / max((((_e4025 * _cse_651_) / _cse_640_) + _e4030), 0.000000000001f)));
        let _e4079 = normal_vec;
        f_l_0_ = (_cse_612_ * dot(((vec2<f32>((_cse_1992_ + min(max(((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_), min(_cse_666_, 0f)), max(_cse_666_, 0f))), (_cse_1931_ + min(max(((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_), min(_cse_669_, 0f)), max(_cse_669_, 0f)))) * 1f) / vec2(_cse_612_)), _e4079));
        let _e4133 = normal_vec;
        f_r_0_ = (_cse_640_ * dot(((vec2<f32>((_cse_1929_ + min(max(((((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1929_), min(_cse_670_, 0f)), max(_cse_670_, 0f))), (_cse_1933_ + min(max(((((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1933_), min(_cse_671_, 0f)), max(_cse_671_, 0f)))) * 1f) / vec2(_cse_640_)), _e4133));
    }
    let _e4138 = constants.scheme;
    if ((_e4138 == 6u) && !(is_boundary_1)) {
        let _cse_677_ = ((_e234 * 0.625f) + (_e758 * 0.375f));
        let _cse_679_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_678_ = (_cse_679_ * 0.125f);
        let _cse_676_ = (_cse_677_ + _cse_678_);
        let _cse_675_ = (_cse_676_ - _e234);
        let _cse_683_ = abs(_cse_675_);
        let _cse_682_ = (_cse_683_ + 0.00000001f);
        let _cse_681_ = max(abs((_e758 - _e234)), _cse_682_);
        let _cse_680_ = (abs((_e758 - _e234)) / _cse_681_);
        let _cse_674_ = (_cse_675_ * _cse_680_);
        let _cse_686_ = ((_e758 - _e234) * _cse_675_);
        let _cse_685_ = max(_cse_686_, 0f);
        let _cse_688_ = abs(_cse_686_);
        let _cse_687_ = max(_cse_688_, 0.00000001f);
        let _cse_684_ = (_cse_685_ / _cse_687_);
        let _cse_673_ = (_cse_674_ * _cse_684_);
        let _cse_672_ = (_e234 + _cse_673_);
        let _e4177 = constants.eos_r;
        let _cse_690_ = (_cse_672_ * _e4177);
        let _cse_694_ = (((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_693_ = (_cse_694_ - _e121);
        let _cse_692_ = ((((_cse_693_ * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(_cse_693_) + 0.00000001f))) * max(((_e536 - _e121) * _cse_693_), 0f)) / max(abs(((_e536 - _e121) * _cse_693_)), 0.00000001f));
        let _cse_691_ = (_e121 + _cse_692_);
        let _cse_689_ = (_cse_690_ * _cse_691_);
        let _cse_700_ = ((_e758 * 0.625f) + (_e234 * 0.375f));
        let _cse_703_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_702_ = dot(_cse_703_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_701_ = (_cse_702_ * 0.125f);
        let _cse_699_ = (_cse_700_ + _cse_701_);
        let _cse_698_ = (_cse_699_ - _e758);
        let _cse_707_ = abs(_cse_698_);
        let _cse_706_ = (_cse_707_ + 0.00000001f);
        let _cse_705_ = max(abs((_e234 - _e758)), _cse_706_);
        let _cse_704_ = (abs((_e234 - _e758)) / _cse_705_);
        let _cse_697_ = (_cse_698_ * _cse_704_);
        let _cse_710_ = ((_e234 - _e758) * _cse_698_);
        let _cse_709_ = max(_cse_710_, 0f);
        let _cse_712_ = abs(_cse_710_);
        let _cse_711_ = max(_cse_712_, 0.00000001f);
        let _cse_708_ = (_cse_709_ / _cse_711_);
        let _cse_696_ = (_cse_697_ * _cse_708_);
        let _cse_695_ = (_e758 + _cse_696_);
        let _e4252 = constants.eos_r;
        let _cse_714_ = (_cse_695_ * _e4252);
        let _cse_721_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_720_ = dot(_cse_721_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_719_ = (_cse_720_ * 0.125f);
        let _cse_718_ = (((_e536 * 0.625f) + (_e121 * 0.375f)) + _cse_719_);
        let _cse_717_ = (_cse_718_ - _e536);
        let _cse_722_ = ((_e121 - _e536) * _cse_717_);
        let _cse_716_ = ((((_cse_717_ * abs((_e121 - _e536))) / max(abs((_e121 - _e536)), (abs(_cse_717_) + 0.00000001f))) * max(_cse_722_, 0f)) / max(abs(_cse_722_), 0.00000001f));
        let _cse_715_ = (_e536 + _cse_716_);
        let _cse_713_ = (_cse_714_ * _cse_715_);
        let _cse_725_ = (((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_724_ = (_cse_725_ - _cse_1992_);
        let _cse_729_ = (((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_728_ = (_cse_729_ - _cse_1931_);
        let _cse_732_ = (((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_731_ = (_cse_732_ - _cse_1929_);
        let _cse_733_ = ((_cse_1992_ - _cse_1929_) * _cse_731_);
        let _cse_735_ = (((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_734_ = (_cse_735_ - _cse_1933_);
        let _e4351 = low_mach_params.model;
        let _e4364 = low_mach_params.pressure_coupling_alpha;
        let _e4369 = constants.eos_gamma;
        let _e4374 = constants.eos_dp_drho;
        u_l_0_ = (_cse_672_ + ((((1f - max(0f, (1f - abs((f32(_e4351) - 2f))))) * _e4364) * _cse_689_) / max((((_e4369 * _cse_689_) / _cse_672_) + _e4374), 0.000000000001f)));
        let _e4382 = low_mach_params.model;
        let _e4395 = low_mach_params.pressure_coupling_alpha;
        let _e4400 = constants.eos_gamma;
        let _e4405 = constants.eos_dp_drho;
        u_r_0_ = (_cse_695_ + ((((1f - max(0f, (1f - abs((f32(_e4382) - 2f))))) * _e4395) * _cse_713_) / max((((_e4400 * _cse_713_) / _cse_695_) + _e4405), 0.000000000001f)));
        let _e4460 = normal_vec;
        f_l_0_ = (_cse_672_ * dot(((vec2<f32>((_cse_1992_ + ((((_cse_724_ * abs((_cse_1929_ - _cse_1992_))) / max(abs((_cse_1929_ - _cse_1992_)), (abs(_cse_724_) + 0.00000001f))) * max(((_cse_1929_ - _cse_1992_) * _cse_724_), 0f)) / max(abs(((_cse_1929_ - _cse_1992_) * _cse_724_)), 0.00000001f))), (_cse_1931_ + ((((_cse_728_ * abs((_cse_1933_ - _cse_1931_))) / max(abs((_cse_1933_ - _cse_1931_)), (abs(_cse_728_) + 0.00000001f))) * max(((_cse_1933_ - _cse_1931_) * _cse_728_), 0f)) / max(abs(((_cse_1933_ - _cse_1931_) * _cse_728_)), 0.00000001f)))) * 1f) / vec2(_cse_672_)), _e4460));
        let _e4508 = normal_vec;
        f_r_0_ = (_cse_695_ * dot(((vec2<f32>((_cse_1929_ + ((((_cse_731_ * abs((_cse_1992_ - _cse_1929_))) / max(abs((_cse_1992_ - _cse_1929_)), (abs(_cse_731_) + 0.00000001f))) * max(_cse_733_, 0f)) / max(abs(_cse_733_), 0.00000001f))), (_cse_1933_ + ((((_cse_734_ * abs((_cse_1931_ - _cse_1933_))) / max(abs((_cse_1931_ - _cse_1933_)), (abs(_cse_734_) + 0.00000001f))) * max(((_cse_1931_ - _cse_1933_) * _cse_734_), 0f)) / max(abs(((_cse_1931_ - _cse_1933_) * _cse_734_)), 0.00000001f)))) * 1f) / vec2(_cse_695_)), _e4508));
    }
    let _e4517 = a_plus;
    let _e4518 = f_l_0_;
    let _e4520 = a_minus;
    let _e4521 = f_r_0_;
    let _e4524 = a_plus;
    let _e4525 = a_minus;
    let _e4527 = u_r_0_;
    let _e4528 = u_l_0_;
    fluxes[((idx * 8u) + 0u)] = (((((_e4517 * _e4518) - (_e4520 * _e4521)) + ((_e4524 * _e4525) * (_e4527 - _e4528))) / denom) * area);
    let _cse_737_ = vec2<f32>(_cse_1992_, _cse_1931_);
    let _cse_736_ = _cse_737_.x;
    let _cse_741_ = vec2<f32>(_cse_1929_, _cse_1933_);
    let _cse_740_ = _cse_741_.x;
    let _cse_744_ = normal_vec.x;
    let _cse_753_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
    let _e4545 = lambda;
    let _cse_752_ = (_cse_753_ * _e4545);
    let _cse_754_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
    let _cse_751_ = (_cse_752_ + _cse_754_);
    let _cse_763_ = state[((owner_1 * 22u) + 10u)];
    let _cse_764_ = state[((owner_1 * 22u) + 11u)];
    let _cse_762_ = vec2<f32>(_cse_763_, _cse_764_);
    let _cse_761_ = _cse_762_.x;
    let _cse_759_ = (_cse_1276_ - _cse_761_);
    let _cse_758_ = (_cse_759_ / max(dist, 0.000001f));
    let _e4570 = normal_vec;
    let _cse_765_ = dot(_e4570, _cse_751_);
    let _cse_757_ = (_cse_758_ - _cse_765_);
    let _cse_756_ = (select(0f, 1f, is_boundary_1) * _cse_757_);
    let _e4577 = normal_vec;
    let _cse_755_ = (_e4577 * _cse_756_);
    let _cse_750_ = (_cse_751_ + _cse_755_);
    let _cse_749_ = _cse_750_.x;
    let _cse_772_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
    let _e4586 = lambda;
    let _cse_771_ = (_cse_772_ * _e4586);
    let _cse_773_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
    let _cse_770_ = (_cse_771_ + _cse_773_);
    let _cse_780_ = _cse_762_.y;
    let _cse_778_ = (_cse_1392_ - _cse_780_);
    let _cse_777_ = (_cse_778_ / max(dist, 0.000001f));
    let _e4596 = normal_vec;
    let _cse_781_ = dot(_e4596, _cse_770_);
    let _cse_776_ = (_cse_777_ - _cse_781_);
    let _cse_775_ = (select(0f, 1f, is_boundary_1) * _cse_776_);
    let _e4603 = normal_vec;
    let _cse_774_ = (_e4603 * _cse_775_);
    let _cse_769_ = (_cse_770_ + _cse_774_);
    let _cse_768_ = _cse_769_.y;
    let _cse_767_ = (_cse_749_ + _cse_768_);
    let _cse_766_ = (0.6666667f * _cse_767_);
    let _cse_748_ = (_cse_749_ - _cse_766_);
    let _cse_747_ = (_cse_748_ * _cse_744_);
    let _cse_783_ = _cse_750_.y;
    let _cse_784_ = normal_vec.y;
    let _cse_782_ = (_cse_783_ * _cse_784_);
    let _cse_746_ = (_cse_747_ + _cse_782_);
    let _e4619 = constants.viscosity;
    let _cse_745_ = (_e4619 * _cse_746_);
    u_l_1_ = _cse_736_;
    u_r_1_ = _cse_740_;
    let _e4627 = normal_vec;
    let _e4632 = constants.eos_r;
    f_l_1_ = (((_cse_736_ * dot(((_cse_737_ * 1f) / vec2(_e234)), _e4627)) + (((_e234 * _e4632) * _e121) * _cse_744_)) - _cse_745_);
    let _e4643 = normal_vec;
    let _e4648 = constants.eos_r;
    f_r_1_ = (((_cse_740_ * dot(((_cse_741_ * 1f) / vec2(_e758)), _e4643)) + (((_e758 * _e4648) * _e536) * _cse_744_)) - _cse_745_);
    let _e4657 = constants.scheme;
    if ((_e4657 == 1u) && !(is_boundary_1)) {
        let _cse_789_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_787_ = (_cse_1992_ + _cse_789_);
        let _cse_792_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_790_ = (_cse_1931_ + _cse_792_);
        let _cse_786_ = vec2<f32>(_cse_787_, _cse_790_);
        let _cse_785_ = _cse_786_.x;
        let _cse_798_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_797_ = dot(_cse_798_, (face_center_vec - c_neigh_cell_vec));
        let _cse_795_ = (_cse_1929_ + _cse_797_);
        let _cse_802_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_801_ = dot(_cse_802_, (face_center_vec - c_neigh_cell_vec));
        let _cse_799_ = (_cse_1933_ + _cse_801_);
        let _cse_794_ = vec2<f32>(_cse_795_, _cse_799_);
        let _cse_793_ = _cse_794_.x;
        let _cse_804_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_803_ = (_e234 + _cse_804_);
        let _cse_805_ = normal_vec.x;
        let _cse_814_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e4701 = lambda;
        let _cse_813_ = (_cse_814_ * _e4701);
        let _cse_815_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_812_ = (_cse_813_ + _cse_815_);
        let _cse_824_ = state[((owner_1 * 22u) + 10u)];
        let _cse_825_ = state[((owner_1 * 22u) + 11u)];
        let _cse_823_ = vec2<f32>(_cse_824_, _cse_825_);
        let _cse_822_ = _cse_823_.x;
        let _cse_820_ = (_cse_1276_ - _cse_822_);
        let _cse_819_ = (_cse_820_ / max(dist, 0.000001f));
        let _e4726 = normal_vec;
        let _cse_826_ = dot(_e4726, _cse_812_);
        let _cse_818_ = (_cse_819_ - _cse_826_);
        let _cse_817_ = (select(0f, 1f, is_boundary_1) * _cse_818_);
        let _e4733 = normal_vec;
        let _cse_816_ = (_e4733 * _cse_817_);
        let _cse_811_ = (_cse_812_ + _cse_816_);
        let _cse_810_ = _cse_811_.x;
        let _cse_833_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e4742 = lambda;
        let _cse_832_ = (_cse_833_ * _e4742);
        let _cse_834_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_831_ = (_cse_832_ + _cse_834_);
        let _cse_841_ = _cse_823_.y;
        let _cse_839_ = (_cse_1392_ - _cse_841_);
        let _cse_838_ = (_cse_839_ / max(dist, 0.000001f));
        let _e4752 = normal_vec;
        let _cse_842_ = dot(_e4752, _cse_831_);
        let _cse_837_ = (_cse_838_ - _cse_842_);
        let _cse_836_ = (select(0f, 1f, is_boundary_1) * _cse_837_);
        let _e4759 = normal_vec;
        let _cse_835_ = (_e4759 * _cse_836_);
        let _cse_830_ = (_cse_831_ + _cse_835_);
        let _cse_829_ = _cse_830_.y;
        let _cse_828_ = (_cse_810_ + _cse_829_);
        let _cse_827_ = (0.6666667f * _cse_828_);
        let _cse_809_ = (_cse_810_ - _cse_827_);
        let _cse_808_ = (_cse_809_ * _cse_805_);
        let _cse_844_ = _cse_811_.y;
        let _cse_845_ = normal_vec.y;
        let _cse_843_ = (_cse_844_ * _cse_845_);
        let _cse_807_ = (_cse_808_ + _cse_843_);
        let _e4775 = constants.viscosity;
        let _cse_806_ = (_e4775 * _cse_807_);
        let _cse_848_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_847_ = dot(_cse_848_, (face_center_vec - c_neigh_cell_vec));
        let _cse_846_ = (_e758 + _cse_847_);
        u_l_1_ = _cse_785_;
        u_r_1_ = _cse_793_;
        let _e4789 = normal_vec;
        let _e4794 = constants.eos_r;
        f_l_1_ = (((_cse_785_ * dot(((_cse_786_ * 1f) / vec2(_cse_803_)), _e4789)) + (((_cse_803_ * _e4794) * (_e121 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)))) * _cse_805_)) - _cse_806_);
        let _e4808 = normal_vec;
        let _e4813 = constants.eos_r;
        f_r_1_ = (((_cse_793_ * dot(((_cse_794_ * 1f) / vec2(_cse_846_)), _e4808)) + (((_cse_846_ * _e4813) * (_e536 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)))) * _cse_805_)) - _cse_806_);
    }
    let _e4829 = constants.scheme;
    if ((_e4829 == 2u) && !(is_boundary_1)) {
        let _cse_855_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_854_ = (_cse_855_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_853_ = (_cse_854_ - _cse_1992_);
        let _cse_851_ = (_cse_1992_ + _cse_853_);
        let _cse_861_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_860_ = (_cse_861_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_859_ = (_cse_860_ - _cse_1931_);
        let _cse_857_ = (_cse_1931_ + _cse_859_);
        let _cse_850_ = vec2<f32>(_cse_851_, _cse_857_);
        let _cse_849_ = _cse_850_.x;
        let _cse_868_ = ((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f));
        let _cse_870_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_869_ = (_cse_870_ * 0.125f);
        let _cse_867_ = (_cse_868_ + _cse_869_);
        let _cse_866_ = (_cse_867_ - _cse_1929_);
        let _cse_865_ = (_cse_1929_ + _cse_866_);
        let _cse_874_ = ((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f));
        let _cse_876_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_875_ = (_cse_876_ * 0.125f);
        let _cse_873_ = (_cse_874_ + _cse_875_);
        let _cse_872_ = (_cse_873_ - _cse_1933_);
        let _cse_871_ = (_cse_1933_ + _cse_872_);
        let _cse_864_ = vec2<f32>(_cse_865_, _cse_871_);
        let _cse_863_ = _cse_864_.x;
        let _cse_885_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e4903 = lambda;
        let _cse_884_ = (_cse_885_ * _e4903);
        let _cse_886_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_883_ = (_cse_884_ + _cse_886_);
        let _cse_895_ = state[((owner_1 * 22u) + 10u)];
        let _cse_896_ = state[((owner_1 * 22u) + 11u)];
        let _cse_894_ = vec2<f32>(_cse_895_, _cse_896_);
        let _cse_893_ = _cse_894_.x;
        let _cse_891_ = (_cse_1276_ - _cse_893_);
        let _cse_890_ = (_cse_891_ / max(dist, 0.000001f));
        let _e4928 = normal_vec;
        let _cse_897_ = dot(_e4928, _cse_883_);
        let _cse_889_ = (_cse_890_ - _cse_897_);
        let _cse_888_ = (select(0f, 1f, is_boundary_1) * _cse_889_);
        let _e4935 = normal_vec;
        let _cse_887_ = (_e4935 * _cse_888_);
        let _cse_882_ = (_cse_883_ + _cse_887_);
        let _cse_881_ = _cse_882_.x;
        let _cse_904_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e4944 = lambda;
        let _cse_903_ = (_cse_904_ * _e4944);
        let _cse_902_ = (_cse_903_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _cse_909_ = (_cse_1392_ - _cse_894_.y);
        let _cse_908_ = (_cse_909_ / max(dist, 0.000001f));
        let _e4954 = normal_vec;
        let _cse_907_ = (_cse_908_ - dot(_e4954, _cse_902_));
        let _cse_906_ = (select(0f, 1f, is_boundary_1) * _cse_907_);
        let _e4961 = normal_vec;
        let _cse_905_ = (_e4961 * _cse_906_);
        let _cse_901_ = (_cse_902_ + _cse_905_);
        let _cse_900_ = _cse_901_.y;
        let _cse_899_ = (_cse_881_ + _cse_900_);
        let _cse_898_ = (0.6666667f * _cse_899_);
        let _cse_880_ = (_cse_881_ - _cse_898_);
        let _e4970 = normal_vec.x;
        let _cse_879_ = (_cse_880_ * _e4970);
        let _cse_911_ = _cse_882_.y;
        let _e4974 = normal_vec.y;
        let _cse_910_ = (_cse_911_ * _e4974);
        let _cse_878_ = (_cse_879_ + _cse_910_);
        let _e4979 = constants.viscosity;
        let _cse_877_ = (_e4979 * _cse_878_);
        let _cse_912_ = ((((_e758 + (_e758 * 0.625f)) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758);
        u_l_1_ = _cse_849_;
        u_r_1_ = _cse_863_;
        let _e5015 = normal_vec;
        let _e5033 = constants.eos_r;
        let _e5050 = normal_vec.x;
        f_l_1_ = (((_cse_849_ * dot(((_cse_850_ * 1f) / vec2(((((_e234 + (_e234 * 0.625f)) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), _e5015)) + (((((((_e234 + (_e234 * 0.625f)) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * _e5033) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) * _e5050)) - _cse_877_);
        let _e5058 = normal_vec;
        let _e5063 = constants.eos_r;
        let _e5084 = normal_vec.x;
        f_r_1_ = (((_cse_863_ * dot(((_cse_864_ * 1f) / vec2(_cse_912_)), _e5058)) + (((_cse_912_ * _e5063) * ((((_e536 + (_e536 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)) * _e5084)) - _cse_877_);
    }
    let _e5090 = constants.scheme;
    if ((_e5090 == 3u) && !(is_boundary_1)) {
        let _cse_920_ = (_cse_1929_ - _cse_1992_);
        let _cse_919_ = min(_cse_920_, 0f);
        let _cse_918_ = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), _cse_919_);
        let _cse_922_ = max(_cse_920_, 0f);
        let _cse_917_ = min(_cse_918_, _cse_922_);
        let _cse_915_ = (_cse_1992_ + _cse_917_);
        let _cse_928_ = (_cse_1933_ - _cse_1931_);
        let _cse_927_ = min(_cse_928_, 0f);
        let _cse_926_ = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), _cse_927_);
        let _cse_930_ = max(_cse_928_, 0f);
        let _cse_925_ = min(_cse_926_, _cse_930_);
        let _cse_923_ = (_cse_1931_ + _cse_925_);
        let _cse_914_ = vec2<f32>(_cse_915_, _cse_923_);
        let _cse_913_ = _cse_914_.x;
        let _cse_937_ = (_cse_1992_ - _cse_1929_);
        let _cse_936_ = min(_cse_937_, 0f);
        let _cse_935_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), _cse_936_);
        let _cse_938_ = max(_cse_937_, 0f);
        let _cse_934_ = min(_cse_935_, _cse_938_);
        let _cse_933_ = (_cse_1929_ + _cse_934_);
        let _cse_943_ = (_cse_1931_ - _cse_1933_);
        let _cse_942_ = min(_cse_943_, 0f);
        let _cse_941_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), _cse_942_);
        let _cse_944_ = max(_cse_943_, 0f);
        let _cse_940_ = min(_cse_941_, _cse_944_);
        let _cse_939_ = (_cse_1933_ + _cse_940_);
        let _cse_932_ = vec2<f32>(_cse_933_, _cse_939_);
        let _cse_931_ = _cse_932_.x;
        let _cse_953_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e5156 = lambda;
        let _cse_952_ = (_cse_953_ * _e5156);
        let _cse_954_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_951_ = (_cse_952_ + _cse_954_);
        let _cse_963_ = state[((owner_1 * 22u) + 10u)];
        let _cse_964_ = state[((owner_1 * 22u) + 11u)];
        let _cse_962_ = vec2<f32>(_cse_963_, _cse_964_);
        let _cse_961_ = _cse_962_.x;
        let _cse_959_ = (_cse_1276_ - _cse_961_);
        let _cse_958_ = (_cse_959_ / max(dist, 0.000001f));
        let _e5181 = normal_vec;
        let _cse_965_ = dot(_e5181, _cse_951_);
        let _cse_957_ = (_cse_958_ - _cse_965_);
        let _cse_956_ = (select(0f, 1f, is_boundary_1) * _cse_957_);
        let _e5188 = normal_vec;
        let _cse_955_ = (_e5188 * _cse_956_);
        let _cse_950_ = (_cse_951_ + _cse_955_);
        let _cse_949_ = _cse_950_.x;
        let _e5197 = lambda;
        let _cse_971_ = (vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e5197);
        let _cse_970_ = (_cse_971_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _e5207 = normal_vec;
        let _cse_974_ = (((_cse_1392_ - _cse_962_.y) / max(dist, 0.000001f)) - dot(_e5207, _cse_970_));
        let _cse_973_ = (select(0f, 1f, is_boundary_1) * _cse_974_);
        let _e5214 = normal_vec;
        let _cse_972_ = (_e5214 * _cse_973_);
        let _cse_969_ = (_cse_970_ + _cse_972_);
        let _cse_968_ = _cse_969_.y;
        let _cse_967_ = (_cse_949_ + _cse_968_);
        let _cse_966_ = (0.6666667f * _cse_967_);
        let _cse_948_ = (_cse_949_ - _cse_966_);
        let _e5223 = normal_vec.x;
        let _cse_947_ = (_cse_948_ * _e5223);
        let _cse_976_ = _cse_950_.y;
        let _e5227 = normal_vec.y;
        let _cse_975_ = (_cse_976_ * _e5227);
        let _cse_946_ = (_cse_947_ + _cse_975_);
        let _e5232 = constants.viscosity;
        let _cse_945_ = (_e5232 * _cse_946_);
        u_l_1_ = _cse_913_;
        u_r_1_ = _cse_931_;
        let _e5250 = normal_vec;
        let _e5267 = constants.eos_r;
        let _e5283 = normal_vec.x;
        f_l_1_ = (((_cse_913_ * dot(((_cse_914_ * 1f) / vec2((_e234 + min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))))), _e5250)) + ((((_e234 + min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))) * _e5267) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) * _e5283)) - _cse_945_);
        let _e5307 = normal_vec;
        let _e5328 = constants.eos_r;
        let _e5348 = normal_vec.x;
        f_r_1_ = (((_cse_931_ * dot(((_cse_932_ * 1f) / vec2((_e758 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))))), _e5307)) + ((((_e758 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))) * _e5328) * (_e536 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f)))) * _e5348)) - _cse_945_);
    }
    let _e5354 = constants.scheme;
    if ((_e5354 == 4u) && !(is_boundary_1)) {
        let _cse_980_ = (vec2<f32>(_cse_1929_, _cse_1933_) - vec2<f32>(_cse_1992_, _cse_1931_));
        let _cse_991_ = vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_990_ = dot(_cse_980_, _cse_991_);
        let _cse_992_ = dot(_cse_980_, _cse_980_);
        let _cse_989_ = (_cse_990_ * _cse_992_);
        let _cse_994_ = (_cse_992_ * _cse_992_);
        let _cse_993_ = (_cse_994_ + 0.000000000000000000000000000001f);
        let _cse_988_ = (_cse_989_ / _cse_993_);
        let _cse_987_ = (2f * _cse_988_);
        let _cse_986_ = (_cse_987_ - 1f);
        let _cse_985_ = min(_cse_986_, 1999f);
        let _cse_984_ = max(-2001f, _cse_985_);
        let _cse_995_ = abs(_cse_984_);
        let _cse_983_ = (_cse_984_ + _cse_995_);
        let _cse_996_ = (1f + _cse_995_);
        let _cse_982_ = (_cse_983_ / _cse_996_);
        let _cse_981_ = (_cse_982_ * lambda_other);
        let _cse_979_ = (_cse_980_ * _cse_981_);
        let _cse_978_ = (vec2<f32>(_cse_1992_, _cse_1931_) + _cse_979_);
        let _cse_977_ = _cse_978_.x;
        let _cse_1011_ = dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)));
        let _cse_1012_ = dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)));
        let _cse_1010_ = vec2<f32>(_cse_1011_, _cse_1012_);
        let _cse_1009_ = dot(_cse_980_, _cse_1010_);
        let _cse_1008_ = (_cse_1009_ * _cse_992_);
        let _cse_1007_ = (_cse_1008_ / _cse_993_);
        let _cse_1006_ = (2f * _cse_1007_);
        let _cse_1005_ = (_cse_1006_ - 1f);
        let _cse_1004_ = min(_cse_1005_, 1999f);
        let _cse_1003_ = max(-2001f, _cse_1004_);
        let _cse_1013_ = abs(_cse_1003_);
        let _cse_1002_ = (_cse_1003_ + _cse_1013_);
        let _cse_1014_ = (1f + _cse_1013_);
        let _cse_1001_ = (_cse_1002_ / _cse_1014_);
        let _e5425 = lambda;
        let _cse_1000_ = (_cse_1001_ * _e5425);
        let _cse_999_ = (_cse_980_ * _cse_1000_);
        let _cse_998_ = (vec2<f32>(_cse_1929_, _cse_1933_) - _cse_999_);
        let _cse_997_ = _cse_998_.x;
        let _cse_1017_ = ((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f);
        let _cse_1016_ = min(_cse_1017_, 1999f);
        let _cse_1015_ = max(-2001f, _cse_1016_);
        let _e5455 = lambda;
        let _cse_1025_ = (vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e5455);
        let _cse_1024_ = (_cse_1025_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _e5466 = state[((owner_1 * 22u) + 10u)];
        let _cse_1030_ = (_cse_1276_ - _e5466);
        let _cse_1029_ = (_cse_1030_ / max(dist, 0.000001f));
        let _e5471 = normal_vec;
        let _cse_1028_ = (_cse_1029_ - dot(_e5471, _cse_1024_));
        let _cse_1027_ = (select(0f, 1f, is_boundary_1) * _cse_1028_);
        let _e5478 = normal_vec;
        let _cse_1026_ = (_e5478 * _cse_1027_);
        let _cse_1023_ = (_cse_1024_ + _cse_1026_);
        let _cse_1022_ = _cse_1023_.x;
        let _e5487 = lambda;
        let _e5492 = normal_vec;
        let _e5503 = state[((owner_1 * 22u) + 11u)];
        let _e5508 = normal_vec;
        let _e5514 = lambda;
        let _cse_1032_ = (_cse_1022_ + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e5487) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e5492 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e5503) / max(dist, 0.000001f)) - dot(_e5508, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e5514) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y);
        let _cse_1031_ = (0.6666667f * _cse_1032_);
        let _cse_1021_ = (_cse_1022_ - _cse_1031_);
        let _e5529 = normal_vec.x;
        let _cse_1020_ = (_cse_1021_ * _e5529);
        let _e5533 = normal_vec.y;
        let _cse_1019_ = (_cse_1020_ + (_cse_1023_.y * _e5533));
        let _e5538 = constants.viscosity;
        let _cse_1018_ = (_e5538 * _cse_1019_);
        let _cse_1040_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f));
        let _cse_1039_ = (2f * _cse_1040_);
        let _cse_1038_ = (_cse_1039_ - 1f);
        let _cse_1037_ = min(_cse_1038_, 1999f);
        let _cse_1036_ = max(-2001f, _cse_1037_);
        let _e5569 = lambda;
        let _cse_1035_ = (((_cse_1036_ + abs(_cse_1036_)) / (1f + abs(_cse_1036_))) * _e5569);
        let _cse_1034_ = (_cse_1035_ * (_e758 - _e234));
        let _cse_1033_ = (_e758 - _cse_1034_);
        u_l_1_ = _cse_977_;
        u_r_1_ = _cse_997_;
        let _e5588 = normal_vec;
        let _e5603 = constants.eos_r;
        let _e5674 = normal_vec.x;
        f_l_1_ = (((_cse_977_ * dot(((_cse_978_ * 1f) / vec2((_e234 + ((((_cse_1015_ + abs(_cse_1015_)) / (1f + abs(_cse_1015_))) * lambda_other) * (_e758 - _e234))))), _e5588)) + ((((_e234 + ((((_cse_1015_ + abs(_cse_1015_)) / (1f + abs(_cse_1015_))) * lambda_other) * (_e758 - _e234))) * _e5603) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) * _e5674)) - _cse_1018_);
        let _e5682 = normal_vec;
        let _e5687 = constants.eos_r;
        let _e5764 = lambda;
        let _e5771 = normal_vec.x;
        f_r_1_ = (((_cse_997_ * dot(((_cse_998_ * 1f) / vec2(_cse_1033_)), _e5682)) + (((_cse_1033_ * _e5687) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e5764) * (_e536 - _e121)))) * _e5771)) - _cse_1018_);
    }
    let _e5777 = constants.scheme;
    if ((_e5777 == 5u) && !(is_boundary_1)) {
        let _cse_1049_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_1048_ = (_cse_1049_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1047_ = (_cse_1048_ - _cse_1992_);
        let _cse_1051_ = (_cse_1929_ - _cse_1992_);
        let _cse_1046_ = max(_cse_1047_, min(_cse_1051_, 0f));
        let _cse_1045_ = min(_cse_1046_, max(_cse_1051_, 0f));
        let _cse_1043_ = (_cse_1992_ + _cse_1045_);
        let _cse_1058_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_1057_ = (_cse_1058_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1056_ = (_cse_1057_ - _cse_1931_);
        let _cse_1060_ = (_cse_1933_ - _cse_1931_);
        let _cse_1055_ = max(_cse_1056_, min(_cse_1060_, 0f));
        let _cse_1054_ = min(_cse_1055_, max(_cse_1060_, 0f));
        let _cse_1052_ = (_cse_1931_ + _cse_1054_);
        let _cse_1042_ = vec2<f32>(_cse_1043_, _cse_1052_);
        let _cse_1041_ = _cse_1042_.x;
        let _cse_1068_ = ((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f));
        let _cse_1067_ = (_cse_1068_ + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1066_ = (_cse_1067_ - _cse_1929_);
        let _cse_1069_ = (_cse_1992_ - _cse_1929_);
        let _cse_1065_ = max(_cse_1066_, min(_cse_1069_, 0f));
        let _cse_1064_ = min(_cse_1065_, max(_cse_1069_, 0f));
        let _cse_1063_ = (_cse_1929_ + _cse_1064_);
        let _cse_1075_ = ((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f));
        let _cse_1074_ = (_cse_1075_ + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1073_ = (_cse_1074_ - _cse_1933_);
        let _cse_1076_ = (_cse_1931_ - _cse_1933_);
        let _cse_1072_ = max(_cse_1073_, min(_cse_1076_, 0f));
        let _cse_1071_ = min(_cse_1072_, max(_cse_1076_, 0f));
        let _cse_1070_ = (_cse_1933_ + _cse_1071_);
        let _cse_1062_ = vec2<f32>(_cse_1063_, _cse_1070_);
        let _cse_1061_ = _cse_1062_.x;
        let _cse_1085_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e5879 = lambda;
        let _cse_1084_ = (_cse_1085_ * _e5879);
        let _cse_1086_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_1083_ = (_cse_1084_ + _cse_1086_);
        let _e5890 = state[((owner_1 * 22u) + 10u)];
        let _e5897 = state[((owner_1 * 22u) + 11u)];
        let _cse_1093_ = vec2<f32>(_e5890, _e5897);
        let _cse_1092_ = _cse_1093_.x;
        let _cse_1091_ = (_cse_1276_ - _cse_1092_);
        let _cse_1090_ = (_cse_1091_ / max(dist, 0.000001f));
        let _e5904 = normal_vec;
        let _cse_1094_ = dot(_e5904, _cse_1083_);
        let _cse_1089_ = (_cse_1090_ - _cse_1094_);
        let _cse_1088_ = (select(0f, 1f, is_boundary_1) * _cse_1089_);
        let _e5911 = normal_vec;
        let _cse_1087_ = (_e5911 * _cse_1088_);
        let _cse_1082_ = (_cse_1083_ + _cse_1087_);
        let _cse_1081_ = _cse_1082_.x;
        let _e5920 = lambda;
        let _cse_1099_ = ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e5920) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _e5930 = normal_vec;
        let _cse_1102_ = (((_cse_1392_ - _cse_1093_.y) / max(dist, 0.000001f)) - dot(_e5930, _cse_1099_));
        let _cse_1101_ = (select(0f, 1f, is_boundary_1) * _cse_1102_);
        let _e5937 = normal_vec;
        let _cse_1100_ = (_e5937 * _cse_1101_);
        let _cse_1098_ = (_cse_1099_ + _cse_1100_);
        let _cse_1097_ = _cse_1098_.y;
        let _cse_1096_ = (_cse_1081_ + _cse_1097_);
        let _cse_1095_ = (0.6666667f * _cse_1096_);
        let _cse_1080_ = (_cse_1081_ - _cse_1095_);
        let _e5946 = normal_vec.x;
        let _cse_1079_ = (_cse_1080_ * _e5946);
        let _cse_1104_ = _cse_1082_.y;
        let _e5950 = normal_vec.y;
        let _cse_1103_ = (_cse_1104_ * _e5950);
        let _cse_1078_ = (_cse_1079_ + _cse_1103_);
        let _e5955 = constants.viscosity;
        let _cse_1077_ = (_e5955 * _cse_1078_);
        u_l_1_ = _cse_1041_;
        u_r_1_ = _cse_1061_;
        let _e5982 = normal_vec;
        let _e6008 = constants.eos_r;
        let _e6033 = normal_vec.x;
        f_l_1_ = (((_cse_1041_ * dot(((_cse_1042_ * 1f) / vec2((_e234 + min(max(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))))), _e5982)) + ((((_e234 + min(max(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))) * _e6008) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) * _e6033)) - _cse_1077_);
        let _e6066 = normal_vec;
        let _e6096 = constants.eos_r;
        let _e6125 = normal_vec.x;
        f_r_1_ = (((_cse_1061_ * dot(((_cse_1062_ * 1f) / vec2((_e758 + min(max(((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))))), _e6066)) + ((((_e758 + min(max(((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))) * _e6096) * (_e536 + min(max(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f)))) * _e6125)) - _cse_1077_);
    }
    let _e6131 = constants.scheme;
    if ((_e6131 == 6u) && !(is_boundary_1)) {
        let _cse_1113_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_1112_ = (_cse_1113_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1111_ = (_cse_1112_ - _cse_1992_);
        let _cse_1116_ = (_cse_1929_ - _cse_1992_);
        let _cse_1115_ = (abs(_cse_1116_) / max(abs(_cse_1116_), (abs(_cse_1111_) + 0.00000001f)));
        let _cse_1110_ = (_cse_1111_ * _cse_1115_);
        let _cse_1118_ = (_cse_1116_ * _cse_1111_);
        let _cse_1117_ = (max(_cse_1118_, 0f) / max(abs(_cse_1118_), 0.00000001f));
        let _cse_1109_ = (_cse_1110_ * _cse_1117_);
        let _cse_1107_ = (_cse_1992_ + _cse_1109_);
        let _cse_1125_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_1124_ = (_cse_1125_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1123_ = (_cse_1124_ - _cse_1931_);
        let _cse_1128_ = (_cse_1933_ - _cse_1931_);
        let _cse_1127_ = (abs(_cse_1128_) / max(abs(_cse_1128_), (abs(_cse_1123_) + 0.00000001f)));
        let _cse_1122_ = (_cse_1123_ * _cse_1127_);
        let _cse_1130_ = (_cse_1128_ * _cse_1123_);
        let _cse_1129_ = (max(_cse_1130_, 0f) / max(abs(_cse_1130_), 0.00000001f));
        let _cse_1121_ = (_cse_1122_ * _cse_1129_);
        let _cse_1119_ = (_cse_1931_ + _cse_1121_);
        let _cse_1106_ = vec2<f32>(_cse_1107_, _cse_1119_);
        let _cse_1105_ = _cse_1106_.x;
        let _cse_1138_ = ((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f));
        let _cse_1139_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1137_ = (_cse_1138_ + _cse_1139_);
        let _cse_1136_ = (_cse_1137_ - _cse_1929_);
        let _cse_1141_ = (_cse_1992_ - _cse_1929_);
        let _cse_1140_ = (abs(_cse_1141_) / max(abs(_cse_1141_), (abs(_cse_1136_) + 0.00000001f)));
        let _cse_1135_ = (_cse_1136_ * _cse_1140_);
        let _cse_1143_ = (_cse_1141_ * _cse_1136_);
        let _cse_1142_ = (max(_cse_1143_, 0f) / max(abs(_cse_1143_), 0.00000001f));
        let _cse_1134_ = (_cse_1135_ * _cse_1142_);
        let _cse_1133_ = (_cse_1929_ + _cse_1134_);
        let _cse_1149_ = ((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f));
        let _cse_1150_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1148_ = (_cse_1149_ + _cse_1150_);
        let _cse_1147_ = (_cse_1148_ - _cse_1933_);
        let _cse_1152_ = (_cse_1931_ - _cse_1933_);
        let _cse_1151_ = (abs(_cse_1152_) / max(abs(_cse_1152_), (abs(_cse_1147_) + 0.00000001f)));
        let _cse_1146_ = (_cse_1147_ * _cse_1151_);
        let _cse_1154_ = (_cse_1152_ * _cse_1147_);
        let _cse_1153_ = (max(_cse_1154_, 0f) / max(abs(_cse_1154_), 0.00000001f));
        let _cse_1145_ = (_cse_1146_ * _cse_1153_);
        let _cse_1144_ = (_cse_1933_ + _cse_1145_);
        let _cse_1132_ = vec2<f32>(_cse_1133_, _cse_1144_);
        let _cse_1131_ = _cse_1132_.x;
        let _e6273 = lambda;
        let _cse_1161_ = ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6273) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _e6284 = state[((owner_1 * 22u) + 10u)];
        let _cse_1165_ = ((_cse_1276_ - _e6284) / max(dist, 0.000001f));
        let _e6289 = normal_vec;
        let _cse_1164_ = (_cse_1165_ - dot(_e6289, _cse_1161_));
        let _cse_1163_ = (select(0f, 1f, is_boundary_1) * _cse_1164_);
        let _e6296 = normal_vec;
        let _cse_1162_ = (_e6296 * _cse_1163_);
        let _cse_1160_ = (_cse_1161_ + _cse_1162_);
        let _cse_1159_ = _cse_1160_.x;
        let _e6305 = lambda;
        let _e6310 = normal_vec;
        let _e6321 = state[((owner_1 * 22u) + 11u)];
        let _e6326 = normal_vec;
        let _e6332 = lambda;
        let _cse_1167_ = (_cse_1159_ + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6305) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e6310 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e6321) / max(dist, 0.000001f)) - dot(_e6326, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6332) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y);
        let _cse_1166_ = (0.6666667f * _cse_1167_);
        let _cse_1158_ = (_cse_1159_ - _cse_1166_);
        let _e6347 = normal_vec.x;
        let _cse_1157_ = (_cse_1158_ * _e6347);
        let _e6351 = normal_vec.y;
        let _cse_1156_ = (_cse_1157_ + (_cse_1160_.y * _e6351));
        let _e6356 = constants.viscosity;
        let _cse_1155_ = (_e6356 * _cse_1156_);
        let _cse_1168_ = ((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758);
        u_l_1_ = _cse_1105_;
        u_r_1_ = _cse_1131_;
        let _e6448 = normal_vec;
        let _e6523 = constants.eos_r;
        let _e6597 = normal_vec.x;
        f_l_1_ = (((_cse_1105_ * dot(((_cse_1106_ * 1f) / vec2((_e234 + ((((((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e758 - _e234))) / max(abs((_e758 - _e234)), (abs(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))))), _e6448)) + ((((_e234 + ((((((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e758 - _e234))) / max(abs((_e758 - _e234)), (abs(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))) * _e6523) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) * _e6597)) - _cse_1155_);
        let _e6627 = normal_vec;
        let _e6654 = constants.eos_r;
        let _e6744 = normal_vec.x;
        f_r_1_ = (((_cse_1131_ * dot(((_cse_1132_ * 1f) / vec2((_e758 + ((((_cse_1168_ * abs((_e234 - _e758))) / max(abs((_e234 - _e758)), (abs(_cse_1168_) + 0.00000001f))) * max(((_e234 - _e758) * _cse_1168_), 0f)) / max(abs(((_e234 - _e758) * _cse_1168_)), 0.00000001f))))), _e6627)) + ((((_e758 + ((((_cse_1168_ * abs((_e234 - _e758))) / max(abs((_e234 - _e758)), (abs(_cse_1168_) + 0.00000001f))) * max(((_e234 - _e758) * _cse_1168_), 0f)) / max(abs(((_e234 - _e758) * _cse_1168_)), 0.00000001f))) * _e6654) * (_e536 + ((((((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536) * abs((_e121 - _e536))) / max(abs((_e121 - _e536)), (abs(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)) + 0.00000001f))) * max(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)), 0f)) / max(abs(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536))), 0.00000001f)))) * _e6744)) - _cse_1155_);
    }
    let _e6754 = a_plus;
    let _e6755 = f_l_1_;
    let _e6757 = a_minus;
    let _e6758 = f_r_1_;
    let _e6761 = a_plus;
    let _e6762 = a_minus;
    let _e6764 = u_r_1_;
    let _e6765 = u_l_1_;
    fluxes[((idx * 8u) + 1u)] = (((((_e6754 * _e6755) - (_e6757 * _e6758)) + ((_e6761 * _e6762) * (_e6764 - _e6765))) / denom) * area);
    let _cse_1170_ = vec2<f32>(_cse_1992_, _cse_1931_);
    let _cse_1169_ = _cse_1170_.y;
    let _cse_1174_ = vec2<f32>(_cse_1929_, _cse_1933_);
    let _cse_1173_ = _cse_1174_.y;
    let _cse_1177_ = normal_vec.y;
    let _cse_1185_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
    let _e6782 = lambda;
    let _cse_1184_ = (_cse_1185_ * _e6782);
    let _cse_1186_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
    let _cse_1183_ = (_cse_1184_ + _cse_1186_);
    let _cse_1195_ = state[((owner_1 * 22u) + 10u)];
    let _cse_1196_ = state[((owner_1 * 22u) + 11u)];
    let _cse_1194_ = vec2<f32>(_cse_1195_, _cse_1196_);
    let _cse_1193_ = _cse_1194_.y;
    let _cse_1191_ = (_cse_1392_ - _cse_1193_);
    let _cse_1190_ = (_cse_1191_ / max(dist, 0.000001f));
    let _e6807 = normal_vec;
    let _cse_1197_ = dot(_e6807, _cse_1183_);
    let _cse_1189_ = (_cse_1190_ - _cse_1197_);
    let _cse_1188_ = (select(0f, 1f, is_boundary_1) * _cse_1189_);
    let _e6814 = normal_vec;
    let _cse_1187_ = (_e6814 * _cse_1188_);
    let _cse_1182_ = (_cse_1183_ + _cse_1187_);
    let _cse_1181_ = _cse_1182_.x;
    let _cse_1198_ = normal_vec.x;
    let _cse_1180_ = (_cse_1181_ * _cse_1198_);
    let _cse_1201_ = _cse_1182_.y;
    let _cse_1208_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
    let _e6827 = lambda;
    let _cse_1207_ = (_cse_1208_ * _e6827);
    let _cse_1209_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
    let _cse_1206_ = (_cse_1207_ + _cse_1209_);
    let _cse_1216_ = _cse_1194_.x;
    let _cse_1214_ = (_cse_1276_ - _cse_1216_);
    let _cse_1213_ = (_cse_1214_ / max(dist, 0.000001f));
    let _e6837 = normal_vec;
    let _cse_1217_ = dot(_e6837, _cse_1206_);
    let _cse_1212_ = (_cse_1213_ - _cse_1217_);
    let _cse_1211_ = (select(0f, 1f, is_boundary_1) * _cse_1212_);
    let _e6844 = normal_vec;
    let _cse_1210_ = (_e6844 * _cse_1211_);
    let _cse_1205_ = (_cse_1206_ + _cse_1210_);
    let _cse_1204_ = _cse_1205_.x;
    let _cse_1203_ = (_cse_1204_ + _cse_1201_);
    let _cse_1202_ = (0.6666667f * _cse_1203_);
    let _cse_1200_ = (_cse_1201_ - _cse_1202_);
    let _cse_1199_ = (_cse_1200_ * _cse_1177_);
    let _cse_1179_ = (_cse_1180_ + _cse_1199_);
    let _e6856 = constants.viscosity;
    let _cse_1178_ = (_e6856 * _cse_1179_);
    u_l_2_ = _cse_1169_;
    u_r_2_ = _cse_1173_;
    let _e6864 = normal_vec;
    let _e6869 = constants.eos_r;
    f_l_2_ = (((_cse_1169_ * dot(((_cse_1170_ * 1f) / vec2(_e234)), _e6864)) + (((_e234 * _e6869) * _e121) * _cse_1177_)) - _cse_1178_);
    let _e6880 = normal_vec;
    let _e6885 = constants.eos_r;
    f_r_2_ = (((_cse_1173_ * dot(((_cse_1174_ * 1f) / vec2(_e758)), _e6880)) + (((_e758 * _e6885) * _e536) * _cse_1177_)) - _cse_1178_);
    let _e6894 = constants.scheme;
    if ((_e6894 == 1u) && !(is_boundary_1)) {
        let _cse_1222_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_1220_ = (_cse_1992_ + _cse_1222_);
        let _cse_1225_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_1223_ = (_cse_1931_ + _cse_1225_);
        let _cse_1219_ = vec2<f32>(_cse_1220_, _cse_1223_);
        let _cse_1218_ = _cse_1219_.y;
        let _cse_1231_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_1230_ = dot(_cse_1231_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1228_ = (_cse_1929_ + _cse_1230_);
        let _cse_1235_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_1234_ = dot(_cse_1235_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1232_ = (_cse_1933_ + _cse_1234_);
        let _cse_1227_ = vec2<f32>(_cse_1228_, _cse_1232_);
        let _cse_1226_ = _cse_1227_.y;
        let _cse_1237_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_1236_ = (_e234 + _cse_1237_);
        let _cse_1238_ = normal_vec.y;
        let _cse_1246_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e6938 = lambda;
        let _cse_1245_ = (_cse_1246_ * _e6938);
        let _cse_1247_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_1244_ = (_cse_1245_ + _cse_1247_);
        let _cse_1256_ = state[((owner_1 * 22u) + 10u)];
        let _cse_1257_ = state[((owner_1 * 22u) + 11u)];
        let _cse_1255_ = vec2<f32>(_cse_1256_, _cse_1257_);
        let _cse_1254_ = _cse_1255_.y;
        let _cse_1252_ = (_cse_1392_ - _cse_1254_);
        let _cse_1251_ = (_cse_1252_ / max(dist, 0.000001f));
        let _e6963 = normal_vec;
        let _cse_1258_ = dot(_e6963, _cse_1244_);
        let _cse_1250_ = (_cse_1251_ - _cse_1258_);
        let _cse_1249_ = (select(0f, 1f, is_boundary_1) * _cse_1250_);
        let _e6970 = normal_vec;
        let _cse_1248_ = (_e6970 * _cse_1249_);
        let _cse_1243_ = (_cse_1244_ + _cse_1248_);
        let _cse_1242_ = _cse_1243_.x;
        let _cse_1259_ = normal_vec.x;
        let _cse_1241_ = (_cse_1242_ * _cse_1259_);
        let _cse_1262_ = _cse_1243_.y;
        let _cse_1269_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e6983 = lambda;
        let _cse_1268_ = (_cse_1269_ * _e6983);
        let _cse_1270_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_1267_ = (_cse_1268_ + _cse_1270_);
        let _cse_1277_ = _cse_1255_.x;
        let _cse_1275_ = (_cse_1276_ - _cse_1277_);
        let _cse_1274_ = (_cse_1275_ / max(dist, 0.000001f));
        let _e6993 = normal_vec;
        let _cse_1278_ = dot(_e6993, _cse_1267_);
        let _cse_1273_ = (_cse_1274_ - _cse_1278_);
        let _cse_1272_ = (select(0f, 1f, is_boundary_1) * _cse_1273_);
        let _e7000 = normal_vec;
        let _cse_1271_ = (_e7000 * _cse_1272_);
        let _cse_1266_ = (_cse_1267_ + _cse_1271_);
        let _cse_1265_ = _cse_1266_.x;
        let _cse_1264_ = (_cse_1265_ + _cse_1262_);
        let _cse_1263_ = (0.6666667f * _cse_1264_);
        let _cse_1261_ = (_cse_1262_ - _cse_1263_);
        let _cse_1260_ = (_cse_1261_ * _cse_1238_);
        let _cse_1240_ = (_cse_1241_ + _cse_1260_);
        let _e7012 = constants.viscosity;
        let _cse_1239_ = (_e7012 * _cse_1240_);
        let _cse_1281_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1280_ = dot(_cse_1281_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1279_ = (_e758 + _cse_1280_);
        u_l_2_ = _cse_1218_;
        u_r_2_ = _cse_1226_;
        let _e7026 = normal_vec;
        let _e7031 = constants.eos_r;
        f_l_2_ = (((_cse_1218_ * dot(((_cse_1219_ * 1f) / vec2(_cse_1236_)), _e7026)) + (((_cse_1236_ * _e7031) * (_e121 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)))) * _cse_1238_)) - _cse_1239_);
        let _e7045 = normal_vec;
        let _e7050 = constants.eos_r;
        f_r_2_ = (((_cse_1226_ * dot(((_cse_1227_ * 1f) / vec2(_cse_1279_)), _e7045)) + (((_cse_1279_ * _e7050) * (_e536 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)))) * _cse_1238_)) - _cse_1239_);
    }
    let _e7066 = constants.scheme;
    if ((_e7066 == 2u) && !(is_boundary_1)) {
        let _cse_1288_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_1287_ = (_cse_1288_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1286_ = (_cse_1287_ - _cse_1992_);
        let _cse_1284_ = (_cse_1992_ + _cse_1286_);
        let _cse_1294_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_1293_ = (_cse_1294_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1292_ = (_cse_1293_ - _cse_1931_);
        let _cse_1290_ = (_cse_1931_ + _cse_1292_);
        let _cse_1283_ = vec2<f32>(_cse_1284_, _cse_1290_);
        let _cse_1282_ = _cse_1283_.y;
        let _cse_1301_ = ((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f));
        let _cse_1303_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1302_ = (_cse_1303_ * 0.125f);
        let _cse_1300_ = (_cse_1301_ + _cse_1302_);
        let _cse_1299_ = (_cse_1300_ - _cse_1929_);
        let _cse_1298_ = (_cse_1929_ + _cse_1299_);
        let _cse_1307_ = ((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f));
        let _cse_1309_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1308_ = (_cse_1309_ * 0.125f);
        let _cse_1306_ = (_cse_1307_ + _cse_1308_);
        let _cse_1305_ = (_cse_1306_ - _cse_1933_);
        let _cse_1304_ = (_cse_1933_ + _cse_1305_);
        let _cse_1297_ = vec2<f32>(_cse_1298_, _cse_1304_);
        let _cse_1296_ = _cse_1297_.y;
        let _cse_1317_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e7140 = lambda;
        let _cse_1316_ = (_cse_1317_ * _e7140);
        let _cse_1318_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_1315_ = (_cse_1316_ + _cse_1318_);
        let _cse_1327_ = state[((owner_1 * 22u) + 10u)];
        let _cse_1328_ = state[((owner_1 * 22u) + 11u)];
        let _cse_1326_ = vec2<f32>(_cse_1327_, _cse_1328_);
        let _cse_1325_ = _cse_1326_.y;
        let _cse_1323_ = (_cse_1392_ - _cse_1325_);
        let _cse_1322_ = (_cse_1323_ / max(dist, 0.000001f));
        let _e7165 = normal_vec;
        let _cse_1329_ = dot(_e7165, _cse_1315_);
        let _cse_1321_ = (_cse_1322_ - _cse_1329_);
        let _cse_1320_ = (select(0f, 1f, is_boundary_1) * _cse_1321_);
        let _e7172 = normal_vec;
        let _cse_1319_ = (_e7172 * _cse_1320_);
        let _cse_1314_ = (_cse_1315_ + _cse_1319_);
        let _cse_1313_ = _cse_1314_.x;
        let _e7177 = normal_vec.x;
        let _cse_1312_ = (_cse_1313_ * _e7177);
        let _cse_1332_ = _cse_1314_.y;
        let _cse_1339_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e7185 = lambda;
        let _cse_1338_ = (_cse_1339_ * _e7185);
        let _cse_1337_ = (_cse_1338_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _cse_1344_ = (_cse_1276_ - _cse_1326_.x);
        let _cse_1343_ = (_cse_1344_ / max(dist, 0.000001f));
        let _e7195 = normal_vec;
        let _cse_1342_ = (_cse_1343_ - dot(_e7195, _cse_1337_));
        let _cse_1341_ = (select(0f, 1f, is_boundary_1) * _cse_1342_);
        let _e7202 = normal_vec;
        let _cse_1340_ = (_e7202 * _cse_1341_);
        let _cse_1336_ = (_cse_1337_ + _cse_1340_);
        let _cse_1335_ = _cse_1336_.x;
        let _cse_1334_ = (_cse_1335_ + _cse_1332_);
        let _cse_1333_ = (0.6666667f * _cse_1334_);
        let _cse_1331_ = (_cse_1332_ - _cse_1333_);
        let _e7211 = normal_vec.y;
        let _cse_1330_ = (_cse_1331_ * _e7211);
        let _cse_1311_ = (_cse_1312_ + _cse_1330_);
        let _e7216 = constants.viscosity;
        let _cse_1310_ = (_e7216 * _cse_1311_);
        let _cse_1345_ = ((((_e758 + (_e758 * 0.625f)) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758);
        u_l_2_ = _cse_1282_;
        u_r_2_ = _cse_1296_;
        let _e7252 = normal_vec;
        let _e7270 = constants.eos_r;
        let _e7287 = normal_vec.y;
        f_l_2_ = (((_cse_1282_ * dot(((_cse_1283_ * 1f) / vec2(((((_e234 + (_e234 * 0.625f)) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), _e7252)) + (((((((_e234 + (_e234 * 0.625f)) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * _e7270) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) * _e7287)) - _cse_1310_);
        let _e7295 = normal_vec;
        let _e7300 = constants.eos_r;
        let _e7321 = normal_vec.y;
        f_r_2_ = (((_cse_1296_ * dot(((_cse_1297_ * 1f) / vec2(_cse_1345_)), _e7295)) + (((_cse_1345_ * _e7300) * ((((_e536 + (_e536 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)) * _e7321)) - _cse_1310_);
    }
    let _e7327 = constants.scheme;
    if ((_e7327 == 3u) && !(is_boundary_1)) {
        let _cse_1353_ = (_cse_1929_ - _cse_1992_);
        let _cse_1352_ = min(_cse_1353_, 0f);
        let _cse_1351_ = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), _cse_1352_);
        let _cse_1355_ = max(_cse_1353_, 0f);
        let _cse_1350_ = min(_cse_1351_, _cse_1355_);
        let _cse_1348_ = (_cse_1992_ + _cse_1350_);
        let _cse_1361_ = (_cse_1933_ - _cse_1931_);
        let _cse_1360_ = min(_cse_1361_, 0f);
        let _cse_1359_ = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), _cse_1360_);
        let _cse_1363_ = max(_cse_1361_, 0f);
        let _cse_1358_ = min(_cse_1359_, _cse_1363_);
        let _cse_1356_ = (_cse_1931_ + _cse_1358_);
        let _cse_1347_ = vec2<f32>(_cse_1348_, _cse_1356_);
        let _cse_1346_ = _cse_1347_.y;
        let _cse_1370_ = (_cse_1992_ - _cse_1929_);
        let _cse_1369_ = min(_cse_1370_, 0f);
        let _cse_1368_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), _cse_1369_);
        let _cse_1371_ = max(_cse_1370_, 0f);
        let _cse_1367_ = min(_cse_1368_, _cse_1371_);
        let _cse_1366_ = (_cse_1929_ + _cse_1367_);
        let _cse_1376_ = (_cse_1931_ - _cse_1933_);
        let _cse_1375_ = min(_cse_1376_, 0f);
        let _cse_1374_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), _cse_1375_);
        let _cse_1377_ = max(_cse_1376_, 0f);
        let _cse_1373_ = min(_cse_1374_, _cse_1377_);
        let _cse_1372_ = (_cse_1933_ + _cse_1373_);
        let _cse_1365_ = vec2<f32>(_cse_1366_, _cse_1372_);
        let _cse_1364_ = _cse_1365_.y;
        let _cse_1385_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e7393 = lambda;
        let _cse_1384_ = (_cse_1385_ * _e7393);
        let _cse_1386_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_1383_ = (_cse_1384_ + _cse_1386_);
        let _cse_1395_ = state[((owner_1 * 22u) + 10u)];
        let _cse_1396_ = state[((owner_1 * 22u) + 11u)];
        let _cse_1394_ = vec2<f32>(_cse_1395_, _cse_1396_);
        let _cse_1393_ = _cse_1394_.y;
        let _cse_1391_ = (_cse_1392_ - _cse_1393_);
        let _cse_1390_ = (_cse_1391_ / max(dist, 0.000001f));
        let _e7418 = normal_vec;
        let _cse_1397_ = dot(_e7418, _cse_1383_);
        let _cse_1389_ = (_cse_1390_ - _cse_1397_);
        let _cse_1388_ = (select(0f, 1f, is_boundary_1) * _cse_1389_);
        let _e7425 = normal_vec;
        let _cse_1387_ = (_e7425 * _cse_1388_);
        let _cse_1382_ = (_cse_1383_ + _cse_1387_);
        let _cse_1381_ = _cse_1382_.x;
        let _e7430 = normal_vec.x;
        let _cse_1380_ = (_cse_1381_ * _e7430);
        let _cse_1400_ = _cse_1382_.y;
        let _e7438 = lambda;
        let _cse_1406_ = (vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e7438);
        let _cse_1405_ = (_cse_1406_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _e7448 = normal_vec;
        let _cse_1409_ = (((_cse_1276_ - _cse_1394_.x) / max(dist, 0.000001f)) - dot(_e7448, _cse_1405_));
        let _cse_1408_ = (select(0f, 1f, is_boundary_1) * _cse_1409_);
        let _e7455 = normal_vec;
        let _cse_1407_ = (_e7455 * _cse_1408_);
        let _cse_1404_ = (_cse_1405_ + _cse_1407_);
        let _cse_1403_ = _cse_1404_.x;
        let _cse_1402_ = (_cse_1403_ + _cse_1400_);
        let _cse_1401_ = (0.6666667f * _cse_1402_);
        let _cse_1399_ = (_cse_1400_ - _cse_1401_);
        let _e7464 = normal_vec.y;
        let _cse_1398_ = (_cse_1399_ * _e7464);
        let _cse_1379_ = (_cse_1380_ + _cse_1398_);
        let _e7469 = constants.viscosity;
        let _cse_1378_ = (_e7469 * _cse_1379_);
        u_l_2_ = _cse_1346_;
        u_r_2_ = _cse_1364_;
        let _e7487 = normal_vec;
        let _e7504 = constants.eos_r;
        let _e7520 = normal_vec.y;
        f_l_2_ = (((_cse_1346_ * dot(((_cse_1347_ * 1f) / vec2((_e234 + min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))))), _e7487)) + ((((_e234 + min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))) * _e7504) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) * _e7520)) - _cse_1378_);
        let _e7544 = normal_vec;
        let _e7565 = constants.eos_r;
        let _e7585 = normal_vec.y;
        f_r_2_ = (((_cse_1364_ * dot(((_cse_1365_ * 1f) / vec2((_e758 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))))), _e7544)) + ((((_e758 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))) * _e7565) * (_e536 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f)))) * _e7585)) - _cse_1378_);
    }
    let _e7591 = constants.scheme;
    if ((_e7591 == 4u) && !(is_boundary_1)) {
        let _cse_1413_ = (vec2<f32>(_cse_1929_, _cse_1933_) - vec2<f32>(_cse_1992_, _cse_1931_));
        let _cse_1424_ = vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_1423_ = dot(_cse_1413_, _cse_1424_);
        let _cse_1425_ = dot(_cse_1413_, _cse_1413_);
        let _cse_1422_ = (_cse_1423_ * _cse_1425_);
        let _cse_1427_ = (_cse_1425_ * _cse_1425_);
        let _cse_1426_ = (_cse_1427_ + 0.000000000000000000000000000001f);
        let _cse_1421_ = (_cse_1422_ / _cse_1426_);
        let _cse_1420_ = (2f * _cse_1421_);
        let _cse_1419_ = (_cse_1420_ - 1f);
        let _cse_1418_ = min(_cse_1419_, 1999f);
        let _cse_1417_ = max(-2001f, _cse_1418_);
        let _cse_1428_ = abs(_cse_1417_);
        let _cse_1416_ = (_cse_1417_ + _cse_1428_);
        let _cse_1429_ = (1f + _cse_1428_);
        let _cse_1415_ = (_cse_1416_ / _cse_1429_);
        let _cse_1414_ = (_cse_1415_ * lambda_other);
        let _cse_1412_ = (_cse_1413_ * _cse_1414_);
        let _cse_1411_ = (vec2<f32>(_cse_1992_, _cse_1931_) + _cse_1412_);
        let _cse_1410_ = _cse_1411_.y;
        let _cse_1444_ = dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)));
        let _cse_1445_ = dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)));
        let _cse_1443_ = vec2<f32>(_cse_1444_, _cse_1445_);
        let _cse_1442_ = dot(_cse_1413_, _cse_1443_);
        let _cse_1441_ = (_cse_1442_ * _cse_1425_);
        let _cse_1440_ = (_cse_1441_ / _cse_1426_);
        let _cse_1439_ = (2f * _cse_1440_);
        let _cse_1438_ = (_cse_1439_ - 1f);
        let _cse_1437_ = min(_cse_1438_, 1999f);
        let _cse_1436_ = max(-2001f, _cse_1437_);
        let _cse_1446_ = abs(_cse_1436_);
        let _cse_1435_ = (_cse_1436_ + _cse_1446_);
        let _cse_1447_ = (1f + _cse_1446_);
        let _cse_1434_ = (_cse_1435_ / _cse_1447_);
        let _e7662 = lambda;
        let _cse_1433_ = (_cse_1434_ * _e7662);
        let _cse_1432_ = (_cse_1413_ * _cse_1433_);
        let _cse_1431_ = (vec2<f32>(_cse_1929_, _cse_1933_) - _cse_1432_);
        let _cse_1430_ = _cse_1431_.y;
        let _cse_1450_ = ((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f);
        let _cse_1449_ = min(_cse_1450_, 1999f);
        let _cse_1448_ = max(-2001f, _cse_1449_);
        let _e7692 = lambda;
        let _cse_1455_ = (vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e7692);
        let _cse_1454_ = (_cse_1455_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _e7703 = state[((owner_1 * 22u) + 11u)];
        let _cse_1460_ = (_cse_1392_ - _e7703);
        let _cse_1459_ = (_cse_1460_ / max(dist, 0.000001f));
        let _e7708 = normal_vec;
        let _cse_1458_ = (_cse_1459_ - dot(_e7708, _cse_1454_));
        let _cse_1457_ = (select(0f, 1f, is_boundary_1) * _cse_1458_);
        let _e7715 = normal_vec;
        let _cse_1456_ = (_e7715 * _cse_1457_);
        let _cse_1453_ = (_cse_1454_ + _cse_1456_);
        let _cse_1463_ = _cse_1453_.y;
        let _e7724 = lambda;
        let _e7729 = normal_vec;
        let _e7740 = state[((owner_1 * 22u) + 10u)];
        let _e7745 = normal_vec;
        let _e7751 = lambda;
        let _cse_1465_ = ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e7724) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e7729 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e7740) / max(dist, 0.000001f)) - dot(_e7745, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e7751) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + _cse_1463_);
        let _cse_1464_ = (0.6666667f * _cse_1465_);
        let _cse_1462_ = (_cse_1463_ - _cse_1464_);
        let _e7766 = normal_vec.y;
        let _cse_1461_ = (_cse_1462_ * _e7766);
        let _e7770 = normal_vec.x;
        let _cse_1452_ = ((_cse_1453_.x * _e7770) + _cse_1461_);
        let _e7775 = constants.viscosity;
        let _cse_1451_ = (_e7775 * _cse_1452_);
        let _cse_1473_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f));
        let _cse_1472_ = (2f * _cse_1473_);
        let _cse_1471_ = (_cse_1472_ - 1f);
        let _cse_1470_ = min(_cse_1471_, 1999f);
        let _cse_1469_ = max(-2001f, _cse_1470_);
        let _e7806 = lambda;
        let _cse_1468_ = (((_cse_1469_ + abs(_cse_1469_)) / (1f + abs(_cse_1469_))) * _e7806);
        let _cse_1467_ = (_cse_1468_ * (_e758 - _e234));
        let _cse_1466_ = (_e758 - _cse_1467_);
        u_l_2_ = _cse_1410_;
        u_r_2_ = _cse_1430_;
        let _e7825 = normal_vec;
        let _e7840 = constants.eos_r;
        let _e7911 = normal_vec.y;
        f_l_2_ = (((_cse_1410_ * dot(((_cse_1411_ * 1f) / vec2((_e234 + ((((_cse_1448_ + abs(_cse_1448_)) / (1f + abs(_cse_1448_))) * lambda_other) * (_e758 - _e234))))), _e7825)) + ((((_e234 + ((((_cse_1448_ + abs(_cse_1448_)) / (1f + abs(_cse_1448_))) * lambda_other) * (_e758 - _e234))) * _e7840) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) * _e7911)) - _cse_1451_);
        let _e7919 = normal_vec;
        let _e7924 = constants.eos_r;
        let _e8001 = lambda;
        let _e8008 = normal_vec.y;
        f_r_2_ = (((_cse_1430_ * dot(((_cse_1431_ * 1f) / vec2(_cse_1466_)), _e7919)) + (((_cse_1466_ * _e7924) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e8001) * (_e536 - _e121)))) * _e8008)) - _cse_1451_);
    }
    let _e8014 = constants.scheme;
    if ((_e8014 == 5u) && !(is_boundary_1)) {
        let _cse_1482_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_1481_ = (_cse_1482_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1480_ = (_cse_1481_ - _cse_1992_);
        let _cse_1484_ = (_cse_1929_ - _cse_1992_);
        let _cse_1479_ = max(_cse_1480_, min(_cse_1484_, 0f));
        let _cse_1478_ = min(_cse_1479_, max(_cse_1484_, 0f));
        let _cse_1476_ = (_cse_1992_ + _cse_1478_);
        let _cse_1491_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_1490_ = (_cse_1491_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1489_ = (_cse_1490_ - _cse_1931_);
        let _cse_1493_ = (_cse_1933_ - _cse_1931_);
        let _cse_1488_ = max(_cse_1489_, min(_cse_1493_, 0f));
        let _cse_1487_ = min(_cse_1488_, max(_cse_1493_, 0f));
        let _cse_1485_ = (_cse_1931_ + _cse_1487_);
        let _cse_1475_ = vec2<f32>(_cse_1476_, _cse_1485_);
        let _cse_1474_ = _cse_1475_.y;
        let _cse_1501_ = ((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f));
        let _cse_1500_ = (_cse_1501_ + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1499_ = (_cse_1500_ - _cse_1929_);
        let _cse_1502_ = (_cse_1992_ - _cse_1929_);
        let _cse_1498_ = max(_cse_1499_, min(_cse_1502_, 0f));
        let _cse_1497_ = min(_cse_1498_, max(_cse_1502_, 0f));
        let _cse_1496_ = (_cse_1929_ + _cse_1497_);
        let _cse_1508_ = ((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f));
        let _cse_1507_ = (_cse_1508_ + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1506_ = (_cse_1507_ - _cse_1933_);
        let _cse_1509_ = (_cse_1931_ - _cse_1933_);
        let _cse_1505_ = max(_cse_1506_, min(_cse_1509_, 0f));
        let _cse_1504_ = min(_cse_1505_, max(_cse_1509_, 0f));
        let _cse_1503_ = (_cse_1933_ + _cse_1504_);
        let _cse_1495_ = vec2<f32>(_cse_1496_, _cse_1503_);
        let _cse_1494_ = _cse_1495_.y;
        let _cse_1517_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e8116 = lambda;
        let _cse_1516_ = (_cse_1517_ * _e8116);
        let _cse_1518_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_1515_ = (_cse_1516_ + _cse_1518_);
        let _e8127 = state[((owner_1 * 22u) + 10u)];
        let _e8134 = state[((owner_1 * 22u) + 11u)];
        let _cse_1525_ = vec2<f32>(_e8127, _e8134);
        let _cse_1524_ = _cse_1525_.y;
        let _cse_1523_ = (_cse_1392_ - _cse_1524_);
        let _cse_1522_ = (_cse_1523_ / max(dist, 0.000001f));
        let _e8141 = normal_vec;
        let _cse_1526_ = dot(_e8141, _cse_1515_);
        let _cse_1521_ = (_cse_1522_ - _cse_1526_);
        let _cse_1520_ = (select(0f, 1f, is_boundary_1) * _cse_1521_);
        let _e8148 = normal_vec;
        let _cse_1519_ = (_e8148 * _cse_1520_);
        let _cse_1514_ = (_cse_1515_ + _cse_1519_);
        let _cse_1513_ = _cse_1514_.x;
        let _e8153 = normal_vec.x;
        let _cse_1512_ = (_cse_1513_ * _e8153);
        let _cse_1529_ = _cse_1514_.y;
        let _e8161 = lambda;
        let _cse_1534_ = ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8161) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _e8171 = normal_vec;
        let _cse_1537_ = (((_cse_1276_ - _cse_1525_.x) / max(dist, 0.000001f)) - dot(_e8171, _cse_1534_));
        let _cse_1536_ = (select(0f, 1f, is_boundary_1) * _cse_1537_);
        let _e8178 = normal_vec;
        let _cse_1535_ = (_e8178 * _cse_1536_);
        let _cse_1533_ = (_cse_1534_ + _cse_1535_);
        let _cse_1532_ = _cse_1533_.x;
        let _cse_1531_ = (_cse_1532_ + _cse_1529_);
        let _cse_1530_ = (0.6666667f * _cse_1531_);
        let _cse_1528_ = (_cse_1529_ - _cse_1530_);
        let _e8187 = normal_vec.y;
        let _cse_1527_ = (_cse_1528_ * _e8187);
        let _cse_1511_ = (_cse_1512_ + _cse_1527_);
        let _e8192 = constants.viscosity;
        let _cse_1510_ = (_e8192 * _cse_1511_);
        u_l_2_ = _cse_1474_;
        u_r_2_ = _cse_1494_;
        let _e8219 = normal_vec;
        let _e8245 = constants.eos_r;
        let _e8270 = normal_vec.y;
        f_l_2_ = (((_cse_1474_ * dot(((_cse_1475_ * 1f) / vec2((_e234 + min(max(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))))), _e8219)) + ((((_e234 + min(max(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f))) * _e8245) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) * _e8270)) - _cse_1510_);
        let _e8303 = normal_vec;
        let _e8333 = constants.eos_r;
        let _e8362 = normal_vec.y;
        f_r_2_ = (((_cse_1494_ * dot(((_cse_1495_ * 1f) / vec2((_e758 + min(max(((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))))), _e8303)) + ((((_e758 + min(max(((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758), min((_e234 - _e758), 0f)), max((_e234 - _e758), 0f))) * _e8333) * (_e536 + min(max(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f)))) * _e8362)) - _cse_1510_);
    }
    let _e8368 = constants.scheme;
    if ((_e8368 == 6u) && !(is_boundary_1)) {
        let _cse_1546_ = ((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f));
        let _cse_1545_ = (_cse_1546_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1544_ = (_cse_1545_ - _cse_1992_);
        let _cse_1549_ = (_cse_1929_ - _cse_1992_);
        let _cse_1548_ = (abs(_cse_1549_) / max(abs(_cse_1549_), (abs(_cse_1544_) + 0.00000001f)));
        let _cse_1543_ = (_cse_1544_ * _cse_1548_);
        let _cse_1551_ = (_cse_1549_ * _cse_1544_);
        let _cse_1550_ = (max(_cse_1551_, 0f) / max(abs(_cse_1551_), 0.00000001f));
        let _cse_1542_ = (_cse_1543_ * _cse_1550_);
        let _cse_1540_ = (_cse_1992_ + _cse_1542_);
        let _cse_1558_ = ((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f));
        let _cse_1557_ = (_cse_1558_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1556_ = (_cse_1557_ - _cse_1931_);
        let _cse_1561_ = (_cse_1933_ - _cse_1931_);
        let _cse_1560_ = (abs(_cse_1561_) / max(abs(_cse_1561_), (abs(_cse_1556_) + 0.00000001f)));
        let _cse_1555_ = (_cse_1556_ * _cse_1560_);
        let _cse_1563_ = (_cse_1561_ * _cse_1556_);
        let _cse_1562_ = (max(_cse_1563_, 0f) / max(abs(_cse_1563_), 0.00000001f));
        let _cse_1554_ = (_cse_1555_ * _cse_1562_);
        let _cse_1552_ = (_cse_1931_ + _cse_1554_);
        let _cse_1539_ = vec2<f32>(_cse_1540_, _cse_1552_);
        let _cse_1538_ = _cse_1539_.y;
        let _cse_1571_ = ((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f));
        let _cse_1572_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1570_ = (_cse_1571_ + _cse_1572_);
        let _cse_1569_ = (_cse_1570_ - _cse_1929_);
        let _cse_1574_ = (_cse_1992_ - _cse_1929_);
        let _cse_1573_ = (abs(_cse_1574_) / max(abs(_cse_1574_), (abs(_cse_1569_) + 0.00000001f)));
        let _cse_1568_ = (_cse_1569_ * _cse_1573_);
        let _cse_1576_ = (_cse_1574_ * _cse_1569_);
        let _cse_1575_ = (max(_cse_1576_, 0f) / max(abs(_cse_1576_), 0.00000001f));
        let _cse_1567_ = (_cse_1568_ * _cse_1575_);
        let _cse_1566_ = (_cse_1929_ + _cse_1567_);
        let _cse_1582_ = ((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f));
        let _cse_1583_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1581_ = (_cse_1582_ + _cse_1583_);
        let _cse_1580_ = (_cse_1581_ - _cse_1933_);
        let _cse_1585_ = (_cse_1931_ - _cse_1933_);
        let _cse_1584_ = (abs(_cse_1585_) / max(abs(_cse_1585_), (abs(_cse_1580_) + 0.00000001f)));
        let _cse_1579_ = (_cse_1580_ * _cse_1584_);
        let _cse_1587_ = (_cse_1585_ * _cse_1580_);
        let _cse_1586_ = (max(_cse_1587_, 0f) / max(abs(_cse_1587_), 0.00000001f));
        let _cse_1578_ = (_cse_1579_ * _cse_1586_);
        let _cse_1577_ = (_cse_1933_ + _cse_1578_);
        let _cse_1565_ = vec2<f32>(_cse_1566_, _cse_1577_);
        let _cse_1564_ = _cse_1565_.y;
        let _e8510 = lambda;
        let _cse_1591_ = ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e8510) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _e8521 = state[((owner_1 * 22u) + 11u)];
        let _cse_1595_ = ((_cse_1392_ - _e8521) / max(dist, 0.000001f));
        let _e8526 = normal_vec;
        let _cse_1594_ = (_cse_1595_ - dot(_e8526, _cse_1591_));
        let _cse_1593_ = (select(0f, 1f, is_boundary_1) * _cse_1594_);
        let _e8533 = normal_vec;
        let _cse_1592_ = (_e8533 * _cse_1593_);
        let _cse_1590_ = (_cse_1591_ + _cse_1592_);
        let _cse_1598_ = _cse_1590_.y;
        let _e8542 = lambda;
        let _e8547 = normal_vec;
        let _e8558 = state[((owner_1 * 22u) + 10u)];
        let _e8563 = normal_vec;
        let _e8569 = lambda;
        let _cse_1600_ = ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8542) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e8547 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e8558) / max(dist, 0.000001f)) - dot(_e8563, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8569) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + _cse_1598_);
        let _cse_1599_ = (0.6666667f * _cse_1600_);
        let _cse_1597_ = (_cse_1598_ - _cse_1599_);
        let _e8584 = normal_vec.y;
        let _cse_1596_ = (_cse_1597_ * _e8584);
        let _e8588 = normal_vec.x;
        let _cse_1589_ = ((_cse_1590_.x * _e8588) + _cse_1596_);
        let _e8593 = constants.viscosity;
        let _cse_1588_ = (_e8593 * _cse_1589_);
        let _cse_1601_ = ((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758);
        u_l_2_ = _cse_1538_;
        u_r_2_ = _cse_1564_;
        let _e8685 = normal_vec;
        let _e8760 = constants.eos_r;
        let _e8834 = normal_vec.y;
        f_l_2_ = (((_cse_1538_ * dot(((_cse_1539_ * 1f) / vec2((_e234 + ((((((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e758 - _e234))) / max(abs((_e758 - _e234)), (abs(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))))), _e8685)) + ((((_e234 + ((((((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e758 - _e234))) / max(abs((_e758 - _e234)), (abs(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e758 - _e234) * ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))) * _e8760) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) * _e8834)) - _cse_1588_);
        let _e8864 = normal_vec;
        let _e8891 = constants.eos_r;
        let _e8981 = normal_vec.y;
        f_r_2_ = (((_cse_1564_ * dot(((_cse_1565_ * 1f) / vec2((_e758 + ((((_cse_1601_ * abs((_e234 - _e758))) / max(abs((_e234 - _e758)), (abs(_cse_1601_) + 0.00000001f))) * max(((_e234 - _e758) * _cse_1601_), 0f)) / max(abs(((_e234 - _e758) * _cse_1601_)), 0.00000001f))))), _e8864)) + ((((_e758 + ((((_cse_1601_ * abs((_e234 - _e758))) / max(abs((_e234 - _e758)), (abs(_cse_1601_) + 0.00000001f))) * max(((_e234 - _e758) * _cse_1601_), 0f)) / max(abs(((_e234 - _e758) * _cse_1601_)), 0.00000001f))) * _e8891) * (_e536 + ((((((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536) * abs((_e121 - _e536))) / max(abs((_e121 - _e536)), (abs(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)) + 0.00000001f))) * max(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)), 0f)) / max(abs(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536))), 0.00000001f)))) * _e8981)) - _cse_1588_);
    }
    let _e8991 = a_plus;
    let _e8992 = f_l_2_;
    let _e8994 = a_minus;
    let _e8995 = f_r_2_;
    let _e8998 = a_plus;
    let _e8999 = a_minus;
    let _e9001 = u_r_2_;
    let _e9002 = u_l_2_;
    fluxes[((idx * 8u) + 2u)] = (((((_e8991 * _e8992) - (_e8994 * _e8995)) + ((_e8998 * _e8999) * (_e9001 - _e9002))) / denom) * area);
    let _cse_1603_ = vec2<f32>(_cse_1992_, _cse_1931_);
    let _cse_1602_ = ((_cse_1603_ * 1f) / vec2(_e234));
    let _cse_1607_ = vec2<f32>(_cse_1929_, _cse_1933_);
    let _cse_1606_ = ((_cse_1607_ * 1f) / vec2(_e758));
    let _e9018 = normal_vec;
    let _cse_1610_ = dot(_cse_1602_, _e9018);
    let _e9026 = state[((owner_1 * 22u) + 10u)];
    let _e9031 = normal_vec;
    let _e9037 = lambda;
    let _cse_1616_ = (((_cse_1276_ - _e9026) / max(dist, 0.000001f)) - dot(_e9031, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9037) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other))));
    let _cse_1615_ = (select(0f, 1f, is_boundary_1) * _cse_1616_);
    let _e9048 = normal_vec;
    let _cse_1614_ = (_e9048 * _cse_1615_);
    let _e9055 = lambda;
    let _cse_1613_ = (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9055) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + _cse_1614_);
    let _e9067 = state[((owner_1 * 22u) + 11u)];
    let _e9072 = normal_vec;
    let _e9078 = lambda;
    let _cse_1620_ = (((_cse_1392_ - _e9067) / max(dist, 0.000001f)) - dot(_e9072, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9078) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other))));
    let _cse_1619_ = (select(0f, 1f, is_boundary_1) * _cse_1620_);
    let _e9089 = normal_vec;
    let _cse_1618_ = (_e9089 * _cse_1619_);
    let _e9096 = lambda;
    let _cse_1617_ = (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9096) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + _cse_1618_);
    let _cse_1622_ = _cse_1613_.x;
    let _cse_1625_ = _cse_1617_.y;
    let _cse_1624_ = (_cse_1622_ + _cse_1625_);
    let _cse_1623_ = (0.6666667f * _cse_1624_);
    let _e9109 = constants.viscosity;
    let _e9112 = normal_vec.x;
    let _e9116 = normal_vec.y;
    let _e9122 = constants.viscosity;
    let _e9125 = normal_vec.x;
    let _e9129 = normal_vec.y;
    let _cse_1621_ = vec2<f32>((_e9109 * (((_cse_1622_ - _cse_1623_) * _e9112) + (_cse_1613_.y * _e9116))), (_e9122 * ((_cse_1617_.x * _e9125) + ((_cse_1625_ - _cse_1623_) * _e9129))));
    let _e9134 = normal_vec;
    let _e9136 = normal_vec;
    let _e9141 = constants.viscosity;
    let _cse_1612_ = ((vec2<f32>(dot(_cse_1613_, _e9134), dot(_cse_1617_, _e9136)) * _e9141) + _cse_1621_);
    let _e9146 = constants.eos_gamma;
    let _e9150 = constants.eos_r;
    let _cse_1637_ = (((_e9146 * _e234) * _e9150) * _e121);
    let _cse_1636_ = (_cse_1637_ / _e234);
    let _e9156 = constants.eos_dp_drho;
    let _cse_1635_ = (_cse_1636_ + _e9156);
    let _cse_1640_ = (_cse_1610_ * _cse_1610_);
    let _cse_1639_ = min(_cse_1640_, _cse_1635_);
    let _e9162 = low_mach_params.model;
    let _cse_1638_ = (max(0f, (1f - abs(f32(_e9162)))) * _cse_1639_);
    let _e9172 = low_mach_params.model;
    let _cse_1634_ = ((max(0f, (1f - abs((f32(_e9172) - 2f)))) * _cse_1635_) + _cse_1638_);
    let _e9185 = low_mach_params.theta_floor;
    let _cse_1643_ = max(_cse_1640_, (_e9185 * _cse_1635_));
    let _cse_1642_ = min(_cse_1643_, _cse_1635_);
    let _e9191 = low_mach_params.model;
    let _cse_1641_ = (max(0f, (1f - abs((f32(_e9191) - 1f)))) * _cse_1642_);
    let _cse_1633_ = (_cse_1634_ + _cse_1641_);
    let _cse_1632_ = sqrt(_cse_1633_);
    let _cse_1631_ = (_cse_1610_ + _cse_1632_);
    let _e9204 = normal_vec;
    let _cse_1645_ = dot(_cse_1606_, _e9204);
    let _e9208 = constants.eos_gamma;
    let _e9212 = constants.eos_r;
    let _cse_1651_ = (((_e9208 * _e758) * _e9212) * _e536);
    let _cse_1650_ = (_cse_1651_ / _e758);
    let _e9218 = constants.eos_dp_drho;
    let _cse_1649_ = (_cse_1650_ + _e9218);
    let _cse_1654_ = (_cse_1645_ * _cse_1645_);
    let _cse_1653_ = min(_cse_1654_, _cse_1649_);
    let _e9224 = low_mach_params.model;
    let _cse_1652_ = (max(0f, (1f - abs(f32(_e9224)))) * _cse_1653_);
    let _e9234 = low_mach_params.model;
    let _cse_1648_ = ((max(0f, (1f - abs((f32(_e9234) - 2f)))) * _cse_1649_) + _cse_1652_);
    let _e9247 = low_mach_params.theta_floor;
    let _cse_1657_ = max(_cse_1654_, (_e9247 * _cse_1649_));
    let _cse_1656_ = min(_cse_1657_, _cse_1649_);
    let _e9253 = low_mach_params.model;
    let _cse_1655_ = (max(0f, (1f - abs((f32(_e9253) - 1f)))) * _cse_1656_);
    let _cse_1647_ = (_cse_1648_ + _cse_1655_);
    let _cse_1646_ = sqrt(_cse_1647_);
    let _cse_1644_ = (_cse_1645_ + _cse_1646_);
    let _cse_1630_ = max(_cse_1631_, _cse_1644_);
    let _cse_1629_ = max(0f, _cse_1630_);
    let _cse_1662_ = (_cse_1610_ - _cse_1632_);
    let _cse_1663_ = (_cse_1645_ - _cse_1646_);
    let _cse_1661_ = min(_cse_1662_, _cse_1663_);
    let _cse_1660_ = min(0f, _cse_1661_);
    let _cse_1659_ = (_cse_1629_ - _cse_1660_);
    let _cse_1658_ = max(_cse_1659_, 0.000001f);
    let _cse_1628_ = (_cse_1629_ / _cse_1658_);
    let _cse_1627_ = (_cse_1602_ * _cse_1628_);
    let _cse_1665_ = (1f - _cse_1628_);
    let _cse_1664_ = (_cse_1606_ * _cse_1665_);
    let _cse_1626_ = (_cse_1627_ + _cse_1664_);
    let _cse_1611_ = dot(_cse_1612_, _cse_1626_);
    let _e9286 = constants.eos_r;
    let _e9291 = constants.eos_gm1_;
    u_l_3_ = ((((_e234 * _e9286) * _e121) / max(_e9291, 0.000000000001f)) + ((0.5f * _e234) * dot(_cse_1602_, _cse_1602_)));
    let _e9303 = constants.eos_r;
    let _e9308 = constants.eos_gm1_;
    u_r_3_ = ((((_e758 * _e9303) * _e536) / max(_e9308, 0.000000000001f)) + ((0.5f * _e758) * dot(_cse_1606_, _cse_1606_)));
    let _e9320 = constants.eos_r;
    let _e9325 = constants.eos_gm1_;
    let _e9336 = constants.eos_r;
    f_l_3_ = (((((((_e234 * _e9320) * _e121) / max(_e9325, 0.000000000001f)) + ((0.5f * _e234) * dot(_cse_1602_, _cse_1602_))) + ((_e234 * _e9336) * _e121)) * _cse_1610_) - _cse_1611_);
    let _e9345 = constants.eos_r;
    let _e9350 = constants.eos_gm1_;
    let _e9361 = constants.eos_r;
    f_r_3_ = (((((((_e758 * _e9345) * _e536) / max(_e9350, 0.000000000001f)) + ((0.5f * _e758) * dot(_cse_1606_, _cse_1606_))) + ((_e758 * _e9361) * _e536)) * _cse_1645_) - _cse_1611_);
    let _e9370 = constants.scheme;
    if ((_e9370 == 1u) && !(is_boundary_1)) {
        let _cse_1668_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_1667_ = (_e234 + _cse_1668_);
        let _e9381 = constants.eos_r;
        let _cse_1666_ = ((_cse_1667_ * _e9381) * (_e121 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec))));
        let _cse_1671_ = (_cse_1992_ + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)));
        let _cse_1672_ = (_cse_1931_ + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)));
        let _cse_1670_ = vec2<f32>(_cse_1671_, _cse_1672_);
        let _cse_1669_ = ((_cse_1670_ * 1f) / vec2(_cse_1667_));
        let _cse_1677_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1676_ = dot(_cse_1677_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1675_ = (_e758 + _cse_1676_);
        let _e9411 = constants.eos_r;
        let _cse_1674_ = (_cse_1675_ * _e9411);
        let _cse_1678_ = (_e536 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)));
        let _cse_1673_ = (_cse_1674_ * _cse_1678_);
        let _cse_1682_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec));
        let _cse_1681_ = (_cse_1929_ + _cse_1682_);
        let _cse_1684_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec));
        let _cse_1683_ = (_cse_1933_ + _cse_1684_);
        let _cse_1680_ = vec2<f32>(_cse_1681_, _cse_1683_);
        let _cse_1685_ = (1f / _cse_1675_);
        let _cse_1679_ = (_cse_1680_ * _cse_1685_);
        let _e9442 = normal_vec;
        let _cse_1686_ = dot(_cse_1669_, _e9442);
        let _e9449 = lambda;
        let _e9454 = normal_vec;
        let _e9465 = state[((owner_1 * 22u) + 10u)];
        let _e9470 = normal_vec;
        let _e9476 = lambda;
        let _e9485 = normal_vec;
        let _e9492 = lambda;
        let _e9497 = normal_vec;
        let _e9508 = state[((owner_1 * 22u) + 11u)];
        let _e9513 = normal_vec;
        let _e9519 = lambda;
        let _e9528 = normal_vec;
        let _e9533 = constants.viscosity;
        let _e9537 = constants.viscosity;
        let _e9543 = lambda;
        let _e9548 = normal_vec;
        let _e9559 = state[((owner_1 * 22u) + 10u)];
        let _e9564 = normal_vec;
        let _e9570 = lambda;
        let _e9585 = lambda;
        let _e9590 = normal_vec;
        let _e9601 = state[((owner_1 * 22u) + 10u)];
        let _e9606 = normal_vec;
        let _e9612 = lambda;
        let _e9627 = lambda;
        let _e9632 = normal_vec;
        let _e9643 = state[((owner_1 * 22u) + 11u)];
        let _e9648 = normal_vec;
        let _e9654 = lambda;
        let _e9669 = normal_vec.x;
        let _e9676 = lambda;
        let _e9681 = normal_vec;
        let _e9692 = state[((owner_1 * 22u) + 10u)];
        let _e9697 = normal_vec;
        let _e9703 = lambda;
        let _e9714 = normal_vec.y;
        let _e9720 = constants.viscosity;
        let _e9726 = lambda;
        let _e9731 = normal_vec;
        let _e9742 = state[((owner_1 * 22u) + 11u)];
        let _e9747 = normal_vec;
        let _e9753 = lambda;
        let _e9764 = normal_vec.x;
        let _e9771 = lambda;
        let _e9776 = normal_vec;
        let _e9787 = state[((owner_1 * 22u) + 11u)];
        let _e9792 = normal_vec;
        let _e9798 = lambda;
        let _e9813 = lambda;
        let _e9818 = normal_vec;
        let _e9829 = state[((owner_1 * 22u) + 10u)];
        let _e9834 = normal_vec;
        let _e9840 = lambda;
        let _e9855 = lambda;
        let _e9860 = normal_vec;
        let _e9871 = state[((owner_1 * 22u) + 11u)];
        let _e9876 = normal_vec;
        let _e9882 = lambda;
        let _e9897 = normal_vec.y;
        let _cse_1688_ = ((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9449) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e9454 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e9465) / max(dist, 0.000001f)) - dot(_e9470, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9476) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e9485), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9492) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e9497 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e9508) / max(dist, 0.000001f)) - dot(_e9513, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9519) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e9528)) * _e9533) + vec2<f32>((_e9537 * ((((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9543) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e9548 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e9559) / max(dist, 0.000001f)) - dot(_e9564, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9570) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9585) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e9590 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e9601) / max(dist, 0.000001f)) - dot(_e9606, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9612) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9627) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e9632 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e9643) / max(dist, 0.000001f)) - dot(_e9648, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9654) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e9669) + ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9676) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e9681 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e9692) / max(dist, 0.000001f)) - dot(_e9697, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9703) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).y * _e9714))), (_e9720 * (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9726) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e9731 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e9742) / max(dist, 0.000001f)) - dot(_e9747, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9753) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).x * _e9764) + (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9771) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e9776 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e9787) / max(dist, 0.000001f)) - dot(_e9792, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9798) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9813) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e9818 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e9829) / max(dist, 0.000001f)) - dot(_e9834, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e9840) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9855) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e9860 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e9871) / max(dist, 0.000001f)) - dot(_e9876, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e9882) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e9897)))));
        let _e9905 = constants.eos_gamma;
        let _cse_1700_ = (_e9905 * _cse_1666_);
        let _cse_1699_ = (_cse_1700_ / _cse_1667_);
        let _e9910 = constants.eos_dp_drho;
        let _cse_1698_ = (_cse_1699_ + _e9910);
        let _cse_1703_ = (_cse_1686_ * _cse_1686_);
        let _cse_1702_ = min(_cse_1703_, _cse_1698_);
        let _e9916 = low_mach_params.model;
        let _cse_1701_ = (max(0f, (1f - abs(f32(_e9916)))) * _cse_1702_);
        let _e9926 = low_mach_params.model;
        let _cse_1697_ = ((max(0f, (1f - abs((f32(_e9926) - 2f)))) * _cse_1698_) + _cse_1701_);
        let _e9939 = low_mach_params.theta_floor;
        let _cse_1706_ = max(_cse_1703_, (_e9939 * _cse_1698_));
        let _cse_1705_ = min(_cse_1706_, _cse_1698_);
        let _e9945 = low_mach_params.model;
        let _cse_1704_ = (max(0f, (1f - abs((f32(_e9945) - 1f)))) * _cse_1705_);
        let _cse_1696_ = (_cse_1697_ + _cse_1704_);
        let _cse_1695_ = sqrt(_cse_1696_);
        let _cse_1694_ = (_cse_1686_ + _cse_1695_);
        let _e9958 = normal_vec;
        let _cse_1708_ = dot(_cse_1679_, _e9958);
        let _e9962 = constants.eos_gamma;
        let _cse_1715_ = (_e9962 * _cse_1673_);
        let _cse_1714_ = (_cse_1715_ / _cse_1675_);
        let _e9967 = constants.eos_dp_drho;
        let _cse_1713_ = (_cse_1714_ + _e9967);
        let _e9971 = low_mach_params.model;
        let _cse_1712_ = (max(0f, (1f - abs((f32(_e9971) - 2f)))) * _cse_1713_);
        let _cse_1718_ = (_cse_1708_ * _cse_1708_);
        let _cse_1717_ = min(_cse_1718_, _cse_1713_);
        let _e9985 = low_mach_params.model;
        let _cse_1716_ = (max(0f, (1f - abs(f32(_e9985)))) * _cse_1717_);
        let _cse_1711_ = (_cse_1712_ + _cse_1716_);
        let _e9996 = low_mach_params.theta_floor;
        let _cse_1721_ = max(_cse_1718_, (_e9996 * _cse_1713_));
        let _cse_1720_ = min(_cse_1721_, _cse_1713_);
        let _e10002 = low_mach_params.model;
        let _cse_1719_ = (max(0f, (1f - abs((f32(_e10002) - 1f)))) * _cse_1720_);
        let _cse_1710_ = (_cse_1711_ + _cse_1719_);
        let _cse_1709_ = sqrt(_cse_1710_);
        let _cse_1707_ = (_cse_1708_ + _cse_1709_);
        let _cse_1693_ = max(_cse_1694_, _cse_1707_);
        let _cse_1692_ = max(0f, _cse_1693_);
        let _cse_1726_ = (_cse_1686_ - _cse_1695_);
        let _cse_1727_ = (_cse_1708_ - _cse_1709_);
        let _cse_1725_ = min(_cse_1726_, _cse_1727_);
        let _cse_1724_ = min(0f, _cse_1725_);
        let _cse_1723_ = (_cse_1692_ - _cse_1724_);
        let _cse_1722_ = max(_cse_1723_, 0.000001f);
        let _cse_1691_ = (_cse_1692_ / _cse_1722_);
        let _cse_1690_ = (_cse_1669_ * _cse_1691_);
        let _cse_1729_ = (1f - _cse_1691_);
        let _cse_1728_ = (_cse_1679_ * _cse_1729_);
        let _cse_1689_ = (_cse_1690_ + _cse_1728_);
        let _cse_1687_ = dot(_cse_1688_, _cse_1689_);
        let _e10035 = constants.eos_gm1_;
        u_l_3_ = ((_cse_1666_ / max(_e10035, 0.000000000001f)) + ((0.5f * _cse_1667_) * dot(_cse_1669_, _cse_1669_)));
        let _e10046 = constants.eos_gm1_;
        u_r_3_ = ((_cse_1673_ / max(_e10046, 0.000000000001f)) + ((0.5f * _cse_1675_) * dot(_cse_1679_, _cse_1679_)));
        let _e10057 = constants.eos_gm1_;
        f_l_3_ = (((((_cse_1666_ / max(_e10057, 0.000000000001f)) + ((0.5f * _cse_1667_) * dot(_cse_1669_, _cse_1669_))) + _cse_1666_) * _cse_1686_) - _cse_1687_);
        let _e10071 = constants.eos_gm1_;
        f_r_3_ = (((((_cse_1673_ / max(_e10071, 0.000000000001f)) + ((0.5f * _cse_1675_) * dot(_cse_1679_, _cse_1679_))) + _cse_1673_) * _cse_1708_) - _cse_1687_);
    }
    let _e10085 = constants.scheme;
    if ((_e10085 == 2u) && !(is_boundary_1)) {
        let _cse_1732_ = (((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1731_ = (_cse_1732_ - _e234);
        let _cse_1730_ = (_e234 + _cse_1731_);
        let _cse_1736_ = ((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_);
        let _cse_1735_ = (_cse_1992_ + _cse_1736_);
        let _cse_1738_ = ((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_);
        let _cse_1737_ = (_cse_1931_ + _cse_1738_);
        let _cse_1734_ = vec2<f32>(_cse_1735_, _cse_1737_);
        let _cse_1733_ = ((_cse_1734_ * 1f) / vec2(_cse_1730_));
        let _cse_1744_ = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1743_ = (_cse_1744_ * 0.125f);
        let _cse_1742_ = (((_e758 * 0.625f) + (_e234 * 0.375f)) + _cse_1743_);
        let _cse_1741_ = (_cse_1742_ - _e758);
        let _cse_1740_ = (_e758 + _cse_1741_);
        let _e10153 = constants.eos_r;
        let _cse_1739_ = ((_cse_1740_ * _e10153) * ((((_e536 + (_e536 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536));
        let _cse_1749_ = (((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1748_ = (_cse_1749_ - _cse_1929_);
        let _cse_1747_ = (_cse_1929_ + _cse_1748_);
        let _cse_1752_ = (((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1751_ = (_cse_1752_ - _cse_1933_);
        let _cse_1750_ = (_cse_1933_ + _cse_1751_);
        let _cse_1746_ = vec2<f32>(_cse_1747_, _cse_1750_);
        let _cse_1745_ = ((_cse_1746_ * 1f) / vec2(_cse_1740_));
        let _e10212 = normal_vec;
        let _cse_1753_ = dot(_cse_1733_, _e10212);
        let _e10216 = constants.eos_gamma;
        let _e10220 = constants.eos_r;
        let _cse_1765_ = ((((_e10216 * _cse_1730_) * _e10220) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) / _cse_1730_);
        let _e10239 = constants.eos_dp_drho;
        let _cse_1764_ = (_cse_1765_ + _e10239);
        let _cse_1768_ = (_cse_1753_ * _cse_1753_);
        let _cse_1767_ = min(_cse_1768_, _cse_1764_);
        let _e10245 = low_mach_params.model;
        let _cse_1766_ = (max(0f, (1f - abs(f32(_e10245)))) * _cse_1767_);
        let _e10255 = low_mach_params.model;
        let _cse_1763_ = ((max(0f, (1f - abs((f32(_e10255) - 2f)))) * _cse_1764_) + _cse_1766_);
        let _e10268 = low_mach_params.theta_floor;
        let _cse_1771_ = max(_cse_1768_, (_e10268 * _cse_1764_));
        let _cse_1770_ = min(_cse_1771_, _cse_1764_);
        let _e10274 = low_mach_params.model;
        let _cse_1769_ = (max(0f, (1f - abs((f32(_e10274) - 1f)))) * _cse_1770_);
        let _cse_1762_ = (_cse_1763_ + _cse_1769_);
        let _cse_1761_ = sqrt(_cse_1762_);
        let _cse_1760_ = (_cse_1753_ + _cse_1761_);
        let _e10287 = normal_vec;
        let _cse_1773_ = dot(_cse_1745_, _e10287);
        let _e10291 = constants.eos_gamma;
        let _cse_1779_ = (_e10291 * _cse_1739_);
        let _cse_1778_ = (_cse_1779_ / _cse_1740_);
        let _e10296 = constants.eos_dp_drho;
        let _cse_1777_ = (_cse_1778_ + _e10296);
        let _cse_1782_ = (_cse_1773_ * _cse_1773_);
        let _cse_1781_ = min(_cse_1782_, _cse_1777_);
        let _e10302 = low_mach_params.model;
        let _cse_1780_ = (max(0f, (1f - abs(f32(_e10302)))) * _cse_1781_);
        let _e10312 = low_mach_params.model;
        let _cse_1776_ = ((max(0f, (1f - abs((f32(_e10312) - 2f)))) * _cse_1777_) + _cse_1780_);
        let _e10325 = low_mach_params.theta_floor;
        let _cse_1785_ = max(_cse_1782_, (_e10325 * _cse_1777_));
        let _cse_1784_ = min(_cse_1785_, _cse_1777_);
        let _e10331 = low_mach_params.model;
        let _cse_1783_ = (max(0f, (1f - abs((f32(_e10331) - 1f)))) * _cse_1784_);
        let _cse_1775_ = (_cse_1776_ + _cse_1783_);
        let _cse_1774_ = sqrt(_cse_1775_);
        let _cse_1772_ = (_cse_1773_ + _cse_1774_);
        let _cse_1759_ = max(_cse_1760_, _cse_1772_);
        let _cse_1758_ = max(0f, _cse_1759_);
        let _cse_1790_ = (_cse_1753_ - _cse_1761_);
        let _cse_1791_ = (_cse_1773_ - _cse_1774_);
        let _cse_1789_ = min(_cse_1790_, _cse_1791_);
        let _cse_1788_ = min(0f, _cse_1789_);
        let _cse_1787_ = (_cse_1758_ - _cse_1788_);
        let _cse_1786_ = max(_cse_1787_, 0.000001f);
        let _cse_1757_ = (_cse_1758_ / _cse_1786_);
        let _cse_1756_ = (_cse_1733_ * _cse_1757_);
        let _cse_1793_ = (1f - _cse_1757_);
        let _cse_1792_ = (_cse_1745_ * _cse_1793_);
        let _cse_1755_ = (_cse_1756_ + _cse_1792_);
        let _e10366 = lambda;
        let _e10371 = normal_vec;
        let _e10382 = state[((owner_1 * 22u) + 10u)];
        let _e10387 = normal_vec;
        let _e10393 = lambda;
        let _e10402 = normal_vec;
        let _e10409 = lambda;
        let _e10414 = normal_vec;
        let _e10425 = state[((owner_1 * 22u) + 11u)];
        let _e10430 = normal_vec;
        let _e10436 = lambda;
        let _e10445 = normal_vec;
        let _e10450 = constants.viscosity;
        let _e10454 = constants.viscosity;
        let _e10460 = lambda;
        let _e10465 = normal_vec;
        let _e10476 = state[((owner_1 * 22u) + 10u)];
        let _e10481 = normal_vec;
        let _e10487 = lambda;
        let _e10502 = lambda;
        let _e10507 = normal_vec;
        let _e10518 = state[((owner_1 * 22u) + 10u)];
        let _e10523 = normal_vec;
        let _e10529 = lambda;
        let _e10544 = lambda;
        let _e10549 = normal_vec;
        let _e10560 = state[((owner_1 * 22u) + 11u)];
        let _e10565 = normal_vec;
        let _e10571 = lambda;
        let _e10586 = normal_vec.x;
        let _e10593 = lambda;
        let _e10598 = normal_vec;
        let _e10609 = state[((owner_1 * 22u) + 10u)];
        let _e10614 = normal_vec;
        let _e10620 = lambda;
        let _e10631 = normal_vec.y;
        let _e10637 = constants.viscosity;
        let _e10643 = lambda;
        let _e10648 = normal_vec;
        let _e10659 = state[((owner_1 * 22u) + 11u)];
        let _e10664 = normal_vec;
        let _e10670 = lambda;
        let _e10681 = normal_vec.x;
        let _e10688 = lambda;
        let _e10693 = normal_vec;
        let _e10704 = state[((owner_1 * 22u) + 11u)];
        let _e10709 = normal_vec;
        let _e10715 = lambda;
        let _e10730 = lambda;
        let _e10735 = normal_vec;
        let _e10746 = state[((owner_1 * 22u) + 10u)];
        let _e10751 = normal_vec;
        let _e10757 = lambda;
        let _e10772 = lambda;
        let _e10777 = normal_vec;
        let _e10788 = state[((owner_1 * 22u) + 11u)];
        let _e10793 = normal_vec;
        let _e10799 = lambda;
        let _e10814 = normal_vec.y;
        let _cse_1754_ = dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10366) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e10371 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e10382) / max(dist, 0.000001f)) - dot(_e10387, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10393) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e10402), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10409) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e10414 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e10425) / max(dist, 0.000001f)) - dot(_e10430, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10436) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e10445)) * _e10450) + vec2<f32>((_e10454 * ((((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10460) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e10465 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e10476) / max(dist, 0.000001f)) - dot(_e10481, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10487) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10502) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e10507 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e10518) / max(dist, 0.000001f)) - dot(_e10523, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10529) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10544) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e10549 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e10560) / max(dist, 0.000001f)) - dot(_e10565, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10571) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e10586) + ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10593) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e10598 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e10609) / max(dist, 0.000001f)) - dot(_e10614, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10620) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).y * _e10631))), (_e10637 * (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10643) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e10648 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e10659) / max(dist, 0.000001f)) - dot(_e10664, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10670) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).x * _e10681) + (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10688) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e10693 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e10704) / max(dist, 0.000001f)) - dot(_e10709, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10715) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10730) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e10735 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e10746) / max(dist, 0.000001f)) - dot(_e10751, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e10757) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10772) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e10777 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e10788) / max(dist, 0.000001f)) - dot(_e10793, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e10799) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e10814))))), _cse_1755_);
        let _e10823 = constants.eos_r;
        let _e10841 = constants.eos_gm1_;
        u_l_3_ = ((((_cse_1730_ * _e10823) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) / max(_e10841, 0.000000000001f)) + ((0.5f * _cse_1730_) * dot(_cse_1733_, _cse_1733_)));
        let _e10852 = constants.eos_gm1_;
        u_r_3_ = ((_cse_1739_ / max(_e10852, 0.000000000001f)) + ((0.5f * _cse_1740_) * dot(_cse_1745_, _cse_1745_)));
        let _e10863 = constants.eos_r;
        let _e10881 = constants.eos_gm1_;
        let _e10892 = constants.eos_r;
        f_l_3_ = (((((((_cse_1730_ * _e10863) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) / max(_e10881, 0.000000000001f)) + ((0.5f * _cse_1730_) * dot(_cse_1733_, _cse_1733_))) + ((_cse_1730_ * _e10892) * ((((_e121 + (_e121 * 0.625f)) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))) * _cse_1753_) - _cse_1754_);
        let _e10913 = constants.eos_gm1_;
        f_r_3_ = (((((_cse_1739_ / max(_e10913, 0.000000000001f)) + ((0.5f * _cse_1740_) * dot(_cse_1745_, _cse_1745_))) + _cse_1739_) * _cse_1773_) - _cse_1754_);
    }
    let _e10927 = constants.scheme;
    if ((_e10927 == 3u) && !(is_boundary_1)) {
        let _cse_1796_ = min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f));
        let _cse_1795_ = (_e234 + _cse_1796_);
        let _e10946 = constants.eos_r;
        let _cse_1794_ = ((_cse_1795_ * _e10946) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f))));
        let _cse_1801_ = min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), min((_cse_1929_ - _cse_1992_), 0f)), max((_cse_1929_ - _cse_1992_), 0f));
        let _cse_1799_ = (_cse_1992_ + _cse_1801_);
        let _cse_1805_ = min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), min((_cse_1933_ - _cse_1931_), 0f)), max((_cse_1933_ - _cse_1931_), 0f));
        let _cse_1803_ = (_cse_1931_ + _cse_1805_);
        let _cse_1798_ = vec2<f32>(_cse_1799_, _cse_1803_);
        let _cse_1797_ = ((_cse_1798_ * 1f) / vec2(_cse_1795_));
        let _cse_1810_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e234 - _e758), 0f));
        let _cse_1809_ = min(_cse_1810_, max((_e234 - _e758), 0f));
        let _cse_1808_ = (_e758 + _cse_1809_);
        let _e11008 = constants.eos_r;
        let _cse_1807_ = ((_cse_1808_ * _e11008) * (_e536 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f))));
        let _cse_1814_ = min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_cse_1992_ - _cse_1929_), 0f)), max((_cse_1992_ - _cse_1929_), 0f));
        let _cse_1813_ = (_cse_1929_ + _cse_1814_);
        let _cse_1816_ = min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_cse_1931_ - _cse_1933_), 0f)), max((_cse_1931_ - _cse_1933_), 0f));
        let _cse_1815_ = (_cse_1933_ + _cse_1816_);
        let _cse_1812_ = vec2<f32>(_cse_1813_, _cse_1815_);
        let _cse_1811_ = ((_cse_1812_ * 1f) / vec2(_cse_1808_));
        let _e11064 = normal_vec;
        let _cse_1817_ = dot(_cse_1797_, _e11064);
        let _e11068 = constants.eos_gamma;
        let _cse_1829_ = ((_e11068 * _cse_1794_) / _cse_1795_);
        let _e11073 = constants.eos_dp_drho;
        let _cse_1828_ = (_cse_1829_ + _e11073);
        let _cse_1832_ = (_cse_1817_ * _cse_1817_);
        let _cse_1831_ = min(_cse_1832_, _cse_1828_);
        let _e11079 = low_mach_params.model;
        let _cse_1830_ = (max(0f, (1f - abs(f32(_e11079)))) * _cse_1831_);
        let _e11089 = low_mach_params.model;
        let _cse_1827_ = ((max(0f, (1f - abs((f32(_e11089) - 2f)))) * _cse_1828_) + _cse_1830_);
        let _e11102 = low_mach_params.theta_floor;
        let _cse_1835_ = max(_cse_1832_, (_e11102 * _cse_1828_));
        let _cse_1834_ = min(_cse_1835_, _cse_1828_);
        let _e11108 = low_mach_params.model;
        let _cse_1833_ = (max(0f, (1f - abs((f32(_e11108) - 1f)))) * _cse_1834_);
        let _cse_1826_ = (_cse_1827_ + _cse_1833_);
        let _cse_1825_ = sqrt(_cse_1826_);
        let _cse_1824_ = (_cse_1817_ + _cse_1825_);
        let _e11121 = normal_vec;
        let _cse_1837_ = dot(_cse_1811_, _e11121);
        let _e11125 = constants.eos_gamma;
        let _cse_1843_ = (_e11125 * _cse_1807_);
        let _cse_1842_ = (_cse_1843_ / _cse_1808_);
        let _e11130 = constants.eos_dp_drho;
        let _cse_1841_ = (_cse_1842_ + _e11130);
        let _cse_1846_ = (_cse_1837_ * _cse_1837_);
        let _cse_1845_ = min(_cse_1846_, _cse_1841_);
        let _e11136 = low_mach_params.model;
        let _cse_1844_ = (max(0f, (1f - abs(f32(_e11136)))) * _cse_1845_);
        let _e11146 = low_mach_params.model;
        let _cse_1840_ = ((max(0f, (1f - abs((f32(_e11146) - 2f)))) * _cse_1841_) + _cse_1844_);
        let _e11159 = low_mach_params.theta_floor;
        let _cse_1849_ = max(_cse_1846_, (_e11159 * _cse_1841_));
        let _cse_1848_ = min(_cse_1849_, _cse_1841_);
        let _e11165 = low_mach_params.model;
        let _cse_1847_ = (max(0f, (1f - abs((f32(_e11165) - 1f)))) * _cse_1848_);
        let _cse_1839_ = (_cse_1840_ + _cse_1847_);
        let _cse_1838_ = sqrt(_cse_1839_);
        let _cse_1836_ = (_cse_1837_ + _cse_1838_);
        let _cse_1823_ = max(_cse_1824_, _cse_1836_);
        let _cse_1822_ = max(0f, _cse_1823_);
        let _cse_1854_ = (_cse_1817_ - _cse_1825_);
        let _cse_1855_ = (_cse_1837_ - _cse_1838_);
        let _cse_1853_ = min(_cse_1854_, _cse_1855_);
        let _cse_1852_ = min(0f, _cse_1853_);
        let _cse_1851_ = (_cse_1822_ - _cse_1852_);
        let _cse_1850_ = max(_cse_1851_, 0.000001f);
        let _cse_1821_ = (_cse_1822_ / _cse_1850_);
        let _cse_1820_ = (_cse_1797_ * _cse_1821_);
        let _cse_1857_ = (1f - _cse_1821_);
        let _cse_1856_ = (_cse_1811_ * _cse_1857_);
        let _cse_1819_ = (_cse_1820_ + _cse_1856_);
        let _e11200 = lambda;
        let _e11205 = normal_vec;
        let _e11216 = state[((owner_1 * 22u) + 10u)];
        let _e11221 = normal_vec;
        let _e11227 = lambda;
        let _e11236 = normal_vec;
        let _e11243 = lambda;
        let _e11248 = normal_vec;
        let _e11259 = state[((owner_1 * 22u) + 11u)];
        let _e11264 = normal_vec;
        let _e11270 = lambda;
        let _e11279 = normal_vec;
        let _e11284 = constants.viscosity;
        let _e11288 = constants.viscosity;
        let _e11294 = lambda;
        let _e11299 = normal_vec;
        let _e11310 = state[((owner_1 * 22u) + 10u)];
        let _e11315 = normal_vec;
        let _e11321 = lambda;
        let _e11336 = lambda;
        let _e11341 = normal_vec;
        let _e11352 = state[((owner_1 * 22u) + 10u)];
        let _e11357 = normal_vec;
        let _e11363 = lambda;
        let _e11378 = lambda;
        let _e11383 = normal_vec;
        let _e11394 = state[((owner_1 * 22u) + 11u)];
        let _e11399 = normal_vec;
        let _e11405 = lambda;
        let _e11420 = normal_vec.x;
        let _e11427 = lambda;
        let _e11432 = normal_vec;
        let _e11443 = state[((owner_1 * 22u) + 10u)];
        let _e11448 = normal_vec;
        let _e11454 = lambda;
        let _e11465 = normal_vec.y;
        let _e11471 = constants.viscosity;
        let _e11477 = lambda;
        let _e11482 = normal_vec;
        let _e11493 = state[((owner_1 * 22u) + 11u)];
        let _e11498 = normal_vec;
        let _e11504 = lambda;
        let _e11515 = normal_vec.x;
        let _e11522 = lambda;
        let _e11527 = normal_vec;
        let _e11538 = state[((owner_1 * 22u) + 11u)];
        let _e11543 = normal_vec;
        let _e11549 = lambda;
        let _e11564 = lambda;
        let _e11569 = normal_vec;
        let _e11580 = state[((owner_1 * 22u) + 10u)];
        let _e11585 = normal_vec;
        let _e11591 = lambda;
        let _e11606 = lambda;
        let _e11611 = normal_vec;
        let _e11622 = state[((owner_1 * 22u) + 11u)];
        let _e11627 = normal_vec;
        let _e11633 = lambda;
        let _e11648 = normal_vec.y;
        let _cse_1818_ = dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11200) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e11205 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e11216) / max(dist, 0.000001f)) - dot(_e11221, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11227) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e11236), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11243) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e11248 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e11259) / max(dist, 0.000001f)) - dot(_e11264, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11270) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e11279)) * _e11284) + vec2<f32>((_e11288 * ((((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11294) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e11299 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e11310) / max(dist, 0.000001f)) - dot(_e11315, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11321) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11336) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e11341 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e11352) / max(dist, 0.000001f)) - dot(_e11357, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11363) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11378) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e11383 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e11394) / max(dist, 0.000001f)) - dot(_e11399, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11405) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e11420) + ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11427) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e11432 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e11443) / max(dist, 0.000001f)) - dot(_e11448, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11454) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).y * _e11465))), (_e11471 * (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11477) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e11482 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e11493) / max(dist, 0.000001f)) - dot(_e11498, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11504) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).x * _e11515) + (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11522) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e11527 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e11538) / max(dist, 0.000001f)) - dot(_e11543, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11549) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11564) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e11569 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e11580) / max(dist, 0.000001f)) - dot(_e11585, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e11591) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11606) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e11611 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e11622) / max(dist, 0.000001f)) - dot(_e11627, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e11633) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e11648))))), _cse_1819_);
        let _e11657 = constants.eos_gm1_;
        u_l_3_ = ((_cse_1794_ / max(_e11657, 0.000000000001f)) + ((0.5f * _cse_1795_) * dot(_cse_1797_, _cse_1797_)));
        let _e11668 = constants.eos_gm1_;
        u_r_3_ = ((_cse_1807_ / max(_e11668, 0.000000000001f)) + ((0.5f * _cse_1808_) * dot(_cse_1811_, _cse_1811_)));
        let _e11679 = constants.eos_gm1_;
        f_l_3_ = (((((_cse_1794_ / max(_e11679, 0.000000000001f)) + ((0.5f * _cse_1795_) * dot(_cse_1797_, _cse_1797_))) + _cse_1794_) * _cse_1817_) - _cse_1818_);
        let _e11693 = constants.eos_gm1_;
        f_r_3_ = (((((_cse_1807_ / max(_e11693, 0.000000000001f)) + ((0.5f * _cse_1808_) * dot(_cse_1811_, _cse_1811_))) + _cse_1807_) * _cse_1837_) - _cse_1818_);
    }
    let _e11707 = constants.scheme;
    if ((_e11707 == 4u) && !(is_boundary_1)) {
        let _cse_1861_ = ((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))));
        let _cse_1860_ = (_cse_1861_ * lambda_other);
        let _cse_1859_ = (_cse_1860_ * (_e758 - _e234));
        let _cse_1858_ = (_e234 + _cse_1859_);
        let _cse_1865_ = (vec2<f32>(_cse_1929_, _cse_1933_) - vec2<f32>(_cse_1992_, _cse_1931_));
        let _cse_1873_ = dot(_cse_1865_, _cse_1865_);
        let _cse_1874_ = ((_cse_1873_ * _cse_1873_) + 0.000000000000000000000000000001f);
        let _cse_1872_ = ((dot(_cse_1865_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_1873_) / _cse_1874_);
        let _cse_1871_ = (2f * _cse_1872_);
        let _cse_1870_ = (_cse_1871_ - 1f);
        let _cse_1869_ = min(_cse_1870_, 1999f);
        let _cse_1868_ = max(-2001f, _cse_1869_);
        let _cse_1867_ = ((_cse_1868_ + abs(_cse_1868_)) / (1f + abs(_cse_1868_)));
        let _cse_1866_ = (_cse_1867_ * lambda_other);
        let _cse_1864_ = (_cse_1865_ * _cse_1866_);
        let _cse_1863_ = (vec2<f32>(_cse_1992_, _cse_1931_) + _cse_1864_);
        let _cse_1862_ = ((_cse_1863_ * 1f) / vec2(_cse_1858_));
        let _cse_1881_ = ((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)))) * (_e758 - _e234)) / (((_e758 - _e234) * (_e758 - _e234)) + 0.000000000000000000000000000001f)) - 1f);
        let _cse_1880_ = min(_cse_1881_, 1999f);
        let _cse_1879_ = max(-2001f, _cse_1880_);
        let _cse_1878_ = ((_cse_1879_ + abs(_cse_1879_)) / (1f + abs(_cse_1879_)));
        let _e11847 = lambda;
        let _cse_1877_ = (_cse_1878_ * _e11847);
        let _cse_1876_ = (_cse_1877_ * (_e758 - _e234));
        let _cse_1875_ = (_e758 - _cse_1876_);
        let _cse_1891_ = ((dot(_cse_1865_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))))) * _cse_1873_) / _cse_1874_);
        let _cse_1890_ = (2f * _cse_1891_);
        let _cse_1889_ = (_cse_1890_ - 1f);
        let _cse_1888_ = min(_cse_1889_, 1999f);
        let _cse_1887_ = max(-2001f, _cse_1888_);
        let _cse_1886_ = ((_cse_1887_ + abs(_cse_1887_)) / (1f + abs(_cse_1887_)));
        let _e11884 = lambda;
        let _cse_1885_ = (_cse_1886_ * _e11884);
        let _cse_1884_ = (_cse_1865_ * _cse_1885_);
        let _cse_1883_ = (vec2<f32>(_cse_1929_, _cse_1933_) - _cse_1884_);
        let _cse_1882_ = ((_cse_1883_ * 1f) / vec2(_cse_1875_));
        let _e11893 = normal_vec;
        let _cse_1892_ = dot(_cse_1862_, _e11893);
        let _cse_1903_ = (_cse_1892_ * _cse_1892_);
        let _e11898 = low_mach_params.model;
        let _e11909 = constants.eos_gamma;
        let _e11913 = constants.eos_r;
        let _e11986 = constants.eos_dp_drho;
        let _e11991 = low_mach_params.model;
        let _e12000 = constants.eos_gamma;
        let _e12004 = constants.eos_r;
        let _e12077 = constants.eos_dp_drho;
        let _cse_1902_ = ((max(0f, (1f - abs((f32(_e11898) - 2f)))) * (((((_e11909 * _cse_1858_) * _e11913) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / _cse_1858_) + _e11986)) + (max(0f, (1f - abs(f32(_e11991)))) * min(_cse_1903_, (((((_e12000 * _cse_1858_) * _e12004) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / _cse_1858_) + _e12077))));
        let _e12084 = low_mach_params.theta_floor;
        let _e12087 = constants.eos_gamma;
        let _e12091 = constants.eos_r;
        let _e12164 = constants.eos_dp_drho;
        let _e12170 = constants.eos_gamma;
        let _e12174 = constants.eos_r;
        let _e12247 = constants.eos_dp_drho;
        let _cse_1905_ = min(max(_cse_1903_, (_e12084 * (((((_e12087 * _cse_1858_) * _e12091) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / _cse_1858_) + _e12164))), (((((_e12170 * _cse_1858_) * _e12174) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / _cse_1858_) + _e12247));
        let _e12252 = low_mach_params.model;
        let _cse_1904_ = (max(0f, (1f - abs((f32(_e12252) - 1f)))) * _cse_1905_);
        let _cse_1901_ = (_cse_1902_ + _cse_1904_);
        let _cse_1900_ = sqrt(_cse_1901_);
        let _cse_1899_ = (_cse_1892_ + _cse_1900_);
        let _e12265 = normal_vec;
        let _cse_1907_ = dot(_cse_1882_, _e12265);
        let _e12269 = constants.eos_gamma;
        let _e12273 = constants.eos_r;
        let _e12350 = lambda;
        let _cse_1912_ = ((((_e12269 * _cse_1875_) * _e12273) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e12350) * (_e536 - _e121)))) / _cse_1875_);
        let _e12359 = constants.eos_dp_drho;
        let _cse_1911_ = (_cse_1912_ + _e12359);
        let _cse_1913_ = (_cse_1907_ * _cse_1907_);
        let _e12364 = low_mach_params.model;
        let _e12376 = low_mach_params.model;
        let _cse_1910_ = ((max(0f, (1f - abs((f32(_e12364) - 2f)))) * _cse_1911_) + (max(0f, (1f - abs(f32(_e12376)))) * min(_cse_1913_, _cse_1911_)));
        let _e12388 = low_mach_params.theta_floor;
        let _cse_1915_ = min(max(_cse_1913_, (_e12388 * _cse_1911_)), _cse_1911_);
        let _e12394 = low_mach_params.model;
        let _cse_1914_ = (max(0f, (1f - abs((f32(_e12394) - 1f)))) * _cse_1915_);
        let _cse_1909_ = (_cse_1910_ + _cse_1914_);
        let _cse_1908_ = sqrt(_cse_1909_);
        let _cse_1906_ = (_cse_1907_ + _cse_1908_);
        let _cse_1898_ = max(_cse_1899_, _cse_1906_);
        let _cse_1897_ = max(0f, _cse_1898_);
        let _cse_1919_ = min((_cse_1892_ - _cse_1900_), (_cse_1907_ - _cse_1908_));
        let _cse_1918_ = min(0f, _cse_1919_);
        let _cse_1917_ = (_cse_1897_ - _cse_1918_);
        let _cse_1916_ = max(_cse_1917_, 0.000001f);
        let _cse_1896_ = (_cse_1897_ / _cse_1916_);
        let _cse_1895_ = (_cse_1862_ * _cse_1896_);
        let _cse_1921_ = (1f - _cse_1896_);
        let _cse_1920_ = (_cse_1882_ * _cse_1921_);
        let _cse_1894_ = (_cse_1895_ + _cse_1920_);
        let _e12429 = lambda;
        let _e12434 = normal_vec;
        let _e12445 = state[((owner_1 * 22u) + 10u)];
        let _e12450 = normal_vec;
        let _e12456 = lambda;
        let _e12465 = normal_vec;
        let _e12472 = lambda;
        let _e12477 = normal_vec;
        let _e12488 = state[((owner_1 * 22u) + 11u)];
        let _e12493 = normal_vec;
        let _e12499 = lambda;
        let _e12508 = normal_vec;
        let _e12513 = constants.viscosity;
        let _e12517 = constants.viscosity;
        let _e12523 = lambda;
        let _e12528 = normal_vec;
        let _e12539 = state[((owner_1 * 22u) + 10u)];
        let _e12544 = normal_vec;
        let _e12550 = lambda;
        let _e12565 = lambda;
        let _e12570 = normal_vec;
        let _e12581 = state[((owner_1 * 22u) + 10u)];
        let _e12586 = normal_vec;
        let _e12592 = lambda;
        let _e12607 = lambda;
        let _e12612 = normal_vec;
        let _e12623 = state[((owner_1 * 22u) + 11u)];
        let _e12628 = normal_vec;
        let _e12634 = lambda;
        let _e12649 = normal_vec.x;
        let _e12656 = lambda;
        let _e12661 = normal_vec;
        let _e12672 = state[((owner_1 * 22u) + 10u)];
        let _e12677 = normal_vec;
        let _e12683 = lambda;
        let _e12694 = normal_vec.y;
        let _e12700 = constants.viscosity;
        let _e12706 = lambda;
        let _e12711 = normal_vec;
        let _e12722 = state[((owner_1 * 22u) + 11u)];
        let _e12727 = normal_vec;
        let _e12733 = lambda;
        let _e12744 = normal_vec.x;
        let _e12751 = lambda;
        let _e12756 = normal_vec;
        let _e12767 = state[((owner_1 * 22u) + 11u)];
        let _e12772 = normal_vec;
        let _e12778 = lambda;
        let _e12793 = lambda;
        let _e12798 = normal_vec;
        let _e12809 = state[((owner_1 * 22u) + 10u)];
        let _e12814 = normal_vec;
        let _e12820 = lambda;
        let _e12835 = lambda;
        let _e12840 = normal_vec;
        let _e12851 = state[((owner_1 * 22u) + 11u)];
        let _e12856 = normal_vec;
        let _e12862 = lambda;
        let _e12877 = normal_vec.y;
        let _cse_1893_ = dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12429) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e12434 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e12445) / max(dist, 0.000001f)) - dot(_e12450, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12456) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e12465), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12472) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e12477 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e12488) / max(dist, 0.000001f)) - dot(_e12493, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12499) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e12508)) * _e12513) + vec2<f32>((_e12517 * ((((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12523) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e12528 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e12539) / max(dist, 0.000001f)) - dot(_e12544, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12550) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12565) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e12570 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e12581) / max(dist, 0.000001f)) - dot(_e12586, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12592) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12607) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e12612 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e12623) / max(dist, 0.000001f)) - dot(_e12628, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12634) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e12649) + ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12656) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e12661 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e12672) / max(dist, 0.000001f)) - dot(_e12677, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12683) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).y * _e12694))), (_e12700 * (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12706) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e12711 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e12722) / max(dist, 0.000001f)) - dot(_e12727, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12733) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).x * _e12744) + (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12751) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e12756 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e12767) / max(dist, 0.000001f)) - dot(_e12772, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12778) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12793) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e12798 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e12809) / max(dist, 0.000001f)) - dot(_e12814, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e12820) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12835) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e12840 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e12851) / max(dist, 0.000001f)) - dot(_e12856, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e12862) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e12877))))), _cse_1894_);
        let _e12886 = constants.eos_r;
        let _e12958 = constants.eos_gm1_;
        u_l_3_ = ((((_cse_1858_ * _e12886) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / max(_e12958, 0.000000000001f)) + ((0.5f * _cse_1858_) * dot(_cse_1862_, _cse_1862_)));
        let _e12969 = constants.eos_r;
        let _e13046 = lambda;
        let _e13054 = constants.eos_gm1_;
        u_r_3_ = ((((_cse_1875_ * _e12969) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e13046) * (_e536 - _e121)))) / max(_e13054, 0.000000000001f)) + ((0.5f * _cse_1875_) * dot(_cse_1882_, _cse_1882_)));
        let _e13065 = constants.eos_r;
        let _e13137 = constants.eos_gm1_;
        let _e13148 = constants.eos_r;
        f_l_3_ = (((((((_cse_1858_ * _e13065) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121)))) / max(_e13137, 0.000000000001f)) + ((0.5f * _cse_1858_) * dot(_cse_1862_, _cse_1862_))) + ((_cse_1858_ * _e13148) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e536 - _e121))))) * _cse_1892_) - _cse_1893_);
        let _e13223 = constants.eos_r;
        let _e13300 = lambda;
        let _e13308 = constants.eos_gm1_;
        let _e13319 = constants.eos_r;
        let _e13396 = lambda;
        f_r_3_ = (((((((_cse_1875_ * _e13223) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e13300) * (_e536 - _e121)))) / max(_e13308, 0.000000000001f)) + ((0.5f * _cse_1875_) * dot(_cse_1882_, _cse_1882_))) + ((_cse_1875_ * _e13319) * (_e536 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e536 - _e121)) / (((_e536 - _e121) * (_e536 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e13396) * (_e536 - _e121))))) * _cse_1907_) - _cse_1893_);
    }
    let _e13407 = constants.scheme;
    if ((_e13407 == 5u) && !(is_boundary_1)) {
        let _cse_1923_ = min(max(((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e758 - _e234), 0f)), max((_e758 - _e234), 0f));
        let _cse_1922_ = (_e234 + _cse_1923_);
        let _cse_1928_ = min(max(((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_), min((_cse_1929_ - _cse_1992_), 0f)), max((_cse_1929_ - _cse_1992_), 0f));
        let _cse_1926_ = (_cse_1992_ + _cse_1928_);
        let _cse_1932_ = min(max(((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_), min((_cse_1933_ - _cse_1931_), 0f)), max((_cse_1933_ - _cse_1931_), 0f));
        let _cse_1930_ = (_cse_1931_ + _cse_1932_);
        let _cse_1925_ = vec2<f32>(_cse_1926_, _cse_1930_);
        let _cse_1924_ = ((_cse_1925_ * 1f) / vec2(_cse_1922_));
        let _cse_1937_ = max(((((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e758), min((_e234 - _e758), 0f));
        let _cse_1936_ = min(_cse_1937_, max((_e234 - _e758), 0f));
        let _cse_1935_ = (_e758 + _cse_1936_);
        let _e13507 = constants.eos_r;
        let _cse_1934_ = ((_cse_1935_ * _e13507) * (_e536 + min(max(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536), min((_e121 - _e536), 0f)), max((_e121 - _e536), 0f))));
        let _cse_1942_ = max(((((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1929_), min((_cse_1992_ - _cse_1929_), 0f));
        let _cse_1941_ = min(_cse_1942_, max((_cse_1992_ - _cse_1929_), 0f));
        let _cse_1940_ = (_cse_1929_ + _cse_1941_);
        let _cse_1945_ = max(((((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1933_), min((_cse_1931_ - _cse_1933_), 0f));
        let _cse_1944_ = min(_cse_1945_, max((_cse_1931_ - _cse_1933_), 0f));
        let _cse_1943_ = (_cse_1933_ + _cse_1944_);
        let _cse_1939_ = vec2<f32>(_cse_1940_, _cse_1943_);
        let _cse_1938_ = ((_cse_1939_ * 1f) / vec2(_cse_1935_));
        let _e13590 = normal_vec;
        let _cse_1946_ = dot(_cse_1924_, _e13590);
        let _e13594 = constants.eos_gamma;
        let _e13598 = constants.eos_r;
        let _cse_1958_ = ((((_e13594 * _cse_1922_) * _e13598) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) / _cse_1922_);
        let _e13625 = constants.eos_dp_drho;
        let _cse_1957_ = (_cse_1958_ + _e13625);
        let _cse_1961_ = (_cse_1946_ * _cse_1946_);
        let _cse_1960_ = min(_cse_1961_, _cse_1957_);
        let _e13631 = low_mach_params.model;
        let _cse_1959_ = (max(0f, (1f - abs(f32(_e13631)))) * _cse_1960_);
        let _e13641 = low_mach_params.model;
        let _cse_1956_ = ((max(0f, (1f - abs((f32(_e13641) - 2f)))) * _cse_1957_) + _cse_1959_);
        let _e13654 = low_mach_params.theta_floor;
        let _cse_1964_ = max(_cse_1961_, (_e13654 * _cse_1957_));
        let _cse_1963_ = min(_cse_1964_, _cse_1957_);
        let _e13660 = low_mach_params.model;
        let _cse_1962_ = (max(0f, (1f - abs((f32(_e13660) - 1f)))) * _cse_1963_);
        let _cse_1955_ = (_cse_1956_ + _cse_1962_);
        let _cse_1954_ = sqrt(_cse_1955_);
        let _cse_1953_ = (_cse_1946_ + _cse_1954_);
        let _e13673 = normal_vec;
        let _cse_1966_ = dot(_cse_1938_, _e13673);
        let _e13677 = constants.eos_gamma;
        let _cse_1971_ = ((_e13677 * _cse_1934_) / _cse_1935_);
        let _e13682 = constants.eos_dp_drho;
        let _cse_1970_ = (_cse_1971_ + _e13682);
        let _cse_1974_ = (_cse_1966_ * _cse_1966_);
        let _cse_1973_ = min(_cse_1974_, _cse_1970_);
        let _e13688 = low_mach_params.model;
        let _cse_1972_ = (max(0f, (1f - abs(f32(_e13688)))) * _cse_1973_);
        let _e13698 = low_mach_params.model;
        let _cse_1969_ = ((max(0f, (1f - abs((f32(_e13698) - 2f)))) * _cse_1970_) + _cse_1972_);
        let _e13711 = low_mach_params.theta_floor;
        let _cse_1977_ = max(_cse_1974_, (_e13711 * _cse_1970_));
        let _cse_1976_ = min(_cse_1977_, _cse_1970_);
        let _e13717 = low_mach_params.model;
        let _cse_1975_ = (max(0f, (1f - abs((f32(_e13717) - 1f)))) * _cse_1976_);
        let _cse_1968_ = (_cse_1969_ + _cse_1975_);
        let _cse_1967_ = sqrt(_cse_1968_);
        let _cse_1965_ = (_cse_1966_ + _cse_1967_);
        let _cse_1952_ = max(_cse_1953_, _cse_1965_);
        let _cse_1951_ = max(0f, _cse_1952_);
        let _cse_1982_ = (_cse_1946_ - _cse_1954_);
        let _cse_1983_ = (_cse_1966_ - _cse_1967_);
        let _cse_1981_ = min(_cse_1982_, _cse_1983_);
        let _cse_1980_ = min(0f, _cse_1981_);
        let _cse_1979_ = (_cse_1951_ - _cse_1980_);
        let _cse_1978_ = max(_cse_1979_, 0.000001f);
        let _cse_1950_ = (_cse_1951_ / _cse_1978_);
        let _cse_1949_ = (_cse_1924_ * _cse_1950_);
        let _cse_1985_ = (1f - _cse_1950_);
        let _cse_1984_ = (_cse_1938_ * _cse_1985_);
        let _cse_1948_ = (_cse_1949_ + _cse_1984_);
        let _e13752 = lambda;
        let _e13757 = normal_vec;
        let _e13768 = state[((owner_1 * 22u) + 10u)];
        let _e13773 = normal_vec;
        let _e13779 = lambda;
        let _e13788 = normal_vec;
        let _e13795 = lambda;
        let _e13800 = normal_vec;
        let _e13811 = state[((owner_1 * 22u) + 11u)];
        let _e13816 = normal_vec;
        let _e13822 = lambda;
        let _e13831 = normal_vec;
        let _e13836 = constants.viscosity;
        let _e13840 = constants.viscosity;
        let _e13846 = lambda;
        let _e13851 = normal_vec;
        let _e13862 = state[((owner_1 * 22u) + 10u)];
        let _e13867 = normal_vec;
        let _e13873 = lambda;
        let _e13888 = lambda;
        let _e13893 = normal_vec;
        let _e13904 = state[((owner_1 * 22u) + 10u)];
        let _e13909 = normal_vec;
        let _e13915 = lambda;
        let _e13930 = lambda;
        let _e13935 = normal_vec;
        let _e13946 = state[((owner_1 * 22u) + 11u)];
        let _e13951 = normal_vec;
        let _e13957 = lambda;
        let _e13972 = normal_vec.x;
        let _e13979 = lambda;
        let _e13984 = normal_vec;
        let _e13995 = state[((owner_1 * 22u) + 10u)];
        let _e14000 = normal_vec;
        let _e14006 = lambda;
        let _e14017 = normal_vec.y;
        let _e14023 = constants.viscosity;
        let _e14029 = lambda;
        let _e14034 = normal_vec;
        let _e14045 = state[((owner_1 * 22u) + 11u)];
        let _e14050 = normal_vec;
        let _e14056 = lambda;
        let _e14067 = normal_vec.x;
        let _e14074 = lambda;
        let _e14079 = normal_vec;
        let _e14090 = state[((owner_1 * 22u) + 11u)];
        let _e14095 = normal_vec;
        let _e14101 = lambda;
        let _e14116 = lambda;
        let _e14121 = normal_vec;
        let _e14132 = state[((owner_1 * 22u) + 10u)];
        let _e14137 = normal_vec;
        let _e14143 = lambda;
        let _e14158 = lambda;
        let _e14163 = normal_vec;
        let _e14174 = state[((owner_1 * 22u) + 11u)];
        let _e14179 = normal_vec;
        let _e14185 = lambda;
        let _e14200 = normal_vec.y;
        let _cse_1947_ = dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13752) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e13757 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e13768) / max(dist, 0.000001f)) - dot(_e13773, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13779) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e13788), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e13795) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e13800 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e13811) / max(dist, 0.000001f)) - dot(_e13816, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e13822) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e13831)) * _e13836) + vec2<f32>((_e13840 * ((((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13846) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e13851 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e13862) / max(dist, 0.000001f)) - dot(_e13867, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13873) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13888) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e13893 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e13904) / max(dist, 0.000001f)) - dot(_e13909, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13915) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e13930) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e13935 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e13946) / max(dist, 0.000001f)) - dot(_e13951, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e13957) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e13972) + ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e13979) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e13984 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e13995) / max(dist, 0.000001f)) - dot(_e14000, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e14006) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).y * _e14017))), (_e14023 * (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14029) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e14034 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e14045) / max(dist, 0.000001f)) - dot(_e14050, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14056) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).x * _e14067) + (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14074) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e14079 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e14090) / max(dist, 0.000001f)) - dot(_e14095, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14101) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e14116) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e14121 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e14132) / max(dist, 0.000001f)) - dot(_e14137, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e14143) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14158) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e14163 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e14174) / max(dist, 0.000001f)) - dot(_e14179, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14185) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e14200))))), _cse_1948_);
        let _e14209 = constants.eos_r;
        let _e14235 = constants.eos_gm1_;
        u_l_3_ = ((((_cse_1922_ * _e14209) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) / max(_e14235, 0.000000000001f)) + ((0.5f * _cse_1922_) * dot(_cse_1924_, _cse_1924_)));
        let _e14246 = constants.eos_gm1_;
        u_r_3_ = ((_cse_1934_ / max(_e14246, 0.000000000001f)) + ((0.5f * _cse_1935_) * dot(_cse_1938_, _cse_1938_)));
        let _e14257 = constants.eos_r;
        let _e14283 = constants.eos_gm1_;
        let _e14294 = constants.eos_r;
        f_l_3_ = (((((((_cse_1922_ * _e14257) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f)))) / max(_e14283, 0.000000000001f)) + ((0.5f * _cse_1922_) * dot(_cse_1924_, _cse_1924_))) + ((_cse_1922_ * _e14294) * (_e121 + min(max(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e536 - _e121), 0f)), max((_e536 - _e121), 0f))))) * _cse_1946_) - _cse_1947_);
        let _e14323 = constants.eos_gm1_;
        f_r_3_ = (((((_cse_1934_ / max(_e14323, 0.000000000001f)) + ((0.5f * _cse_1935_) * dot(_cse_1938_, _cse_1938_))) + _cse_1934_) * _cse_1966_) - _cse_1947_);
    }
    let _e14337 = constants.scheme;
    if ((_e14337 == 6u) && !(is_boundary_1)) {
        let _cse_1988_ = ((((_e234 * 0.625f) + (_e758 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234);
        let _cse_1987_ = ((((_cse_1988_ * abs((_e758 - _e234))) / max(abs((_e758 - _e234)), (abs(_cse_1988_) + 0.00000001f))) * max(((_e758 - _e234) * _cse_1988_), 0f)) / max(abs(((_e758 - _e234) * _cse_1988_)), 0.00000001f));
        let _cse_1986_ = (_e234 + _cse_1987_);
        let _cse_1993_ = ((((((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_) * abs((_cse_1929_ - _cse_1992_))) / max(abs((_cse_1929_ - _cse_1992_)), (abs(((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_)) + 0.00000001f))) * max(((_cse_1929_ - _cse_1992_) * ((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_)), 0f)) / max(abs(((_cse_1929_ - _cse_1992_) * ((((_cse_1992_ * 0.625f) + (_cse_1929_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1992_))), 0.00000001f));
        let _cse_1991_ = (_cse_1992_ + _cse_1993_);
        let _cse_1995_ = ((((((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_) * abs((_cse_1933_ - _cse_1931_))) / max(abs((_cse_1933_ - _cse_1931_)), (abs(((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_)) + 0.00000001f))) * max(((_cse_1933_ - _cse_1931_) * ((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_)), 0f)) / max(abs(((_cse_1933_ - _cse_1931_) * ((((_cse_1931_ * 0.625f) + (_cse_1933_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1931_))), 0.00000001f));
        let _cse_1994_ = (_cse_1931_ + _cse_1995_);
        let _cse_1990_ = vec2<f32>(_cse_1991_, _cse_1994_);
        let _cse_1989_ = ((_cse_1990_ * 1f) / vec2(_cse_1986_));
        let _cse_2000_ = (((_e758 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1999_ = (_cse_2000_ - _e758);
        let _cse_1998_ = ((((_cse_1999_ * abs((_e234 - _e758))) / max(abs((_e234 - _e758)), (abs(_cse_1999_) + 0.00000001f))) * max(((_e234 - _e758) * _cse_1999_), 0f)) / max(abs(((_e234 - _e758) * _cse_1999_)), 0.00000001f));
        let _cse_1997_ = (_e758 + _cse_1998_);
        let _e14561 = constants.eos_r;
        let _cse_1996_ = ((_cse_1997_ * _e14561) * (_e536 + ((((((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536) * abs((_e121 - _e536))) / max(abs((_e121 - _e536)), (abs(((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)) + 0.00000001f))) * max(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536)), 0f)) / max(abs(((_e121 - _e536) * ((((_e536 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e536))), 0.00000001f))));
        let _cse_2005_ = ((((_cse_1929_ * 0.625f) + (_cse_1992_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1929_);
        let _cse_2004_ = ((((_cse_2005_ * abs((_cse_1992_ - _cse_1929_))) / max(abs((_cse_1992_ - _cse_1929_)), (abs(_cse_2005_) + 0.00000001f))) * max(((_cse_1992_ - _cse_1929_) * _cse_2005_), 0f)) / max(abs(((_cse_1992_ - _cse_1929_) * _cse_2005_)), 0.00000001f));
        let _cse_2003_ = (_cse_1929_ + _cse_2004_);
        let _cse_2008_ = ((((_cse_1933_ * 0.625f) + (_cse_1931_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1933_);
        let _cse_2007_ = ((((_cse_2008_ * abs((_cse_1931_ - _cse_1933_))) / max(abs((_cse_1931_ - _cse_1933_)), (abs(_cse_2008_) + 0.00000001f))) * max(((_cse_1931_ - _cse_1933_) * _cse_2008_), 0f)) / max(abs(((_cse_1931_ - _cse_1933_) * _cse_2008_)), 0.00000001f));
        let _cse_2006_ = (_cse_1933_ + _cse_2007_);
        let _cse_2002_ = vec2<f32>(_cse_2003_, _cse_2006_);
        let _cse_2001_ = ((_cse_2002_ * 1f) / vec2(_cse_1997_));
        let _e14731 = normal_vec;
        let _cse_2009_ = dot(_cse_1989_, _e14731);
        let _e14735 = constants.eos_gamma;
        let _e14739 = constants.eos_r;
        let _cse_2021_ = ((((_e14735 * _cse_1986_) * _e14739) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) / _cse_1986_);
        let _e14815 = constants.eos_dp_drho;
        let _cse_2020_ = (_cse_2021_ + _e14815);
        let _cse_2024_ = (_cse_2009_ * _cse_2009_);
        let _cse_2023_ = min(_cse_2024_, _cse_2020_);
        let _e14821 = low_mach_params.model;
        let _cse_2022_ = (max(0f, (1f - abs(f32(_e14821)))) * _cse_2023_);
        let _e14831 = low_mach_params.model;
        let _cse_2019_ = ((max(0f, (1f - abs((f32(_e14831) - 2f)))) * _cse_2020_) + _cse_2022_);
        let _e14844 = low_mach_params.theta_floor;
        let _cse_2027_ = max(_cse_2024_, (_e14844 * _cse_2020_));
        let _cse_2026_ = min(_cse_2027_, _cse_2020_);
        let _e14850 = low_mach_params.model;
        let _cse_2025_ = (max(0f, (1f - abs((f32(_e14850) - 1f)))) * _cse_2026_);
        let _cse_2018_ = (_cse_2019_ + _cse_2025_);
        let _cse_2017_ = sqrt(_cse_2018_);
        let _cse_2016_ = (_cse_2009_ + _cse_2017_);
        let _e14863 = normal_vec;
        let _cse_2029_ = dot(_cse_2001_, _e14863);
        let _e14867 = constants.eos_gamma;
        let _cse_2035_ = (_e14867 * _cse_1996_);
        let _cse_2034_ = (_cse_2035_ / _cse_1997_);
        let _e14872 = constants.eos_dp_drho;
        let _cse_2033_ = (_cse_2034_ + _e14872);
        let _cse_2038_ = (_cse_2029_ * _cse_2029_);
        let _cse_2037_ = min(_cse_2038_, _cse_2033_);
        let _e14878 = low_mach_params.model;
        let _cse_2036_ = (max(0f, (1f - abs(f32(_e14878)))) * _cse_2037_);
        let _e14888 = low_mach_params.model;
        let _cse_2032_ = ((max(0f, (1f - abs((f32(_e14888) - 2f)))) * _cse_2033_) + _cse_2036_);
        let _e14901 = low_mach_params.theta_floor;
        let _cse_2041_ = max(_cse_2038_, (_e14901 * _cse_2033_));
        let _cse_2040_ = min(_cse_2041_, _cse_2033_);
        let _e14907 = low_mach_params.model;
        let _cse_2039_ = (max(0f, (1f - abs((f32(_e14907) - 1f)))) * _cse_2040_);
        let _cse_2031_ = (_cse_2032_ + _cse_2039_);
        let _cse_2030_ = sqrt(_cse_2031_);
        let _cse_2028_ = (_cse_2029_ + _cse_2030_);
        let _cse_2015_ = max(_cse_2016_, _cse_2028_);
        let _cse_2014_ = max(0f, _cse_2015_);
        let _cse_2046_ = (_cse_2009_ - _cse_2017_);
        let _cse_2047_ = (_cse_2029_ - _cse_2030_);
        let _cse_2045_ = min(_cse_2046_, _cse_2047_);
        let _cse_2044_ = min(0f, _cse_2045_);
        let _cse_2043_ = (_cse_2014_ - _cse_2044_);
        let _cse_2042_ = max(_cse_2043_, 0.000001f);
        let _cse_2013_ = (_cse_2014_ / _cse_2042_);
        let _cse_2012_ = (_cse_1989_ * _cse_2013_);
        let _cse_2049_ = (1f - _cse_2013_);
        let _cse_2048_ = (_cse_2001_ * _cse_2049_);
        let _cse_2011_ = (_cse_2012_ + _cse_2048_);
        let _e14942 = lambda;
        let _e14947 = normal_vec;
        let _e14958 = state[((owner_1 * 22u) + 10u)];
        let _e14963 = normal_vec;
        let _e14969 = lambda;
        let _e14978 = normal_vec;
        let _e14985 = lambda;
        let _e14990 = normal_vec;
        let _e15001 = state[((owner_1 * 22u) + 11u)];
        let _e15006 = normal_vec;
        let _e15012 = lambda;
        let _e15021 = normal_vec;
        let _e15026 = constants.viscosity;
        let _e15030 = constants.viscosity;
        let _e15036 = lambda;
        let _e15041 = normal_vec;
        let _e15052 = state[((owner_1 * 22u) + 10u)];
        let _e15057 = normal_vec;
        let _e15063 = lambda;
        let _e15078 = lambda;
        let _e15083 = normal_vec;
        let _e15094 = state[((owner_1 * 22u) + 10u)];
        let _e15099 = normal_vec;
        let _e15105 = lambda;
        let _e15120 = lambda;
        let _e15125 = normal_vec;
        let _e15136 = state[((owner_1 * 22u) + 11u)];
        let _e15141 = normal_vec;
        let _e15147 = lambda;
        let _e15162 = normal_vec.x;
        let _e15169 = lambda;
        let _e15174 = normal_vec;
        let _e15185 = state[((owner_1 * 22u) + 10u)];
        let _e15190 = normal_vec;
        let _e15196 = lambda;
        let _e15207 = normal_vec.y;
        let _e15213 = constants.viscosity;
        let _e15219 = lambda;
        let _e15224 = normal_vec;
        let _e15235 = state[((owner_1 * 22u) + 11u)];
        let _e15240 = normal_vec;
        let _e15246 = lambda;
        let _e15257 = normal_vec.x;
        let _e15264 = lambda;
        let _e15269 = normal_vec;
        let _e15280 = state[((owner_1 * 22u) + 11u)];
        let _e15285 = normal_vec;
        let _e15291 = lambda;
        let _e15306 = lambda;
        let _e15311 = normal_vec;
        let _e15322 = state[((owner_1 * 22u) + 10u)];
        let _e15327 = normal_vec;
        let _e15333 = lambda;
        let _e15348 = lambda;
        let _e15353 = normal_vec;
        let _e15364 = state[((owner_1 * 22u) + 11u)];
        let _e15369 = normal_vec;
        let _e15375 = lambda;
        let _e15390 = normal_vec.y;
        let _cse_2010_ = dot(((vec2<f32>(dot((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e14942) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e14947 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e14958) / max(dist, 0.000001f)) - dot(_e14963, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e14969) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))), _e14978), dot((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e14985) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e14990 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e15001) / max(dist, 0.000001f)) - dot(_e15006, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15012) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))), _e15021)) * _e15026) + vec2<f32>((_e15030 * ((((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15036) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e15041 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e15052) / max(dist, 0.000001f)) - dot(_e15057, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15063) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15078) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e15083 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e15094) / max(dist, 0.000001f)) - dot(_e15099, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15105) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15120) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e15125 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e15136) / max(dist, 0.000001f)) - dot(_e15141, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15147) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e15162) + ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15169) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e15174 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e15185) / max(dist, 0.000001f)) - dot(_e15190, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15196) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).y * _e15207))), (_e15213 * (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15219) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e15224 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e15235) / max(dist, 0.000001f)) - dot(_e15240, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15246) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).x * _e15257) + (((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15264) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e15269 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e15280) / max(dist, 0.000001f)) - dot(_e15285, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15291) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y - (0.6666667f * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15306) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)) + ((_e15311 * select(0f, 1f, is_boundary_1)) * (((_cse_1276_ - _e15322) / max(dist, 0.000001f)) - dot(_e15327, ((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e15333) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)))))).x + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15348) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)) + ((_e15353 * select(0f, 1f, is_boundary_1)) * (((_cse_1392_ - _e15364) / max(dist, 0.000001f)) - dot(_e15369, ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e15375) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)))))).y))) * _e15390))))), _cse_2011_);
        let _e15399 = constants.eos_r;
        let _e15474 = constants.eos_gm1_;
        u_l_3_ = ((((_cse_1986_ * _e15399) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) / max(_e15474, 0.000000000001f)) + ((0.5f * _cse_1986_) * dot(_cse_1989_, _cse_1989_)));
        let _e15485 = constants.eos_gm1_;
        u_r_3_ = ((_cse_1996_ / max(_e15485, 0.000000000001f)) + ((0.5f * _cse_1997_) * dot(_cse_2001_, _cse_2001_)));
        let _e15496 = constants.eos_r;
        let _e15571 = constants.eos_gm1_;
        let _e15582 = constants.eos_r;
        f_l_3_ = (((((((_cse_1986_ * _e15496) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) / max(_e15571, 0.000000000001f)) + ((0.5f * _cse_1986_) * dot(_cse_1989_, _cse_1989_))) + ((_cse_1986_ * _e15582) * (_e121 + ((((((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e536 - _e121))) / max(abs((_e536 - _e121)), (abs(((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e536 - _e121) * ((((_e121 * 0.625f) + (_e536 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f))))) * _cse_2009_) - _cse_2010_);
        let _e15660 = constants.eos_gm1_;
        f_r_3_ = (((((_cse_1996_ / max(_e15660, 0.000000000001f)) + ((0.5f * _cse_1997_) * dot(_cse_2001_, _cse_2001_))) + _cse_1996_) * _cse_2029_) - _cse_2010_);
    }
    let _e15678 = a_plus;
    let _e15679 = f_l_3_;
    let _e15681 = a_minus;
    let _e15682 = f_r_3_;
    let _e15685 = a_plus;
    let _e15686 = a_minus;
    let _e15688 = u_r_3_;
    let _e15689 = u_l_3_;
    fluxes[((idx * 8u) + 3u)] = (((((_e15678 * _e15679) - (_e15681 * _e15682)) + ((_e15685 * _e15686) * (_e15688 - _e15689))) / denom) * area);
    let _e15697 = constants.scheme;
    if ((_e15697 == 1u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e15712 = constants.scheme;
    if ((_e15712 == 2u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e15723 = constants.scheme;
    if ((_e15723 == 3u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e15734 = constants.scheme;
    if ((_e15734 == 4u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e15745 = constants.scheme;
    if ((_e15745 == 5u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e15756 = constants.scheme;
    if ((_e15756 == 6u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e15771 = a_plus;
    let _e15772 = f_l_4_;
    let _e15774 = a_minus;
    let _e15775 = f_r_4_;
    let _e15778 = a_plus;
    let _e15779 = a_minus;
    let _e15781 = u_r_4_;
    let _e15782 = u_l_4_;
    fluxes[((idx * 8u) + 4u)] = (((((_e15771 * _e15772) - (_e15774 * _e15775)) + ((_e15778 * _e15779) * (_e15781 - _e15782))) / denom) * area);
    let _e15790 = constants.scheme;
    if ((_e15790 == 1u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e15805 = constants.scheme;
    if ((_e15805 == 2u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e15816 = constants.scheme;
    if ((_e15816 == 3u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e15827 = constants.scheme;
    if ((_e15827 == 4u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e15838 = constants.scheme;
    if ((_e15838 == 5u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e15849 = constants.scheme;
    if ((_e15849 == 6u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e15864 = a_plus;
    let _e15865 = f_l_5_;
    let _e15867 = a_minus;
    let _e15868 = f_r_5_;
    let _e15871 = a_plus;
    let _e15872 = a_minus;
    let _e15874 = u_r_5_;
    let _e15875 = u_l_5_;
    fluxes[((idx * 8u) + 5u)] = (((((_e15864 * _e15865) - (_e15867 * _e15868)) + ((_e15871 * _e15872) * (_e15874 - _e15875))) / denom) * area);
    let _e15883 = constants.scheme;
    if ((_e15883 == 1u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e15898 = constants.scheme;
    if ((_e15898 == 2u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e15909 = constants.scheme;
    if ((_e15909 == 3u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e15920 = constants.scheme;
    if ((_e15920 == 4u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e15931 = constants.scheme;
    if ((_e15931 == 5u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e15942 = constants.scheme;
    if ((_e15942 == 6u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e15957 = a_plus;
    let _e15958 = f_l_6_;
    let _e15960 = a_minus;
    let _e15961 = f_r_6_;
    let _e15964 = a_plus;
    let _e15965 = a_minus;
    let _e15967 = u_r_6_;
    let _e15968 = u_l_6_;
    fluxes[((idx * 8u) + 6u)] = (((((_e15957 * _e15958) - (_e15960 * _e15961)) + ((_e15964 * _e15965) * (_e15967 - _e15968))) / denom) * area);
    let _e15976 = constants.scheme;
    if ((_e15976 == 1u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e15991 = constants.scheme;
    if ((_e15991 == 2u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e16002 = constants.scheme;
    if ((_e16002 == 3u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e16013 = constants.scheme;
    if ((_e16013 == 4u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e16024 = constants.scheme;
    if ((_e16024 == 5u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e16035 = constants.scheme;
    if ((_e16035 == 6u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e16050 = a_plus;
    let _e16051 = f_l_7_;
    let _e16053 = a_minus;
    let _e16054 = f_r_7_;
    let _e16057 = a_plus;
    let _e16058 = a_minus;
    let _e16060 = u_r_7_;
    let _e16061 = u_l_7_;
    fluxes[((idx * 8u) + 7u)] = (((((_e16050 * _e16051) - (_e16053 * _e16054)) + ((_e16057 * _e16058) * (_e16060 - _e16061))) / denom) * area);
    return;
}
"#;
    }
    pub mod flux_module_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_gradients_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_rho_u_x: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho_u_y: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho_e: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_T: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_u_x: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_u_y: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 22u) + 1u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 22u) + 1u)];
            let _e129 = state[((idx * 22u) + 1u)];
            let _e136 = bc_value[((face_idx * 8u) + 1u)];
            let _e143 = bc_kind[((face_idx * 8u) + 1u)];
            let _e153 = state[((idx * 22u) + 1u)];
            let _e160 = bc_value[((face_idx * 8u) + 1u)];
            let _e169 = bc_kind[((face_idx * 8u) + 1u)];
            let _e180 = state[((idx * 22u) + 1u)];
            let _e187 = state[((idx * 22u) + 1u)];
            let _e189 = normal_vec.x;
            let _e197 = state[((idx * 22u) + 2u)];
            let _e199 = normal_vec.y;
            let _e203 = normal_vec.x;
            let _e215 = grad_acc_rho_u_x;
            grad_acc_rho_u_x = (_e215 + ((_e105 * ((_e112 * _e113) + (select(select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary), (_e180 - (((_e187 * _e189) + (_e197 * _e199)) * _e203)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e217 = normal_vec;
            let _e224 = state[((idx * 22u) + 2u)];
            let _e225 = lambda;
            let _e227 = other_idx;
            let _e234 = state[((_e227 * 22u) + 2u)];
            let _e241 = state[((idx * 22u) + 2u)];
            let _e248 = bc_value[((face_idx * 8u) + 2u)];
            let _e255 = bc_kind[((face_idx * 8u) + 2u)];
            let _e265 = state[((idx * 22u) + 2u)];
            let _e272 = bc_value[((face_idx * 8u) + 2u)];
            let _e281 = bc_kind[((face_idx * 8u) + 2u)];
            let _e292 = state[((idx * 22u) + 2u)];
            let _e299 = state[((idx * 22u) + 1u)];
            let _e301 = normal_vec.x;
            let _e309 = state[((idx * 22u) + 2u)];
            let _e311 = normal_vec.y;
            let _e315 = normal_vec.y;
            let _e327 = grad_acc_rho_u_y;
            grad_acc_rho_u_y = (_e327 + ((_e217 * ((_e224 * _e225) + (select(select(_e234, select(select(_e241, _e248, (_e255 == 1u)), (_e265 + (_e272 * d_own)), (_e281 == 2u)), is_boundary), (_e292 - (((_e299 * _e301) + (_e309 * _e311)) * _e315)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 22u) + 0u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 22u) + 0u)];
            let _e353 = state[((idx * 22u) + 0u)];
            let _e360 = bc_value[((face_idx * 8u) + 0u)];
            let _e367 = bc_kind[((face_idx * 8u) + 0u)];
            let _e377 = state[((idx * 22u) + 0u)];
            let _e384 = bc_value[((face_idx * 8u) + 0u)];
            let _e393 = bc_kind[((face_idx * 8u) + 0u)];
            let _e403 = grad_acc_rho;
            grad_acc_rho = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 22u) + 7u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 22u) + 7u)];
            let _e429 = state[((idx * 22u) + 7u)];
            let _e436 = bc_value[((face_idx * 8u) + 3u)];
            let _e443 = bc_kind[((face_idx * 8u) + 3u)];
            let _e453 = state[((idx * 22u) + 7u)];
            let _e460 = bc_value[((face_idx * 8u) + 3u)];
            let _e469 = bc_kind[((face_idx * 8u) + 3u)];
            let _e479 = grad_acc_rho_e;
            grad_acc_rho_e = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 22u) + 9u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 22u) + 9u)];
            let _e505 = state[((idx * 22u) + 9u)];
            let _e512 = bc_value[((face_idx * 8u) + 7u)];
            let _e519 = bc_kind[((face_idx * 8u) + 7u)];
            let _e529 = state[((idx * 22u) + 9u)];
            let _e536 = bc_value[((face_idx * 8u) + 7u)];
            let _e545 = bc_kind[((face_idx * 8u) + 7u)];
            let _e555 = grad_acc_T;
            grad_acc_T = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 22u) + 10u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 22u) + 10u)];
            let _e581 = state[((idx * 22u) + 10u)];
            let _e588 = bc_value[((face_idx * 8u) + 4u)];
            let _e595 = bc_kind[((face_idx * 8u) + 4u)];
            let _e605 = state[((idx * 22u) + 10u)];
            let _e612 = bc_value[((face_idx * 8u) + 4u)];
            let _e621 = bc_kind[((face_idx * 8u) + 4u)];
            let _e632 = state[((idx * 22u) + 10u)];
            let _e639 = state[((idx * 22u) + 10u)];
            let _e641 = normal_vec.x;
            let _e649 = state[((idx * 22u) + 11u)];
            let _e651 = normal_vec.y;
            let _e655 = normal_vec.x;
            let _e667 = grad_acc_u_x;
            grad_acc_u_x = (_e667 + ((_e557 * ((_e564 * _e565) + (select(select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary), (_e632 - (((_e639 * _e641) + (_e649 * _e651)) * _e655)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e669 = normal_vec;
            let _e676 = state[((idx * 22u) + 11u)];
            let _e677 = lambda;
            let _e679 = other_idx;
            let _e686 = state[((_e679 * 22u) + 11u)];
            let _e693 = state[((idx * 22u) + 11u)];
            let _e700 = bc_value[((face_idx * 8u) + 5u)];
            let _e707 = bc_kind[((face_idx * 8u) + 5u)];
            let _e717 = state[((idx * 22u) + 11u)];
            let _e724 = bc_value[((face_idx * 8u) + 5u)];
            let _e733 = bc_kind[((face_idx * 8u) + 5u)];
            let _e744 = state[((idx * 22u) + 11u)];
            let _e751 = state[((idx * 22u) + 10u)];
            let _e753 = normal_vec.x;
            let _e761 = state[((idx * 22u) + 11u)];
            let _e763 = normal_vec.y;
            let _e767 = normal_vec.y;
            let _e779 = grad_acc_u_y;
            grad_acc_u_y = (_e779 + ((_e669 * ((_e676 * _e677) + (select(select(_e686, select(select(_e693, _e700, (_e707 == 1u)), (_e717 + (_e724 * d_own)), (_e733 == 2u)), is_boundary), (_e744 - (((_e751 * _e753) + (_e761 * _e763)) * _e767)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
        }
        continuing {
            let _e782 = k;
            k = (_e782 + 1u);
        }
    }
    let _e784 = grad_acc_rho_u_x;
    let grad_out_rho_u_x = ((_e784 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 3u)] = grad_out_rho_u_x.x;
    state[((idx * 22u) + 4u)] = grad_out_rho_u_x.y;
    let _e805 = grad_acc_rho_u_y;
    let grad_out_rho_u_y = ((_e805 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 5u)] = grad_out_rho_u_y.x;
    state[((idx * 22u) + 6u)] = grad_out_rho_u_y.y;
    let _e826 = grad_acc_rho;
    let grad_out_rho = ((_e826 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 12u)] = grad_out_rho.x;
    state[((idx * 22u) + 13u)] = grad_out_rho.y;
    let _e847 = grad_acc_rho_e;
    let grad_out_rho_e = ((_e847 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 14u)] = grad_out_rho_e.x;
    state[((idx * 22u) + 15u)] = grad_out_rho_e.y;
    let _e868 = grad_acc_T;
    let grad_out_T = ((_e868 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 16u)] = grad_out_T.x;
    state[((idx * 22u) + 17u)] = grad_out_T.y;
    let _e889 = grad_acc_u_x;
    let grad_out_u_x = ((_e889 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 18u)] = grad_out_u_x.x;
    state[((idx * 22u) + 19u)] = grad_out_u_x.y;
    let _e910 = grad_acc_u_y;
    let grad_out_u_y = ((_e910 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 20u)] = grad_out_u_y.x;
    state[((idx * 22u) + 21u)] = grad_out_u_y.y;
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 8u) + 2u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 8u) + 2u)];
            let _e129 = state[((idx * 8u) + 2u)];
            let _e136 = bc_value[((face_idx * 3u) + 2u)];
            let _e143 = bc_kind[((face_idx * 3u) + 2u)];
            let _e153 = state[((idx * 8u) + 2u)];
            let _e160 = bc_value[((face_idx * 3u) + 2u)];
            let _e169 = bc_kind[((face_idx * 3u) + 2u)];
            let _e179 = grad_acc_p;
            grad_acc_p = (_e179 + ((_e105 * ((_e112 * _e113) + (select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e182 = k;
            k = (_e182 + 1u);
        }
    }
    let _e184 = grad_acc_p;
    let grad_out_p = ((_e184 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let _e69 = normal_vec;
    let d_own_1 = abs(dot((face_center_vec - c_owner_vec), _e69));
    let _e72 = c_neigh_vec;
    let _e74 = normal_vec;
    let d_neigh = abs(dot((_e72 - face_center_vec), _e74));
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e82 = lambda;
    let lambda_other = (1f - _e82);
    let _e85 = c_neigh_vec;
    let d_vec = (_e85 - c_owner_vec);
    let _e87 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e87));
    let dist = max(dist_proj, 0.000001f);
    let _e98 = state[((owner_1 * 8u) + 0u)];
    let _e105 = state[((owner_1 * 8u) + 0u)];
    let _e112 = bc_kind[((idx * 3u) + 0u)];
    let _e119 = bc_value[((idx * 3u) + 0u)];
    let _e120 = bc_neighbor_scalar(_e98, _e105, _e112, _e119, d_own_1, is_boundary_1);
    let _e127 = state[((owner_1 * 8u) + 0u)];
    let _e134 = state[((owner_1 * 8u) + 0u)];
    let _e136 = normal_vec.x;
    let _e144 = state[((owner_1 * 8u) + 1u)];
    let _e146 = normal_vec.y;
    let _e150 = normal_vec.x;
    let s_own_U_x = select(_e120, (_e127 - (((_e134 * _e136) + (_e144 * _e146)) * _e150)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e166 = state[((owner_1 * 8u) + 1u)];
    let _e173 = state[((owner_1 * 8u) + 1u)];
    let _e180 = bc_kind[((idx * 3u) + 1u)];
    let _e187 = bc_value[((idx * 3u) + 1u)];
    let _e188 = bc_neighbor_scalar(_e166, _e173, _e180, _e187, d_own_1, is_boundary_1);
    let _e195 = state[((owner_1 * 8u) + 1u)];
    let _e202 = state[((owner_1 * 8u) + 0u)];
    let _e204 = normal_vec.x;
    let _e212 = state[((owner_1 * 8u) + 1u)];
    let _e214 = normal_vec.y;
    let _e218 = normal_vec.y;
    let s_own_U_y = select(_e188, (_e195 - (((_e202 * _e204) + (_e212 * _e214)) * _e218)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let s_own_d_p = state[((owner_1 * 8u) + 3u)];
    let s_own_grad_p_x = state[((owner_1 * 8u) + 4u)];
    let s_own_grad_p_y = state[((owner_1 * 8u) + 5u)];
    let _e255 = state[((owner_1 * 8u) + 2u)];
    let _e262 = state[((owner_1 * 8u) + 2u)];
    let _e269 = bc_kind[((idx * 3u) + 2u)];
    let _e276 = bc_value[((idx * 3u) + 2u)];
    let _e277 = bc_neighbor_scalar(_e255, _e262, _e269, _e276, d_own_1, is_boundary_1);
    let _e278 = neigh_idx;
    let _e285 = state[((_e278 * 8u) + 0u)];
    let _e292 = state[((owner_1 * 8u) + 0u)];
    let _e299 = bc_kind[((idx * 3u) + 0u)];
    let _e306 = bc_value[((idx * 3u) + 0u)];
    let _e307 = bc_neighbor_scalar(_e285, _e292, _e299, _e306, d_own_1, is_boundary_1);
    let _e314 = state[((owner_1 * 8u) + 0u)];
    let _e321 = state[((owner_1 * 8u) + 0u)];
    let _e323 = normal_vec.x;
    let _e331 = state[((owner_1 * 8u) + 1u)];
    let _e333 = normal_vec.y;
    let _e337 = normal_vec.x;
    let s_neigh_U_x = select(_e307, (_e314 - (((_e321 * _e323) + (_e331 * _e333)) * _e337)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e347 = neigh_idx;
    let _e354 = state[((_e347 * 8u) + 1u)];
    let _e361 = state[((owner_1 * 8u) + 1u)];
    let _e368 = bc_kind[((idx * 3u) + 1u)];
    let _e375 = bc_value[((idx * 3u) + 1u)];
    let _e376 = bc_neighbor_scalar(_e354, _e361, _e368, _e375, d_own_1, is_boundary_1);
    let _e383 = state[((owner_1 * 8u) + 1u)];
    let _e390 = state[((owner_1 * 8u) + 0u)];
    let _e392 = normal_vec.x;
    let _e400 = state[((owner_1 * 8u) + 1u)];
    let _e402 = normal_vec.y;
    let _e406 = normal_vec.y;
    let s_neigh_U_y = select(_e376, (_e383 - (((_e390 * _e392) + (_e400 * _e402)) * _e406)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e416 = neigh_idx;
    let _e423 = state[((_e416 * 8u) + 3u)];
    let _e430 = state[((owner_1 * 8u) + 3u)];
    let s_neigh_d_p = select(_e423, _e430, is_boundary_1);
    let _e432 = neigh_idx;
    let _e439 = state[((_e432 * 8u) + 4u)];
    let _e446 = state[((owner_1 * 8u) + 4u)];
    let s_neigh_grad_p_x = select(_e439, _e446, is_boundary_1);
    let _e448 = neigh_idx;
    let _e455 = state[((_e448 * 8u) + 5u)];
    let _e462 = state[((owner_1 * 8u) + 5u)];
    let s_neigh_grad_p_y = select(_e455, _e462, is_boundary_1);
    let _e464 = neigh_idx;
    let _e471 = state[((_e464 * 8u) + 2u)];
    let _e478 = state[((owner_1 * 8u) + 2u)];
    let _e485 = bc_kind[((idx * 3u) + 2u)];
    let _e492 = bc_value[((idx * 3u) + 2u)];
    let _e493 = bc_neighbor_scalar(_e471, _e478, _e485, _e492, d_own_1, is_boundary_1);
    let _e502 = constants.density;
    let _e504 = lambda;
    let _e510 = lambda;
    let _e527 = lambda;
    let _e533 = normal_vec;
    let _e539 = constants.density;
    let _e540 = lambda;
    fluxes[((idx * 3u) + 0u)] = (((_e502 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e504) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e510) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e527) + (s_neigh_d_p * lambda_other)))), _e533)) * area) - ((((_e539 * ((s_own_d_p * _e540) + (s_neigh_d_p * lambda_other))) * (_e493 - _e277)) / dist) * area));
    let _e558 = constants.density;
    let _e560 = lambda;
    let _e566 = lambda;
    let _e583 = lambda;
    let _e589 = normal_vec;
    let _e595 = constants.density;
    let _e596 = lambda;
    fluxes[((idx * 3u) + 1u)] = (((_e558 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e560) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e566) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e583) + (s_neigh_d_p * lambda_other)))), _e589)) * area) - ((((_e595 * ((s_own_d_p * _e596) + (s_neigh_d_p * lambda_other))) * (_e493 - _e277)) / dist) * area));
    let _e614 = constants.density;
    let _e616 = lambda;
    let _e622 = lambda;
    let _e639 = lambda;
    let _e645 = normal_vec;
    fluxes[((idx * 3u) + 2u)] = ((_e614 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e616) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e622) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e639) + (s_neigh_d_p * lambda_other)))), _e645)) * area);
    return;
}
"#;
    }
    pub mod generic_coupled_apply {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub row_offsets: wgpu::BufferBinding<'a>,
            pub col_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub row_offsets: wgpu::BindGroupEntry<'a>,
            pub col_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.row_offsets),
                    },
                    col_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.col_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.row_offsets, self.col_indices, self.matrix_values]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"col_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub y: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub y: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    y: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.y),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.x, self.y, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::generic_coupled_apply::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> y: array<f32>;
@group(1) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e5 = constants.stride_x;
    let row = ((global_id.y * _e5) + global_id.x);
    let n = (arrayLength((&row_offsets)) - 1u);
    if (row >= n) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e23 = k;
        if (_e23 < end) {
        } else {
            break;
        }
        {
            let _e26 = k;
            let col = col_indices[_e26];
            let _e30 = k;
            let _e32 = matrix_values[_e30];
            let _e36 = x[col];
            let _e38 = sum;
            sum = (_e38 + (_e32 * _e36));
        }
        continuing {
            let _e41 = k;
            k = (_e41 + 1u);
        }
    }
    let _e45 = sum;
    y[row] = _e45;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup3::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 22u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 22u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 22u) + 0u)];
        let _e750 = state_old_old[((idx * 22u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 22u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 22u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 22u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 22u) + 1u)];
        let _e871 = state_old_old[((idx * 22u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 22u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 22u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 22u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 22u) + 2u)];
        let _e992 = state_old_old[((idx * 22u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 22u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 22u) + 7u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 22u) + 7u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 22u) + 7u)];
        let _e1113 = state_old_old[((idx * 22u) + 7u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 22u) + 7u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 22u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 22u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 22u) + 10u)];
    let _e1332 = state[((idx * 22u) + 10u)];
    let _e1340 = state[((idx * 22u) + 11u)];
    let _e1347 = state[((idx * 22u) + 11u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 22u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1561 = constants.viscosity;
            let _e1564 = constants.viscosity;
            let _e1568 = is_boundary;
            let _e1572 = dist;
            let diff_coeff_rho_u = ((select(_e1558, ((_e1561 + _e1564) * 0.5f), !(_e1568)) * area) / _e1572);
            let _e1574 = is_boundary;
            if !(_e1574) {
                let _e1583 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1583 + diff_coeff_rho_u);
                let _e1592 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1592 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1603 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1603 + diff_coeff_rho_u);
                    let _e1611 = state[((idx * 22u) + 10u)];
                    let _e1618 = state[((idx * 22u) + 10u)];
                    let _e1620 = normal.x;
                    let _e1628 = state[((idx * 22u) + 11u)];
                    let _e1630 = normal.y;
                    let _e1634 = normal.x;
                    let _e1638 = rhs_1_;
                    rhs_1_ = (_e1638 + (diff_coeff_rho_u * (_e1611 - (((_e1618 * _e1620) + (_e1628 * _e1630)) * _e1634))));
                } else {
                    let _e1646 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1646 == 1u) {
                        let _e1656 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                        matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1656 + diff_coeff_rho_u);
                        let _e1664 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1666 = rhs_1_;
                        rhs_1_ = (_e1666 + (diff_coeff_rho_u * _e1664));
                    } else {
                        let _e1674 = bc_kind[((face_idx * 8u) + 4u)];
                        if (_e1674 == 2u) {
                            let _e1679 = constants.viscosity;
                            let _e1682 = constants.viscosity;
                            let _e1685 = constants.viscosity;
                            let _e1689 = is_boundary;
                            let _e1699 = bc_value[((face_idx * 8u) + 4u)];
                            let _e1702 = rhs_1_;
                            rhs_1_ = (_e1702 + -(((select(_e1679, ((_e1682 + _e1685) * 0.5f), !(_e1689)) * area) * _e1699)));
                        }
                    }
                }
            }
            let _e1704 = is_boundary;
            if !(_e1704) {
                let _e1713 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1713 + diff_coeff_rho_u);
                let _e1722 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1722 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1733 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1733 + diff_coeff_rho_u);
                    let _e1741 = state[((idx * 22u) + 11u)];
                    let _e1748 = state[((idx * 22u) + 10u)];
                    let _e1750 = normal.x;
                    let _e1758 = state[((idx * 22u) + 11u)];
                    let _e1760 = normal.y;
                    let _e1764 = normal.y;
                    let _e1768 = rhs_2_;
                    rhs_2_ = (_e1768 + (diff_coeff_rho_u * (_e1741 - (((_e1748 * _e1750) + (_e1758 * _e1760)) * _e1764))));
                } else {
                    let _e1776 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1776 == 1u) {
                        let _e1786 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                        matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1786 + diff_coeff_rho_u);
                        let _e1794 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1796 = rhs_2_;
                        rhs_2_ = (_e1796 + (diff_coeff_rho_u * _e1794));
                    } else {
                        let _e1804 = bc_kind[((face_idx * 8u) + 5u)];
                        if (_e1804 == 2u) {
                            let _e1809 = constants.viscosity;
                            let _e1812 = constants.viscosity;
                            let _e1815 = constants.viscosity;
                            let _e1819 = is_boundary;
                            let _e1829 = bc_value[((face_idx * 8u) + 5u)];
                            let _e1832 = rhs_2_;
                            rhs_2_ = (_e1832 + -(((select(_e1809, ((_e1812 + _e1815) * 0.5f), !(_e1819)) * area) * _e1829)));
                        }
                    }
                }
            }
            let _e1840 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1840;
            if (owner != idx) {
                let _e1843 = phi_1_;
                let _e1846 = phi_1_;
                phi_1_ = (_e1846 - (_e1843 * 2f));
            }
            let _e1848 = phi_1_;
            let _e1849 = rhs_1_;
            rhs_1_ = (_e1849 - _e1848);
            let _e1857 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1857;
            if (owner != idx) {
                let _e1860 = phi_2_;
                let _e1863 = phi_2_;
                phi_2_ = (_e1863 - (_e1860 * 2f));
            }
            let _e1865 = phi_2_;
            let _e1866 = rhs_2_;
            rhs_2_ = (_e1866 - _e1865);
            let _e1870 = constants.viscosity;
            let _e1873 = constants.eos_gamma;
            let _e1877 = constants.eos_r;
            let _e1881 = constants.eos_gm1_;
            let _e1889 = constants.viscosity;
            let _e1892 = constants.eos_gamma;
            let _e1896 = constants.eos_r;
            let _e1900 = constants.eos_gm1_;
            let _e1908 = constants.viscosity;
            let _e1911 = constants.eos_gamma;
            let _e1915 = constants.eos_r;
            let _e1919 = constants.eos_gm1_;
            let _e1928 = is_boundary;
            let _e1932 = dist;
            let diff_coeff_rho_e = ((select(((((_e1870 * _e1873) * _e1877) / max(_e1881, 0.000000000001f)) / 0.71f), ((((((_e1889 * _e1892) * _e1896) / max(_e1900, 0.000000000001f)) / 0.71f) + ((((_e1908 * _e1911) * _e1915) / max(_e1919, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e1928)) * area) / _e1932);
            let _e1934 = is_boundary;
            if !(_e1934) {
                let _e1943 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1943 + diff_coeff_rho_e);
                let _e1952 = matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)] = (_e1952 - diff_coeff_rho_e);
            } else {
                let _e1960 = bc_kind[((face_idx * 8u) + 7u)];
                if (_e1960 == 1u) {
                    let _e1970 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1970 + diff_coeff_rho_e);
                    let _e1978 = bc_value[((face_idx * 8u) + 7u)];
                    let _e1980 = rhs_3_;
                    rhs_3_ = (_e1980 + (diff_coeff_rho_e * _e1978));
                } else {
                    let _e1988 = bc_kind[((face_idx * 8u) + 7u)];
                    if (_e1988 == 2u) {
                        let _e1993 = constants.viscosity;
                        let _e1996 = constants.eos_gamma;
                        let _e2000 = constants.eos_r;
                        let _e2004 = constants.eos_gm1_;
                        let _e2012 = constants.viscosity;
                        let _e2015 = constants.eos_gamma;
                        let _e2019 = constants.eos_r;
                        let _e2023 = constants.eos_gm1_;
                        let _e2031 = constants.viscosity;
                        let _e2034 = constants.eos_gamma;
                        let _e2038 = constants.eos_r;
                        let _e2042 = constants.eos_gm1_;
                        let _e2051 = is_boundary;
                        let _e2061 = bc_value[((face_idx * 8u) + 7u)];
                        let _e2064 = rhs_3_;
                        rhs_3_ = (_e2064 + -(((select(((((_e1993 * _e1996) * _e2000) / max(_e2004, 0.000000000001f)) / 0.71f), ((((((_e2012 * _e2015) * _e2019) / max(_e2023, 0.000000000001f)) / 0.71f) + ((((_e2031 * _e2034) * _e2038) / max(_e2042, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e2051)) * area) * _e2061)));
                    }
                }
            }
            let _e2072 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e2072;
            if (owner != idx) {
                let _e2075 = phi_3_;
                let _e2078 = phi_3_;
                phi_3_ = (_e2078 - (_e2075 * 2f));
            }
            let _e2080 = phi_3_;
            let _e2081 = rhs_3_;
            rhs_3_ = (_e2081 - _e2080);
        }
        continuing {
            let _e2084 = k;
            k = (_e2084 + 1u);
        }
    }
    let _e2093 = diag_0_;
    let _e2094 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e2094 + _e2093);
    let _e2102 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e2102;
    let _e2110 = diag_1_;
    let _e2111 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e2111 + _e2110);
    let _e2119 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e2119;
    let _e2127 = diag_2_;
    let _e2128 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e2128 + _e2127);
    let _e2136 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e2136;
    let _e2144 = diag_3_;
    let _e2145 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e2145 + _e2144);
    let _e2153 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e2153;
    let _e2161 = diag_4_;
    let _e2162 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e2162 + _e2161);
    let _e2171 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e2171;
    let _e2179 = diag_5_;
    let _e2180 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e2180 + _e2179);
    let _e2189 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e2189;
    let _e2197 = diag_6_;
    let _e2198 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e2198 + _e2197);
    let _e2206 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e2206;
    let _e2214 = diag_7_;
    let _e2215 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e2215 + _e2214);
    let _e2224 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e2224;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 22u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 22u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 22u) + 0u)];
        let _e750 = state_old_old[((idx * 22u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 22u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 22u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 22u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 22u) + 1u)];
        let _e871 = state_old_old[((idx * 22u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 22u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 22u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 22u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 22u) + 2u)];
        let _e992 = state_old_old[((idx * 22u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 22u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 22u) + 7u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 22u) + 7u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 22u) + 7u)];
        let _e1113 = state_old_old[((idx * 22u) + 7u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 22u) + 7u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 22u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 22u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 22u) + 10u)];
    let _e1332 = state[((idx * 22u) + 10u)];
    let _e1340 = state[((idx * 22u) + 11u)];
    let _e1347 = state[((idx * 22u) + 11u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 22u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1561 = constants.viscosity;
            let _e1564 = constants.viscosity;
            let _e1568 = is_boundary;
            let _e1572 = dist;
            let diff_coeff_rho_u = ((select(_e1558, ((_e1561 + _e1564) * 0.5f), !(_e1568)) * area) / _e1572);
            let _e1574 = is_boundary;
            if !(_e1574) {
                let _e1583 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1583 + diff_coeff_rho_u);
                let _e1592 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1592 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1603 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1603 + diff_coeff_rho_u);
                    let _e1611 = state[((idx * 22u) + 10u)];
                    let _e1618 = state[((idx * 22u) + 10u)];
                    let _e1620 = normal.x;
                    let _e1628 = state[((idx * 22u) + 11u)];
                    let _e1630 = normal.y;
                    let _e1634 = normal.x;
                    let _e1638 = rhs_1_;
                    rhs_1_ = (_e1638 + (diff_coeff_rho_u * (_e1611 - (((_e1618 * _e1620) + (_e1628 * _e1630)) * _e1634))));
                } else {
                    let _e1646 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1646 == 1u) {
                        let _e1656 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                        matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1656 + diff_coeff_rho_u);
                        let _e1664 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1666 = rhs_1_;
                        rhs_1_ = (_e1666 + (diff_coeff_rho_u * _e1664));
                    } else {
                        let _e1674 = bc_kind[((face_idx * 8u) + 4u)];
                        if (_e1674 == 2u) {
                            let _e1679 = constants.viscosity;
                            let _e1682 = constants.viscosity;
                            let _e1685 = constants.viscosity;
                            let _e1689 = is_boundary;
                            let _e1699 = bc_value[((face_idx * 8u) + 4u)];
                            let _e1702 = rhs_1_;
                            rhs_1_ = (_e1702 + -(((select(_e1679, ((_e1682 + _e1685) * 0.5f), !(_e1689)) * area) * _e1699)));
                        }
                    }
                }
            }
            let _e1704 = is_boundary;
            if !(_e1704) {
                let _e1713 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1713 + diff_coeff_rho_u);
                let _e1722 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1722 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1733 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1733 + diff_coeff_rho_u);
                    let _e1741 = state[((idx * 22u) + 11u)];
                    let _e1748 = state[((idx * 22u) + 10u)];
                    let _e1750 = normal.x;
                    let _e1758 = state[((idx * 22u) + 11u)];
                    let _e1760 = normal.y;
                    let _e1764 = normal.y;
                    let _e1768 = rhs_2_;
                    rhs_2_ = (_e1768 + (diff_coeff_rho_u * (_e1741 - (((_e1748 * _e1750) + (_e1758 * _e1760)) * _e1764))));
                } else {
                    let _e1776 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1776 == 1u) {
                        let _e1786 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                        matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1786 + diff_coeff_rho_u);
                        let _e1794 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1796 = rhs_2_;
                        rhs_2_ = (_e1796 + (diff_coeff_rho_u * _e1794));
                    } else {
                        let _e1804 = bc_kind[((face_idx * 8u) + 5u)];
                        if (_e1804 == 2u) {
                            let _e1809 = constants.viscosity;
                            let _e1812 = constants.viscosity;
                            let _e1815 = constants.viscosity;
                            let _e1819 = is_boundary;
                            let _e1829 = bc_value[((face_idx * 8u) + 5u)];
                            let _e1832 = rhs_2_;
                            rhs_2_ = (_e1832 + -(((select(_e1809, ((_e1812 + _e1815) * 0.5f), !(_e1819)) * area) * _e1829)));
                        }
                    }
                }
            }
            let _e1840 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1840;
            if (owner != idx) {
                let _e1843 = phi_1_;
                let _e1846 = phi_1_;
                phi_1_ = (_e1846 - (_e1843 * 2f));
            }
            let _e1848 = phi_1_;
            let _e1849 = rhs_1_;
            rhs_1_ = (_e1849 - _e1848);
            let _e1857 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1857;
            if (owner != idx) {
                let _e1860 = phi_2_;
                let _e1863 = phi_2_;
                phi_2_ = (_e1863 - (_e1860 * 2f));
            }
            let _e1865 = phi_2_;
            let _e1866 = rhs_2_;
            rhs_2_ = (_e1866 - _e1865);
            let _e1870 = constants.viscosity;
            let _e1873 = constants.eos_gamma;
            let _e1877 = constants.eos_r;
            let _e1881 = constants.eos_gm1_;
            let _e1889 = constants.viscosity;
            let _e1892 = constants.eos_gamma;
            let _e1896 = constants.eos_r;
            let _e1900 = constants.eos_gm1_;
            let _e1908 = constants.viscosity;
            let _e1911 = constants.eos_gamma;
            let _e1915 = constants.eos_r;
            let _e1919 = constants.eos_gm1_;
            let _e1928 = is_boundary;
            let _e1932 = dist;
            let diff_coeff_rho_e = ((select(((((_e1870 * _e1873) * _e1877) / max(_e1881, 0.000000000001f)) / 0.71f), ((((((_e1889 * _e1892) * _e1896) / max(_e1900, 0.000000000001f)) / 0.71f) + ((((_e1908 * _e1911) * _e1915) / max(_e1919, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e1928)) * area) / _e1932);
            let _e1934 = is_boundary;
            if !(_e1934) {
                let _e1943 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1943 + diff_coeff_rho_e);
                let _e1952 = matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)];
                matrix_values[((start_row_3_ + (neighbor_rank * 8u)) + 7u)] = (_e1952 - diff_coeff_rho_e);
            } else {
                let _e1960 = bc_kind[((face_idx * 8u) + 7u)];
                if (_e1960 == 1u) {
                    let _e1970 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)];
                    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 7u)] = (_e1970 + diff_coeff_rho_e);
                    let _e1978 = bc_value[((face_idx * 8u) + 7u)];
                    let _e1980 = rhs_3_;
                    rhs_3_ = (_e1980 + (diff_coeff_rho_e * _e1978));
                } else {
                    let _e1988 = bc_kind[((face_idx * 8u) + 7u)];
                    if (_e1988 == 2u) {
                        let _e1993 = constants.viscosity;
                        let _e1996 = constants.eos_gamma;
                        let _e2000 = constants.eos_r;
                        let _e2004 = constants.eos_gm1_;
                        let _e2012 = constants.viscosity;
                        let _e2015 = constants.eos_gamma;
                        let _e2019 = constants.eos_r;
                        let _e2023 = constants.eos_gm1_;
                        let _e2031 = constants.viscosity;
                        let _e2034 = constants.eos_gamma;
                        let _e2038 = constants.eos_r;
                        let _e2042 = constants.eos_gm1_;
                        let _e2051 = is_boundary;
                        let _e2061 = bc_value[((face_idx * 8u) + 7u)];
                        let _e2064 = rhs_3_;
                        rhs_3_ = (_e2064 + -(((select(((((_e1993 * _e1996) * _e2000) / max(_e2004, 0.000000000001f)) / 0.71f), ((((((_e2012 * _e2015) * _e2019) / max(_e2023, 0.000000000001f)) / 0.71f) + ((((_e2031 * _e2034) * _e2038) / max(_e2042, 0.000000000001f)) / 0.71f)) * 0.5f), !(_e2051)) * area) * _e2061)));
                    }
                }
            }
            let _e2072 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e2072;
            if (owner != idx) {
                let _e2075 = phi_3_;
                let _e2078 = phi_3_;
                phi_3_ = (_e2078 - (_e2075 * 2f));
            }
            let _e2080 = phi_3_;
            let _e2081 = rhs_3_;
            rhs_3_ = (_e2081 - _e2080);
        }
        continuing {
            let _e2084 = k;
            k = (_e2084 + 1u);
        }
    }
    let _e2093 = diag_0_;
    let _e2094 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e2094 + _e2093);
    let _e2102 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e2102;
    let _e2110 = diag_1_;
    let _e2111 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e2111 + _e2110);
    let _e2119 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e2119;
    let _e2127 = diag_2_;
    let _e2128 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e2128 + _e2127);
    let _e2136 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e2136;
    let _e2144 = diag_3_;
    let _e2145 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e2145 + _e2144);
    let _e2153 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e2153;
    let _e2161 = diag_4_;
    let _e2162 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e2162 + _e2161);
    let _e2171 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e2171;
    let _e2179 = diag_5_;
    let _e2180 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e2180 + _e2179);
    let _e2189 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e2189;
    let _e2197 = diag_6_;
    let _e2198 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e2198 + _e2197);
    let _e2206 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e2206;
    let _e2214 = diag_7_;
    let _e2215 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e2215 + _e2214);
    let _e2224 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e2224;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some(
                    "generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann.wgsl",
                ),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e528 = constants.viscosity;
            let _e531 = constants.viscosity;
            let _e535 = is_boundary;
            let _e539 = dist;
            let diff_coeff_U = ((select(_e525, ((_e528 + _e531) * 0.5f), !(_e535)) * area) / _e539);
            let _e541 = is_boundary;
            if !(_e541) {
                let _e543 = diag_0_;
                diag_0_ = (_e543 + diff_coeff_U);
                let _e552 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e552 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e556 = diag_0_;
                    diag_0_ = (_e556 + diff_coeff_U);
                    let _e564 = state[((idx * 8u) + 0u)];
                    let _e571 = state[((idx * 8u) + 0u)];
                    let _e573 = normal.x;
                    let _e581 = state[((idx * 8u) + 1u)];
                    let _e583 = normal.y;
                    let _e587 = normal.x;
                    let _e591 = rhs_0_;
                    rhs_0_ = (_e591 + (diff_coeff_U * (_e564 - (((_e571 * _e573) + (_e581 * _e583)) * _e587))));
                } else {
                    let _e599 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e599 == 1u) {
                        let _e602 = diag_0_;
                        diag_0_ = (_e602 + diff_coeff_U);
                        let _e610 = bc_value[((face_idx * 3u) + 0u)];
                        let _e612 = rhs_0_;
                        rhs_0_ = (_e612 + (diff_coeff_U * _e610));
                    } else {
                        let _e620 = bc_kind[((face_idx * 3u) + 0u)];
                        if (_e620 == 2u) {
                            let _e625 = constants.viscosity;
                            let _e628 = constants.viscosity;
                            let _e631 = constants.viscosity;
                            let _e635 = is_boundary;
                            let _e645 = bc_value[((face_idx * 3u) + 0u)];
                            let _e648 = rhs_0_;
                            rhs_0_ = (_e648 + -(((select(_e625, ((_e628 + _e631) * 0.5f), !(_e635)) * area) * _e645)));
                        }
                    }
                }
            }
            let _e650 = is_boundary;
            if !(_e650) {
                let _e652 = diag_1_;
                diag_1_ = (_e652 + diff_coeff_U);
                let _e661 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e661 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e665 = diag_1_;
                    diag_1_ = (_e665 + diff_coeff_U);
                    let _e673 = state[((idx * 8u) + 1u)];
                    let _e680 = state[((idx * 8u) + 0u)];
                    let _e682 = normal.x;
                    let _e690 = state[((idx * 8u) + 1u)];
                    let _e692 = normal.y;
                    let _e696 = normal.y;
                    let _e700 = rhs_1_;
                    rhs_1_ = (_e700 + (diff_coeff_U * (_e673 - (((_e680 * _e682) + (_e690 * _e692)) * _e696))));
                } else {
                    let _e708 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e708 == 1u) {
                        let _e711 = diag_1_;
                        diag_1_ = (_e711 + diff_coeff_U);
                        let _e719 = bc_value[((face_idx * 3u) + 1u)];
                        let _e721 = rhs_1_;
                        rhs_1_ = (_e721 + (diff_coeff_U * _e719));
                    } else {
                        let _e729 = bc_kind[((face_idx * 3u) + 1u)];
                        if (_e729 == 2u) {
                            let _e734 = constants.viscosity;
                            let _e737 = constants.viscosity;
                            let _e740 = constants.viscosity;
                            let _e744 = is_boundary;
                            let _e754 = bc_value[((face_idx * 3u) + 1u)];
                            let _e757 = rhs_1_;
                            rhs_1_ = (_e757 + -(((select(_e734, ((_e737 + _e740) * 0.5f), !(_e744)) * area) * _e754)));
                        }
                    }
                }
            }
            let _e765 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e765;
            if (owner != idx) {
                let _e768 = phi_0_;
                let _e771 = phi_0_;
                phi_0_ = (_e771 - (_e768 * 2f));
            }
            let _e773 = is_boundary;
            if !(_e773) {
                let _e775 = phi_0_;
                let _e778 = diag_0_;
                diag_0_ = (_e778 + max(_e775, 0f));
                let _e787 = phi_0_;
                let _e790 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e790 + min(_e787, 0f));
                let _e792 = phi_0_;
                let _e799 = state[((idx * 8u) + 0u)];
                let _e800 = other_idx;
                let _e807 = state[((_e800 * 8u) + 0u)];
                let _e808 = phi_0_;
                let _e812 = other_idx;
                let _e819 = state[((_e812 * 8u) + 0u)];
                let _e820 = other_idx;
                let _e828 = grad_state[((_e820 * 8u) + 0u)].x;
                let _e829 = other_idx;
                let _e837 = grad_state[((_e829 * 8u) + 0u)].y;
                let _e843 = other_center.x;
                let _e845 = other_center.y;
                let _e856 = state[((idx * 8u) + 0u)];
                let _e864 = grad_state[((idx * 8u) + 0u)].x;
                let _e872 = grad_state[((idx * 8u) + 0u)].y;
                let _e883 = phi_0_;
                let _e889 = constants.scheme;
                let _e893 = other_idx;
                let _e900 = state[((_e893 * 8u) + 0u)];
                let _e901 = other_idx;
                let _e908 = state[((_e901 * 8u) + 0u)];
                let _e918 = state[((idx * 8u) + 0u)];
                let _e922 = other_idx;
                let _e930 = grad_state[((_e922 * 8u) + 0u)].x;
                let _e931 = other_idx;
                let _e939 = grad_state[((_e931 * 8u) + 0u)].y;
                let _e945 = other_center.x;
                let _e947 = other_center.y;
                let _e954 = other_idx;
                let _e961 = state[((_e954 * 8u) + 0u)];
                let _e969 = state[((idx * 8u) + 0u)];
                let _e976 = state[((idx * 8u) + 0u)];
                let _e980 = other_idx;
                let _e987 = state[((_e980 * 8u) + 0u)];
                let _e998 = grad_state[((idx * 8u) + 0u)].x;
                let _e1006 = grad_state[((idx * 8u) + 0u)].y;
                let _e1009 = other_center.x;
                let _e1011 = other_center.y;
                let _e1027 = state[((idx * 8u) + 0u)];
                let _e1029 = phi_0_;
                let _e1035 = constants.scheme;
                let _e1039 = other_idx;
                let _e1046 = state[((_e1039 * 8u) + 0u)];
                let _e1047 = other_idx;
                let _e1055 = grad_state[((_e1047 * 8u) + 0u)].x;
                let _e1056 = other_idx;
                let _e1064 = grad_state[((_e1056 * 8u) + 0u)].y;
                let _e1070 = other_center.x;
                let _e1072 = other_center.y;
                let _e1082 = state[((idx * 8u) + 0u)];
                let _e1083 = other_idx;
                let _e1090 = state[((_e1083 * 8u) + 0u)];
                let _e1101 = state[((idx * 8u) + 0u)];
                let _e1102 = other_idx;
                let _e1109 = state[((_e1102 * 8u) + 0u)];
                let _e1121 = state[((idx * 8u) + 0u)];
                let _e1129 = grad_state[((idx * 8u) + 0u)].x;
                let _e1137 = grad_state[((idx * 8u) + 0u)].y;
                let _e1147 = other_idx;
                let _e1154 = state[((_e1147 * 8u) + 0u)];
                let _e1161 = state[((idx * 8u) + 0u)];
                let _e1166 = other_idx;
                let _e1173 = state[((_e1166 * 8u) + 0u)];
                let _e1180 = state[((idx * 8u) + 0u)];
                let _e1186 = phi_0_;
                let _e1192 = constants.scheme;
                let _e1196 = other_idx;
                let _e1203 = state[((_e1196 * 8u) + 0u)];
                let _e1204 = other_idx;
                let _e1212 = grad_state[((_e1204 * 8u) + 0u)].x;
                let _e1213 = other_idx;
                let _e1221 = grad_state[((_e1213 * 8u) + 0u)].y;
                let _e1227 = other_center.x;
                let _e1229 = other_center.y;
                let _e1239 = state[((idx * 8u) + 0u)];
                let _e1240 = other_idx;
                let _e1247 = state[((_e1240 * 8u) + 0u)];
                let _e1257 = state[((idx * 8u) + 0u)];
                let _e1258 = other_idx;
                let _e1265 = state[((_e1258 * 8u) + 0u)];
                let _e1268 = other_idx;
                let _e1276 = grad_state[((_e1268 * 8u) + 0u)].x;
                let _e1277 = other_idx;
                let _e1285 = grad_state[((_e1277 * 8u) + 0u)].y;
                let _e1291 = other_center.x;
                let _e1293 = other_center.y;
                let _e1308 = state[((idx * 8u) + 0u)];
                let _e1309 = other_idx;
                let _e1316 = state[((_e1309 * 8u) + 0u)];
                let _e1318 = other_idx;
                let _e1326 = grad_state[((_e1318 * 8u) + 0u)].x;
                let _e1327 = other_idx;
                let _e1335 = grad_state[((_e1327 * 8u) + 0u)].y;
                let _e1341 = other_center.x;
                let _e1343 = other_center.y;
                let _e1357 = state[((idx * 8u) + 0u)];
                let _e1358 = other_idx;
                let _e1365 = state[((_e1358 * 8u) + 0u)];
                let _e1367 = other_idx;
                let _e1375 = grad_state[((_e1367 * 8u) + 0u)].x;
                let _e1376 = other_idx;
                let _e1384 = grad_state[((_e1376 * 8u) + 0u)].y;
                let _e1390 = other_center.x;
                let _e1392 = other_center.y;
                let _e1408 = state[((idx * 8u) + 0u)];
                let _e1416 = grad_state[((idx * 8u) + 0u)].x;
                let _e1424 = grad_state[((idx * 8u) + 0u)].y;
                let _e1434 = other_idx;
                let _e1441 = state[((_e1434 * 8u) + 0u)];
                let _e1448 = state[((idx * 8u) + 0u)];
                let _e1452 = other_idx;
                let _e1459 = state[((_e1452 * 8u) + 0u)];
                let _e1466 = state[((idx * 8u) + 0u)];
                let _e1476 = grad_state[((idx * 8u) + 0u)].x;
                let _e1484 = grad_state[((idx * 8u) + 0u)].y;
                let _e1499 = other_idx;
                let _e1506 = state[((_e1499 * 8u) + 0u)];
                let _e1513 = state[((idx * 8u) + 0u)];
                let _e1522 = grad_state[((idx * 8u) + 0u)].x;
                let _e1530 = grad_state[((idx * 8u) + 0u)].y;
                let _e1544 = other_idx;
                let _e1551 = state[((_e1544 * 8u) + 0u)];
                let _e1558 = state[((idx * 8u) + 0u)];
                let _e1567 = grad_state[((idx * 8u) + 0u)].x;
                let _e1575 = grad_state[((idx * 8u) + 0u)].y;
                let _e1591 = phi_0_;
                let _e1597 = constants.scheme;
                let _e1601 = other_idx;
                let _e1608 = state[((_e1601 * 8u) + 0u)];
                let _e1609 = other_idx;
                let _e1616 = state[((_e1609 * 8u) + 0u)];
                let _e1625 = state[((idx * 8u) + 0u)];
                let _e1629 = other_idx;
                let _e1637 = grad_state[((_e1629 * 8u) + 0u)].x;
                let _e1638 = other_idx;
                let _e1646 = grad_state[((_e1638 * 8u) + 0u)].y;
                let _e1652 = other_center.x;
                let _e1654 = other_center.y;
                let _e1661 = other_idx;
                let _e1668 = state[((_e1661 * 8u) + 0u)];
                let _e1676 = state[((idx * 8u) + 0u)];
                let _e1677 = other_idx;
                let _e1684 = state[((_e1677 * 8u) + 0u)];
                let _e1695 = state[((idx * 8u) + 0u)];
                let _e1696 = other_idx;
                let _e1703 = state[((_e1696 * 8u) + 0u)];
                let _e1715 = state[((idx * 8u) + 0u)];
                let _e1722 = state[((idx * 8u) + 0u)];
                let _e1725 = other_idx;
                let _e1732 = state[((_e1725 * 8u) + 0u)];
                let _e1743 = grad_state[((idx * 8u) + 0u)].x;
                let _e1751 = grad_state[((idx * 8u) + 0u)].y;
                let _e1754 = other_center.x;
                let _e1756 = other_center.y;
                let _e1772 = state[((idx * 8u) + 0u)];
                let _e1774 = other_idx;
                let _e1781 = state[((_e1774 * 8u) + 0u)];
                let _e1788 = state[((idx * 8u) + 0u)];
                let _e1793 = other_idx;
                let _e1800 = state[((_e1793 * 8u) + 0u)];
                let _e1807 = state[((idx * 8u) + 0u)];
                let _e1813 = phi_0_;
                let _e1819 = constants.scheme;
                let _e1823 = other_idx;
                let _e1830 = state[((_e1823 * 8u) + 0u)];
                let _e1831 = other_idx;
                let _e1838 = state[((_e1831 * 8u) + 0u)];
                let _e1847 = state[((idx * 8u) + 0u)];
                let _e1851 = other_idx;
                let _e1859 = grad_state[((_e1851 * 8u) + 0u)].x;
                let _e1860 = other_idx;
                let _e1868 = grad_state[((_e1860 * 8u) + 0u)].y;
                let _e1874 = other_center.x;
                let _e1876 = other_center.y;
                let _e1883 = other_idx;
                let _e1890 = state[((_e1883 * 8u) + 0u)];
                let _e1898 = state[((idx * 8u) + 0u)];
                let _e1899 = other_idx;
                let _e1906 = state[((_e1899 * 8u) + 0u)];
                let _e1916 = state[((idx * 8u) + 0u)];
                let _e1917 = other_idx;
                let _e1924 = state[((_e1917 * 8u) + 0u)];
                let _e1927 = other_idx;
                let _e1934 = state[((_e1927 * 8u) + 0u)];
                let _e1943 = state[((idx * 8u) + 0u)];
                let _e1947 = other_idx;
                let _e1955 = grad_state[((_e1947 * 8u) + 0u)].x;
                let _e1956 = other_idx;
                let _e1964 = grad_state[((_e1956 * 8u) + 0u)].y;
                let _e1970 = other_center.x;
                let _e1972 = other_center.y;
                let _e1979 = other_idx;
                let _e1986 = state[((_e1979 * 8u) + 0u)];
                let _e1999 = state[((idx * 8u) + 0u)];
                let _e2000 = other_idx;
                let _e2007 = state[((_e2000 * 8u) + 0u)];
                let _e2009 = other_idx;
                let _e2016 = state[((_e2009 * 8u) + 0u)];
                let _e2025 = state[((idx * 8u) + 0u)];
                let _e2029 = other_idx;
                let _e2037 = grad_state[((_e2029 * 8u) + 0u)].x;
                let _e2038 = other_idx;
                let _e2046 = grad_state[((_e2038 * 8u) + 0u)].y;
                let _e2052 = other_center.x;
                let _e2054 = other_center.y;
                let _e2061 = other_idx;
                let _e2068 = state[((_e2061 * 8u) + 0u)];
                let _e2080 = state[((idx * 8u) + 0u)];
                let _e2081 = other_idx;
                let _e2088 = state[((_e2081 * 8u) + 0u)];
                let _e2090 = other_idx;
                let _e2097 = state[((_e2090 * 8u) + 0u)];
                let _e2106 = state[((idx * 8u) + 0u)];
                let _e2110 = other_idx;
                let _e2118 = grad_state[((_e2110 * 8u) + 0u)].x;
                let _e2119 = other_idx;
                let _e2127 = grad_state[((_e2119 * 8u) + 0u)].y;
                let _e2133 = other_center.x;
                let _e2135 = other_center.y;
                let _e2142 = other_idx;
                let _e2149 = state[((_e2142 * 8u) + 0u)];
                let _e2163 = state[((idx * 8u) + 0u)];
                let _e2170 = state[((idx * 8u) + 0u)];
                let _e2173 = other_idx;
                let _e2180 = state[((_e2173 * 8u) + 0u)];
                let _e2191 = grad_state[((idx * 8u) + 0u)].x;
                let _e2199 = grad_state[((idx * 8u) + 0u)].y;
                let _e2202 = other_center.x;
                let _e2204 = other_center.y;
                let _e2220 = state[((idx * 8u) + 0u)];
                let _e2222 = other_idx;
                let _e2229 = state[((_e2222 * 8u) + 0u)];
                let _e2236 = state[((idx * 8u) + 0u)];
                let _e2240 = other_idx;
                let _e2247 = state[((_e2240 * 8u) + 0u)];
                let _e2254 = state[((idx * 8u) + 0u)];
                let _e2263 = state[((idx * 8u) + 0u)];
                let _e2266 = other_idx;
                let _e2273 = state[((_e2266 * 8u) + 0u)];
                let _e2284 = grad_state[((idx * 8u) + 0u)].x;
                let _e2292 = grad_state[((idx * 8u) + 0u)].y;
                let _e2295 = other_center.x;
                let _e2297 = other_center.y;
                let _e2313 = state[((idx * 8u) + 0u)];
                let _e2320 = other_idx;
                let _e2327 = state[((_e2320 * 8u) + 0u)];
                let _e2334 = state[((idx * 8u) + 0u)];
                let _e2342 = state[((idx * 8u) + 0u)];
                let _e2345 = other_idx;
                let _e2352 = state[((_e2345 * 8u) + 0u)];
                let _e2363 = grad_state[((idx * 8u) + 0u)].x;
                let _e2371 = grad_state[((idx * 8u) + 0u)].y;
                let _e2374 = other_center.x;
                let _e2376 = other_center.y;
                let _e2392 = state[((idx * 8u) + 0u)];
                let _e2398 = other_idx;
                let _e2405 = state[((_e2398 * 8u) + 0u)];
                let _e2412 = state[((idx * 8u) + 0u)];
                let _e2420 = state[((idx * 8u) + 0u)];
                let _e2423 = other_idx;
                let _e2430 = state[((_e2423 * 8u) + 0u)];
                let _e2441 = grad_state[((idx * 8u) + 0u)].x;
                let _e2449 = grad_state[((idx * 8u) + 0u)].y;
                let _e2452 = other_center.x;
                let _e2454 = other_center.y;
                let _e2470 = state[((idx * 8u) + 0u)];
                let _e2478 = phi_0_;
                let _e2484 = constants.scheme;
                let _e2494 = state[((idx * 8u) + 0u)];
                let _e2495 = other_idx;
                let _e2502 = state[((_e2495 * 8u) + 0u)];
                let _e2503 = phi_0_;
                let _e2509 = rhs_0_;
                rhs_0_ = (_e2509 - (_e792 * (select(select(select(select(select(select(select(_e799, _e807, (_e808 < 0f)), select((_e819 + dot(vec2<f32>(_e828, _e837), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e843, _e845)))), (_e856 + dot(vec2<f32>(_e864, _e872), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e883 > 0f)), (_e889 == 1u)), select(((((_e900 + (_e908 * 0.625f)) + (_e918 * 0.375f)) + (dot(vec2<f32>(_e930, _e939), (vec2<f32>(center.x, center.y) - vec2<f32>(_e945, _e947))) * 0.125f)) - _e961), ((((_e969 + (_e976 * 0.625f)) + (_e987 * 0.375f)) + (dot(vec2<f32>(_e998, _e1006), (vec2<f32>(_e1009, _e1011) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1027), (_e1029 > 0f)), (_e1035 == 2u)), select((_e1046 + min(max(dot(vec2<f32>(_e1055, _e1064), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1070, _e1072))), min((_e1082 - _e1090), 0f)), max((_e1101 - _e1109), 0f))), (_e1121 + min(max(dot(vec2<f32>(_e1129, _e1137), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1154 - _e1161), 0f)), max((_e1173 - _e1180), 0f))), (_e1186 > 0f)), (_e1192 == 3u)), select((_e1203 + ((((dot(vec2<f32>(_e1212, _e1221), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1227, _e1229))) * abs((_e1239 - _e1247))) / max(abs((_e1257 - _e1265)), (abs(dot(vec2<f32>(_e1276, _e1285), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1291, _e1293)))) + 0.00000001f))) * max(((_e1308 - _e1316) * dot(vec2<f32>(_e1326, _e1335), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1341, _e1343)))), 0f)) / max(abs(((_e1357 - _e1365) * dot(vec2<f32>(_e1375, _e1384), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1390, _e1392))))), 0.00000001f))), (_e1408 + ((((dot(vec2<f32>(_e1416, _e1424), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1441 - _e1448))) / max(abs((_e1459 - _e1466)), (abs(dot(vec2<f32>(_e1476, _e1484), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1506 - _e1513) * dot(vec2<f32>(_e1522, _e1530), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1551 - _e1558) * dot(vec2<f32>(_e1567, _e1575), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1591 > 0f)), (_e1597 == 4u)), select((_e1608 + min(max(((((_e1616 * 0.625f) + (_e1625 * 0.375f)) + (dot(vec2<f32>(_e1637, _e1646), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1652, _e1654))) * 0.125f)) - _e1668), min((_e1676 - _e1684), 0f)), max((_e1695 - _e1703), 0f))), (_e1715 + min(max(((((_e1722 * 0.625f) + (_e1732 * 0.375f)) + (dot(vec2<f32>(_e1743, _e1751), (vec2<f32>(_e1754, _e1756) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1772), min((_e1781 - _e1788), 0f)), max((_e1800 - _e1807), 0f))), (_e1813 > 0f)), (_e1819 == 5u)), select((_e1830 + ((((((((_e1838 * 0.625f) + (_e1847 * 0.375f)) + (dot(vec2<f32>(_e1859, _e1868), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1874, _e1876))) * 0.125f)) - _e1890) * abs((_e1898 - _e1906))) / max(abs((_e1916 - _e1924)), (abs(((((_e1934 * 0.625f) + (_e1943 * 0.375f)) + (dot(vec2<f32>(_e1955, _e1964), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1970, _e1972))) * 0.125f)) - _e1986)) + 0.00000001f))) * max(((_e1999 - _e2007) * ((((_e2016 * 0.625f) + (_e2025 * 0.375f)) + (dot(vec2<f32>(_e2037, _e2046), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2052, _e2054))) * 0.125f)) - _e2068)), 0f)) / max(abs(((_e2080 - _e2088) * ((((_e2097 * 0.625f) + (_e2106 * 0.375f)) + (dot(vec2<f32>(_e2118, _e2127), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2133, _e2135))) * 0.125f)) - _e2149))), 0.00000001f))), (_e2163 + ((((((((_e2170 * 0.625f) + (_e2180 * 0.375f)) + (dot(vec2<f32>(_e2191, _e2199), (vec2<f32>(_e2202, _e2204) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2220) * abs((_e2229 - _e2236))) / max(abs((_e2247 - _e2254)), (abs(((((_e2263 * 0.625f) + (_e2273 * 0.375f)) + (dot(vec2<f32>(_e2284, _e2292), (vec2<f32>(_e2295, _e2297) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2313)) + 0.00000001f))) * max(((_e2327 - _e2334) * ((((_e2342 * 0.625f) + (_e2352 * 0.375f)) + (dot(vec2<f32>(_e2363, _e2371), (vec2<f32>(_e2374, _e2376) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2392)), 0f)) / max(abs(((_e2405 - _e2412) * ((((_e2420 * 0.625f) + (_e2430 * 0.375f)) + (dot(vec2<f32>(_e2441, _e2449), (vec2<f32>(_e2452, _e2454) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2470))), 0.00000001f))), (_e2478 > 0f)), (_e2484 == 6u)) - select(_e2494, _e2502, (_e2503 < 0f)))));
            } else {
                let _e2517 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e2517 == 1u) {
                    let _e2520 = phi_0_;
                    let _e2523 = diag_0_;
                    diag_0_ = (_e2523 + max(_e2520, 0f));
                    let _e2525 = phi_0_;
                    let _e2534 = bc_value[((face_idx * 3u) + 0u)];
                    let _e2536 = rhs_0_;
                    rhs_0_ = (_e2536 - (min(_e2525, 0f) * _e2534));
                } else {
                    let _e2538 = phi_0_;
                    let _e2539 = diag_0_;
                    diag_0_ = (_e2539 + _e2538);
                }
            }
            let _e2547 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e2547;
            if (owner != idx) {
                let _e2550 = phi_1_;
                let _e2553 = phi_1_;
                phi_1_ = (_e2553 - (_e2550 * 2f));
            }
            let _e2555 = is_boundary;
            if !(_e2555) {
                let _e2557 = phi_1_;
                let _e2560 = diag_1_;
                diag_1_ = (_e2560 + max(_e2557, 0f));
                let _e2569 = phi_1_;
                let _e2572 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e2572 + min(_e2569, 0f));
                let _e2574 = phi_1_;
                let _e2581 = state[((idx * 8u) + 1u)];
                let _e2582 = other_idx;
                let _e2589 = state[((_e2582 * 8u) + 1u)];
                let _e2590 = phi_1_;
                let _e2594 = other_idx;
                let _e2601 = state[((_e2594 * 8u) + 1u)];
                let _e2602 = other_idx;
                let _e2610 = grad_state[((_e2602 * 8u) + 1u)].x;
                let _e2611 = other_idx;
                let _e2619 = grad_state[((_e2611 * 8u) + 1u)].y;
                let _e2625 = other_center.x;
                let _e2627 = other_center.y;
                let _e2638 = state[((idx * 8u) + 1u)];
                let _e2646 = grad_state[((idx * 8u) + 1u)].x;
                let _e2654 = grad_state[((idx * 8u) + 1u)].y;
                let _e2665 = phi_1_;
                let _e2671 = constants.scheme;
                let _e2675 = other_idx;
                let _e2682 = state[((_e2675 * 8u) + 1u)];
                let _e2683 = other_idx;
                let _e2690 = state[((_e2683 * 8u) + 1u)];
                let _e2700 = state[((idx * 8u) + 1u)];
                let _e2704 = other_idx;
                let _e2712 = grad_state[((_e2704 * 8u) + 1u)].x;
                let _e2713 = other_idx;
                let _e2721 = grad_state[((_e2713 * 8u) + 1u)].y;
                let _e2727 = other_center.x;
                let _e2729 = other_center.y;
                let _e2736 = other_idx;
                let _e2743 = state[((_e2736 * 8u) + 1u)];
                let _e2751 = state[((idx * 8u) + 1u)];
                let _e2758 = state[((idx * 8u) + 1u)];
                let _e2762 = other_idx;
                let _e2769 = state[((_e2762 * 8u) + 1u)];
                let _e2780 = grad_state[((idx * 8u) + 1u)].x;
                let _e2788 = grad_state[((idx * 8u) + 1u)].y;
                let _e2791 = other_center.x;
                let _e2793 = other_center.y;
                let _e2809 = state[((idx * 8u) + 1u)];
                let _e2811 = phi_1_;
                let _e2817 = constants.scheme;
                let _e2821 = other_idx;
                let _e2828 = state[((_e2821 * 8u) + 1u)];
                let _e2829 = other_idx;
                let _e2837 = grad_state[((_e2829 * 8u) + 1u)].x;
                let _e2838 = other_idx;
                let _e2846 = grad_state[((_e2838 * 8u) + 1u)].y;
                let _e2852 = other_center.x;
                let _e2854 = other_center.y;
                let _e2864 = state[((idx * 8u) + 1u)];
                let _e2865 = other_idx;
                let _e2872 = state[((_e2865 * 8u) + 1u)];
                let _e2883 = state[((idx * 8u) + 1u)];
                let _e2884 = other_idx;
                let _e2891 = state[((_e2884 * 8u) + 1u)];
                let _e2903 = state[((idx * 8u) + 1u)];
                let _e2911 = grad_state[((idx * 8u) + 1u)].x;
                let _e2919 = grad_state[((idx * 8u) + 1u)].y;
                let _e2929 = other_idx;
                let _e2936 = state[((_e2929 * 8u) + 1u)];
                let _e2943 = state[((idx * 8u) + 1u)];
                let _e2948 = other_idx;
                let _e2955 = state[((_e2948 * 8u) + 1u)];
                let _e2962 = state[((idx * 8u) + 1u)];
                let _e2968 = phi_1_;
                let _e2974 = constants.scheme;
                let _e2978 = other_idx;
                let _e2985 = state[((_e2978 * 8u) + 1u)];
                let _e2986 = other_idx;
                let _e2994 = grad_state[((_e2986 * 8u) + 1u)].x;
                let _e2995 = other_idx;
                let _e3003 = grad_state[((_e2995 * 8u) + 1u)].y;
                let _e3009 = other_center.x;
                let _e3011 = other_center.y;
                let _e3021 = state[((idx * 8u) + 1u)];
                let _e3022 = other_idx;
                let _e3029 = state[((_e3022 * 8u) + 1u)];
                let _e3039 = state[((idx * 8u) + 1u)];
                let _e3040 = other_idx;
                let _e3047 = state[((_e3040 * 8u) + 1u)];
                let _e3050 = other_idx;
                let _e3058 = grad_state[((_e3050 * 8u) + 1u)].x;
                let _e3059 = other_idx;
                let _e3067 = grad_state[((_e3059 * 8u) + 1u)].y;
                let _e3073 = other_center.x;
                let _e3075 = other_center.y;
                let _e3090 = state[((idx * 8u) + 1u)];
                let _e3091 = other_idx;
                let _e3098 = state[((_e3091 * 8u) + 1u)];
                let _e3100 = other_idx;
                let _e3108 = grad_state[((_e3100 * 8u) + 1u)].x;
                let _e3109 = other_idx;
                let _e3117 = grad_state[((_e3109 * 8u) + 1u)].y;
                let _e3123 = other_center.x;
                let _e3125 = other_center.y;
                let _e3139 = state[((idx * 8u) + 1u)];
                let _e3140 = other_idx;
                let _e3147 = state[((_e3140 * 8u) + 1u)];
                let _e3149 = other_idx;
                let _e3157 = grad_state[((_e3149 * 8u) + 1u)].x;
                let _e3158 = other_idx;
                let _e3166 = grad_state[((_e3158 * 8u) + 1u)].y;
                let _e3172 = other_center.x;
                let _e3174 = other_center.y;
                let _e3190 = state[((idx * 8u) + 1u)];
                let _e3198 = grad_state[((idx * 8u) + 1u)].x;
                let _e3206 = grad_state[((idx * 8u) + 1u)].y;
                let _e3216 = other_idx;
                let _e3223 = state[((_e3216 * 8u) + 1u)];
                let _e3230 = state[((idx * 8u) + 1u)];
                let _e3234 = other_idx;
                let _e3241 = state[((_e3234 * 8u) + 1u)];
                let _e3248 = state[((idx * 8u) + 1u)];
                let _e3258 = grad_state[((idx * 8u) + 1u)].x;
                let _e3266 = grad_state[((idx * 8u) + 1u)].y;
                let _e3281 = other_idx;
                let _e3288 = state[((_e3281 * 8u) + 1u)];
                let _e3295 = state[((idx * 8u) + 1u)];
                let _e3304 = grad_state[((idx * 8u) + 1u)].x;
                let _e3312 = grad_state[((idx * 8u) + 1u)].y;
                let _e3326 = other_idx;
                let _e3333 = state[((_e3326 * 8u) + 1u)];
                let _e3340 = state[((idx * 8u) + 1u)];
                let _e3349 = grad_state[((idx * 8u) + 1u)].x;
                let _e3357 = grad_state[((idx * 8u) + 1u)].y;
                let _e3373 = phi_1_;
                let _e3379 = constants.scheme;
                let _e3383 = other_idx;
                let _e3390 = state[((_e3383 * 8u) + 1u)];
                let _e3391 = other_idx;
                let _e3398 = state[((_e3391 * 8u) + 1u)];
                let _e3407 = state[((idx * 8u) + 1u)];
                let _e3411 = other_idx;
                let _e3419 = grad_state[((_e3411 * 8u) + 1u)].x;
                let _e3420 = other_idx;
                let _e3428 = grad_state[((_e3420 * 8u) + 1u)].y;
                let _e3434 = other_center.x;
                let _e3436 = other_center.y;
                let _e3443 = other_idx;
                let _e3450 = state[((_e3443 * 8u) + 1u)];
                let _e3458 = state[((idx * 8u) + 1u)];
                let _e3459 = other_idx;
                let _e3466 = state[((_e3459 * 8u) + 1u)];
                let _e3477 = state[((idx * 8u) + 1u)];
                let _e3478 = other_idx;
                let _e3485 = state[((_e3478 * 8u) + 1u)];
                let _e3497 = state[((idx * 8u) + 1u)];
                let _e3504 = state[((idx * 8u) + 1u)];
                let _e3507 = other_idx;
                let _e3514 = state[((_e3507 * 8u) + 1u)];
                let _e3525 = grad_state[((idx * 8u) + 1u)].x;
                let _e3533 = grad_state[((idx * 8u) + 1u)].y;
                let _e3536 = other_center.x;
                let _e3538 = other_center.y;
                let _e3554 = state[((idx * 8u) + 1u)];
                let _e3556 = other_idx;
                let _e3563 = state[((_e3556 * 8u) + 1u)];
                let _e3570 = state[((idx * 8u) + 1u)];
                let _e3575 = other_idx;
                let _e3582 = state[((_e3575 * 8u) + 1u)];
                let _e3589 = state[((idx * 8u) + 1u)];
                let _e3595 = phi_1_;
                let _e3601 = constants.scheme;
                let _e3605 = other_idx;
                let _e3612 = state[((_e3605 * 8u) + 1u)];
                let _e3613 = other_idx;
                let _e3620 = state[((_e3613 * 8u) + 1u)];
                let _e3629 = state[((idx * 8u) + 1u)];
                let _e3633 = other_idx;
                let _e3641 = grad_state[((_e3633 * 8u) + 1u)].x;
                let _e3642 = other_idx;
                let _e3650 = grad_state[((_e3642 * 8u) + 1u)].y;
                let _e3656 = other_center.x;
                let _e3658 = other_center.y;
                let _e3665 = other_idx;
                let _e3672 = state[((_e3665 * 8u) + 1u)];
                let _e3680 = state[((idx * 8u) + 1u)];
                let _e3681 = other_idx;
                let _e3688 = state[((_e3681 * 8u) + 1u)];
                let _e3698 = state[((idx * 8u) + 1u)];
                let _e3699 = other_idx;
                let _e3706 = state[((_e3699 * 8u) + 1u)];
                let _e3709 = other_idx;
                let _e3716 = state[((_e3709 * 8u) + 1u)];
                let _e3725 = state[((idx * 8u) + 1u)];
                let _e3729 = other_idx;
                let _e3737 = grad_state[((_e3729 * 8u) + 1u)].x;
                let _e3738 = other_idx;
                let _e3746 = grad_state[((_e3738 * 8u) + 1u)].y;
                let _e3752 = other_center.x;
                let _e3754 = other_center.y;
                let _e3761 = other_idx;
                let _e3768 = state[((_e3761 * 8u) + 1u)];
                let _e3781 = state[((idx * 8u) + 1u)];
                let _e3782 = other_idx;
                let _e3789 = state[((_e3782 * 8u) + 1u)];
                let _e3791 = other_idx;
                let _e3798 = state[((_e3791 * 8u) + 1u)];
                let _e3807 = state[((idx * 8u) + 1u)];
                let _e3811 = other_idx;
                let _e3819 = grad_state[((_e3811 * 8u) + 1u)].x;
                let _e3820 = other_idx;
                let _e3828 = grad_state[((_e3820 * 8u) + 1u)].y;
                let _e3834 = other_center.x;
                let _e3836 = other_center.y;
                let _e3843 = other_idx;
                let _e3850 = state[((_e3843 * 8u) + 1u)];
                let _e3862 = state[((idx * 8u) + 1u)];
                let _e3863 = other_idx;
                let _e3870 = state[((_e3863 * 8u) + 1u)];
                let _e3872 = other_idx;
                let _e3879 = state[((_e3872 * 8u) + 1u)];
                let _e3888 = state[((idx * 8u) + 1u)];
                let _e3892 = other_idx;
                let _e3900 = grad_state[((_e3892 * 8u) + 1u)].x;
                let _e3901 = other_idx;
                let _e3909 = grad_state[((_e3901 * 8u) + 1u)].y;
                let _e3915 = other_center.x;
                let _e3917 = other_center.y;
                let _e3924 = other_idx;
                let _e3931 = state[((_e3924 * 8u) + 1u)];
                let _e3945 = state[((idx * 8u) + 1u)];
                let _e3952 = state[((idx * 8u) + 1u)];
                let _e3955 = other_idx;
                let _e3962 = state[((_e3955 * 8u) + 1u)];
                let _e3973 = grad_state[((idx * 8u) + 1u)].x;
                let _e3981 = grad_state[((idx * 8u) + 1u)].y;
                let _e3984 = other_center.x;
                let _e3986 = other_center.y;
                let _e4002 = state[((idx * 8u) + 1u)];
                let _e4004 = other_idx;
                let _e4011 = state[((_e4004 * 8u) + 1u)];
                let _e4018 = state[((idx * 8u) + 1u)];
                let _e4022 = other_idx;
                let _e4029 = state[((_e4022 * 8u) + 1u)];
                let _e4036 = state[((idx * 8u) + 1u)];
                let _e4045 = state[((idx * 8u) + 1u)];
                let _e4048 = other_idx;
                let _e4055 = state[((_e4048 * 8u) + 1u)];
                let _e4066 = grad_state[((idx * 8u) + 1u)].x;
                let _e4074 = grad_state[((idx * 8u) + 1u)].y;
                let _e4077 = other_center.x;
                let _e4079 = other_center.y;
                let _e4095 = state[((idx * 8u) + 1u)];
                let _e4102 = other_idx;
                let _e4109 = state[((_e4102 * 8u) + 1u)];
                let _e4116 = state[((idx * 8u) + 1u)];
                let _e4124 = state[((idx * 8u) + 1u)];
                let _e4127 = other_idx;
                let _e4134 = state[((_e4127 * 8u) + 1u)];
                let _e4145 = grad_state[((idx * 8u) + 1u)].x;
                let _e4153 = grad_state[((idx * 8u) + 1u)].y;
                let _e4156 = other_center.x;
                let _e4158 = other_center.y;
                let _e4174 = state[((idx * 8u) + 1u)];
                let _e4180 = other_idx;
                let _e4187 = state[((_e4180 * 8u) + 1u)];
                let _e4194 = state[((idx * 8u) + 1u)];
                let _e4202 = state[((idx * 8u) + 1u)];
                let _e4205 = other_idx;
                let _e4212 = state[((_e4205 * 8u) + 1u)];
                let _e4223 = grad_state[((idx * 8u) + 1u)].x;
                let _e4231 = grad_state[((idx * 8u) + 1u)].y;
                let _e4234 = other_center.x;
                let _e4236 = other_center.y;
                let _e4252 = state[((idx * 8u) + 1u)];
                let _e4260 = phi_1_;
                let _e4266 = constants.scheme;
                let _e4276 = state[((idx * 8u) + 1u)];
                let _e4277 = other_idx;
                let _e4284 = state[((_e4277 * 8u) + 1u)];
                let _e4285 = phi_1_;
                let _e4291 = rhs_1_;
                rhs_1_ = (_e4291 - (_e2574 * (select(select(select(select(select(select(select(_e2581, _e2589, (_e2590 < 0f)), select((_e2601 + dot(vec2<f32>(_e2610, _e2619), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2625, _e2627)))), (_e2638 + dot(vec2<f32>(_e2646, _e2654), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e2665 > 0f)), (_e2671 == 1u)), select(((((_e2682 + (_e2690 * 0.625f)) + (_e2700 * 0.375f)) + (dot(vec2<f32>(_e2712, _e2721), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2727, _e2729))) * 0.125f)) - _e2743), ((((_e2751 + (_e2758 * 0.625f)) + (_e2769 * 0.375f)) + (dot(vec2<f32>(_e2780, _e2788), (vec2<f32>(_e2791, _e2793) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2809), (_e2811 > 0f)), (_e2817 == 2u)), select((_e2828 + min(max(dot(vec2<f32>(_e2837, _e2846), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2852, _e2854))), min((_e2864 - _e2872), 0f)), max((_e2883 - _e2891), 0f))), (_e2903 + min(max(dot(vec2<f32>(_e2911, _e2919), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e2936 - _e2943), 0f)), max((_e2955 - _e2962), 0f))), (_e2968 > 0f)), (_e2974 == 3u)), select((_e2985 + ((((dot(vec2<f32>(_e2994, _e3003), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3009, _e3011))) * abs((_e3021 - _e3029))) / max(abs((_e3039 - _e3047)), (abs(dot(vec2<f32>(_e3058, _e3067), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3073, _e3075)))) + 0.00000001f))) * max(((_e3090 - _e3098) * dot(vec2<f32>(_e3108, _e3117), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3123, _e3125)))), 0f)) / max(abs(((_e3139 - _e3147) * dot(vec2<f32>(_e3157, _e3166), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3172, _e3174))))), 0.00000001f))), (_e3190 + ((((dot(vec2<f32>(_e3198, _e3206), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e3223 - _e3230))) / max(abs((_e3241 - _e3248)), (abs(dot(vec2<f32>(_e3258, _e3266), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e3288 - _e3295) * dot(vec2<f32>(_e3304, _e3312), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e3333 - _e3340) * dot(vec2<f32>(_e3349, _e3357), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e3373 > 0f)), (_e3379 == 4u)), select((_e3390 + min(max(((((_e3398 * 0.625f) + (_e3407 * 0.375f)) + (dot(vec2<f32>(_e3419, _e3428), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3434, _e3436))) * 0.125f)) - _e3450), min((_e3458 - _e3466), 0f)), max((_e3477 - _e3485), 0f))), (_e3497 + min(max(((((_e3504 * 0.625f) + (_e3514 * 0.375f)) + (dot(vec2<f32>(_e3525, _e3533), (vec2<f32>(_e3536, _e3538) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3554), min((_e3563 - _e3570), 0f)), max((_e3582 - _e3589), 0f))), (_e3595 > 0f)), (_e3601 == 5u)), select((_e3612 + ((((((((_e3620 * 0.625f) + (_e3629 * 0.375f)) + (dot(vec2<f32>(_e3641, _e3650), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3656, _e3658))) * 0.125f)) - _e3672) * abs((_e3680 - _e3688))) / max(abs((_e3698 - _e3706)), (abs(((((_e3716 * 0.625f) + (_e3725 * 0.375f)) + (dot(vec2<f32>(_e3737, _e3746), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3752, _e3754))) * 0.125f)) - _e3768)) + 0.00000001f))) * max(((_e3781 - _e3789) * ((((_e3798 * 0.625f) + (_e3807 * 0.375f)) + (dot(vec2<f32>(_e3819, _e3828), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3834, _e3836))) * 0.125f)) - _e3850)), 0f)) / max(abs(((_e3862 - _e3870) * ((((_e3879 * 0.625f) + (_e3888 * 0.375f)) + (dot(vec2<f32>(_e3900, _e3909), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3915, _e3917))) * 0.125f)) - _e3931))), 0.00000001f))), (_e3945 + ((((((((_e3952 * 0.625f) + (_e3962 * 0.375f)) + (dot(vec2<f32>(_e3973, _e3981), (vec2<f32>(_e3984, _e3986) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4002) * abs((_e4011 - _e4018))) / max(abs((_e4029 - _e4036)), (abs(((((_e4045 * 0.625f) + (_e4055 * 0.375f)) + (dot(vec2<f32>(_e4066, _e4074), (vec2<f32>(_e4077, _e4079) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4095)) + 0.00000001f))) * max(((_e4109 - _e4116) * ((((_e4124 * 0.625f) + (_e4134 * 0.375f)) + (dot(vec2<f32>(_e4145, _e4153), (vec2<f32>(_e4156, _e4158) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4174)), 0f)) / max(abs(((_e4187 - _e4194) * ((((_e4202 * 0.625f) + (_e4212 * 0.375f)) + (dot(vec2<f32>(_e4223, _e4231), (vec2<f32>(_e4234, _e4236) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4252))), 0.00000001f))), (_e4260 > 0f)), (_e4266 == 6u)) - select(_e4276, _e4284, (_e4285 < 0f)))));
            } else {
                let _e4299 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e4299 == 1u) {
                    let _e4302 = phi_1_;
                    let _e4305 = diag_1_;
                    diag_1_ = (_e4305 + max(_e4302, 0f));
                    let _e4307 = phi_1_;
                    let _e4316 = bc_value[((face_idx * 3u) + 1u)];
                    let _e4318 = rhs_1_;
                    rhs_1_ = (_e4318 - (min(_e4307, 0f) * _e4316));
                } else {
                    let _e4320 = phi_1_;
                    let _e4321 = diag_1_;
                    diag_1_ = (_e4321 + _e4320);
                }
            }
            let _e4326 = normal.x;
            let _e4334 = state[((idx * 8u) + 2u)];
            let _e4335 = other_idx;
            let _e4342 = state[((_e4335 * 8u) + 2u)];
            let _e4345 = rhs_0_;
            rhs_0_ = (_e4345 - (((0.5f * area) * _e4326) * (_e4334 + _e4342)));
            let _e4350 = normal.y;
            let _e4358 = state[((idx * 8u) + 2u)];
            let _e4359 = other_idx;
            let _e4366 = state[((_e4359 * 8u) + 2u)];
            let _e4369 = rhs_1_;
            rhs_1_ = (_e4369 - (((0.5f * area) * _e4350) * (_e4358 + _e4366)));
            let _e4373 = constants.density;
            let _e4380 = state[((idx * 8u) + 3u)];
            let _e4384 = constants.density;
            let _e4391 = state[((idx * 8u) + 3u)];
            let _e4395 = constants.density;
            let _e4396 = other_idx;
            let _e4403 = state[((_e4396 * 8u) + 3u)];
            let _e4408 = is_boundary;
            let _e4412 = dist;
            let diff_coeff_p = ((select((_e4373 * _e4380), (((_e4384 * _e4391) + (_e4395 * _e4403)) * 0.5f), !(_e4408)) * area) / _e4412);
            let _e4414 = is_boundary;
            if !(_e4414) {
                let _e4417 = diag_2_;
                diag_2_ = (_e4417 + diff_coeff_p);
                let _e4426 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e4426 - diff_coeff_p);
            } else {
                let _e4434 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e4434 == 1u) {
                    let _e4437 = diag_2_;
                    diag_2_ = (_e4437 + diff_coeff_p);
                    let _e4446 = bc_value[((face_idx * 3u) + 2u)];
                    let _e4448 = rhs_2_;
                    rhs_2_ = (_e4448 + (diff_coeff_p * _e4446));
                } else {
                    let _e4456 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e4456 == 2u) {
                        let _e4461 = constants.density;
                        let _e4468 = state[((idx * 8u) + 3u)];
                        let _e4472 = constants.density;
                        let _e4479 = state[((idx * 8u) + 3u)];
                        let _e4483 = constants.density;
                        let _e4484 = other_idx;
                        let _e4491 = state[((_e4484 * 8u) + 3u)];
                        let _e4496 = is_boundary;
                        let _e4506 = bc_value[((face_idx * 3u) + 2u)];
                        let _e4509 = rhs_2_;
                        rhs_2_ = (_e4509 + -(((select((_e4461 * _e4468), (((_e4472 * _e4479) + (_e4483 * _e4491)) * 0.5f), !(_e4496)) * area) * _e4506)));
                    }
                }
            }
            let _e4517 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e4517;
            if (owner != idx) {
                let _e4520 = phi_2_;
                let _e4523 = phi_2_;
                phi_2_ = (_e4523 - (_e4520 * 2f));
            }
            let _e4525 = phi_2_;
            let _e4526 = rhs_2_;
            rhs_2_ = (_e4526 - _e4525);
        }
        continuing {
            let _e4529 = k;
            k = (_e4529 + 1u);
        }
    }
    let _e4538 = diag_0_;
    let _e4539 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e4539 + _e4538);
    let _e4547 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e4547;
    let _e4555 = diag_1_;
    let _e4556 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e4556 + _e4555);
    let _e4564 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e4564;
    let _e4572 = diag_2_;
    let _e4573 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e4573 + _e4572);
    let _e4581 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e4581;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e528 = constants.viscosity;
            let _e531 = constants.viscosity;
            let _e535 = is_boundary;
            let _e539 = dist;
            let diff_coeff_U = ((select(_e525, ((_e528 + _e531) * 0.5f), !(_e535)) * area) / _e539);
            let _e541 = is_boundary;
            if !(_e541) {
                let _e543 = diag_0_;
                diag_0_ = (_e543 + diff_coeff_U);
                let _e552 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e552 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e556 = diag_0_;
                    diag_0_ = (_e556 + diff_coeff_U);
                    let _e564 = state[((idx * 8u) + 0u)];
                    let _e571 = state[((idx * 8u) + 0u)];
                    let _e573 = normal.x;
                    let _e581 = state[((idx * 8u) + 1u)];
                    let _e583 = normal.y;
                    let _e587 = normal.x;
                    let _e591 = rhs_0_;
                    rhs_0_ = (_e591 + (diff_coeff_U * (_e564 - (((_e571 * _e573) + (_e581 * _e583)) * _e587))));
                } else {
                    let _e599 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e599 == 1u) {
                        let _e602 = diag_0_;
                        diag_0_ = (_e602 + diff_coeff_U);
                        let _e610 = bc_value[((face_idx * 3u) + 0u)];
                        let _e612 = rhs_0_;
                        rhs_0_ = (_e612 + (diff_coeff_U * _e610));
                    } else {
                        let _e620 = bc_kind[((face_idx * 3u) + 0u)];
                        if (_e620 == 2u) {
                            let _e625 = constants.viscosity;
                            let _e628 = constants.viscosity;
                            let _e631 = constants.viscosity;
                            let _e635 = is_boundary;
                            let _e645 = bc_value[((face_idx * 3u) + 0u)];
                            let _e648 = rhs_0_;
                            rhs_0_ = (_e648 + -(((select(_e625, ((_e628 + _e631) * 0.5f), !(_e635)) * area) * _e645)));
                        }
                    }
                }
            }
            let _e650 = is_boundary;
            if !(_e650) {
                let _e652 = diag_1_;
                diag_1_ = (_e652 + diff_coeff_U);
                let _e661 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e661 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e665 = diag_1_;
                    diag_1_ = (_e665 + diff_coeff_U);
                    let _e673 = state[((idx * 8u) + 1u)];
                    let _e680 = state[((idx * 8u) + 0u)];
                    let _e682 = normal.x;
                    let _e690 = state[((idx * 8u) + 1u)];
                    let _e692 = normal.y;
                    let _e696 = normal.y;
                    let _e700 = rhs_1_;
                    rhs_1_ = (_e700 + (diff_coeff_U * (_e673 - (((_e680 * _e682) + (_e690 * _e692)) * _e696))));
                } else {
                    let _e708 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e708 == 1u) {
                        let _e711 = diag_1_;
                        diag_1_ = (_e711 + diff_coeff_U);
                        let _e719 = bc_value[((face_idx * 3u) + 1u)];
                        let _e721 = rhs_1_;
                        rhs_1_ = (_e721 + (diff_coeff_U * _e719));
                    } else {
                        let _e729 = bc_kind[((face_idx * 3u) + 1u)];
                        if (_e729 == 2u) {
                            let _e734 = constants.viscosity;
                            let _e737 = constants.viscosity;
                            let _e740 = constants.viscosity;
                            let _e744 = is_boundary;
                            let _e754 = bc_value[((face_idx * 3u) + 1u)];
                            let _e757 = rhs_1_;
                            rhs_1_ = (_e757 + -(((select(_e734, ((_e737 + _e740) * 0.5f), !(_e744)) * area) * _e754)));
                        }
                    }
                }
            }
            let _e765 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e765;
            if (owner != idx) {
                let _e768 = phi_0_;
                let _e771 = phi_0_;
                phi_0_ = (_e771 - (_e768 * 2f));
            }
            let _e773 = is_boundary;
            if !(_e773) {
                let _e775 = phi_0_;
                let _e778 = diag_0_;
                diag_0_ = (_e778 + max(_e775, 0f));
                let _e787 = phi_0_;
                let _e790 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e790 + min(_e787, 0f));
                let _e792 = phi_0_;
                let _e799 = state[((idx * 8u) + 0u)];
                let _e800 = other_idx;
                let _e807 = state[((_e800 * 8u) + 0u)];
                let _e808 = phi_0_;
                let _e812 = other_idx;
                let _e819 = state[((_e812 * 8u) + 0u)];
                let _e820 = other_idx;
                let _e827 = state[((_e820 * 8u) + 0u)];
                let _e834 = state[((idx * 8u) + 0u)];
                let _e843 = other_idx;
                let _e850 = state[((_e843 * 8u) + 0u)];
                let _e857 = state[((idx * 8u) + 0u)];
                let _e871 = other_center.x;
                let _e873 = other_center.y;
                let _e884 = state[((idx * 8u) + 0u)];
                let _e885 = other_idx;
                let _e892 = state[((_e885 * 8u) + 0u)];
                let _e899 = state[((idx * 8u) + 0u)];
                let _e908 = other_idx;
                let _e915 = state[((_e908 * 8u) + 0u)];
                let _e922 = state[((idx * 8u) + 0u)];
                let _e941 = phi_0_;
                let _e947 = constants.scheme;
                let _e951 = other_idx;
                let _e958 = state[((_e951 * 8u) + 0u)];
                let _e959 = other_idx;
                let _e966 = state[((_e959 * 8u) + 0u)];
                let _e976 = state[((idx * 8u) + 0u)];
                let _e980 = other_idx;
                let _e987 = state[((_e980 * 8u) + 0u)];
                let _e994 = state[((idx * 8u) + 0u)];
                let _e1003 = other_idx;
                let _e1010 = state[((_e1003 * 8u) + 0u)];
                let _e1017 = state[((idx * 8u) + 0u)];
                let _e1031 = other_center.x;
                let _e1033 = other_center.y;
                let _e1040 = other_idx;
                let _e1047 = state[((_e1040 * 8u) + 0u)];
                let _e1055 = state[((idx * 8u) + 0u)];
                let _e1062 = state[((idx * 8u) + 0u)];
                let _e1066 = other_idx;
                let _e1073 = state[((_e1066 * 8u) + 0u)];
                let _e1077 = other_idx;
                let _e1084 = state[((_e1077 * 8u) + 0u)];
                let _e1091 = state[((idx * 8u) + 0u)];
                let _e1100 = other_idx;
                let _e1107 = state[((_e1100 * 8u) + 0u)];
                let _e1114 = state[((idx * 8u) + 0u)];
                let _e1125 = other_center.x;
                let _e1127 = other_center.y;
                let _e1143 = state[((idx * 8u) + 0u)];
                let _e1145 = phi_0_;
                let _e1151 = constants.scheme;
                let _e1155 = other_idx;
                let _e1162 = state[((_e1155 * 8u) + 0u)];
                let _e1163 = other_idx;
                let _e1170 = state[((_e1163 * 8u) + 0u)];
                let _e1177 = state[((idx * 8u) + 0u)];
                let _e1186 = other_idx;
                let _e1193 = state[((_e1186 * 8u) + 0u)];
                let _e1200 = state[((idx * 8u) + 0u)];
                let _e1214 = other_center.x;
                let _e1216 = other_center.y;
                let _e1226 = state[((idx * 8u) + 0u)];
                let _e1227 = other_idx;
                let _e1234 = state[((_e1227 * 8u) + 0u)];
                let _e1245 = state[((idx * 8u) + 0u)];
                let _e1246 = other_idx;
                let _e1253 = state[((_e1246 * 8u) + 0u)];
                let _e1265 = state[((idx * 8u) + 0u)];
                let _e1266 = other_idx;
                let _e1273 = state[((_e1266 * 8u) + 0u)];
                let _e1280 = state[((idx * 8u) + 0u)];
                let _e1289 = other_idx;
                let _e1296 = state[((_e1289 * 8u) + 0u)];
                let _e1303 = state[((idx * 8u) + 0u)];
                let _e1321 = other_idx;
                let _e1328 = state[((_e1321 * 8u) + 0u)];
                let _e1335 = state[((idx * 8u) + 0u)];
                let _e1340 = other_idx;
                let _e1347 = state[((_e1340 * 8u) + 0u)];
                let _e1354 = state[((idx * 8u) + 0u)];
                let _e1360 = phi_0_;
                let _e1366 = constants.scheme;
                let _e1370 = other_idx;
                let _e1377 = state[((_e1370 * 8u) + 0u)];
                let _e1378 = other_idx;
                let _e1385 = state[((_e1378 * 8u) + 0u)];
                let _e1392 = state[((idx * 8u) + 0u)];
                let _e1401 = other_idx;
                let _e1408 = state[((_e1401 * 8u) + 0u)];
                let _e1415 = state[((idx * 8u) + 0u)];
                let _e1429 = other_center.x;
                let _e1431 = other_center.y;
                let _e1441 = state[((idx * 8u) + 0u)];
                let _e1442 = other_idx;
                let _e1449 = state[((_e1442 * 8u) + 0u)];
                let _e1459 = state[((idx * 8u) + 0u)];
                let _e1460 = other_idx;
                let _e1467 = state[((_e1460 * 8u) + 0u)];
                let _e1470 = other_idx;
                let _e1477 = state[((_e1470 * 8u) + 0u)];
                let _e1484 = state[((idx * 8u) + 0u)];
                let _e1493 = other_idx;
                let _e1500 = state[((_e1493 * 8u) + 0u)];
                let _e1507 = state[((idx * 8u) + 0u)];
                let _e1521 = other_center.x;
                let _e1523 = other_center.y;
                let _e1538 = state[((idx * 8u) + 0u)];
                let _e1539 = other_idx;
                let _e1546 = state[((_e1539 * 8u) + 0u)];
                let _e1548 = other_idx;
                let _e1555 = state[((_e1548 * 8u) + 0u)];
                let _e1562 = state[((idx * 8u) + 0u)];
                let _e1571 = other_idx;
                let _e1578 = state[((_e1571 * 8u) + 0u)];
                let _e1585 = state[((idx * 8u) + 0u)];
                let _e1599 = other_center.x;
                let _e1601 = other_center.y;
                let _e1615 = state[((idx * 8u) + 0u)];
                let _e1616 = other_idx;
                let _e1623 = state[((_e1616 * 8u) + 0u)];
                let _e1625 = other_idx;
                let _e1632 = state[((_e1625 * 8u) + 0u)];
                let _e1639 = state[((idx * 8u) + 0u)];
                let _e1648 = other_idx;
                let _e1655 = state[((_e1648 * 8u) + 0u)];
                let _e1662 = state[((idx * 8u) + 0u)];
                let _e1676 = other_center.x;
                let _e1678 = other_center.y;
                let _e1694 = state[((idx * 8u) + 0u)];
                let _e1695 = other_idx;
                let _e1702 = state[((_e1695 * 8u) + 0u)];
                let _e1709 = state[((idx * 8u) + 0u)];
                let _e1718 = other_idx;
                let _e1725 = state[((_e1718 * 8u) + 0u)];
                let _e1732 = state[((idx * 8u) + 0u)];
                let _e1750 = other_idx;
                let _e1757 = state[((_e1750 * 8u) + 0u)];
                let _e1764 = state[((idx * 8u) + 0u)];
                let _e1768 = other_idx;
                let _e1775 = state[((_e1768 * 8u) + 0u)];
                let _e1782 = state[((idx * 8u) + 0u)];
                let _e1785 = other_idx;
                let _e1792 = state[((_e1785 * 8u) + 0u)];
                let _e1799 = state[((idx * 8u) + 0u)];
                let _e1808 = other_idx;
                let _e1815 = state[((_e1808 * 8u) + 0u)];
                let _e1822 = state[((idx * 8u) + 0u)];
                let _e1845 = other_idx;
                let _e1852 = state[((_e1845 * 8u) + 0u)];
                let _e1859 = state[((idx * 8u) + 0u)];
                let _e1861 = other_idx;
                let _e1868 = state[((_e1861 * 8u) + 0u)];
                let _e1875 = state[((idx * 8u) + 0u)];
                let _e1884 = other_idx;
                let _e1891 = state[((_e1884 * 8u) + 0u)];
                let _e1898 = state[((idx * 8u) + 0u)];
                let _e1920 = other_idx;
                let _e1927 = state[((_e1920 * 8u) + 0u)];
                let _e1934 = state[((idx * 8u) + 0u)];
                let _e1936 = other_idx;
                let _e1943 = state[((_e1936 * 8u) + 0u)];
                let _e1950 = state[((idx * 8u) + 0u)];
                let _e1959 = other_idx;
                let _e1966 = state[((_e1959 * 8u) + 0u)];
                let _e1973 = state[((idx * 8u) + 0u)];
                let _e1997 = phi_0_;
                let _e2003 = constants.scheme;
                let _e2007 = other_idx;
                let _e2014 = state[((_e2007 * 8u) + 0u)];
                let _e2015 = other_idx;
                let _e2022 = state[((_e2015 * 8u) + 0u)];
                let _e2031 = state[((idx * 8u) + 0u)];
                let _e2035 = other_idx;
                let _e2042 = state[((_e2035 * 8u) + 0u)];
                let _e2049 = state[((idx * 8u) + 0u)];
                let _e2058 = other_idx;
                let _e2065 = state[((_e2058 * 8u) + 0u)];
                let _e2072 = state[((idx * 8u) + 0u)];
                let _e2086 = other_center.x;
                let _e2088 = other_center.y;
                let _e2095 = other_idx;
                let _e2102 = state[((_e2095 * 8u) + 0u)];
                let _e2110 = state[((idx * 8u) + 0u)];
                let _e2111 = other_idx;
                let _e2118 = state[((_e2111 * 8u) + 0u)];
                let _e2129 = state[((idx * 8u) + 0u)];
                let _e2130 = other_idx;
                let _e2137 = state[((_e2130 * 8u) + 0u)];
                let _e2149 = state[((idx * 8u) + 0u)];
                let _e2156 = state[((idx * 8u) + 0u)];
                let _e2159 = other_idx;
                let _e2166 = state[((_e2159 * 8u) + 0u)];
                let _e2170 = other_idx;
                let _e2177 = state[((_e2170 * 8u) + 0u)];
                let _e2184 = state[((idx * 8u) + 0u)];
                let _e2193 = other_idx;
                let _e2200 = state[((_e2193 * 8u) + 0u)];
                let _e2207 = state[((idx * 8u) + 0u)];
                let _e2218 = other_center.x;
                let _e2220 = other_center.y;
                let _e2236 = state[((idx * 8u) + 0u)];
                let _e2238 = other_idx;
                let _e2245 = state[((_e2238 * 8u) + 0u)];
                let _e2252 = state[((idx * 8u) + 0u)];
                let _e2257 = other_idx;
                let _e2264 = state[((_e2257 * 8u) + 0u)];
                let _e2271 = state[((idx * 8u) + 0u)];
                let _e2277 = phi_0_;
                let _e2283 = constants.scheme;
                let _e2287 = other_idx;
                let _e2294 = state[((_e2287 * 8u) + 0u)];
                let _e2295 = other_idx;
                let _e2302 = state[((_e2295 * 8u) + 0u)];
                let _e2311 = state[((idx * 8u) + 0u)];
                let _e2315 = other_idx;
                let _e2322 = state[((_e2315 * 8u) + 0u)];
                let _e2329 = state[((idx * 8u) + 0u)];
                let _e2338 = other_idx;
                let _e2345 = state[((_e2338 * 8u) + 0u)];
                let _e2352 = state[((idx * 8u) + 0u)];
                let _e2366 = other_center.x;
                let _e2368 = other_center.y;
                let _e2375 = other_idx;
                let _e2382 = state[((_e2375 * 8u) + 0u)];
                let _e2390 = state[((idx * 8u) + 0u)];
                let _e2391 = other_idx;
                let _e2398 = state[((_e2391 * 8u) + 0u)];
                let _e2408 = state[((idx * 8u) + 0u)];
                let _e2409 = other_idx;
                let _e2416 = state[((_e2409 * 8u) + 0u)];
                let _e2419 = other_idx;
                let _e2426 = state[((_e2419 * 8u) + 0u)];
                let _e2435 = state[((idx * 8u) + 0u)];
                let _e2439 = other_idx;
                let _e2446 = state[((_e2439 * 8u) + 0u)];
                let _e2453 = state[((idx * 8u) + 0u)];
                let _e2462 = other_idx;
                let _e2469 = state[((_e2462 * 8u) + 0u)];
                let _e2476 = state[((idx * 8u) + 0u)];
                let _e2490 = other_center.x;
                let _e2492 = other_center.y;
                let _e2499 = other_idx;
                let _e2506 = state[((_e2499 * 8u) + 0u)];
                let _e2519 = state[((idx * 8u) + 0u)];
                let _e2520 = other_idx;
                let _e2527 = state[((_e2520 * 8u) + 0u)];
                let _e2529 = other_idx;
                let _e2536 = state[((_e2529 * 8u) + 0u)];
                let _e2545 = state[((idx * 8u) + 0u)];
                let _e2549 = other_idx;
                let _e2556 = state[((_e2549 * 8u) + 0u)];
                let _e2563 = state[((idx * 8u) + 0u)];
                let _e2572 = other_idx;
                let _e2579 = state[((_e2572 * 8u) + 0u)];
                let _e2586 = state[((idx * 8u) + 0u)];
                let _e2600 = other_center.x;
                let _e2602 = other_center.y;
                let _e2609 = other_idx;
                let _e2616 = state[((_e2609 * 8u) + 0u)];
                let _e2628 = state[((idx * 8u) + 0u)];
                let _e2629 = other_idx;
                let _e2636 = state[((_e2629 * 8u) + 0u)];
                let _e2638 = other_idx;
                let _e2645 = state[((_e2638 * 8u) + 0u)];
                let _e2654 = state[((idx * 8u) + 0u)];
                let _e2658 = other_idx;
                let _e2665 = state[((_e2658 * 8u) + 0u)];
                let _e2672 = state[((idx * 8u) + 0u)];
                let _e2681 = other_idx;
                let _e2688 = state[((_e2681 * 8u) + 0u)];
                let _e2695 = state[((idx * 8u) + 0u)];
                let _e2709 = other_center.x;
                let _e2711 = other_center.y;
                let _e2718 = other_idx;
                let _e2725 = state[((_e2718 * 8u) + 0u)];
                let _e2739 = state[((idx * 8u) + 0u)];
                let _e2746 = state[((idx * 8u) + 0u)];
                let _e2749 = other_idx;
                let _e2756 = state[((_e2749 * 8u) + 0u)];
                let _e2760 = other_idx;
                let _e2767 = state[((_e2760 * 8u) + 0u)];
                let _e2774 = state[((idx * 8u) + 0u)];
                let _e2783 = other_idx;
                let _e2790 = state[((_e2783 * 8u) + 0u)];
                let _e2797 = state[((idx * 8u) + 0u)];
                let _e2808 = other_center.x;
                let _e2810 = other_center.y;
                let _e2826 = state[((idx * 8u) + 0u)];
                let _e2828 = other_idx;
                let _e2835 = state[((_e2828 * 8u) + 0u)];
                let _e2842 = state[((idx * 8u) + 0u)];
                let _e2846 = other_idx;
                let _e2853 = state[((_e2846 * 8u) + 0u)];
                let _e2860 = state[((idx * 8u) + 0u)];
                let _e2869 = state[((idx * 8u) + 0u)];
                let _e2872 = other_idx;
                let _e2879 = state[((_e2872 * 8u) + 0u)];
                let _e2883 = other_idx;
                let _e2890 = state[((_e2883 * 8u) + 0u)];
                let _e2897 = state[((idx * 8u) + 0u)];
                let _e2906 = other_idx;
                let _e2913 = state[((_e2906 * 8u) + 0u)];
                let _e2920 = state[((idx * 8u) + 0u)];
                let _e2931 = other_center.x;
                let _e2933 = other_center.y;
                let _e2949 = state[((idx * 8u) + 0u)];
                let _e2956 = other_idx;
                let _e2963 = state[((_e2956 * 8u) + 0u)];
                let _e2970 = state[((idx * 8u) + 0u)];
                let _e2978 = state[((idx * 8u) + 0u)];
                let _e2981 = other_idx;
                let _e2988 = state[((_e2981 * 8u) + 0u)];
                let _e2992 = other_idx;
                let _e2999 = state[((_e2992 * 8u) + 0u)];
                let _e3006 = state[((idx * 8u) + 0u)];
                let _e3015 = other_idx;
                let _e3022 = state[((_e3015 * 8u) + 0u)];
                let _e3029 = state[((idx * 8u) + 0u)];
                let _e3040 = other_center.x;
                let _e3042 = other_center.y;
                let _e3058 = state[((idx * 8u) + 0u)];
                let _e3064 = other_idx;
                let _e3071 = state[((_e3064 * 8u) + 0u)];
                let _e3078 = state[((idx * 8u) + 0u)];
                let _e3086 = state[((idx * 8u) + 0u)];
                let _e3089 = other_idx;
                let _e3096 = state[((_e3089 * 8u) + 0u)];
                let _e3100 = other_idx;
                let _e3107 = state[((_e3100 * 8u) + 0u)];
                let _e3114 = state[((idx * 8u) + 0u)];
                let _e3123 = other_idx;
                let _e3130 = state[((_e3123 * 8u) + 0u)];
                let _e3137 = state[((idx * 8u) + 0u)];
                let _e3148 = other_center.x;
                let _e3150 = other_center.y;
                let _e3166 = state[((idx * 8u) + 0u)];
                let _e3174 = phi_0_;
                let _e3180 = constants.scheme;
                let _e3190 = state[((idx * 8u) + 0u)];
                let _e3191 = other_idx;
                let _e3198 = state[((_e3191 * 8u) + 0u)];
                let _e3199 = phi_0_;
                let _e3205 = rhs_0_;
                rhs_0_ = (_e3205 - (_e792 * (select(select(select(select(select(select(select(_e799, _e807, (_e808 < 0f)), select((_e819 + dot(vec2<f32>((((_e827 - _e834) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e850 - _e857) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e871, _e873)))), (_e884 + dot(vec2<f32>((((_e892 - _e899) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e915 - _e922) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e941 > 0f)), (_e947 == 1u)), select(((((_e958 + (_e966 * 0.625f)) + (_e976 * 0.375f)) + (dot(vec2<f32>((((_e987 - _e994) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1010 - _e1017) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1031, _e1033))) * 0.125f)) - _e1047), ((((_e1055 + (_e1062 * 0.625f)) + (_e1073 * 0.375f)) + (dot(vec2<f32>((((_e1084 - _e1091) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1107 - _e1114) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e1125, _e1127) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1143), (_e1145 > 0f)), (_e1151 == 2u)), select((_e1162 + min(max(dot(vec2<f32>((((_e1170 - _e1177) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1193 - _e1200) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1214, _e1216))), min((_e1226 - _e1234), 0f)), max((_e1245 - _e1253), 0f))), (_e1265 + min(max(dot(vec2<f32>((((_e1273 - _e1280) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1296 - _e1303) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1328 - _e1335), 0f)), max((_e1347 - _e1354), 0f))), (_e1360 > 0f)), (_e1366 == 3u)), select((_e1377 + ((((dot(vec2<f32>((((_e1385 - _e1392) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1408 - _e1415) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1429, _e1431))) * abs((_e1441 - _e1449))) / max(abs((_e1459 - _e1467)), (abs(dot(vec2<f32>((((_e1477 - _e1484) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1500 - _e1507) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1521, _e1523)))) + 0.00000001f))) * max(((_e1538 - _e1546) * dot(vec2<f32>((((_e1555 - _e1562) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1578 - _e1585) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1599, _e1601)))), 0f)) / max(abs(((_e1615 - _e1623) * dot(vec2<f32>((((_e1632 - _e1639) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1655 - _e1662) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1676, _e1678))))), 0.00000001f))), (_e1694 + ((((dot(vec2<f32>((((_e1702 - _e1709) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1725 - _e1732) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1757 - _e1764))) / max(abs((_e1775 - _e1782)), (abs(dot(vec2<f32>((((_e1792 - _e1799) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1815 - _e1822) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1852 - _e1859) * dot(vec2<f32>((((_e1868 - _e1875) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1891 - _e1898) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1927 - _e1934) * dot(vec2<f32>((((_e1943 - _e1950) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1966 - _e1973) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1997 > 0f)), (_e2003 == 4u)), select((_e2014 + min(max(((((_e2022 * 0.625f) + (_e2031 * 0.375f)) + (dot(vec2<f32>((((_e2042 - _e2049) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2065 - _e2072) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2086, _e2088))) * 0.125f)) - _e2102), min((_e2110 - _e2118), 0f)), max((_e2129 - _e2137), 0f))), (_e2149 + min(max(((((_e2156 * 0.625f) + (_e2166 * 0.375f)) + (dot(vec2<f32>((((_e2177 - _e2184) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2200 - _e2207) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2218, _e2220) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2236), min((_e2245 - _e2252), 0f)), max((_e2264 - _e2271), 0f))), (_e2277 > 0f)), (_e2283 == 5u)), select((_e2294 + ((((((((_e2302 * 0.625f) + (_e2311 * 0.375f)) + (dot(vec2<f32>((((_e2322 - _e2329) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2345 - _e2352) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2366, _e2368))) * 0.125f)) - _e2382) * abs((_e2390 - _e2398))) / max(abs((_e2408 - _e2416)), (abs(((((_e2426 * 0.625f) + (_e2435 * 0.375f)) + (dot(vec2<f32>((((_e2446 - _e2453) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2469 - _e2476) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2490, _e2492))) * 0.125f)) - _e2506)) + 0.00000001f))) * max(((_e2519 - _e2527) * ((((_e2536 * 0.625f) + (_e2545 * 0.375f)) + (dot(vec2<f32>((((_e2556 - _e2563) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2579 - _e2586) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2600, _e2602))) * 0.125f)) - _e2616)), 0f)) / max(abs(((_e2628 - _e2636) * ((((_e2645 * 0.625f) + (_e2654 * 0.375f)) + (dot(vec2<f32>((((_e2665 - _e2672) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2688 - _e2695) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2709, _e2711))) * 0.125f)) - _e2725))), 0.00000001f))), (_e2739 + ((((((((_e2746 * 0.625f) + (_e2756 * 0.375f)) + (dot(vec2<f32>((((_e2767 - _e2774) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2790 - _e2797) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2808, _e2810) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2826) * abs((_e2835 - _e2842))) / max(abs((_e2853 - _e2860)), (abs(((((_e2869 * 0.625f) + (_e2879 * 0.375f)) + (dot(vec2<f32>((((_e2890 - _e2897) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2913 - _e2920) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2931, _e2933) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2949)) + 0.00000001f))) * max(((_e2963 - _e2970) * ((((_e2978 * 0.625f) + (_e2988 * 0.375f)) + (dot(vec2<f32>((((_e2999 - _e3006) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3022 - _e3029) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3040, _e3042) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3058)), 0f)) / max(abs(((_e3071 - _e3078) * ((((_e3086 * 0.625f) + (_e3096 * 0.375f)) + (dot(vec2<f32>((((_e3107 - _e3114) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3130 - _e3137) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3148, _e3150) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3166))), 0.00000001f))), (_e3174 > 0f)), (_e3180 == 6u)) - select(_e3190, _e3198, (_e3199 < 0f)))));
            } else {
                let _e3213 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3213 == 1u) {
                    let _e3216 = phi_0_;
                    let _e3219 = diag_0_;
                    diag_0_ = (_e3219 + max(_e3216, 0f));
                    let _e3221 = phi_0_;
                    let _e3230 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3232 = rhs_0_;
                    rhs_0_ = (_e3232 - (min(_e3221, 0f) * _e3230));
                } else {
                    let _e3234 = phi_0_;
                    let _e3235 = diag_0_;
                    diag_0_ = (_e3235 + _e3234);
                }
            }
            let _e3243 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3243;
            if (owner != idx) {
                let _e3246 = phi_1_;
                let _e3249 = phi_1_;
                phi_1_ = (_e3249 - (_e3246 * 2f));
            }
            let _e3251 = is_boundary;
            if !(_e3251) {
                let _e3253 = phi_1_;
                let _e3256 = diag_1_;
                diag_1_ = (_e3256 + max(_e3253, 0f));
                let _e3265 = phi_1_;
                let _e3268 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3268 + min(_e3265, 0f));
                let _e3270 = phi_1_;
                let _e3277 = state[((idx * 8u) + 1u)];
                let _e3278 = other_idx;
                let _e3285 = state[((_e3278 * 8u) + 1u)];
                let _e3286 = phi_1_;
                let _e3290 = other_idx;
                let _e3297 = state[((_e3290 * 8u) + 1u)];
                let _e3298 = other_idx;
                let _e3305 = state[((_e3298 * 8u) + 1u)];
                let _e3312 = state[((idx * 8u) + 1u)];
                let _e3321 = other_idx;
                let _e3328 = state[((_e3321 * 8u) + 1u)];
                let _e3335 = state[((idx * 8u) + 1u)];
                let _e3349 = other_center.x;
                let _e3351 = other_center.y;
                let _e3362 = state[((idx * 8u) + 1u)];
                let _e3363 = other_idx;
                let _e3370 = state[((_e3363 * 8u) + 1u)];
                let _e3377 = state[((idx * 8u) + 1u)];
                let _e3386 = other_idx;
                let _e3393 = state[((_e3386 * 8u) + 1u)];
                let _e3400 = state[((idx * 8u) + 1u)];
                let _e3419 = phi_1_;
                let _e3425 = constants.scheme;
                let _e3429 = other_idx;
                let _e3436 = state[((_e3429 * 8u) + 1u)];
                let _e3437 = other_idx;
                let _e3444 = state[((_e3437 * 8u) + 1u)];
                let _e3454 = state[((idx * 8u) + 1u)];
                let _e3458 = other_idx;
                let _e3465 = state[((_e3458 * 8u) + 1u)];
                let _e3472 = state[((idx * 8u) + 1u)];
                let _e3481 = other_idx;
                let _e3488 = state[((_e3481 * 8u) + 1u)];
                let _e3495 = state[((idx * 8u) + 1u)];
                let _e3509 = other_center.x;
                let _e3511 = other_center.y;
                let _e3518 = other_idx;
                let _e3525 = state[((_e3518 * 8u) + 1u)];
                let _e3533 = state[((idx * 8u) + 1u)];
                let _e3540 = state[((idx * 8u) + 1u)];
                let _e3544 = other_idx;
                let _e3551 = state[((_e3544 * 8u) + 1u)];
                let _e3555 = other_idx;
                let _e3562 = state[((_e3555 * 8u) + 1u)];
                let _e3569 = state[((idx * 8u) + 1u)];
                let _e3578 = other_idx;
                let _e3585 = state[((_e3578 * 8u) + 1u)];
                let _e3592 = state[((idx * 8u) + 1u)];
                let _e3603 = other_center.x;
                let _e3605 = other_center.y;
                let _e3621 = state[((idx * 8u) + 1u)];
                let _e3623 = phi_1_;
                let _e3629 = constants.scheme;
                let _e3633 = other_idx;
                let _e3640 = state[((_e3633 * 8u) + 1u)];
                let _e3641 = other_idx;
                let _e3648 = state[((_e3641 * 8u) + 1u)];
                let _e3655 = state[((idx * 8u) + 1u)];
                let _e3664 = other_idx;
                let _e3671 = state[((_e3664 * 8u) + 1u)];
                let _e3678 = state[((idx * 8u) + 1u)];
                let _e3692 = other_center.x;
                let _e3694 = other_center.y;
                let _e3704 = state[((idx * 8u) + 1u)];
                let _e3705 = other_idx;
                let _e3712 = state[((_e3705 * 8u) + 1u)];
                let _e3723 = state[((idx * 8u) + 1u)];
                let _e3724 = other_idx;
                let _e3731 = state[((_e3724 * 8u) + 1u)];
                let _e3743 = state[((idx * 8u) + 1u)];
                let _e3744 = other_idx;
                let _e3751 = state[((_e3744 * 8u) + 1u)];
                let _e3758 = state[((idx * 8u) + 1u)];
                let _e3767 = other_idx;
                let _e3774 = state[((_e3767 * 8u) + 1u)];
                let _e3781 = state[((idx * 8u) + 1u)];
                let _e3799 = other_idx;
                let _e3806 = state[((_e3799 * 8u) + 1u)];
                let _e3813 = state[((idx * 8u) + 1u)];
                let _e3818 = other_idx;
                let _e3825 = state[((_e3818 * 8u) + 1u)];
                let _e3832 = state[((idx * 8u) + 1u)];
                let _e3838 = phi_1_;
                let _e3844 = constants.scheme;
                let _e3848 = other_idx;
                let _e3855 = state[((_e3848 * 8u) + 1u)];
                let _e3856 = other_idx;
                let _e3863 = state[((_e3856 * 8u) + 1u)];
                let _e3870 = state[((idx * 8u) + 1u)];
                let _e3879 = other_idx;
                let _e3886 = state[((_e3879 * 8u) + 1u)];
                let _e3893 = state[((idx * 8u) + 1u)];
                let _e3907 = other_center.x;
                let _e3909 = other_center.y;
                let _e3919 = state[((idx * 8u) + 1u)];
                let _e3920 = other_idx;
                let _e3927 = state[((_e3920 * 8u) + 1u)];
                let _e3937 = state[((idx * 8u) + 1u)];
                let _e3938 = other_idx;
                let _e3945 = state[((_e3938 * 8u) + 1u)];
                let _e3948 = other_idx;
                let _e3955 = state[((_e3948 * 8u) + 1u)];
                let _e3962 = state[((idx * 8u) + 1u)];
                let _e3971 = other_idx;
                let _e3978 = state[((_e3971 * 8u) + 1u)];
                let _e3985 = state[((idx * 8u) + 1u)];
                let _e3999 = other_center.x;
                let _e4001 = other_center.y;
                let _e4016 = state[((idx * 8u) + 1u)];
                let _e4017 = other_idx;
                let _e4024 = state[((_e4017 * 8u) + 1u)];
                let _e4026 = other_idx;
                let _e4033 = state[((_e4026 * 8u) + 1u)];
                let _e4040 = state[((idx * 8u) + 1u)];
                let _e4049 = other_idx;
                let _e4056 = state[((_e4049 * 8u) + 1u)];
                let _e4063 = state[((idx * 8u) + 1u)];
                let _e4077 = other_center.x;
                let _e4079 = other_center.y;
                let _e4093 = state[((idx * 8u) + 1u)];
                let _e4094 = other_idx;
                let _e4101 = state[((_e4094 * 8u) + 1u)];
                let _e4103 = other_idx;
                let _e4110 = state[((_e4103 * 8u) + 1u)];
                let _e4117 = state[((idx * 8u) + 1u)];
                let _e4126 = other_idx;
                let _e4133 = state[((_e4126 * 8u) + 1u)];
                let _e4140 = state[((idx * 8u) + 1u)];
                let _e4154 = other_center.x;
                let _e4156 = other_center.y;
                let _e4172 = state[((idx * 8u) + 1u)];
                let _e4173 = other_idx;
                let _e4180 = state[((_e4173 * 8u) + 1u)];
                let _e4187 = state[((idx * 8u) + 1u)];
                let _e4196 = other_idx;
                let _e4203 = state[((_e4196 * 8u) + 1u)];
                let _e4210 = state[((idx * 8u) + 1u)];
                let _e4228 = other_idx;
                let _e4235 = state[((_e4228 * 8u) + 1u)];
                let _e4242 = state[((idx * 8u) + 1u)];
                let _e4246 = other_idx;
                let _e4253 = state[((_e4246 * 8u) + 1u)];
                let _e4260 = state[((idx * 8u) + 1u)];
                let _e4263 = other_idx;
                let _e4270 = state[((_e4263 * 8u) + 1u)];
                let _e4277 = state[((idx * 8u) + 1u)];
                let _e4286 = other_idx;
                let _e4293 = state[((_e4286 * 8u) + 1u)];
                let _e4300 = state[((idx * 8u) + 1u)];
                let _e4323 = other_idx;
                let _e4330 = state[((_e4323 * 8u) + 1u)];
                let _e4337 = state[((idx * 8u) + 1u)];
                let _e4339 = other_idx;
                let _e4346 = state[((_e4339 * 8u) + 1u)];
                let _e4353 = state[((idx * 8u) + 1u)];
                let _e4362 = other_idx;
                let _e4369 = state[((_e4362 * 8u) + 1u)];
                let _e4376 = state[((idx * 8u) + 1u)];
                let _e4398 = other_idx;
                let _e4405 = state[((_e4398 * 8u) + 1u)];
                let _e4412 = state[((idx * 8u) + 1u)];
                let _e4414 = other_idx;
                let _e4421 = state[((_e4414 * 8u) + 1u)];
                let _e4428 = state[((idx * 8u) + 1u)];
                let _e4437 = other_idx;
                let _e4444 = state[((_e4437 * 8u) + 1u)];
                let _e4451 = state[((idx * 8u) + 1u)];
                let _e4475 = phi_1_;
                let _e4481 = constants.scheme;
                let _e4485 = other_idx;
                let _e4492 = state[((_e4485 * 8u) + 1u)];
                let _e4493 = other_idx;
                let _e4500 = state[((_e4493 * 8u) + 1u)];
                let _e4509 = state[((idx * 8u) + 1u)];
                let _e4513 = other_idx;
                let _e4520 = state[((_e4513 * 8u) + 1u)];
                let _e4527 = state[((idx * 8u) + 1u)];
                let _e4536 = other_idx;
                let _e4543 = state[((_e4536 * 8u) + 1u)];
                let _e4550 = state[((idx * 8u) + 1u)];
                let _e4564 = other_center.x;
                let _e4566 = other_center.y;
                let _e4573 = other_idx;
                let _e4580 = state[((_e4573 * 8u) + 1u)];
                let _e4588 = state[((idx * 8u) + 1u)];
                let _e4589 = other_idx;
                let _e4596 = state[((_e4589 * 8u) + 1u)];
                let _e4607 = state[((idx * 8u) + 1u)];
                let _e4608 = other_idx;
                let _e4615 = state[((_e4608 * 8u) + 1u)];
                let _e4627 = state[((idx * 8u) + 1u)];
                let _e4634 = state[((idx * 8u) + 1u)];
                let _e4637 = other_idx;
                let _e4644 = state[((_e4637 * 8u) + 1u)];
                let _e4648 = other_idx;
                let _e4655 = state[((_e4648 * 8u) + 1u)];
                let _e4662 = state[((idx * 8u) + 1u)];
                let _e4671 = other_idx;
                let _e4678 = state[((_e4671 * 8u) + 1u)];
                let _e4685 = state[((idx * 8u) + 1u)];
                let _e4696 = other_center.x;
                let _e4698 = other_center.y;
                let _e4714 = state[((idx * 8u) + 1u)];
                let _e4716 = other_idx;
                let _e4723 = state[((_e4716 * 8u) + 1u)];
                let _e4730 = state[((idx * 8u) + 1u)];
                let _e4735 = other_idx;
                let _e4742 = state[((_e4735 * 8u) + 1u)];
                let _e4749 = state[((idx * 8u) + 1u)];
                let _e4755 = phi_1_;
                let _e4761 = constants.scheme;
                let _e4765 = other_idx;
                let _e4772 = state[((_e4765 * 8u) + 1u)];
                let _e4773 = other_idx;
                let _e4780 = state[((_e4773 * 8u) + 1u)];
                let _e4789 = state[((idx * 8u) + 1u)];
                let _e4793 = other_idx;
                let _e4800 = state[((_e4793 * 8u) + 1u)];
                let _e4807 = state[((idx * 8u) + 1u)];
                let _e4816 = other_idx;
                let _e4823 = state[((_e4816 * 8u) + 1u)];
                let _e4830 = state[((idx * 8u) + 1u)];
                let _e4844 = other_center.x;
                let _e4846 = other_center.y;
                let _e4853 = other_idx;
                let _e4860 = state[((_e4853 * 8u) + 1u)];
                let _e4868 = state[((idx * 8u) + 1u)];
                let _e4869 = other_idx;
                let _e4876 = state[((_e4869 * 8u) + 1u)];
                let _e4886 = state[((idx * 8u) + 1u)];
                let _e4887 = other_idx;
                let _e4894 = state[((_e4887 * 8u) + 1u)];
                let _e4897 = other_idx;
                let _e4904 = state[((_e4897 * 8u) + 1u)];
                let _e4913 = state[((idx * 8u) + 1u)];
                let _e4917 = other_idx;
                let _e4924 = state[((_e4917 * 8u) + 1u)];
                let _e4931 = state[((idx * 8u) + 1u)];
                let _e4940 = other_idx;
                let _e4947 = state[((_e4940 * 8u) + 1u)];
                let _e4954 = state[((idx * 8u) + 1u)];
                let _e4968 = other_center.x;
                let _e4970 = other_center.y;
                let _e4977 = other_idx;
                let _e4984 = state[((_e4977 * 8u) + 1u)];
                let _e4997 = state[((idx * 8u) + 1u)];
                let _e4998 = other_idx;
                let _e5005 = state[((_e4998 * 8u) + 1u)];
                let _e5007 = other_idx;
                let _e5014 = state[((_e5007 * 8u) + 1u)];
                let _e5023 = state[((idx * 8u) + 1u)];
                let _e5027 = other_idx;
                let _e5034 = state[((_e5027 * 8u) + 1u)];
                let _e5041 = state[((idx * 8u) + 1u)];
                let _e5050 = other_idx;
                let _e5057 = state[((_e5050 * 8u) + 1u)];
                let _e5064 = state[((idx * 8u) + 1u)];
                let _e5078 = other_center.x;
                let _e5080 = other_center.y;
                let _e5087 = other_idx;
                let _e5094 = state[((_e5087 * 8u) + 1u)];
                let _e5106 = state[((idx * 8u) + 1u)];
                let _e5107 = other_idx;
                let _e5114 = state[((_e5107 * 8u) + 1u)];
                let _e5116 = other_idx;
                let _e5123 = state[((_e5116 * 8u) + 1u)];
                let _e5132 = state[((idx * 8u) + 1u)];
                let _e5136 = other_idx;
                let _e5143 = state[((_e5136 * 8u) + 1u)];
                let _e5150 = state[((idx * 8u) + 1u)];
                let _e5159 = other_idx;
                let _e5166 = state[((_e5159 * 8u) + 1u)];
                let _e5173 = state[((idx * 8u) + 1u)];
                let _e5187 = other_center.x;
                let _e5189 = other_center.y;
                let _e5196 = other_idx;
                let _e5203 = state[((_e5196 * 8u) + 1u)];
                let _e5217 = state[((idx * 8u) + 1u)];
                let _e5224 = state[((idx * 8u) + 1u)];
                let _e5227 = other_idx;
                let _e5234 = state[((_e5227 * 8u) + 1u)];
                let _e5238 = other_idx;
                let _e5245 = state[((_e5238 * 8u) + 1u)];
                let _e5252 = state[((idx * 8u) + 1u)];
                let _e5261 = other_idx;
                let _e5268 = state[((_e5261 * 8u) + 1u)];
                let _e5275 = state[((idx * 8u) + 1u)];
                let _e5286 = other_center.x;
                let _e5288 = other_center.y;
                let _e5304 = state[((idx * 8u) + 1u)];
                let _e5306 = other_idx;
                let _e5313 = state[((_e5306 * 8u) + 1u)];
                let _e5320 = state[((idx * 8u) + 1u)];
                let _e5324 = other_idx;
                let _e5331 = state[((_e5324 * 8u) + 1u)];
                let _e5338 = state[((idx * 8u) + 1u)];
                let _e5347 = state[((idx * 8u) + 1u)];
                let _e5350 = other_idx;
                let _e5357 = state[((_e5350 * 8u) + 1u)];
                let _e5361 = other_idx;
                let _e5368 = state[((_e5361 * 8u) + 1u)];
                let _e5375 = state[((idx * 8u) + 1u)];
                let _e5384 = other_idx;
                let _e5391 = state[((_e5384 * 8u) + 1u)];
                let _e5398 = state[((idx * 8u) + 1u)];
                let _e5409 = other_center.x;
                let _e5411 = other_center.y;
                let _e5427 = state[((idx * 8u) + 1u)];
                let _e5434 = other_idx;
                let _e5441 = state[((_e5434 * 8u) + 1u)];
                let _e5448 = state[((idx * 8u) + 1u)];
                let _e5456 = state[((idx * 8u) + 1u)];
                let _e5459 = other_idx;
                let _e5466 = state[((_e5459 * 8u) + 1u)];
                let _e5470 = other_idx;
                let _e5477 = state[((_e5470 * 8u) + 1u)];
                let _e5484 = state[((idx * 8u) + 1u)];
                let _e5493 = other_idx;
                let _e5500 = state[((_e5493 * 8u) + 1u)];
                let _e5507 = state[((idx * 8u) + 1u)];
                let _e5518 = other_center.x;
                let _e5520 = other_center.y;
                let _e5536 = state[((idx * 8u) + 1u)];
                let _e5542 = other_idx;
                let _e5549 = state[((_e5542 * 8u) + 1u)];
                let _e5556 = state[((idx * 8u) + 1u)];
                let _e5564 = state[((idx * 8u) + 1u)];
                let _e5567 = other_idx;
                let _e5574 = state[((_e5567 * 8u) + 1u)];
                let _e5578 = other_idx;
                let _e5585 = state[((_e5578 * 8u) + 1u)];
                let _e5592 = state[((idx * 8u) + 1u)];
                let _e5601 = other_idx;
                let _e5608 = state[((_e5601 * 8u) + 1u)];
                let _e5615 = state[((idx * 8u) + 1u)];
                let _e5626 = other_center.x;
                let _e5628 = other_center.y;
                let _e5644 = state[((idx * 8u) + 1u)];
                let _e5652 = phi_1_;
                let _e5658 = constants.scheme;
                let _e5668 = state[((idx * 8u) + 1u)];
                let _e5669 = other_idx;
                let _e5676 = state[((_e5669 * 8u) + 1u)];
                let _e5677 = phi_1_;
                let _e5683 = rhs_1_;
                rhs_1_ = (_e5683 - (_e3270 * (select(select(select(select(select(select(select(_e3277, _e3285, (_e3286 < 0f)), select((_e3297 + dot(vec2<f32>((((_e3305 - _e3312) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3328 - _e3335) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3349, _e3351)))), (_e3362 + dot(vec2<f32>((((_e3370 - _e3377) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3393 - _e3400) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3419 > 0f)), (_e3425 == 1u)), select(((((_e3436 + (_e3444 * 0.625f)) + (_e3454 * 0.375f)) + (dot(vec2<f32>((((_e3465 - _e3472) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3488 - _e3495) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3509, _e3511))) * 0.125f)) - _e3525), ((((_e3533 + (_e3540 * 0.625f)) + (_e3551 * 0.375f)) + (dot(vec2<f32>((((_e3562 - _e3569) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3585 - _e3592) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3603, _e3605) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3621), (_e3623 > 0f)), (_e3629 == 2u)), select((_e3640 + min(max(dot(vec2<f32>((((_e3648 - _e3655) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3671 - _e3678) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3692, _e3694))), min((_e3704 - _e3712), 0f)), max((_e3723 - _e3731), 0f))), (_e3743 + min(max(dot(vec2<f32>((((_e3751 - _e3758) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3774 - _e3781) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e3806 - _e3813), 0f)), max((_e3825 - _e3832), 0f))), (_e3838 > 0f)), (_e3844 == 3u)), select((_e3855 + ((((dot(vec2<f32>((((_e3863 - _e3870) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3886 - _e3893) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3907, _e3909))) * abs((_e3919 - _e3927))) / max(abs((_e3937 - _e3945)), (abs(dot(vec2<f32>((((_e3955 - _e3962) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3978 - _e3985) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3999, _e4001)))) + 0.00000001f))) * max(((_e4016 - _e4024) * dot(vec2<f32>((((_e4033 - _e4040) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4056 - _e4063) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4077, _e4079)))), 0f)) / max(abs(((_e4093 - _e4101) * dot(vec2<f32>((((_e4110 - _e4117) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4133 - _e4140) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4154, _e4156))))), 0.00000001f))), (_e4172 + ((((dot(vec2<f32>((((_e4180 - _e4187) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4203 - _e4210) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e4235 - _e4242))) / max(abs((_e4253 - _e4260)), (abs(dot(vec2<f32>((((_e4270 - _e4277) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4293 - _e4300) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e4330 - _e4337) * dot(vec2<f32>((((_e4346 - _e4353) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4369 - _e4376) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e4405 - _e4412) * dot(vec2<f32>((((_e4421 - _e4428) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4444 - _e4451) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e4475 > 0f)), (_e4481 == 4u)), select((_e4492 + min(max(((((_e4500 * 0.625f) + (_e4509 * 0.375f)) + (dot(vec2<f32>((((_e4520 - _e4527) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4543 - _e4550) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4564, _e4566))) * 0.125f)) - _e4580), min((_e4588 - _e4596), 0f)), max((_e4607 - _e4615), 0f))), (_e4627 + min(max(((((_e4634 * 0.625f) + (_e4644 * 0.375f)) + (dot(vec2<f32>((((_e4655 - _e4662) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4678 - _e4685) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e4696, _e4698) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4714), min((_e4723 - _e4730), 0f)), max((_e4742 - _e4749), 0f))), (_e4755 > 0f)), (_e4761 == 5u)), select((_e4772 + ((((((((_e4780 * 0.625f) + (_e4789 * 0.375f)) + (dot(vec2<f32>((((_e4800 - _e4807) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4823 - _e4830) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4844, _e4846))) * 0.125f)) - _e4860) * abs((_e4868 - _e4876))) / max(abs((_e4886 - _e4894)), (abs(((((_e4904 * 0.625f) + (_e4913 * 0.375f)) + (dot(vec2<f32>((((_e4924 - _e4931) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4947 - _e4954) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4968, _e4970))) * 0.125f)) - _e4984)) + 0.00000001f))) * max(((_e4997 - _e5005) * ((((_e5014 * 0.625f) + (_e5023 * 0.375f)) + (dot(vec2<f32>((((_e5034 - _e5041) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5057 - _e5064) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5078, _e5080))) * 0.125f)) - _e5094)), 0f)) / max(abs(((_e5106 - _e5114) * ((((_e5123 * 0.625f) + (_e5132 * 0.375f)) + (dot(vec2<f32>((((_e5143 - _e5150) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5166 - _e5173) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5187, _e5189))) * 0.125f)) - _e5203))), 0.00000001f))), (_e5217 + ((((((((_e5224 * 0.625f) + (_e5234 * 0.375f)) + (dot(vec2<f32>((((_e5245 - _e5252) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5268 - _e5275) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5286, _e5288) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5304) * abs((_e5313 - _e5320))) / max(abs((_e5331 - _e5338)), (abs(((((_e5347 * 0.625f) + (_e5357 * 0.375f)) + (dot(vec2<f32>((((_e5368 - _e5375) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5391 - _e5398) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5409, _e5411) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5427)) + 0.00000001f))) * max(((_e5441 - _e5448) * ((((_e5456 * 0.625f) + (_e5466 * 0.375f)) + (dot(vec2<f32>((((_e5477 - _e5484) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5500 - _e5507) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5518, _e5520) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5536)), 0f)) / max(abs(((_e5549 - _e5556) * ((((_e5564 * 0.625f) + (_e5574 * 0.375f)) + (dot(vec2<f32>((((_e5585 - _e5592) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5608 - _e5615) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5626, _e5628) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5644))), 0.00000001f))), (_e5652 > 0f)), (_e5658 == 6u)) - select(_e5668, _e5676, (_e5677 < 0f)))));
            } else {
                let _e5691 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e5691 == 1u) {
                    let _e5694 = phi_1_;
                    let _e5697 = diag_1_;
                    diag_1_ = (_e5697 + max(_e5694, 0f));
                    let _e5699 = phi_1_;
                    let _e5708 = bc_value[((face_idx * 3u) + 1u)];
                    let _e5710 = rhs_1_;
                    rhs_1_ = (_e5710 - (min(_e5699, 0f) * _e5708));
                } else {
                    let _e5712 = phi_1_;
                    let _e5713 = diag_1_;
                    diag_1_ = (_e5713 + _e5712);
                }
            }
            let _e5718 = normal.x;
            let _e5726 = state[((idx * 8u) + 2u)];
            let _e5727 = other_idx;
            let _e5734 = state[((_e5727 * 8u) + 2u)];
            let _e5737 = rhs_0_;
            rhs_0_ = (_e5737 - (((0.5f * area) * _e5718) * (_e5726 + _e5734)));
            let _e5742 = normal.y;
            let _e5750 = state[((idx * 8u) + 2u)];
            let _e5751 = other_idx;
            let _e5758 = state[((_e5751 * 8u) + 2u)];
            let _e5761 = rhs_1_;
            rhs_1_ = (_e5761 - (((0.5f * area) * _e5742) * (_e5750 + _e5758)));
            let _e5765 = constants.density;
            let _e5772 = state[((idx * 8u) + 3u)];
            let _e5776 = constants.density;
            let _e5783 = state[((idx * 8u) + 3u)];
            let _e5787 = constants.density;
            let _e5788 = other_idx;
            let _e5795 = state[((_e5788 * 8u) + 3u)];
            let _e5800 = is_boundary;
            let _e5804 = dist;
            let diff_coeff_p = ((select((_e5765 * _e5772), (((_e5776 * _e5783) + (_e5787 * _e5795)) * 0.5f), !(_e5800)) * area) / _e5804);
            let _e5806 = is_boundary;
            if !(_e5806) {
                let _e5809 = diag_2_;
                diag_2_ = (_e5809 + diff_coeff_p);
                let _e5818 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e5818 - diff_coeff_p);
            } else {
                let _e5826 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e5826 == 1u) {
                    let _e5829 = diag_2_;
                    diag_2_ = (_e5829 + diff_coeff_p);
                    let _e5838 = bc_value[((face_idx * 3u) + 2u)];
                    let _e5840 = rhs_2_;
                    rhs_2_ = (_e5840 + (diff_coeff_p * _e5838));
                } else {
                    let _e5848 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e5848 == 2u) {
                        let _e5853 = constants.density;
                        let _e5860 = state[((idx * 8u) + 3u)];
                        let _e5864 = constants.density;
                        let _e5871 = state[((idx * 8u) + 3u)];
                        let _e5875 = constants.density;
                        let _e5876 = other_idx;
                        let _e5883 = state[((_e5876 * 8u) + 3u)];
                        let _e5888 = is_boundary;
                        let _e5898 = bc_value[((face_idx * 3u) + 2u)];
                        let _e5901 = rhs_2_;
                        rhs_2_ = (_e5901 + -(((select((_e5853 * _e5860), (((_e5864 * _e5871) + (_e5875 * _e5883)) * 0.5f), !(_e5888)) * area) * _e5898)));
                    }
                }
            }
            let _e5909 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e5909;
            if (owner != idx) {
                let _e5912 = phi_2_;
                let _e5915 = phi_2_;
                phi_2_ = (_e5915 - (_e5912 * 2f));
            }
            let _e5917 = phi_2_;
            let _e5918 = rhs_2_;
            rhs_2_ = (_e5918 - _e5917);
        }
        continuing {
            let _e5921 = k;
            k = (_e5921 + 1u);
        }
    }
    let _e5930 = diag_0_;
    let _e5931 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e5931 + _e5930);
    let _e5939 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e5939;
    let _e5947 = diag_1_;
    let _e5948 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e5948 + _e5947);
    let _e5956 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e5956;
    let _e5964 = diag_2_;
    let _e5965 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e5965 + _e5964);
    let _e5973 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e5973;
    return;
}
"#;
    }
    pub mod generic_coupled_update_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_compressible :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 22u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 22u) + 0u)];
    let _e32 = x[((idx * 8u) + 0u)];
    let _e39 = state[((idx * 22u) + 0u)];
    let _e46 = x[((idx * 8u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e52 = constants.dtau;
    let _e64 = state[((idx * 22u) + 0u)];
    let _e71 = state[((idx * 22u) + 0u)];
    let _e79 = state[((idx * 22u) + 0u)];
    let _e91 = x[((idx * 8u) + 0u)];
    let _e98 = x[((idx * 8u) + 0u)];
    let _e106 = x[((idx * 8u) + 0u)];
    state[((idx * 22u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, select(1f, _e49, (_e52 > 0f))), ((_e64 == _e71) && (abs(_e79) < 340000000000000000000000000000000000000f))), ((_e91 == _e98) && (abs(_e106) < 340000000000000000000000000000000000000f)));
    let _e124 = state[((idx * 22u) + 0u)];
    let _e131 = x[((idx * 8u) + 0u)];
    let _e138 = state[((idx * 22u) + 0u)];
    let _e145 = x[((idx * 8u) + 0u)];
    let _e148 = constants.alpha_u;
    let _e151 = constants.dtau;
    let _e163 = state[((idx * 22u) + 0u)];
    let _e170 = state[((idx * 22u) + 0u)];
    let _e178 = state[((idx * 22u) + 0u)];
    let _e190 = x[((idx * 8u) + 0u)];
    let _e197 = x[((idx * 8u) + 0u)];
    let _e205 = x[((idx * 8u) + 0u)];
    x[((idx * 8u) + 0u)] = select(_e124, select(_e131, mix(_e138, _e145, select(1f, _e148, (_e151 > 0f))), ((_e163 == _e170) && (abs(_e178) < 340000000000000000000000000000000000000f))), ((_e190 == _e197) && (abs(_e205) < 340000000000000000000000000000000000000f)));
    let _e223 = state[((idx * 22u) + 1u)];
    let _e230 = x[((idx * 8u) + 1u)];
    let _e237 = state[((idx * 22u) + 1u)];
    let _e244 = x[((idx * 8u) + 1u)];
    let _e247 = constants.alpha_u;
    let _e250 = constants.dtau;
    let _e262 = state[((idx * 22u) + 1u)];
    let _e269 = state[((idx * 22u) + 1u)];
    let _e277 = state[((idx * 22u) + 1u)];
    let _e289 = x[((idx * 8u) + 1u)];
    let _e296 = x[((idx * 8u) + 1u)];
    let _e304 = x[((idx * 8u) + 1u)];
    state[((idx * 22u) + 1u)] = select(_e223, select(_e230, mix(_e237, _e244, select(1f, _e247, (_e250 > 0f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f))), ((_e289 == _e296) && (abs(_e304) < 340000000000000000000000000000000000000f)));
    let _e322 = state[((idx * 22u) + 1u)];
    let _e329 = x[((idx * 8u) + 1u)];
    let _e336 = state[((idx * 22u) + 1u)];
    let _e343 = x[((idx * 8u) + 1u)];
    let _e346 = constants.alpha_u;
    let _e349 = constants.dtau;
    let _e361 = state[((idx * 22u) + 1u)];
    let _e368 = state[((idx * 22u) + 1u)];
    let _e376 = state[((idx * 22u) + 1u)];
    let _e388 = x[((idx * 8u) + 1u)];
    let _e395 = x[((idx * 8u) + 1u)];
    let _e403 = x[((idx * 8u) + 1u)];
    x[((idx * 8u) + 1u)] = select(_e322, select(_e329, mix(_e336, _e343, select(1f, _e346, (_e349 > 0f))), ((_e361 == _e368) && (abs(_e376) < 340000000000000000000000000000000000000f))), ((_e388 == _e395) && (abs(_e403) < 340000000000000000000000000000000000000f)));
    let _e421 = state[((idx * 22u) + 2u)];
    let _e428 = x[((idx * 8u) + 2u)];
    let _e435 = state[((idx * 22u) + 2u)];
    let _e442 = x[((idx * 8u) + 2u)];
    let _e445 = constants.alpha_u;
    let _e448 = constants.dtau;
    let _e460 = state[((idx * 22u) + 2u)];
    let _e467 = state[((idx * 22u) + 2u)];
    let _e475 = state[((idx * 22u) + 2u)];
    let _e487 = x[((idx * 8u) + 2u)];
    let _e494 = x[((idx * 8u) + 2u)];
    let _e502 = x[((idx * 8u) + 2u)];
    state[((idx * 22u) + 2u)] = select(_e421, select(_e428, mix(_e435, _e442, select(1f, _e445, (_e448 > 0f))), ((_e460 == _e467) && (abs(_e475) < 340000000000000000000000000000000000000f))), ((_e487 == _e494) && (abs(_e502) < 340000000000000000000000000000000000000f)));
    let _e520 = state[((idx * 22u) + 2u)];
    let _e527 = x[((idx * 8u) + 2u)];
    let _e534 = state[((idx * 22u) + 2u)];
    let _e541 = x[((idx * 8u) + 2u)];
    let _e544 = constants.alpha_u;
    let _e547 = constants.dtau;
    let _e559 = state[((idx * 22u) + 2u)];
    let _e566 = state[((idx * 22u) + 2u)];
    let _e574 = state[((idx * 22u) + 2u)];
    let _e586 = x[((idx * 8u) + 2u)];
    let _e593 = x[((idx * 8u) + 2u)];
    let _e601 = x[((idx * 8u) + 2u)];
    x[((idx * 8u) + 2u)] = select(_e520, select(_e527, mix(_e534, _e541, select(1f, _e544, (_e547 > 0f))), ((_e559 == _e566) && (abs(_e574) < 340000000000000000000000000000000000000f))), ((_e586 == _e593) && (abs(_e601) < 340000000000000000000000000000000000000f)));
    let _e619 = state[((idx * 22u) + 7u)];
    let _e626 = x[((idx * 8u) + 3u)];
    let _e633 = state[((idx * 22u) + 7u)];
    let _e640 = x[((idx * 8u) + 3u)];
    let _e643 = constants.alpha_u;
    let _e646 = constants.dtau;
    let _e658 = state[((idx * 22u) + 7u)];
    let _e665 = state[((idx * 22u) + 7u)];
    let _e673 = state[((idx * 22u) + 7u)];
    let _e685 = x[((idx * 8u) + 3u)];
    let _e692 = x[((idx * 8u) + 3u)];
    let _e700 = x[((idx * 8u) + 3u)];
    state[((idx * 22u) + 7u)] = select(_e619, select(_e626, mix(_e633, _e640, select(1f, _e643, (_e646 > 0f))), ((_e658 == _e665) && (abs(_e673) < 340000000000000000000000000000000000000f))), ((_e685 == _e692) && (abs(_e700) < 340000000000000000000000000000000000000f)));
    let _e718 = state[((idx * 22u) + 7u)];
    let _e725 = x[((idx * 8u) + 3u)];
    let _e732 = state[((idx * 22u) + 7u)];
    let _e739 = x[((idx * 8u) + 3u)];
    let _e742 = constants.alpha_u;
    let _e745 = constants.dtau;
    let _e757 = state[((idx * 22u) + 7u)];
    let _e764 = state[((idx * 22u) + 7u)];
    let _e772 = state[((idx * 22u) + 7u)];
    let _e784 = x[((idx * 8u) + 3u)];
    let _e791 = x[((idx * 8u) + 3u)];
    let _e799 = x[((idx * 8u) + 3u)];
    x[((idx * 8u) + 3u)] = select(_e718, select(_e725, mix(_e732, _e739, select(1f, _e742, (_e745 > 0f))), ((_e757 == _e764) && (abs(_e772) < 340000000000000000000000000000000000000f))), ((_e784 == _e791) && (abs(_e799) < 340000000000000000000000000000000000000f)));
    let _e817 = state[((idx * 22u) + 10u)];
    let _e824 = x[((idx * 8u) + 4u)];
    let _e831 = state[((idx * 22u) + 10u)];
    let _e838 = x[((idx * 8u) + 4u)];
    let _e841 = constants.alpha_u;
    let _e844 = constants.dtau;
    let _e856 = state[((idx * 22u) + 10u)];
    let _e863 = state[((idx * 22u) + 10u)];
    let _e871 = state[((idx * 22u) + 10u)];
    let _e883 = x[((idx * 8u) + 4u)];
    let _e890 = x[((idx * 8u) + 4u)];
    let _e898 = x[((idx * 8u) + 4u)];
    state[((idx * 22u) + 10u)] = select(_e817, select(_e824, mix(_e831, _e838, select(1f, _e841, (_e844 > 0f))), ((_e856 == _e863) && (abs(_e871) < 340000000000000000000000000000000000000f))), ((_e883 == _e890) && (abs(_e898) < 340000000000000000000000000000000000000f)));
    let _e916 = state[((idx * 22u) + 10u)];
    let _e923 = x[((idx * 8u) + 4u)];
    let _e930 = state[((idx * 22u) + 10u)];
    let _e937 = x[((idx * 8u) + 4u)];
    let _e940 = constants.alpha_u;
    let _e943 = constants.dtau;
    let _e955 = state[((idx * 22u) + 10u)];
    let _e962 = state[((idx * 22u) + 10u)];
    let _e970 = state[((idx * 22u) + 10u)];
    let _e982 = x[((idx * 8u) + 4u)];
    let _e989 = x[((idx * 8u) + 4u)];
    let _e997 = x[((idx * 8u) + 4u)];
    x[((idx * 8u) + 4u)] = select(_e916, select(_e923, mix(_e930, _e937, select(1f, _e940, (_e943 > 0f))), ((_e955 == _e962) && (abs(_e970) < 340000000000000000000000000000000000000f))), ((_e982 == _e989) && (abs(_e997) < 340000000000000000000000000000000000000f)));
    let _e1015 = state[((idx * 22u) + 11u)];
    let _e1022 = x[((idx * 8u) + 5u)];
    let _e1029 = state[((idx * 22u) + 11u)];
    let _e1036 = x[((idx * 8u) + 5u)];
    let _e1039 = constants.alpha_u;
    let _e1042 = constants.dtau;
    let _e1054 = state[((idx * 22u) + 11u)];
    let _e1061 = state[((idx * 22u) + 11u)];
    let _e1069 = state[((idx * 22u) + 11u)];
    let _e1081 = x[((idx * 8u) + 5u)];
    let _e1088 = x[((idx * 8u) + 5u)];
    let _e1096 = x[((idx * 8u) + 5u)];
    state[((idx * 22u) + 11u)] = select(_e1015, select(_e1022, mix(_e1029, _e1036, select(1f, _e1039, (_e1042 > 0f))), ((_e1054 == _e1061) && (abs(_e1069) < 340000000000000000000000000000000000000f))), ((_e1081 == _e1088) && (abs(_e1096) < 340000000000000000000000000000000000000f)));
    let _e1114 = state[((idx * 22u) + 11u)];
    let _e1121 = x[((idx * 8u) + 5u)];
    let _e1128 = state[((idx * 22u) + 11u)];
    let _e1135 = x[((idx * 8u) + 5u)];
    let _e1138 = constants.alpha_u;
    let _e1141 = constants.dtau;
    let _e1153 = state[((idx * 22u) + 11u)];
    let _e1160 = state[((idx * 22u) + 11u)];
    let _e1168 = state[((idx * 22u) + 11u)];
    let _e1180 = x[((idx * 8u) + 5u)];
    let _e1187 = x[((idx * 8u) + 5u)];
    let _e1195 = x[((idx * 8u) + 5u)];
    x[((idx * 8u) + 5u)] = select(_e1114, select(_e1121, mix(_e1128, _e1135, select(1f, _e1138, (_e1141 > 0f))), ((_e1153 == _e1160) && (abs(_e1168) < 340000000000000000000000000000000000000f))), ((_e1180 == _e1187) && (abs(_e1195) < 340000000000000000000000000000000000000f)));
    let _e1213 = state[((idx * 22u) + 8u)];
    let _e1220 = x[((idx * 8u) + 6u)];
    let _e1227 = state[((idx * 22u) + 8u)];
    let _e1234 = x[((idx * 8u) + 6u)];
    let _e1237 = constants.alpha_p;
    let _e1240 = constants.dtau;
    let _e1252 = state[((idx * 22u) + 8u)];
    let _e1259 = state[((idx * 22u) + 8u)];
    let _e1267 = state[((idx * 22u) + 8u)];
    let _e1279 = x[((idx * 8u) + 6u)];
    let _e1286 = x[((idx * 8u) + 6u)];
    let _e1294 = x[((idx * 8u) + 6u)];
    state[((idx * 22u) + 8u)] = select(_e1213, select(_e1220, mix(_e1227, _e1234, select(1f, _e1237, (_e1240 > 0f))), ((_e1252 == _e1259) && (abs(_e1267) < 340000000000000000000000000000000000000f))), ((_e1279 == _e1286) && (abs(_e1294) < 340000000000000000000000000000000000000f)));
    let _e1312 = state[((idx * 22u) + 8u)];
    let _e1319 = x[((idx * 8u) + 6u)];
    let _e1326 = state[((idx * 22u) + 8u)];
    let _e1333 = x[((idx * 8u) + 6u)];
    let _e1336 = constants.alpha_p;
    let _e1339 = constants.dtau;
    let _e1351 = state[((idx * 22u) + 8u)];
    let _e1358 = state[((idx * 22u) + 8u)];
    let _e1366 = state[((idx * 22u) + 8u)];
    let _e1378 = x[((idx * 8u) + 6u)];
    let _e1385 = x[((idx * 8u) + 6u)];
    let _e1393 = x[((idx * 8u) + 6u)];
    x[((idx * 8u) + 6u)] = select(_e1312, select(_e1319, mix(_e1326, _e1333, select(1f, _e1336, (_e1339 > 0f))), ((_e1351 == _e1358) && (abs(_e1366) < 340000000000000000000000000000000000000f))), ((_e1378 == _e1385) && (abs(_e1393) < 340000000000000000000000000000000000000f)));
    let _e1411 = state[((idx * 22u) + 9u)];
    let _e1418 = x[((idx * 8u) + 7u)];
    let _e1425 = state[((idx * 22u) + 9u)];
    let _e1432 = x[((idx * 8u) + 7u)];
    let _e1435 = constants.alpha_u;
    let _e1438 = constants.dtau;
    let _e1450 = state[((idx * 22u) + 9u)];
    let _e1457 = state[((idx * 22u) + 9u)];
    let _e1465 = state[((idx * 22u) + 9u)];
    let _e1477 = x[((idx * 8u) + 7u)];
    let _e1484 = x[((idx * 8u) + 7u)];
    let _e1492 = x[((idx * 8u) + 7u)];
    state[((idx * 22u) + 9u)] = select(_e1411, select(_e1418, mix(_e1425, _e1432, select(1f, _e1435, (_e1438 > 0f))), ((_e1450 == _e1457) && (abs(_e1465) < 340000000000000000000000000000000000000f))), ((_e1477 == _e1484) && (abs(_e1492) < 340000000000000000000000000000000000000f)));
    let _e1510 = state[((idx * 22u) + 9u)];
    let _e1517 = x[((idx * 8u) + 7u)];
    let _e1524 = state[((idx * 22u) + 9u)];
    let _e1531 = x[((idx * 8u) + 7u)];
    let _e1534 = constants.alpha_u;
    let _e1537 = constants.dtau;
    let _e1549 = state[((idx * 22u) + 9u)];
    let _e1556 = state[((idx * 22u) + 9u)];
    let _e1564 = state[((idx * 22u) + 9u)];
    let _e1576 = x[((idx * 8u) + 7u)];
    let _e1583 = x[((idx * 8u) + 7u)];
    let _e1591 = x[((idx * 8u) + 7u)];
    x[((idx * 8u) + 7u)] = select(_e1510, select(_e1517, mix(_e1524, _e1531, select(1f, _e1534, (_e1537 > 0f))), ((_e1549 == _e1556) && (abs(_e1564) < 340000000000000000000000000000000000000f))), ((_e1576 == _e1583) && (abs(_e1591) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 3u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 3u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e57 = state[((idx * 8u) + 0u)];
    let _e64 = state[((idx * 8u) + 0u)];
    let _e72 = state[((idx * 8u) + 0u)];
    let _e84 = x[((idx * 3u) + 0u)];
    let _e91 = x[((idx * 3u) + 0u)];
    let _e99 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, _e49), ((_e57 == _e64) && (abs(_e72) < 340000000000000000000000000000000000000f))), ((_e84 == _e91) && (abs(_e99) < 340000000000000000000000000000000000000f)));
    let _e117 = state[((idx * 8u) + 0u)];
    let _e124 = x[((idx * 3u) + 0u)];
    let _e131 = state[((idx * 8u) + 0u)];
    let _e138 = x[((idx * 3u) + 0u)];
    let _e141 = constants.alpha_u;
    let _e149 = state[((idx * 8u) + 0u)];
    let _e156 = state[((idx * 8u) + 0u)];
    let _e164 = state[((idx * 8u) + 0u)];
    let _e176 = x[((idx * 3u) + 0u)];
    let _e183 = x[((idx * 3u) + 0u)];
    let _e191 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e117, select(_e124, mix(_e131, _e138, _e141), ((_e149 == _e156) && (abs(_e164) < 340000000000000000000000000000000000000f))), ((_e176 == _e183) && (abs(_e191) < 340000000000000000000000000000000000000f)));
    let _e209 = state[((idx * 8u) + 1u)];
    let _e216 = x[((idx * 3u) + 1u)];
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 3u) + 1u)];
    let _e233 = constants.alpha_u;
    let _e241 = state[((idx * 8u) + 1u)];
    let _e248 = state[((idx * 8u) + 1u)];
    let _e256 = state[((idx * 8u) + 1u)];
    let _e268 = x[((idx * 3u) + 1u)];
    let _e275 = x[((idx * 3u) + 1u)];
    let _e283 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e209, select(_e216, mix(_e223, _e230, _e233), ((_e241 == _e248) && (abs(_e256) < 340000000000000000000000000000000000000f))), ((_e268 == _e275) && (abs(_e283) < 340000000000000000000000000000000000000f)));
    let _e301 = state[((idx * 8u) + 1u)];
    let _e308 = x[((idx * 3u) + 1u)];
    let _e315 = state[((idx * 8u) + 1u)];
    let _e322 = x[((idx * 3u) + 1u)];
    let _e325 = constants.alpha_u;
    let _e333 = state[((idx * 8u) + 1u)];
    let _e340 = state[((idx * 8u) + 1u)];
    let _e348 = state[((idx * 8u) + 1u)];
    let _e360 = x[((idx * 3u) + 1u)];
    let _e367 = x[((idx * 3u) + 1u)];
    let _e375 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e301, select(_e308, mix(_e315, _e322, _e325), ((_e333 == _e340) && (abs(_e348) < 340000000000000000000000000000000000000f))), ((_e360 == _e367) && (abs(_e375) < 340000000000000000000000000000000000000f)));
    let _e393 = state[((idx * 8u) + 2u)];
    let _e400 = x[((idx * 3u) + 2u)];
    let _e407 = state[((idx * 8u) + 2u)];
    let _e414 = x[((idx * 3u) + 2u)];
    let _e417 = constants.alpha_p;
    let _e425 = state[((idx * 8u) + 2u)];
    let _e432 = state[((idx * 8u) + 2u)];
    let _e440 = state[((idx * 8u) + 2u)];
    let _e452 = x[((idx * 3u) + 2u)];
    let _e459 = x[((idx * 3u) + 2u)];
    let _e467 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e393, select(_e400, mix(_e407, _e414, _e417), ((_e425 == _e432) && (abs(_e440) < 340000000000000000000000000000000000000f))), ((_e452 == _e459) && (abs(_e467) < 340000000000000000000000000000000000000f)));
    let _e485 = state[((idx * 8u) + 2u)];
    let _e492 = x[((idx * 3u) + 2u)];
    let _e499 = state[((idx * 8u) + 2u)];
    let _e506 = x[((idx * 3u) + 2u)];
    let _e509 = constants.alpha_p;
    let _e517 = state[((idx * 8u) + 2u)];
    let _e524 = state[((idx * 8u) + 2u)];
    let _e532 = state[((idx * 8u) + 2u)];
    let _e544 = x[((idx * 3u) + 2u)];
    let _e551 = x[((idx * 3u) + 2u)];
    let _e559 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e485, select(_e492, mix(_e499, _e506, _e509), ((_e517 == _e524) && (abs(_e532) < 340000000000000000000000000000000000000f))), ((_e544 == _e551) && (abs(_e559) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod packed_state_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_3_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_4_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_5_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_6_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_7_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 22u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 22u) + 0u)];
            let _e125 = state[((idx * 22u) + 0u)];
            let _e132 = bc_value[((face_idx * 8u) + 0u)];
            let _e139 = bc_kind[((face_idx * 8u) + 0u)];
            let _e149 = state[((idx * 22u) + 0u)];
            let _e156 = bc_value[((face_idx * 8u) + 0u)];
            let _e165 = bc_kind[((face_idx * 8u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 22u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 22u) + 1u)];
            let _e201 = state[((idx * 22u) + 1u)];
            let _e208 = bc_value[((face_idx * 8u) + 1u)];
            let _e215 = bc_kind[((face_idx * 8u) + 1u)];
            let _e225 = state[((idx * 22u) + 1u)];
            let _e232 = bc_value[((face_idx * 8u) + 1u)];
            let _e241 = bc_kind[((face_idx * 8u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 22u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 22u) + 2u)];
            let _e277 = state[((idx * 22u) + 2u)];
            let _e284 = bc_value[((face_idx * 8u) + 2u)];
            let _e291 = bc_kind[((face_idx * 8u) + 2u)];
            let _e301 = state[((idx * 22u) + 2u)];
            let _e308 = bc_value[((face_idx * 8u) + 2u)];
            let _e317 = bc_kind[((face_idx * 8u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 22u) + 3u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 22u) + 3u)];
            let _e353 = state[((idx * 22u) + 3u)];
            let _e360 = bc_value[((face_idx * 8u) + 3u)];
            let _e367 = bc_kind[((face_idx * 8u) + 3u)];
            let _e377 = state[((idx * 22u) + 3u)];
            let _e384 = bc_value[((face_idx * 8u) + 3u)];
            let _e393 = bc_kind[((face_idx * 8u) + 3u)];
            let _e403 = grad_acc_3_;
            grad_acc_3_ = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 22u) + 4u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 22u) + 4u)];
            let _e429 = state[((idx * 22u) + 4u)];
            let _e436 = bc_value[((face_idx * 8u) + 4u)];
            let _e443 = bc_kind[((face_idx * 8u) + 4u)];
            let _e453 = state[((idx * 22u) + 4u)];
            let _e460 = bc_value[((face_idx * 8u) + 4u)];
            let _e469 = bc_kind[((face_idx * 8u) + 4u)];
            let _e479 = grad_acc_4_;
            grad_acc_4_ = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 22u) + 5u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 22u) + 5u)];
            let _e505 = state[((idx * 22u) + 5u)];
            let _e512 = bc_value[((face_idx * 8u) + 5u)];
            let _e519 = bc_kind[((face_idx * 8u) + 5u)];
            let _e529 = state[((idx * 22u) + 5u)];
            let _e536 = bc_value[((face_idx * 8u) + 5u)];
            let _e545 = bc_kind[((face_idx * 8u) + 5u)];
            let _e555 = grad_acc_5_;
            grad_acc_5_ = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 22u) + 6u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 22u) + 6u)];
            let _e581 = state[((idx * 22u) + 6u)];
            let _e588 = bc_value[((face_idx * 8u) + 6u)];
            let _e595 = bc_kind[((face_idx * 8u) + 6u)];
            let _e605 = state[((idx * 22u) + 6u)];
            let _e612 = bc_value[((face_idx * 8u) + 6u)];
            let _e621 = bc_kind[((face_idx * 8u) + 6u)];
            let _e631 = grad_acc_6_;
            grad_acc_6_ = (_e631 + ((_e557 * ((_e564 * _e565) + (select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary) * lambda_other))) * area));
            let _e633 = normal_vec;
            let _e640 = state[((idx * 22u) + 7u)];
            let _e641 = lambda;
            let _e643 = other_idx;
            let _e650 = state[((_e643 * 22u) + 7u)];
            let _e657 = state[((idx * 22u) + 7u)];
            let _e664 = bc_value[((face_idx * 8u) + 7u)];
            let _e671 = bc_kind[((face_idx * 8u) + 7u)];
            let _e681 = state[((idx * 22u) + 7u)];
            let _e688 = bc_value[((face_idx * 8u) + 7u)];
            let _e697 = bc_kind[((face_idx * 8u) + 7u)];
            let _e707 = grad_acc_7_;
            grad_acc_7_ = (_e707 + ((_e633 * ((_e640 * _e641) + (select(_e650, select(select(_e657, _e664, (_e671 == 1u)), (_e681 + (_e688 * d_own)), (_e697 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e710 = k;
            k = (_e710 + 1u);
        }
    }
    let _e712 = grad_acc_0_;
    let grad_out_0_ = ((_e712 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 22u) + 0u)].y = grad_out_0_.y;
    let _e735 = grad_acc_1_;
    let grad_out_1_ = ((_e735 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 22u) + 1u)].y = grad_out_1_.y;
    let _e758 = grad_acc_2_;
    let grad_out_2_ = ((_e758 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 22u) + 2u)].y = grad_out_2_.y;
    let _e781 = grad_acc_3_;
    let grad_out_3_ = ((_e781 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 3u)].x = grad_out_3_.x;
    grad_state[((idx * 22u) + 3u)].y = grad_out_3_.y;
    let _e804 = grad_acc_4_;
    let grad_out_4_ = ((_e804 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 4u)].x = grad_out_4_.x;
    grad_state[((idx * 22u) + 4u)].y = grad_out_4_.y;
    let _e827 = grad_acc_5_;
    let grad_out_5_ = ((_e827 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 5u)].x = grad_out_5_.x;
    grad_state[((idx * 22u) + 5u)].y = grad_out_5_.y;
    let _e850 = grad_acc_6_;
    let grad_out_6_ = ((_e850 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 6u)].x = grad_out_6_.x;
    grad_state[((idx * 22u) + 6u)].y = grad_out_6_.y;
    let _e873 = grad_acc_7_;
    let grad_out_7_ = ((_e873 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 7u)].x = grad_out_7_.x;
    grad_state[((idx * 22u) + 7u)].y = grad_out_7_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 3u) + 0u)];
            let _e139 = bc_kind[((face_idx * 3u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 3u) + 0u)];
            let _e165 = bc_kind[((face_idx * 3u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 3u) + 1u)];
            let _e215 = bc_kind[((face_idx * 3u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 3u) + 1u)];
            let _e241 = bc_kind[((face_idx * 3u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 3u) + 2u)];
            let _e291 = bc_kind[((face_idx * 3u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 3u) + 2u)];
            let _e317 = bc_kind[((face_idx * 3u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e330 = k;
            k = (_e330 + 1u);
        }
    }
    let _e332 = grad_acc_0_;
    let grad_out_0_ = ((_e332 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e355 = grad_acc_1_;
    let grad_out_1_ = ((_e355 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e378 = grad_acc_2_;
    let grad_out_2_ = ((_e378 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_delta_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_delta_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * 8u);
    let d_p = state[(base + 3u)];
    let grad_px = state[(base + 4u)];
    let grad_py = state[(base + 5u)];
    let grad_old_x = state[(base + 6u)];
    let grad_old_y = state[(base + 7u)];
    let corr_x = (d_p * (grad_px - grad_old_x));
    let corr_y = (d_p * (grad_py - grad_old_y));
    let _e52 = state[(base + 0u)];
    state[(base + 0u)] = (_e52 - corr_x);
    let _e62 = state[(base + 1u)];
    state[(base + 1u)] = (_e62 - corr_y);
    return;
}
"#;
    }
    pub mod rhie_chow_grad_p_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_grad_p_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_grad_p_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 8u) + 2u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 8u) + 2u)];
            let _e129 = state[((idx * 8u) + 2u)];
            let _e136 = bc_value[((face_idx * 3u) + 2u)];
            let _e143 = bc_kind[((face_idx * 3u) + 2u)];
            let _e153 = state[((idx * 8u) + 2u)];
            let _e160 = bc_value[((face_idx * 3u) + 2u)];
            let _e169 = bc_kind[((face_idx * 3u) + 2u)];
            let _e179 = grad_acc_p;
            grad_acc_p = (_e179 + ((_e105 * ((_e112 * _e113) + (select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e182 = k;
            k = (_e182 + 1u);
        }
    }
    let _e184 = grad_acc_p;
    let grad_out_p = ((_e184 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod rhie_chow_store_grad_p_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowStoreGradPIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_store_grad_p_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowStoreGradPIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedRhieChowStoreGradPIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_store_grad_p_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * 8u);
    let _e23 = state[(base + 4u)];
    state[(base + 6u)] = _e23;
    let _e32 = state[(base + 5u)];
    state[(base + 7u)] = _e32;
    return;
}
"#;
    }
}
pub mod generic_coupled_schur_setup {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 16, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl SetupParams {
        pub const fn new(
            num_cells: u32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                num_cells,
                unknowns_per_cell,
                p,
                u_len,
                u0123,
                u4567,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_DIAG_AND_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_diag_and_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_diag_and_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_diag_and_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_DIAG_AND_PRESSURE: &str = "build_diag_and_pressure";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        pub diagonal_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        pub diagonal_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalar_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                },
                diagonal_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
                params: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.scalar_row_offsets,
                self.diagonal_indices,
                self.matrix_values,
                self.diag_u_inv,
                self.diag_p_inv,
                self.p_matrix_values,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalar_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diagonal_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(6): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::generic_coupled_schur_setup::SetupParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GenericCoupledSchurSetup::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("generic_coupled_schur_setup.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SetupParams {
    num_cells: u32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> p_matrix_values: array<f32>;
@group(0) @binding(6) 
var<uniform> params: SetupParams;

fn u_index(i_1: u32) -> u32 {
    if (i_1 < 4u) {
        let _e6 = params.u0123_[i_1];
        return _e6;
    }
    let _e12 = params.u4567_[(i_1 - 4u)];
    return _e12;
}

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_diag_and_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var i: u32 = 0u;
    var rank: u32 = 0u;

    let cell = ((global_id.y * (num_workgroups.x * 64u)) + global_id.x);
    let _e12 = params.num_cells;
    if (cell >= _e12) {
        return;
    }
    let scalar_offset = scalar_row_offsets[cell];
    let scalar_end = scalar_row_offsets[(cell + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[cell];
    let diag_rank = (_e25 - scalar_offset);
    let _e29 = params.unknowns_per_cell;
    let _e32 = params.unknowns_per_cell;
    let block_stride = (_e29 * _e32);
    let start_row_0_ = (scalar_offset * block_stride);
    let _e37 = params.unknowns_per_cell;
    let row_stride = (num_neighbors * _e37);
    let _e41 = params.p;
    let start_row_p = (start_row_0_ + (_e41 * row_stride));
    let _e46 = params.unknowns_per_cell;
    let _e52 = params.p;
    let diag_p = matrix_values[((start_row_p + (diag_rank * _e46)) + _e52)];
    loop {
        let _e57 = i;
        let _e60 = params.u_len;
        if (_e57 < _e60) {
        } else {
            break;
        }
        {
            let _e62 = i;
            let _e63 = u_index(_e62);
            let start_row_u = (start_row_0_ + (_e63 * row_stride));
            let _e69 = params.unknowns_per_cell;
            let diag_u = matrix_values[((start_row_u + (diag_rank * _e69)) + _e63)];
            let _e75 = safe_inverse(diag_u);
            let _e79 = params.u_len;
            let _e81 = i;
            diag_u_inv[((cell * _e79) + _e81)] = _e75;
        }
        continuing {
            let _e85 = i;
            i = (_e85 + 1u);
        }
    }
    let _e89 = safe_inverse(diag_p);
    diag_p_inv[cell] = _e89;
    loop {
        let _e91 = rank;
        if (_e91 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e94 = rank;
            let _e97 = rank;
            let _e100 = params.unknowns_per_cell;
            let _e106 = params.p;
            let _e109 = matrix_values[((start_row_p + (_e97 * _e100)) + _e106)];
            p_matrix_values[(scalar_offset + _e94)] = _e109;
        }
        continuing {
            let _e111 = rank;
            rank = (_e111 + 1u);
        }
    }
    return;
}
"#;
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let j = params.num_iters;
    let n = params.n;
    let num_groups_n = ((n + 63u) / WORKGROUP_SIZE);
    let stride_x = (num_workgroups.x * WORKGROUP_SIZE);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
    if (group_flat >= num_groups_n) {
        return;
    }
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e39 = b_w[idx];
        w_val = _e39;
    }
    loop {
        let _e42 = i;
        if (_e42 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e48 = i;
                if (_e48 <= j) {
                    let _e52 = i;
                    let _e56 = b_basis[((_e52 * stride_words) + idx)];
                    v.x = _e56;
                }
                let _e57 = i;
                if ((_e57 + 1u) <= j) {
                    let _e62 = i;
                    let _e69 = b_basis[(((_e62 + 1u) * stride_words) + idx)];
                    v.y = _e69;
                }
                let _e70 = i;
                if ((_e70 + 2u) <= j) {
                    let _e75 = i;
                    let _e82 = b_basis[(((_e75 + 2u) * stride_words) + idx)];
                    v.z = _e82;
                }
                let _e83 = i;
                if ((_e83 + 3u) <= j) {
                    let _e88 = i;
                    let _e95 = b_basis[(((_e88 + 3u) * stride_words) + idx)];
                    v.w = _e95;
                }
            }
            let _e96 = v;
            let _e97 = w_val;
            let prod = (_e96 * _e97);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e114 = sdata_vec4_[(local_id.x + 32u)];
                let _e115 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e115 + _e114);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e128 = sdata_vec4_[(local_id.x + 16u)];
                let _e129 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e129 + _e128);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e142 = sdata_vec4_[(local_id.x + 8u)];
                let _e143 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e143 + _e142);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e156 = sdata_vec4_[(local_id.x + 4u)];
                let _e157 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e157 + _e156);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e170 = sdata_vec4_[(local_id.x + 2u)];
                let _e171 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e171 + _e170);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e184 = sdata_vec4_[(local_id.x + 1u)];
                let _e185 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e185 + _e184);
                let sum_1 = sdata_vec4_[0];
                let _e190 = i;
                if (_e190 <= j) {
                    let _e193 = i;
                    b_dot_partial[((_e193 * num_groups_n) + group_flat)] = sum_1.x;
                }
                let _e198 = i;
                if ((_e198 + 1u) <= j) {
                    let _e202 = i;
                    b_dot_partial[(((_e202 + 1u) * num_groups_n) + group_flat)] = sum_1.y;
                }
                let _e210 = i;
                if ((_e210 + 2u) <= j) {
                    let _e214 = i;
                    b_dot_partial[(((_e214 + 2u) * num_groups_n) + group_flat)] = sum_1.z;
                }
                let _e222 = i;
                if ((_e222 + 3u) <= j) {
                    let _e226 = i;
                    b_dot_partial[(((_e226 + 3u) * num_groups_n) + group_flat)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e235 = i;
            i = (_e235 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e8 = params.n;
    let num_groups_n_1 = ((_e8 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e16 = k;
        if (_e16 < num_groups_n_1) {
        } else {
            break;
        }
        {
            let _e21 = k;
            let _e24 = b_dot_partial[((i_2 * num_groups_n_1) + _e21)];
            let _e25 = sum;
            sum = (_e25 + _e24);
        }
        continuing {
            let _e28 = k;
            k = (_e28 + 64u);
        }
    }
    let _e33 = sum;
    sdata[local_id_1.x] = _e33;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e45 = sdata[(local_id_1.x + 32u)];
        let _e46 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e46 + _e45);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e59 = sdata[(local_id_1.x + 16u)];
        let _e60 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e60 + _e59);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e73 = sdata[(local_id_1.x + 8u)];
        let _e74 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e74 + _e73);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e87 = sdata[(local_id_1.x + 4u)];
        let _e88 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e88 + _e87);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e101 = sdata[(local_id_1.x + 2u)];
        let _e102 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e102 + _e101);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e115 = sdata[(local_id_1.x + 1u)];
        let _e116 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e116 + _e115);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e129 = sdata[0];
        b_hessenberg[h_idx] = _e129;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let stride_x_1 = (num_workgroups_1.x * WORKGROUP_SIZE);
    let idx_1 = ((global_id_2.y * stride_x_1) + global_id_2.x);
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e30 = i_1;
        if (_e30 <= j_2) {
        } else {
            break;
        }
        {
            let _e32 = i_1;
            if (_e32 <= j_2) {
                let _e38 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e38)];
                let _e43 = i_1;
                let v_val = b_basis[((_e43 * stride_words_1) + idx_1)];
                let _e50 = correction;
                correction = (_e50 + (h_val * v_val));
            }
            let _e52 = i_1;
            if ((_e52 + 1u) <= j_2) {
                let _e59 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e59 + 1u))];
                let _e66 = i_1;
                let v_val_1 = b_basis[(((_e66 + 1u) * stride_words_1) + idx_1)];
                let _e75 = correction;
                correction = (_e75 + (h_val_1 * v_val_1));
            }
            let _e77 = i_1;
            if ((_e77 + 2u) <= j_2) {
                let _e84 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e84 + 2u))];
                let _e91 = i_1;
                let v_val_2 = b_basis[(((_e91 + 2u) * stride_words_1) + idx_1)];
                let _e100 = correction;
                correction = (_e100 + (h_val_2 * v_val_2));
            }
            let _e102 = i_1;
            if ((_e102 + 3u) <= j_2) {
                let _e109 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e109 + 3u))];
                let _e116 = i_1;
                let v_val_3 = b_basis[(((_e116 + 3u) * stride_words_1) + idx_1)];
                let _e125 = correction;
                correction = (_e125 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e128 = i_1;
            i_1 = (_e128 + 4u);
        }
    }
    let _e134 = b_w[idx_1];
    let _e135 = correction;
    b_w[idx_1] = (_e134 - _e135);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.iter_params, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let j_1 = iter_params.current_idx;
    loop {
        let _e7 = i;
        if (_e7 < j_1) {
        } else {
            break;
        }
        {
            let _e9 = i;
            let _e10 = h_idx(_e9, j_1);
            let _e11 = i;
            let _e14 = h_idx((_e11 + 1u), j_1);
            let h_ij = hessenberg[_e10];
            let h_i1j = hessenberg[_e14];
            let _e22 = i;
            let cs = givens[_e22];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e10] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e14] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e39 = i;
            i = (_e39 + 1u);
        }
    }
    let _e41 = h_idx(j_1, j_1);
    let _e44 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e41];
    let h_j1j = hessenberg[_e44];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e56 = rho;
    if (abs(_e56) > 0.00000000000000000001f) {
        let _e60 = rho;
        c = (h_jj / _e60);
        let _e63 = rho;
        s = (h_j1j / _e63);
    }
    let _e68 = c;
    let _e69 = s;
    givens[j_1] = vec2<f32>(_e68, _e69);
    let _e73 = rho;
    hessenberg[_e41] = _e73;
    hessenberg[_e44] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e87 = c;
    let _e89 = s;
    g_rhs[j_1] = ((_e87 * g_j) + (_e89 * g_j1_));
    let _e96 = s;
    let _e99 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e96) * g_j) + (_e99 * g_j1_));
    let _e108 = g_rhs[(j_1 + 1u)];
    scalars[0] = abs(_e108);
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let k = iter_params.current_idx;
    loop {
        let _e5 = loop_i;
        if (_e5 < k) {
        } else {
            break;
        }
        {
            let _e9 = loop_i;
            let i_1 = ((k - 1u) - _e9);
            let _e13 = g_rhs[i_1];
            sum = _e13;
            j = (i_1 + 1u);
            loop {
                let _e18 = j;
                if (_e18 < k) {
                } else {
                    break;
                }
                {
                    let _e20 = j;
                    let _e21 = h_idx(i_1, _e20);
                    let _e24 = hessenberg[_e21];
                    let _e26 = j;
                    let _e28 = y_sol[_e26];
                    let _e30 = sum;
                    sum = (_e30 - (_e24 * _e28));
                }
                continuing {
                    let _e33 = j;
                    j = (_e33 + 1u);
                }
            }
            let _e35 = h_idx(i_1, i_1);
            let diag = hessenberg[_e35];
            if (abs(diag) > 0.000000000001f) {
                let _e44 = sum;
                y_sol[i_1] = (_e44 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e50 = loop_i;
            loop_i = (_e50 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const EXTRACT_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_extract_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline extract_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("extract_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    pub const ENTRY_EXTRACT_DIAG_INV: &str = "extract_diag_inv";
    pub const ENTRY_APPLY_DIAG_INV: &str = "apply_diag_inv";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn global_index(global_id_14: vec3<u32>, num_workgroups_12: vec3<u32>) -> u32 {
    return ((global_id_14.y * (num_workgroups_12.x * WORKGROUP_SIZE)) + global_id_14.x);
}

fn workgroup_index(group_id_2: vec3<u32>, num_workgroups_13: vec3<u32>) -> u32 {
    return ((group_id_2.y * num_workgroups_13.x) + group_id_2.x);
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val_1 = matrix_values[_e24];
            let _e30 = vec_x[col];
            let _e32 = sum;
            sum = (_e32 + (val_1 * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    vec_y[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let _e2 = global_index(global_id_1, num_workgroups_1);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha = scalars[0];
    let _e14 = vec_x[_e2];
    let _e18 = vec_y[_e2];
    vec_y[_e2] = ((alpha * _e14) + _e18);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    let _e2 = global_index(global_id_2, num_workgroups_2);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e10 = iter_params.current_idx;
    let alpha_1 = y_sol[_e10];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_y[_e2] = ((alpha_1 * _e17) + _e21);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let _e2 = global_index(global_id_3, num_workgroups_3);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_z[_e2] = ((alpha_2 * _e17) + (beta * _e21));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>, @builtin(num_workgroups) num_workgroups_4: vec3<u32>) {
    let _e2 = global_index(global_id_4, num_workgroups_4);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (alpha_3 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>, @builtin(num_workgroups) num_workgroups_5: vec3<u32>) {
    let _e2 = global_index(global_id_5, num_workgroups_5);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e14 = vec_y[_e2];
    vec_y[_e2] = (alpha_4 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>, @builtin(num_workgroups) num_workgroups_6: vec3<u32>) {
    let _e2 = global_index(global_id_6, num_workgroups_6);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = vec_x[_e2];
    vec_y[_e2] = _e11;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups_7: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e4 = global_index(global_id_7, num_workgroups_7);
    let lid = local_id.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let _e13 = vec_x[_e4];
        let _e16 = vec_y[_e4];
        local_sum = (_e13 * _e16);
    }
    let _e21 = local_sum;
    partial_sums[lid] = _e21;
    workgroupBarrier();
    loop {
        let _e23 = stride;
        if (_e23 > 0u) {
        } else {
            break;
        }
        {
            let _e26 = stride;
            if (lid < _e26) {
                let _e31 = stride;
                let _e34 = partial_sums[(lid + _e31)];
                let _e35 = partial_sums[lid];
                partial_sums[lid] = (_e35 + _e34);
            }
            workgroupBarrier();
        }
        continuing {
            let _e38 = stride;
            stride = (_e38 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e43 = workgroup_index(group_id, num_workgroups_7);
        let _e46 = params.n;
        let num_groups_n = ((_e46 + 63u) / WORKGROUP_SIZE);
        if (_e43 < num_groups_n) {
            let _e56 = partial_sums[0];
            vec_z[_e43] = _e56;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_8: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e4 = global_index(global_id_8, num_workgroups_8);
    let lid_1 = local_id_1.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let val_2 = vec_x[_e4];
        local_sum_1 = (val_2 * val_2);
    }
    let _e18 = local_sum_1;
    partial_sums[lid_1] = _e18;
    workgroupBarrier();
    loop {
        let _e20 = stride_1;
        if (_e20 > 0u) {
        } else {
            break;
        }
        {
            let _e23 = stride_1;
            if (lid_1 < _e23) {
                let _e28 = stride_1;
                let _e31 = partial_sums[(lid_1 + _e28)];
                let _e32 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e32 + _e31);
            }
            workgroupBarrier();
        }
        continuing {
            let _e35 = stride_1;
            stride_1 = (_e35 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e40 = workgroup_index(group_id_1, num_workgroups_8);
        let _e43 = params.n;
        let num_groups_n_1 = ((_e43 + 63u) / WORKGROUP_SIZE);
        if (_e40 < num_groups_n_1) {
            let _e53 = partial_sums[0];
            vec_z[_e40] = _e53;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>, @builtin(num_workgroups) num_workgroups_9: vec3<u32>) {
    let _e2 = global_index(global_id_9, num_workgroups_9);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let h = scalars[0];
    let _e14 = vec_y[_e2];
    let _e17 = vec_x[_e2];
    vec_y[_e2] = (_e14 - (h * _e17));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let num_partials_1 = params.n;
    loop {
        let _e6 = i_1;
        if (_e6 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e10 = i_1;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum_1;
            total_sum_1 = (_e13 + _e12);
        }
        continuing {
            let _e16 = i_1;
            i_1 = (_e16 + 1u);
        }
    }
    let _e18 = total_sum_1;
    let norm = sqrt(_e18);
    let _e23 = iter_params.current_idx;
    hessenberg[_e23] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn extract_diag_inv(@builtin(global_invocation_id) global_id_12: vec3<u32>, @builtin(num_workgroups) num_workgroups_10: vec3<u32>) {
    var diag: f32 = 1f;
    var k_1: u32;

    let _e3 = global_index(global_id_12, num_workgroups_10);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start_1 = row_offsets[_e3];
    let end_1 = row_offsets[(_e3 + 1u)];
    k_1 = start_1;
    loop {
        let _e17 = k_1;
        if (_e17 < end_1) {
        } else {
            break;
        }
        {
            let _e20 = k_1;
            let _e22 = col_indices[_e20];
            if (_e22 == _e3) {
                let _e25 = k_1;
                let _e27 = matrix_values[_e25];
                diag = _e27;
                break;
            }
        }
        continuing {
            let _e29 = k_1;
            k_1 = (_e29 + 1u);
        }
    }
    let _e32 = diag;
    let _e33 = safe_inverse(_e32);
    diag_u[_e3] = _e33;
    diag_v[_e3] = _e33;
    diag_p[_e3] = _e33;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_diag_inv(@builtin(global_invocation_id) global_id_13: vec3<u32>, @builtin(num_workgroups) num_workgroups_11: vec3<u32>) {
    let _e2 = global_index(global_id_13, num_workgroups_11);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = diag_u[_e2];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (_e11 * _e14);
    return;
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.x, self.r, self.p, self.v]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

fn global_index(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = matrix_values[_e24];
            let _e30 = p[col];
            let _e32 = sum;
            sum = (_e32 + (val * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    v[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var alpha: f32 = 0f;

    let _e3 = global_index(global_id_1, num_workgroups_1);
    let _e6 = scalars.r0_v;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_old;
        let _e15 = scalars.r0_v;
        alpha = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (_e3 >= _e25) {
        return;
    }
    let _e29 = alpha;
    let _e32 = p[_e3];
    let _e34 = x[_e3];
    x[_e3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha;
    let _e41 = v[_e3];
    let _e43 = r[_e3];
    r[_e3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var beta: f32 = 0f;

    let _e3 = global_index(global_id_2, num_workgroups_2);
    let _e6 = scalars.rho_old;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_new;
        let _e15 = scalars.rho_old;
        beta = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = beta;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (_e3 >= _e30) {
        return;
    }
    let _e36 = r[_e3];
    let _e37 = beta;
    let _e40 = p[_e3];
    p[_e3] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod outer_convergence {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub stride: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_targets: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl Params {
        pub const fn new(num_cells: u32, stride: u32, num_targets: u32, _pad0: u32) -> Self {
            Self {
                num_cells,
                stride,
                num_targets,
                _pad0,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct TargetDesc {
        #[doc = "offset: 0, size: 16, type: `array<u32, 4>`"]
        pub offsets: [u32; 4],
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub num_comps: u32,
        #[doc = "offset: 20, size: 12, type: `array<u32, 3>`"]
        pub _pad0: [u32; 3],
    }
    impl TargetDesc {
        pub const fn new(offsets: [u32; 4], num_comps: u32, _pad0: [u32; 3]) -> Self {
            Self {
                offsets,
                num_comps,
                _pad0,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input: wgpu::BufferBinding<'a>,
        pub targets: wgpu::BufferBinding<'a>,
        pub out_bits: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input: wgpu::BindGroupEntry<'a>,
        pub targets: wgpu::BindGroupEntry<'a>,
        pub out_bits: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input),
                },
                targets: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.targets),
                },
                out_bits: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.out_bits),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.input, self.targets, self.out_bits, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("OuterConvergence::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"targets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"out_bits\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::outer_convergence::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("OuterConvergence::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("OuterConvergence::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("outer_convergence.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    num_cells: u32,
    stride: u32,
    num_targets: u32,
    _pad0_: u32,
}

struct TargetDesc {
    offsets: array<u32, 4>,
    num_comps: u32,
    _pad0_: array<u32, 3>,
}

@group(0) @binding(0) 
var<storage> input: array<f32>;
@group(0) @binding(1) 
var<storage> targets: array<TargetDesc>;
@group(0) @binding(2) 
var<storage, read_write> out_bits: array<atomic<u32>>;
@group(0) @binding(3) 
var<uniform> params: Params;

@compute @workgroup_size(256, 1, 1) 
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    var t: u32 = 0u;
    var mag2_: f32;
    var c: u32;

    let cell = gid.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let _e9 = params.stride;
    let base = (cell * _e9);
    loop {
        let _e12 = t;
        let _e15 = params.num_targets;
        if (_e12 < _e15) {
        } else {
            break;
        }
        {
            let _e18 = t;
            let desc = targets[_e18];
            mag2_ = 0f;
            c = 0u;
            loop {
                let _e25 = c;
                if (_e25 < desc.num_comps) {
                } else {
                    break;
                }
                {
                    let _e29 = c;
                    let off = desc.offsets[_e29];
                    let v = input[(base + off)];
                    let _e35 = mag2_;
                    mag2_ = (_e35 + (v * v));
                }
                continuing {
                    let _e38 = c;
                    c = (_e38 + 1u);
                }
            }
            let _e41 = mag2_;
            let mag = sqrt(_e41);
            let bits = bitcast<u32>(mag);
            let _e45 = t;
            let _e47 = atomicMax((&out_bits[_e45]), bits);
        }
        continuing {
            let _e48 = t;
            t = (_e48 + 1u);
        }
    }
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_4;
            i_4 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_2] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_5;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_5;
            if (lid_2 < _e27) {
                let _e32 = i_5;
                let _e35 = scratch1_[(lid_2 + _e32)];
                let _e36 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_5;
            i_5 = (_e39 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u0: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            u0: u32,
            u1: u32,
            p: u32,
            _pad0: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                u0,
                u1,
                p,
                _pad0,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    u0_: u32,
    u1_: u32,
    p: u32,
    _pad0_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u = (base + _e14);
    let _e18 = params.u1_;
    let row_v = (base + _e18);
    let p_val = p_sol[_e3];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e32 = k_1;
        if (_e32 < end_u) {
        } else {
            break;
        }
        {
            let _e35 = k_1;
            let col = col_indices[_e35];
            let _e40 = params.unknowns_per_cell;
            let _e44 = params.p;
            if ((col % _e40) == _e44) {
                let _e48 = params.unknowns_per_cell;
                let p_cell = (col / _e48);
                let _e51 = k_1;
                let _e53 = matrix_values[_e51];
                let _e57 = p_sol[p_cell];
                let _e59 = correction_u;
                correction_u = (_e59 + (_e53 * _e57));
            }
        }
        continuing {
            let _e62 = k_1;
            k_1 = (_e62 + 1u);
        }
    }
    let _e68 = diag_u_inv[_e3];
    let _e69 = correction_u;
    let _e71 = z_out[row_u];
    z_out[row_u] = (_e71 - (_e68 * _e69));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e82 = k_2;
        if (_e82 < end_v) {
        } else {
            break;
        }
        {
            let _e85 = k_2;
            let col_1 = col_indices[_e85];
            let _e90 = params.unknowns_per_cell;
            let _e94 = params.p;
            if ((col_1 % _e90) == _e94) {
                let _e98 = params.unknowns_per_cell;
                let p_cell_1 = (col_1 / _e98);
                let _e101 = k_2;
                let _e103 = matrix_values[_e101];
                let _e107 = p_sol[p_cell_1];
                let _e109 = correction_v;
                correction_v = (_e109 + (_e103 * _e107));
            }
        }
        continuing {
            let _e112 = k_2;
            k_2 = (_e112 + 1u);
        }
    }
    let _e118 = diag_v_inv[_e3];
    let _e119 = correction_v;
    let _e121 = z_out[row_v];
    z_out[row_v] = (_e121 - (_e118 * _e119));
    let _e126 = params.p;
    z_out[(base + _e126)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u_1 = (base_1 + _e14);
    let _e18 = params.u1_;
    let row_v_1 = (base_1 + _e18);
    let _e22 = params.p;
    let row_p = (base_1 + _e22);
    loop {
        let _e25 = c;
        let _e28 = params.unknowns_per_cell;
        if (_e25 < _e28) {
        } else {
            break;
        }
        {
            let _e31 = c;
            let _e35 = c;
            let _e38 = r_in[(base_1 + _e35)];
            z_out[(base_1 + _e31)] = _e38;
        }
        continuing {
            let _e40 = c;
            c = (_e40 + 1u);
        }
    }
    let r_u = r_in[row_u_1];
    let r_v = r_in[row_v_1];
    let _e52 = diag_u_inv[_e3];
    z_out[row_u_1] = (_e52 * r_u);
    let _e58 = diag_v_inv[_e3];
    z_out[row_v_1] = (_e58 * r_v);
    z_out[row_p] = 0f;
    let _e65 = r_in[row_p];
    rhs_p = _e65;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e76 = k_3;
        if (_e76 < end_1) {
        } else {
            break;
        }
        {
            let _e79 = k_3;
            let col_2 = col_indices[_e79];
            let _e84 = params.unknowns_per_cell;
            let rem = (col_2 % _e84);
            z_val = 0f;
            let _e90 = params.u0_;
            if (rem == _e90) {
                let _e94 = params.unknowns_per_cell;
                let c_1 = (col_2 / _e94);
                let _e98 = r_in[col_2];
                let _e101 = diag_u_inv[c_1];
                z_val = (_e98 * _e101);
            } else {
                let _e105 = params.u1_;
                if (rem == _e105) {
                    let _e109 = params.unknowns_per_cell;
                    let c_2 = (col_2 / _e109);
                    let _e113 = r_in[col_2];
                    let _e116 = diag_v_inv[c_2];
                    z_val = (_e113 * _e116);
                }
            }
            let _e119 = k_3;
            let _e121 = matrix_values[_e119];
            let _e122 = z_val;
            let _e124 = rhs_p;
            rhs_p = (_e124 - (_e121 * _e122));
        }
        continuing {
            let _e127 = k_3;
            k_3 = (_e127 + 1u);
        }
    }
    let _e131 = rhs_p;
    temp_p[_e3] = _e131;
    let _e136 = diag_p_inv[_e3];
    let _e137 = rhs_p;
    p_sol[_e3] = (_e136 * _e137);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
pub mod schur_precond_generic {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            _pad0: u32,
            _pad1: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                p,
                u_len,
                _pad0,
                _pad1,
                u0123,
                u4567,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u_inv, self.diag_p_inv, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond_generic::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecondGeneric::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond_generic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    _pad0_: u32,
    _pad1_: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(2) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn u_index(i_3: u32) -> u32 {
    if (i_3 < 4u) {
        let _e6 = params.u0123_[i_3];
        return _e6;
    }
    let _e12 = params.u4567_[(i_3 - 4u)];
    return _e12;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var i: u32 = 0u;
    var correction_u: f32;
    var k_1: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let p_val = p_sol[_e3];
    loop {
        let _e16 = i;
        let _e19 = params.u_len;
        if (_e16 < _e19) {
        } else {
            break;
        }
        {
            let _e21 = i;
            let _e22 = u_index(_e21);
            let row_u = (base + _e22);
            let start_u = row_offsets[row_u];
            let end_u = row_offsets[(row_u + 1u)];
            correction_u = 0f;
            k_1 = start_u;
            loop {
                let _e35 = k_1;
                if (_e35 < end_u) {
                } else {
                    break;
                }
                {
                    let _e38 = k_1;
                    let col = col_indices[_e38];
                    let _e43 = params.unknowns_per_cell;
                    let _e47 = params.p;
                    if ((col % _e43) == _e47) {
                        let _e51 = params.unknowns_per_cell;
                        let p_cell = (col / _e51);
                        let _e54 = k_1;
                        let _e56 = matrix_values[_e54];
                        let _e59 = p_sol[p_cell];
                        let _e61 = correction_u;
                        correction_u = (_e61 + (_e56 * _e59));
                    }
                }
                continuing {
                    let _e64 = k_1;
                    k_1 = (_e64 + 1u);
                }
            }
            let _e71 = params.u_len;
            let _e73 = i;
            let _e76 = diag_u_inv[((_e3 * _e71) + _e73)];
            let _e77 = correction_u;
            let _e79 = z_out[row_u];
            z_out[row_u] = (_e79 - (_e76 * _e77));
        }
        continuing {
            let _e82 = i;
            i = (_e82 + 1u);
        }
    }
    let _e87 = params.p;
    z_out[(base + _e87)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var i_1: u32 = 0u;
    var rhs_p: f32;
    var k_2: u32;
    var z_val: f32;
    var i_2: u32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.p;
    let row_p = (base_1 + _e14);
    loop {
        let _e17 = c;
        let _e20 = params.unknowns_per_cell;
        if (_e17 < _e20) {
        } else {
            break;
        }
        {
            let _e23 = c;
            let _e27 = c;
            let _e30 = r_in[(base_1 + _e27)];
            z_out[(base_1 + _e23)] = _e30;
        }
        continuing {
            let _e32 = c;
            c = (_e32 + 1u);
        }
    }
    loop {
        let _e35 = i_1;
        let _e38 = params.u_len;
        if (_e35 < _e38) {
        } else {
            break;
        }
        {
            let _e40 = i_1;
            let _e41 = u_index(_e40);
            let row_u_1 = (base_1 + _e41);
            let _e48 = params.u_len;
            let _e50 = i_1;
            let _e53 = diag_u_inv[((_e3 * _e48) + _e50)];
            let _e56 = r_in[row_u_1];
            z_out[row_u_1] = (_e53 * _e56);
        }
        continuing {
            let _e59 = i_1;
            i_1 = (_e59 + 1u);
        }
    }
    z_out[row_p] = 0f;
    let _e66 = r_in[row_p];
    rhs_p = _e66;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_2 = start_1;
    loop {
        let _e77 = k_2;
        if (_e77 < end_1) {
        } else {
            break;
        }
        {
            let _e80 = k_2;
            let col_1 = col_indices[_e80];
            let _e85 = params.unknowns_per_cell;
            let rem = (col_1 % _e85);
            z_val = 0f;
            i_2 = 0u;
            loop {
                let _e91 = i_2;
                let _e94 = params.u_len;
                if (_e91 < _e94) {
                } else {
                    break;
                }
                {
                    let _e96 = i_2;
                    let _e97 = u_index(_e96);
                    if (rem == _e97) {
                        let _e101 = params.unknowns_per_cell;
                        let c_1 = (col_1 / _e101);
                        let _e105 = r_in[col_1];
                        let _e109 = params.u_len;
                        let _e111 = i_2;
                        let _e114 = diag_u_inv[((c_1 * _e109) + _e111)];
                        z_val = (_e105 * _e114);
                        break;
                    }
                }
                continuing {
                    let _e117 = i_2;
                    i_2 = (_e117 + 1u);
                }
            }
            let _e120 = k_2;
            let _e122 = matrix_values[_e120];
            let _e123 = z_val;
            let _e125 = rhs_p;
            rhs_p = (_e125 - (_e122 * _e123));
        }
        continuing {
            let _e128 = k_2;
            k_2 = (_e128 + 1u);
        }
    }
    let _e132 = rhs_p;
    temp_p[_e3] = _e132;
    let _e137 = diag_p_inv[_e3];
    let _e138 = rhs_p;
    p_sol[_e3] = (_e137 * _e138);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
