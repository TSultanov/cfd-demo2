// GENERATED BY CFD2 CODEGEN (flux_module)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;

// Group 2: Boundary conditions (per face x unknown)

@group(2) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(2) @binding(1) 
var<storage, read> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32 = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = owner + value * d_own;
    }
    return select(interior, boundary, is_boundary);
}

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = neighbor == -1;
    var neigh_idx: u32 = owner;
    if (neighbor != -1) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    let c_owner = cell_centers[owner];
    let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    if (dot(face_center_vec - c_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    let c_neigh = cell_centers[neigh_idx];
    var c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec: vec2<f32> = c_neigh_vec;
    if (is_boundary) {
        c_neigh_vec = face_center_vec;
    }
    let d_own = abs(dot(face_center_vec - c_owner_vec, normal_vec));
    let d_neigh = abs(dot(c_neigh_vec - face_center_vec, normal_vec));
    let total_dist = d_own + d_neigh;
    var lambda: f32 = 0.5;
    if (total_dist > 0.000001) {
        lambda = d_neigh / total_dist;
    }
    let lambda_other = 1.0 - lambda;
    let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
    let dist_proj = abs(dot(d_vec, normal_vec));
    let dist = max(dist_proj, 0.000001);
    let s_own_T = bc_neighbor_scalar(state[owner * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_own_grad_T_x = state[owner * 22u + 16u];
    let s_own_grad_T_y = state[owner * 22u + 17u];
    let s_own_grad_rho_x = state[owner * 22u + 12u];
    let s_own_grad_rho_y = state[owner * 22u + 13u];
    let s_own_grad_rho_u_x_x = state[owner * 22u + 3u];
    let s_own_grad_rho_u_x_y = state[owner * 22u + 4u];
    let s_own_grad_rho_u_y_x = state[owner * 22u + 5u];
    let s_own_grad_rho_u_y_y = state[owner * 22u + 6u];
    let s_own_rho = bc_neighbor_scalar(state[owner * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_own_rho_u_x = select(bc_neighbor_scalar(state[owner * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_own_rho_u_y = select(bc_neighbor_scalar(state[owner * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let s_neigh_T = bc_neighbor_scalar(state[neigh_idx * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_neigh_grad_T_x = select(state[neigh_idx * 22u + 16u], state[owner * 22u + 16u], is_boundary);
    let s_neigh_grad_T_y = select(state[neigh_idx * 22u + 17u], state[owner * 22u + 17u], is_boundary);
    let s_neigh_grad_rho_x = select(state[neigh_idx * 22u + 12u], state[owner * 22u + 12u], is_boundary);
    let s_neigh_grad_rho_y = select(state[neigh_idx * 22u + 13u], state[owner * 22u + 13u], is_boundary);
    let s_neigh_grad_rho_u_x_x = select(state[neigh_idx * 22u + 3u], state[owner * 22u + 3u], is_boundary);
    let s_neigh_grad_rho_u_x_y = select(state[neigh_idx * 22u + 4u], state[owner * 22u + 4u], is_boundary);
    let s_neigh_grad_rho_u_y_x = select(state[neigh_idx * 22u + 5u], state[owner * 22u + 5u], is_boundary);
    let s_neigh_grad_rho_u_y_y = select(state[neigh_idx * 22u + 6u], state[owner * 22u + 6u], is_boundary);
    let s_neigh_rho = bc_neighbor_scalar(state[neigh_idx * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_neigh_rho_u_x = select(bc_neighbor_scalar(state[neigh_idx * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_neigh_rho_u_y = select(bc_neighbor_scalar(state[neigh_idx * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let _cse_3 = s_own_rho_u_x;
    let _cse_4 = s_own_rho_u_y;
    let _cse_2 = vec2<f32>(_cse_3, _cse_4);
    let _cse_1 = _cse_2 * 1.0 / s_own_rho;
    let _cse_0 = dot(_cse_1, normal_vec);
    let _cse_12 = f32(low_mach_params.model) - 2.0;
    let _cse_11 = abs(_cse_12);
    let _cse_10 = 1.0 - _cse_11;
    let _cse_9 = max(0.0, _cse_10);
    let _cse_16 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_15 = constants.eos_gamma * _cse_16;
    let _cse_14 = _cse_15 / s_own_rho;
    let _cse_13 = _cse_14 + constants.eos_dp_drho;
    let _cse_8 = _cse_9 * _cse_13;
    let _cse_21 = f32(low_mach_params.model);
    let _cse_20 = abs(_cse_21);
    let _cse_19 = 1.0 - _cse_20;
    let _cse_18 = max(0.0, _cse_19);
    let _cse_23 = _cse_0 * _cse_0;
    let _cse_22 = min(_cse_23, _cse_13);
    let _cse_17 = _cse_18 * _cse_22;
    let _cse_7 = _cse_8 + _cse_17;
    let _cse_28 = f32(low_mach_params.model) - 1.0;
    let _cse_27 = abs(_cse_28);
    let _cse_26 = 1.0 - _cse_27;
    let _cse_25 = max(0.0, _cse_26);
    let _cse_31 = low_mach_params.theta_floor * _cse_13;
    let _cse_30 = max(_cse_23, _cse_31);
    let _cse_29 = min(_cse_30, _cse_13);
    let _cse_24 = _cse_25 * _cse_29;
    let _cse_6 = _cse_7 + _cse_24;
    let _cse_5 = sqrt(_cse_6);
    let _cse_35 = s_neigh_rho_u_x;
    let _cse_36 = s_neigh_rho_u_y;
    let _cse_34 = vec2<f32>(_cse_35, _cse_36);
    let _cse_33 = _cse_34 * 1.0 / s_neigh_rho;
    let _cse_32 = dot(_cse_33, normal_vec);
    let _cse_44 = s_neigh_rho * constants.eos_r * s_neigh_T;
    let _cse_43 = constants.eos_gamma * _cse_44;
    let _cse_42 = _cse_43 / s_neigh_rho;
    let _cse_41 = _cse_42 + constants.eos_dp_drho;
    let _cse_40 = _cse_9 * _cse_41;
    let _cse_47 = _cse_32 * _cse_32;
    let _cse_46 = min(_cse_47, _cse_41);
    let _cse_45 = _cse_18 * _cse_46;
    let _cse_39 = _cse_40 + _cse_45;
    let _cse_51 = low_mach_params.theta_floor * _cse_41;
    let _cse_50 = max(_cse_47, _cse_51);
    let _cse_49 = min(_cse_50, _cse_41);
    let _cse_48 = _cse_25 * _cse_49;
    let _cse_38 = _cse_39 + _cse_48;
    let _cse_37 = sqrt(_cse_38);
    var a_plus: f32 = max(0.0, max(_cse_0 + _cse_5, _cse_32 + _cse_37));
    var a_minus: f32 = min(0.0, min(_cse_0 - _cse_5, _cse_32 - _cse_37));
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_56 = s_own_rho_u_x;
        let _cse_57 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_55 = _cse_56 + _cse_57;
        let _cse_59 = s_own_rho_u_y;
        let _cse_60 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_58 = _cse_59 + _cse_60;
        let _cse_54 = vec2<f32>(_cse_55, _cse_58);
        let _cse_63 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_62 = s_own_rho + _cse_63;
        let _cse_61 = 1.0 / _cse_62;
        let _cse_53 = _cse_54 * _cse_61;
        let _cse_52 = dot(_cse_53, normal_vec);
        let _cse_72 = _cse_62 * constants.eos_r;
        let _cse_74 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_73 = s_own_T + _cse_74;
        let _cse_71 = _cse_72 * _cse_73;
        let _cse_70 = constants.eos_gamma * _cse_71;
        let _cse_69 = _cse_70 / _cse_62;
        let _cse_68 = _cse_69 + constants.eos_dp_drho;
        let _cse_67 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_68;
        let _cse_77 = _cse_52 * _cse_52;
        let _cse_76 = min(_cse_77, _cse_68);
        let _cse_75 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_76;
        let _cse_66 = _cse_67 + _cse_75;
        let _cse_81 = low_mach_params.theta_floor * _cse_68;
        let _cse_80 = max(_cse_77, _cse_81);
        let _cse_79 = min(_cse_80, _cse_68);
        let _cse_78 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_79;
        let _cse_65 = _cse_66 + _cse_78;
        let _cse_64 = sqrt(_cse_65);
        let _cse_86 = s_neigh_rho_u_x;
        let _cse_88 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_87 = dot(_cse_88, face_center_vec - c_neigh_cell_vec);
        let _cse_85 = _cse_86 + _cse_87;
        let _cse_90 = s_neigh_rho_u_y;
        let _cse_92 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_91 = dot(_cse_92, face_center_vec - c_neigh_cell_vec);
        let _cse_89 = _cse_90 + _cse_91;
        let _cse_84 = vec2<f32>(_cse_85, _cse_89);
        let _cse_96 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_95 = dot(_cse_96, face_center_vec - c_neigh_cell_vec);
        let _cse_94 = s_neigh_rho + _cse_95;
        let _cse_93 = 1.0 / _cse_94;
        let _cse_83 = _cse_84 * _cse_93;
        let _cse_82 = dot(_cse_83, normal_vec);
        let _cse_105 = _cse_94 * constants.eos_r;
        let _cse_108 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_107 = dot(_cse_108, face_center_vec - c_neigh_cell_vec);
        let _cse_106 = s_neigh_T + _cse_107;
        let _cse_104 = _cse_105 * _cse_106;
        let _cse_103 = constants.eos_gamma * _cse_104;
        let _cse_102 = _cse_103 / _cse_94;
        let _cse_101 = _cse_102 + constants.eos_dp_drho;
        let _cse_100 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_101;
        let _cse_111 = _cse_82 * _cse_82;
        let _cse_110 = min(_cse_111, _cse_101);
        let _cse_109 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_110;
        let _cse_99 = _cse_100 + _cse_109;
        let _cse_115 = low_mach_params.theta_floor * _cse_101;
        let _cse_114 = max(_cse_111, _cse_115);
        let _cse_113 = min(_cse_114, _cse_101);
        let _cse_112 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_113;
        let _cse_98 = _cse_99 + _cse_112;
        let _cse_97 = sqrt(_cse_98);
        a_plus = max(0.0, max(_cse_52 + _cse_64, _cse_82 + _cse_97));
        a_minus = min(0.0, min(_cse_52 - _cse_64, _cse_82 - _cse_97));
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_120 = s_own_rho_u_x;
        let _cse_124 = s_neigh_rho_u_x;
        let _cse_123 = _cse_120 * 0.625 + _cse_124 * 0.375;
        let _cse_122 = _cse_123 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_121 = _cse_122 - _cse_120;
        let _cse_119 = _cse_120 + _cse_121;
        let _cse_126 = s_own_rho_u_y;
        let _cse_130 = s_neigh_rho_u_y;
        let _cse_129 = _cse_126 * 0.625 + _cse_130 * 0.375;
        let _cse_128 = _cse_129 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_127 = _cse_128 - _cse_126;
        let _cse_125 = _cse_126 + _cse_127;
        let _cse_118 = vec2<f32>(_cse_119, _cse_125);
        let _cse_136 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_135 = _cse_136 * 0.125;
        let _cse_134 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + _cse_135;
        let _cse_133 = _cse_134 - s_own_rho;
        let _cse_132 = s_own_rho + _cse_133;
        let _cse_131 = 1.0 / _cse_132;
        let _cse_117 = _cse_118 * _cse_131;
        let _cse_116 = dot(_cse_117, normal_vec);
        let _cse_143 = _cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T);
        let _cse_142 = constants.eos_gamma * _cse_143;
        let _cse_141 = _cse_142 / _cse_132;
        let _cse_140 = _cse_141 + constants.eos_dp_drho;
        let _cse_146 = _cse_116 * _cse_116;
        let _cse_145 = min(_cse_146, _cse_140);
        let _cse_144 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_145;
        let _cse_139 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_140 + _cse_144;
        let _cse_149 = max(_cse_146, low_mach_params.theta_floor * _cse_140);
        let _cse_148 = min(_cse_149, _cse_140);
        let _cse_147 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_148;
        let _cse_138 = _cse_139 + _cse_147;
        let _cse_137 = sqrt(_cse_138);
        let _cse_155 = _cse_124 * 0.625 + _cse_120 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_154 = _cse_155 - _cse_124;
        let _cse_153 = _cse_124 + _cse_154;
        let _cse_158 = _cse_130 * 0.625 + _cse_126 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_157 = _cse_158 - _cse_130;
        let _cse_156 = _cse_130 + _cse_157;
        let _cse_152 = vec2<f32>(_cse_153, _cse_156);
        let _cse_165 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_164 = dot(_cse_165, c_owner_vec - c_neigh_cell_vec);
        let _cse_163 = _cse_164 * 0.125;
        let _cse_162 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_163;
        let _cse_161 = _cse_162 - s_neigh_rho;
        let _cse_160 = s_neigh_rho + _cse_161;
        let _cse_159 = 1.0 / _cse_160;
        let _cse_151 = _cse_152 * _cse_159;
        let _cse_150 = dot(_cse_151, normal_vec);
        let _cse_173 = _cse_160 * constants.eos_r;
        let _cse_172 = _cse_173 * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T);
        let _cse_171 = constants.eos_gamma * _cse_172;
        let _cse_170 = _cse_171 / _cse_160;
        let _cse_169 = _cse_170 + constants.eos_dp_drho;
        let _cse_176 = _cse_150 * _cse_150;
        let _cse_175 = min(_cse_176, _cse_169);
        let _cse_174 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_175;
        let _cse_168 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_169 + _cse_174;
        let _cse_179 = max(_cse_176, low_mach_params.theta_floor * _cse_169);
        let _cse_178 = min(_cse_179, _cse_169);
        let _cse_177 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_178;
        let _cse_167 = _cse_168 + _cse_177;
        let _cse_166 = sqrt(_cse_167);
        a_plus = max(0.0, max(_cse_116 + _cse_137, _cse_150 + _cse_166));
        a_minus = min(0.0, min(_cse_116 - _cse_137, _cse_150 - _cse_166));
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_184 = s_own_rho_u_x;
        let _cse_188 = s_neigh_rho_u_x;
        let _cse_187 = _cse_188 - _cse_184;
        let _cse_186 = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), min(_cse_187, 0.0));
        let _cse_185 = min(_cse_186, max(_cse_187, 0.0));
        let _cse_183 = _cse_184 + _cse_185;
        let _cse_190 = s_own_rho_u_y;
        let _cse_194 = s_neigh_rho_u_y;
        let _cse_193 = _cse_194 - _cse_190;
        let _cse_192 = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), min(_cse_193, 0.0));
        let _cse_191 = min(_cse_192, max(_cse_193, 0.0));
        let _cse_189 = _cse_190 + _cse_191;
        let _cse_182 = vec2<f32>(_cse_183, _cse_189);
        let _cse_198 = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec), min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_197 = min(_cse_198, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_196 = s_own_rho + _cse_197;
        let _cse_195 = 1.0 / _cse_196;
        let _cse_181 = _cse_182 * _cse_195;
        let _cse_180 = dot(_cse_181, normal_vec);
        let _cse_205 = _cse_196 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)));
        let _cse_204 = constants.eos_gamma * _cse_205;
        let _cse_203 = _cse_204 / _cse_196;
        let _cse_202 = _cse_203 + constants.eos_dp_drho;
        let _cse_208 = _cse_180 * _cse_180;
        let _cse_207 = min(_cse_208, _cse_202);
        let _cse_206 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_207;
        let _cse_201 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_202 + _cse_206;
        let _cse_211 = max(_cse_208, low_mach_params.theta_floor * _cse_202);
        let _cse_210 = min(_cse_211, _cse_202);
        let _cse_209 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_210;
        let _cse_200 = _cse_201 + _cse_209;
        let _cse_199 = sqrt(_cse_200);
        let _cse_218 = _cse_184 - _cse_188;
        let _cse_217 = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_218, 0.0));
        let _cse_216 = min(_cse_217, max(_cse_218, 0.0));
        let _cse_215 = _cse_188 + _cse_216;
        let _cse_222 = _cse_190 - _cse_194;
        let _cse_221 = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_222, 0.0));
        let _cse_220 = min(_cse_221, max(_cse_222, 0.0));
        let _cse_219 = _cse_194 + _cse_220;
        let _cse_214 = vec2<f32>(_cse_215, _cse_219);
        let _cse_228 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_227 = dot(_cse_228, face_center_vec - c_neigh_cell_vec);
        let _cse_226 = max(_cse_227, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_225 = min(_cse_226, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_224 = s_neigh_rho + _cse_225;
        let _cse_223 = 1.0 / _cse_224;
        let _cse_213 = _cse_214 * _cse_223;
        let _cse_212 = dot(_cse_213, normal_vec);
        let _cse_236 = _cse_224 * constants.eos_r;
        let _cse_237 = s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0));
        let _cse_235 = _cse_236 * _cse_237;
        let _cse_234 = constants.eos_gamma * _cse_235;
        let _cse_233 = _cse_234 / _cse_224;
        let _cse_232 = _cse_233 + constants.eos_dp_drho;
        let _cse_240 = _cse_212 * _cse_212;
        let _cse_239 = min(_cse_240, _cse_232);
        let _cse_238 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_239;
        let _cse_231 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_232 + _cse_238;
        let _cse_243 = max(_cse_240, low_mach_params.theta_floor * _cse_232);
        let _cse_242 = min(_cse_243, _cse_232);
        let _cse_241 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_242;
        let _cse_230 = _cse_231 + _cse_241;
        let _cse_229 = sqrt(_cse_230);
        a_plus = max(0.0, max(_cse_180 + _cse_199, _cse_212 + _cse_229));
        a_minus = min(0.0, min(_cse_180 - _cse_199, _cse_212 - _cse_229));
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_248 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_257 = dot(_cse_248, _cse_248);
        let _cse_259 = _cse_257 * _cse_257;
        let _cse_258 = _cse_259 + 0.000000000000000000000000000001;
        let _cse_256 = dot(_cse_248, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_257 / _cse_258;
        let _cse_255 = 2.0 * _cse_256;
        let _cse_254 = _cse_255 - 1.0;
        let _cse_253 = min(_cse_254, 1999.0);
        let _cse_252 = max(-2001.0, _cse_253);
        let _cse_260 = abs(_cse_252);
        let _cse_251 = _cse_252 + _cse_260;
        let _cse_250 = _cse_251 / (1.0 + _cse_260);
        let _cse_249 = _cse_250 * lambda_other;
        let _cse_247 = _cse_248 * _cse_249;
        let _cse_246 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_247;
        let _cse_267 = 2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0;
        let _cse_266 = min(_cse_267, 1999.0);
        let _cse_265 = max(-2001.0, _cse_266);
        let _cse_264 = (_cse_265 + abs(_cse_265)) / (1.0 + abs(_cse_265));
        let _cse_263 = _cse_264 * lambda_other;
        let _cse_262 = _cse_263 * (s_neigh_rho - s_own_rho);
        let _cse_261 = s_own_rho + _cse_262;
        let _cse_245 = _cse_246 * 1.0 / _cse_261;
        let _cse_244 = dot(_cse_245, normal_vec);
        let _cse_271 = constants.eos_gamma * _cse_261 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / _cse_261;
        let _cse_270 = _cse_271 + constants.eos_dp_drho;
        let _cse_272 = _cse_244 * _cse_244;
        let _cse_269 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_270 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_272, _cse_270) + max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * min(max(_cse_272, low_mach_params.theta_floor * _cse_270), _cse_270);
        let _cse_268 = sqrt(_cse_269);
        let _cse_285 = dot(_cse_248, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))))) * _cse_257;
        let _cse_284 = _cse_285 / _cse_258;
        let _cse_283 = 2.0 * _cse_284;
        let _cse_282 = _cse_283 - 1.0;
        let _cse_281 = min(_cse_282, 1999.0);
        let _cse_280 = max(-2001.0, _cse_281);
        let _cse_286 = abs(_cse_280);
        let _cse_279 = _cse_280 + _cse_286;
        let _cse_278 = _cse_279 / (1.0 + _cse_286);
        let _cse_277 = _cse_278 * lambda;
        let _cse_276 = _cse_248 * _cse_277;
        let _cse_275 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_276;
        let _cse_296 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001);
        let _cse_295 = 2.0 * _cse_296;
        let _cse_294 = _cse_295 - 1.0;
        let _cse_293 = min(_cse_294, 1999.0);
        let _cse_292 = max(-2001.0, _cse_293);
        let _cse_297 = abs(_cse_292);
        let _cse_291 = _cse_292 + _cse_297;
        let _cse_290 = _cse_291 / (1.0 + _cse_297);
        let _cse_289 = _cse_290 * lambda;
        let _cse_288 = _cse_289 * (s_neigh_rho - s_own_rho);
        let _cse_287 = s_neigh_rho - _cse_288;
        let _cse_274 = _cse_275 * 1.0 / _cse_287;
        let _cse_273 = dot(_cse_274, normal_vec);
        let _cse_304 = _cse_287 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T));
        let _cse_303 = constants.eos_gamma * _cse_304;
        let _cse_302 = _cse_303 / _cse_287;
        let _cse_301 = _cse_302 + constants.eos_dp_drho;
        let _cse_305 = _cse_273 * _cse_273;
        let _cse_300 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_301 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_305, _cse_301);
        let _cse_307 = min(max(_cse_305, low_mach_params.theta_floor * _cse_301), _cse_301);
        let _cse_306 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_307;
        let _cse_299 = _cse_300 + _cse_306;
        let _cse_298 = sqrt(_cse_299);
        a_plus = max(0.0, max(_cse_244 + _cse_268, _cse_273 + _cse_298));
        a_minus = min(0.0, min(_cse_244 - _cse_268, _cse_273 - _cse_298));
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_312 = s_own_rho_u_x;
        let _cse_316 = s_neigh_rho_u_x;
        let _cse_315 = _cse_312 * 0.625 + _cse_316 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_312;
        let _cse_314 = max(_cse_315, min(_cse_316 - _cse_312, 0.0));
        let _cse_313 = min(_cse_314, max(_cse_316 - _cse_312, 0.0));
        let _cse_311 = _cse_312 + _cse_313;
        let _cse_318 = s_own_rho_u_y;
        let _cse_322 = s_neigh_rho_u_y;
        let _cse_321 = _cse_318 * 0.625 + _cse_322 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_318;
        let _cse_320 = max(_cse_321, min(_cse_322 - _cse_318, 0.0));
        let _cse_319 = min(_cse_320, max(_cse_322 - _cse_318, 0.0));
        let _cse_317 = _cse_318 + _cse_319;
        let _cse_310 = vec2<f32>(_cse_311, _cse_317);
        let _cse_327 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_326 = _cse_327 - s_own_rho;
        let _cse_325 = max(_cse_326, min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_324 = min(_cse_325, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_323 = s_own_rho + _cse_324;
        let _cse_309 = _cse_310 * 1.0 / _cse_323;
        let _cse_308 = dot(_cse_309, normal_vec);
        let _cse_334 = _cse_323 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)));
        let _cse_333 = constants.eos_gamma * _cse_334;
        let _cse_332 = _cse_333 / _cse_323;
        let _cse_331 = _cse_332 + constants.eos_dp_drho;
        let _cse_337 = _cse_308 * _cse_308;
        let _cse_336 = min(_cse_337, _cse_331);
        let _cse_335 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_336;
        let _cse_330 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_331 + _cse_335;
        let _cse_340 = max(_cse_337, low_mach_params.theta_floor * _cse_331);
        let _cse_339 = min(_cse_340, _cse_331);
        let _cse_338 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_339;
        let _cse_329 = _cse_330 + _cse_338;
        let _cse_328 = sqrt(_cse_329);
        let _cse_347 = _cse_316 * 0.625 + _cse_312 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_316;
        let _cse_346 = max(_cse_347, min(_cse_312 - _cse_316, 0.0));
        let _cse_345 = min(_cse_346, max(_cse_312 - _cse_316, 0.0));
        let _cse_344 = _cse_316 + _cse_345;
        let _cse_351 = _cse_322 * 0.625 + _cse_318 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_322;
        let _cse_350 = max(_cse_351, min(_cse_318 - _cse_322, 0.0));
        let _cse_349 = min(_cse_350, max(_cse_318 - _cse_322, 0.0));
        let _cse_348 = _cse_322 + _cse_349;
        let _cse_343 = vec2<f32>(_cse_344, _cse_348);
        let _cse_358 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_357 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_358;
        let _cse_356 = _cse_357 - s_neigh_rho;
        let _cse_355 = max(_cse_356, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_354 = min(_cse_355, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_353 = s_neigh_rho + _cse_354;
        let _cse_352 = 1.0 / _cse_353;
        let _cse_342 = _cse_343 * _cse_352;
        let _cse_341 = dot(_cse_342, normal_vec);
        let _cse_365 = _cse_353 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_364 = constants.eos_gamma * _cse_365;
        let _cse_363 = _cse_364 / _cse_353;
        let _cse_362 = _cse_363 + constants.eos_dp_drho;
        let _cse_368 = _cse_341 * _cse_341;
        let _cse_367 = min(_cse_368, _cse_362);
        let _cse_366 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_367;
        let _cse_361 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_362 + _cse_366;
        let _cse_371 = max(_cse_368, low_mach_params.theta_floor * _cse_362);
        let _cse_370 = min(_cse_371, _cse_362);
        let _cse_369 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_370;
        let _cse_360 = _cse_361 + _cse_369;
        let _cse_359 = sqrt(_cse_360);
        a_plus = max(0.0, max(_cse_308 + _cse_328, _cse_341 + _cse_359));
        a_minus = min(0.0, min(_cse_308 - _cse_328, _cse_341 - _cse_359));
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_376 = s_own_rho_u_x;
        let _cse_379 = s_neigh_rho_u_x;
        let _cse_378 = _cse_376 * 0.625 + _cse_379 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_376;
        let _cse_377 = _cse_378 * abs(_cse_379 - _cse_376) / max(abs(_cse_379 - _cse_376), abs(_cse_378) + 0.00000001) * max((_cse_379 - _cse_376) * _cse_378, 0.0) / max(abs((_cse_379 - _cse_376) * _cse_378), 0.00000001);
        let _cse_375 = _cse_376 + _cse_377;
        let _cse_381 = s_own_rho_u_y;
        let _cse_384 = s_neigh_rho_u_y;
        let _cse_383 = _cse_381 * 0.625 + _cse_384 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_381;
        let _cse_382 = _cse_383 * abs(_cse_384 - _cse_381) / max(abs(_cse_384 - _cse_381), abs(_cse_383) + 0.00000001) * max((_cse_384 - _cse_381) * _cse_383, 0.0) / max(abs((_cse_384 - _cse_381) * _cse_383), 0.00000001);
        let _cse_380 = _cse_381 + _cse_382;
        let _cse_374 = vec2<f32>(_cse_375, _cse_380);
        let _cse_389 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_388 = _cse_389 - s_own_rho;
        let _cse_387 = _cse_388 * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(_cse_388) + 0.00000001);
        let _cse_386 = _cse_387 * max((s_neigh_rho - s_own_rho) * _cse_388, 0.0) / max(abs((s_neigh_rho - s_own_rho) * _cse_388), 0.00000001);
        let _cse_385 = s_own_rho + _cse_386;
        let _cse_373 = _cse_374 * 1.0 / _cse_385;
        let _cse_372 = dot(_cse_373, normal_vec);
        let _cse_396 = _cse_385 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001));
        let _cse_395 = constants.eos_gamma * _cse_396;
        let _cse_394 = _cse_395 / _cse_385;
        let _cse_393 = _cse_394 + constants.eos_dp_drho;
        let _cse_399 = _cse_372 * _cse_372;
        let _cse_398 = min(_cse_399, _cse_393);
        let _cse_397 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_398;
        let _cse_392 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_393 + _cse_397;
        let _cse_402 = max(_cse_399, low_mach_params.theta_floor * _cse_393);
        let _cse_401 = min(_cse_402, _cse_393);
        let _cse_400 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_401;
        let _cse_391 = _cse_392 + _cse_400;
        let _cse_390 = sqrt(_cse_391);
        let _cse_409 = _cse_379 * 0.625 + _cse_376 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_408 = _cse_409 - _cse_379;
        let _cse_407 = _cse_408 * abs(_cse_376 - _cse_379) / max(abs(_cse_376 - _cse_379), abs(_cse_408) + 0.00000001) * max((_cse_376 - _cse_379) * _cse_408, 0.0) / max(abs((_cse_376 - _cse_379) * _cse_408), 0.00000001);
        let _cse_406 = _cse_379 + _cse_407;
        let _cse_413 = _cse_384 * 0.625 + _cse_381 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_412 = _cse_413 - _cse_384;
        let _cse_411 = _cse_412 * abs(_cse_381 - _cse_384) / max(abs(_cse_381 - _cse_384), abs(_cse_412) + 0.00000001) * max((_cse_381 - _cse_384) * _cse_412, 0.0) / max(abs((_cse_381 - _cse_384) * _cse_412), 0.00000001);
        let _cse_410 = _cse_384 + _cse_411;
        let _cse_405 = vec2<f32>(_cse_406, _cse_410);
        let _cse_420 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_419 = _cse_420 * 0.125;
        let _cse_418 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_419;
        let _cse_417 = _cse_418 - s_neigh_rho;
        let _cse_416 = _cse_417 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_417) + 0.00000001);
        let _cse_422 = (s_own_rho - s_neigh_rho) * _cse_417;
        let _cse_421 = max(_cse_422, 0.0) / max(abs(_cse_422), 0.00000001);
        let _cse_415 = _cse_416 * _cse_421;
        let _cse_414 = s_neigh_rho + _cse_415;
        let _cse_404 = _cse_405 * 1.0 / _cse_414;
        let _cse_403 = dot(_cse_404, normal_vec);
        let _cse_429 = _cse_414 * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001));
        let _cse_428 = constants.eos_gamma * _cse_429;
        let _cse_427 = _cse_428 / _cse_414;
        let _cse_426 = _cse_427 + constants.eos_dp_drho;
        let _cse_432 = _cse_403 * _cse_403;
        let _cse_431 = min(_cse_432, _cse_426);
        let _cse_430 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_431;
        let _cse_425 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_426 + _cse_430;
        let _cse_435 = max(_cse_432, low_mach_params.theta_floor * _cse_426);
        let _cse_434 = min(_cse_435, _cse_426);
        let _cse_433 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_434;
        let _cse_424 = _cse_425 + _cse_433;
        let _cse_423 = sqrt(_cse_424);
        a_plus = max(0.0, max(_cse_372 + _cse_390, _cse_403 + _cse_423));
        a_minus = min(0.0, min(_cse_372 - _cse_390, _cse_403 - _cse_423));
    }
    let denom = max(a_plus - a_minus, 0.000001);
    let _cse_441 = f32(low_mach_params.model) - 2.0;
    let _cse_440 = abs(_cse_441);
    let _cse_439 = 1.0 - _cse_440;
    let _cse_438 = max(0.0, _cse_439);
    let _cse_437 = 1.0 - _cse_438;
    let _cse_436 = _cse_437 * low_mach_params.pressure_coupling_alpha;
    let _cse_442 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_443 = s_neigh_rho * constants.eos_r * s_neigh_T;
    var u_l_0: f32 = s_own_rho + _cse_436 * _cse_442 / max(constants.eos_gamma * _cse_442 / s_own_rho + constants.eos_dp_drho, 0.000000000001);
    var u_r_0: f32 = s_neigh_rho + _cse_436 * _cse_443 / max(constants.eos_gamma * _cse_443 / s_neigh_rho + constants.eos_dp_drho, 0.000000000001);
    var f_l_0: f32 = s_own_rho * dot(vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) * 1.0 / s_own_rho, normal_vec);
    var f_r_0: f32 = s_neigh_rho * dot(vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) * 1.0 / s_neigh_rho, normal_vec);
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_445 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_444 = s_own_rho + _cse_445;
        let _cse_451 = f32(low_mach_params.model) - 2.0;
        let _cse_450 = abs(_cse_451);
        let _cse_449 = 1.0 - _cse_450;
        let _cse_448 = max(0.0, _cse_449);
        let _cse_447 = 1.0 - _cse_448;
        let _cse_446 = _cse_447 * low_mach_params.pressure_coupling_alpha;
        let _cse_453 = _cse_444 * constants.eos_r;
        let _cse_455 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_454 = s_own_T + _cse_455;
        let _cse_452 = _cse_453 * _cse_454;
        let _cse_458 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_457 = dot(_cse_458, face_center_vec - c_neigh_cell_vec);
        let _cse_456 = s_neigh_rho + _cse_457;
        let _cse_460 = _cse_456 * constants.eos_r;
        let _cse_463 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_462 = dot(_cse_463, face_center_vec - c_neigh_cell_vec);
        let _cse_461 = s_neigh_T + _cse_462;
        let _cse_459 = _cse_460 * _cse_461;
        u_l_0 = _cse_444 + _cse_446 * _cse_452 / max(constants.eos_gamma * _cse_452 / _cse_444 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_456 + _cse_446 * _cse_459 / max(constants.eos_gamma * _cse_459 / _cse_456 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_444 * dot(vec2<f32>(s_own_rho_u_x + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), s_own_rho_u_y + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec)) * 1.0 / _cse_444, normal_vec);
        f_r_0 = _cse_456 * dot(vec2<f32>(s_neigh_rho_u_x + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), s_neigh_rho_u_y + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec)) * 1.0 / _cse_456, normal_vec);
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_467 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_469 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_468 = _cse_469 * 0.125;
        let _cse_466 = _cse_467 + _cse_468;
        let _cse_465 = _cse_466 - s_own_rho;
        let _cse_464 = s_own_rho + _cse_465;
        let _cse_475 = f32(low_mach_params.model) - 2.0;
        let _cse_474 = abs(_cse_475);
        let _cse_473 = 1.0 - _cse_474;
        let _cse_472 = max(0.0, _cse_473);
        let _cse_471 = 1.0 - _cse_472;
        let _cse_470 = _cse_471 * low_mach_params.pressure_coupling_alpha;
        let _cse_477 = _cse_464 * constants.eos_r;
        let _cse_481 = s_own_T * 0.625 + s_neigh_T * 0.375;
        let _cse_483 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_482 = _cse_483 * 0.125;
        let _cse_480 = _cse_481 + _cse_482;
        let _cse_479 = _cse_480 - s_own_T;
        let _cse_478 = s_own_T + _cse_479;
        let _cse_476 = _cse_477 * _cse_478;
        let _cse_487 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_490 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_489 = dot(_cse_490, c_owner_vec - c_neigh_cell_vec);
        let _cse_488 = _cse_489 * 0.125;
        let _cse_486 = _cse_487 + _cse_488;
        let _cse_485 = _cse_486 - s_neigh_rho;
        let _cse_484 = s_neigh_rho + _cse_485;
        let _cse_492 = _cse_484 * constants.eos_r;
        let _cse_496 = s_neigh_T * 0.625 + s_own_T * 0.375;
        let _cse_499 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_498 = dot(_cse_499, c_owner_vec - c_neigh_cell_vec);
        let _cse_497 = _cse_498 * 0.125;
        let _cse_495 = _cse_496 + _cse_497;
        let _cse_494 = _cse_495 - s_neigh_T;
        let _cse_493 = s_neigh_T + _cse_494;
        let _cse_491 = _cse_492 * _cse_493;
        let _cse_500 = s_own_rho_u_x;
        let _cse_501 = s_neigh_rho_u_x;
        let _cse_502 = s_own_rho_u_y;
        let _cse_503 = s_neigh_rho_u_y;
        u_l_0 = _cse_464 + _cse_470 * _cse_476 / max(constants.eos_gamma * _cse_476 / _cse_464 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_484 + _cse_470 * _cse_491 / max(constants.eos_gamma * _cse_491 / _cse_484 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_464 * dot(vec2<f32>(_cse_500 + _cse_500 * 0.625 + _cse_501 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_500, _cse_502 + _cse_502 * 0.625 + _cse_503 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_502) * 1.0 / _cse_464, normal_vec);
        f_r_0 = _cse_484 * dot(vec2<f32>(_cse_501 + _cse_501 * 0.625 + _cse_500 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_501, _cse_503 + _cse_503 * 0.625 + _cse_502 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_503) * 1.0 / _cse_484, normal_vec);
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_507 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_508 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_506 = max(_cse_507, _cse_508);
        let _cse_509 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_505 = min(_cse_506, _cse_509);
        let _cse_504 = s_own_rho + _cse_505;
        let _cse_515 = f32(low_mach_params.model) - 2.0;
        let _cse_514 = abs(_cse_515);
        let _cse_513 = 1.0 - _cse_514;
        let _cse_512 = max(0.0, _cse_513);
        let _cse_511 = 1.0 - _cse_512;
        let _cse_510 = _cse_511 * low_mach_params.pressure_coupling_alpha;
        let _cse_517 = _cse_504 * constants.eos_r;
        let _cse_521 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_522 = min(s_neigh_T - s_own_T, 0.0);
        let _cse_520 = max(_cse_521, _cse_522);
        let _cse_523 = max(s_neigh_T - s_own_T, 0.0);
        let _cse_519 = min(_cse_520, _cse_523);
        let _cse_518 = s_own_T + _cse_519;
        let _cse_516 = _cse_517 * _cse_518;
        let _cse_528 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_527 = dot(_cse_528, face_center_vec - c_neigh_cell_vec);
        let _cse_529 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_526 = max(_cse_527, _cse_529);
        let _cse_530 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_525 = min(_cse_526, _cse_530);
        let _cse_524 = s_neigh_rho + _cse_525;
        let _cse_532 = _cse_524 * constants.eos_r;
        let _cse_537 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_536 = dot(_cse_537, face_center_vec - c_neigh_cell_vec);
        let _cse_538 = min(s_own_T - s_neigh_T, 0.0);
        let _cse_535 = max(_cse_536, _cse_538);
        let _cse_539 = max(s_own_T - s_neigh_T, 0.0);
        let _cse_534 = min(_cse_535, _cse_539);
        let _cse_533 = s_neigh_T + _cse_534;
        let _cse_531 = _cse_532 * _cse_533;
        let _cse_540 = s_own_rho_u_x;
        let _cse_542 = s_neigh_rho_u_x;
        let _cse_541 = _cse_542 - _cse_540;
        let _cse_543 = s_own_rho_u_y;
        let _cse_545 = s_neigh_rho_u_y;
        let _cse_544 = _cse_545 - _cse_543;
        let _cse_546 = _cse_540 - _cse_542;
        let _cse_547 = _cse_543 - _cse_545;
        u_l_0 = _cse_504 + _cse_510 * _cse_516 / max(constants.eos_gamma * _cse_516 / _cse_504 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_524 + _cse_510 * _cse_531 / max(constants.eos_gamma * _cse_531 / _cse_524 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_504 * dot(vec2<f32>(_cse_540 + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), min(_cse_541, 0.0)), max(_cse_541, 0.0)), _cse_543 + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), min(_cse_544, 0.0)), max(_cse_544, 0.0))) * 1.0 / _cse_504, normal_vec);
        f_r_0 = _cse_524 * dot(vec2<f32>(_cse_542 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_546, 0.0)), max(_cse_546, 0.0)), _cse_545 + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(_cse_547, 0.0)), max(_cse_547, 0.0))) * 1.0 / _cse_524, normal_vec);
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_559 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y));
        let _cse_558 = _cse_559 * (s_neigh_rho - s_own_rho);
        let _cse_561 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho);
        let _cse_560 = _cse_561 + 0.000000000000000000000000000001;
        let _cse_557 = _cse_558 / _cse_560;
        let _cse_556 = 2.0 * _cse_557;
        let _cse_555 = _cse_556 - 1.0;
        let _cse_554 = min(_cse_555, 1999.0);
        let _cse_553 = max(-2001.0, _cse_554);
        let _cse_562 = abs(_cse_553);
        let _cse_552 = _cse_553 + _cse_562;
        let _cse_563 = 1.0 + _cse_562;
        let _cse_551 = _cse_552 / _cse_563;
        let _cse_550 = _cse_551 * lambda_other;
        let _cse_549 = _cse_550 * (s_neigh_rho - s_own_rho);
        let _cse_548 = s_own_rho + _cse_549;
        let _cse_568 = 2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001);
        let _cse_567 = _cse_568 - 1.0;
        let _cse_566 = min(_cse_567, 1999.0);
        let _cse_565 = max(-2001.0, _cse_566);
        let _cse_564 = _cse_548 * constants.eos_r * (s_own_T + (_cse_565 + abs(_cse_565)) / (1.0 + abs(_cse_565)) * lambda_other * (s_neigh_T - s_own_T));
        let _cse_581 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_580 = dot(c_neigh_cell_vec - c_owner_vec, _cse_581);
        let _cse_579 = _cse_580 * (s_neigh_rho - s_own_rho);
        let _cse_578 = _cse_579 / _cse_560;
        let _cse_577 = 2.0 * _cse_578;
        let _cse_576 = _cse_577 - 1.0;
        let _cse_575 = min(_cse_576, 1999.0);
        let _cse_574 = max(-2001.0, _cse_575);
        let _cse_582 = abs(_cse_574);
        let _cse_573 = _cse_574 + _cse_582;
        let _cse_583 = 1.0 + _cse_582;
        let _cse_572 = _cse_573 / _cse_583;
        let _cse_571 = _cse_572 * lambda;
        let _cse_570 = _cse_571 * (s_neigh_rho - s_own_rho);
        let _cse_569 = s_neigh_rho - _cse_570;
        let _cse_585 = _cse_569 * constants.eos_r;
        let _cse_594 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001);
        let _cse_593 = 2.0 * _cse_594;
        let _cse_592 = _cse_593 - 1.0;
        let _cse_591 = min(_cse_592, 1999.0);
        let _cse_590 = max(-2001.0, _cse_591);
        let _cse_595 = abs(_cse_590);
        let _cse_589 = (_cse_590 + _cse_595) / (1.0 + _cse_595);
        let _cse_588 = _cse_589 * lambda;
        let _cse_587 = _cse_588 * (s_neigh_T - s_own_T);
        let _cse_586 = s_neigh_T - _cse_587;
        let _cse_584 = _cse_585 * _cse_586;
        let _cse_596 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_602 = dot(_cse_596, _cse_596);
        let _cse_604 = _cse_602 * _cse_602;
        let _cse_603 = _cse_604 + 0.000000000000000000000000000001;
        let _cse_601 = dot(_cse_596, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_602 / _cse_603;
        let _cse_600 = 2.0 * _cse_601;
        let _cse_599 = _cse_600 - 1.0;
        let _cse_598 = min(_cse_599, 1999.0);
        let _cse_597 = max(-2001.0, _cse_598);
        let _cse_610 = dot(_cse_596, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))))) * _cse_602;
        let _cse_609 = _cse_610 / _cse_603;
        let _cse_608 = 2.0 * _cse_609;
        let _cse_607 = _cse_608 - 1.0;
        let _cse_606 = min(_cse_607, 1999.0);
        let _cse_605 = max(-2001.0, _cse_606);
        let _cse_611 = abs(_cse_605);
        u_l_0 = _cse_548 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_564 / max(constants.eos_gamma * _cse_564 / _cse_548 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_569 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_584 / max(constants.eos_gamma * _cse_584 / _cse_569 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_548 * dot((vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_596 * (_cse_597 + abs(_cse_597)) / (1.0 + abs(_cse_597)) * lambda_other) * 1.0 / _cse_548, normal_vec);
        f_r_0 = _cse_569 * dot((vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_596 * (_cse_605 + _cse_611) / (1.0 + _cse_611) * lambda) * 1.0 / _cse_569, normal_vec);
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_617 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_619 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_618 = _cse_619 * 0.125;
        let _cse_616 = _cse_617 + _cse_618;
        let _cse_615 = _cse_616 - s_own_rho;
        let _cse_620 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_614 = max(_cse_615, _cse_620);
        let _cse_621 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_613 = min(_cse_614, _cse_621);
        let _cse_612 = s_own_rho + _cse_613;
        let _cse_627 = f32(low_mach_params.model) - 2.0;
        let _cse_626 = abs(_cse_627);
        let _cse_625 = 1.0 - _cse_626;
        let _cse_624 = max(0.0, _cse_625);
        let _cse_623 = 1.0 - _cse_624;
        let _cse_622 = _cse_623 * low_mach_params.pressure_coupling_alpha;
        let _cse_629 = _cse_612 * constants.eos_r;
        let _cse_635 = s_own_T * 0.625 + s_neigh_T * 0.375;
        let _cse_637 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_636 = _cse_637 * 0.125;
        let _cse_634 = _cse_635 + _cse_636;
        let _cse_633 = _cse_634 - s_own_T;
        let _cse_638 = min(s_neigh_T - s_own_T, 0.0);
        let _cse_632 = max(_cse_633, _cse_638);
        let _cse_639 = max(s_neigh_T - s_own_T, 0.0);
        let _cse_631 = min(_cse_632, _cse_639);
        let _cse_630 = s_own_T + _cse_631;
        let _cse_628 = _cse_629 * _cse_630;
        let _cse_645 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_648 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_647 = dot(_cse_648, c_owner_vec - c_neigh_cell_vec);
        let _cse_646 = _cse_647 * 0.125;
        let _cse_644 = _cse_645 + _cse_646;
        let _cse_643 = _cse_644 - s_neigh_rho;
        let _cse_649 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_642 = max(_cse_643, _cse_649);
        let _cse_650 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_641 = min(_cse_642, _cse_650);
        let _cse_640 = s_neigh_rho + _cse_641;
        let _cse_652 = _cse_640 * constants.eos_r;
        let _cse_658 = s_neigh_T * 0.625 + s_own_T * 0.375;
        let _cse_661 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_660 = dot(_cse_661, c_owner_vec - c_neigh_cell_vec);
        let _cse_659 = _cse_660 * 0.125;
        let _cse_657 = _cse_658 + _cse_659;
        let _cse_656 = _cse_657 - s_neigh_T;
        let _cse_662 = min(s_own_T - s_neigh_T, 0.0);
        let _cse_655 = max(_cse_656, _cse_662);
        let _cse_663 = max(s_own_T - s_neigh_T, 0.0);
        let _cse_654 = min(_cse_655, _cse_663);
        let _cse_653 = s_neigh_T + _cse_654;
        let _cse_651 = _cse_652 * _cse_653;
        let _cse_664 = s_own_rho_u_x;
        let _cse_665 = s_neigh_rho_u_x;
        let _cse_666 = _cse_665 - _cse_664;
        let _cse_667 = s_own_rho_u_y;
        let _cse_668 = s_neigh_rho_u_y;
        let _cse_669 = _cse_668 - _cse_667;
        let _cse_670 = _cse_664 - _cse_665;
        let _cse_671 = _cse_667 - _cse_668;
        u_l_0 = _cse_612 + _cse_622 * _cse_628 / max(constants.eos_gamma * _cse_628 / _cse_612 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_640 + _cse_622 * _cse_651 / max(constants.eos_gamma * _cse_651 / _cse_640 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_612 * dot(vec2<f32>(_cse_664 + min(max(_cse_664 * 0.625 + _cse_665 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_664, min(_cse_666, 0.0)), max(_cse_666, 0.0)), _cse_667 + min(max(_cse_667 * 0.625 + _cse_668 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - _cse_667, min(_cse_669, 0.0)), max(_cse_669, 0.0))) * 1.0 / _cse_612, normal_vec);
        f_r_0 = _cse_640 * dot(vec2<f32>(_cse_665 + min(max(_cse_665 * 0.625 + _cse_664 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_665, min(_cse_670, 0.0)), max(_cse_670, 0.0)), _cse_668 + min(max(_cse_668 * 0.625 + _cse_667 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - _cse_668, min(_cse_671, 0.0)), max(_cse_671, 0.0))) * 1.0 / _cse_640, normal_vec);
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_677 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_679 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_678 = _cse_679 * 0.125;
        let _cse_676 = _cse_677 + _cse_678;
        let _cse_675 = _cse_676 - s_own_rho;
        let _cse_683 = abs(_cse_675);
        let _cse_682 = _cse_683 + 0.00000001;
        let _cse_681 = max(abs(s_neigh_rho - s_own_rho), _cse_682);
        let _cse_680 = abs(s_neigh_rho - s_own_rho) / _cse_681;
        let _cse_674 = _cse_675 * _cse_680;
        let _cse_686 = (s_neigh_rho - s_own_rho) * _cse_675;
        let _cse_685 = max(_cse_686, 0.0);
        let _cse_688 = abs(_cse_686);
        let _cse_687 = max(_cse_688, 0.00000001);
        let _cse_684 = _cse_685 / _cse_687;
        let _cse_673 = _cse_674 * _cse_684;
        let _cse_672 = s_own_rho + _cse_673;
        let _cse_690 = _cse_672 * constants.eos_r;
        let _cse_694 = s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_693 = _cse_694 - s_own_T;
        let _cse_692 = _cse_693 * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(_cse_693) + 0.00000001) * max((s_neigh_T - s_own_T) * _cse_693, 0.0) / max(abs((s_neigh_T - s_own_T) * _cse_693), 0.00000001);
        let _cse_691 = s_own_T + _cse_692;
        let _cse_689 = _cse_690 * _cse_691;
        let _cse_700 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_703 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_702 = dot(_cse_703, c_owner_vec - c_neigh_cell_vec);
        let _cse_701 = _cse_702 * 0.125;
        let _cse_699 = _cse_700 + _cse_701;
        let _cse_698 = _cse_699 - s_neigh_rho;
        let _cse_707 = abs(_cse_698);
        let _cse_706 = _cse_707 + 0.00000001;
        let _cse_705 = max(abs(s_own_rho - s_neigh_rho), _cse_706);
        let _cse_704 = abs(s_own_rho - s_neigh_rho) / _cse_705;
        let _cse_697 = _cse_698 * _cse_704;
        let _cse_710 = (s_own_rho - s_neigh_rho) * _cse_698;
        let _cse_709 = max(_cse_710, 0.0);
        let _cse_712 = abs(_cse_710);
        let _cse_711 = max(_cse_712, 0.00000001);
        let _cse_708 = _cse_709 / _cse_711;
        let _cse_696 = _cse_697 * _cse_708;
        let _cse_695 = s_neigh_rho + _cse_696;
        let _cse_714 = _cse_695 * constants.eos_r;
        let _cse_721 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_720 = dot(_cse_721, c_owner_vec - c_neigh_cell_vec);
        let _cse_719 = _cse_720 * 0.125;
        let _cse_718 = s_neigh_T * 0.625 + s_own_T * 0.375 + _cse_719;
        let _cse_717 = _cse_718 - s_neigh_T;
        let _cse_722 = (s_own_T - s_neigh_T) * _cse_717;
        let _cse_716 = _cse_717 * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(_cse_717) + 0.00000001) * max(_cse_722, 0.0) / max(abs(_cse_722), 0.00000001);
        let _cse_715 = s_neigh_T + _cse_716;
        let _cse_713 = _cse_714 * _cse_715;
        let _cse_723 = s_own_rho_u_x;
        let _cse_726 = s_neigh_rho_u_x;
        let _cse_725 = _cse_723 * 0.625 + _cse_726 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_724 = _cse_725 - _cse_723;
        let _cse_727 = s_own_rho_u_y;
        let _cse_730 = s_neigh_rho_u_y;
        let _cse_729 = _cse_727 * 0.625 + _cse_730 * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_728 = _cse_729 - _cse_727;
        let _cse_732 = _cse_726 * 0.625 + _cse_723 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_731 = _cse_732 - _cse_726;
        let _cse_733 = (_cse_723 - _cse_726) * _cse_731;
        let _cse_735 = _cse_730 * 0.625 + _cse_727 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_734 = _cse_735 - _cse_730;
        u_l_0 = _cse_672 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_689 / max(constants.eos_gamma * _cse_689 / _cse_672 + constants.eos_dp_drho, 0.000000000001);
        u_r_0 = _cse_695 + (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * low_mach_params.pressure_coupling_alpha * _cse_713 / max(constants.eos_gamma * _cse_713 / _cse_695 + constants.eos_dp_drho, 0.000000000001);
        f_l_0 = _cse_672 * dot(vec2<f32>(_cse_723 + _cse_724 * abs(_cse_726 - _cse_723) / max(abs(_cse_726 - _cse_723), abs(_cse_724) + 0.00000001) * max((_cse_726 - _cse_723) * _cse_724, 0.0) / max(abs((_cse_726 - _cse_723) * _cse_724), 0.00000001), _cse_727 + _cse_728 * abs(_cse_730 - _cse_727) / max(abs(_cse_730 - _cse_727), abs(_cse_728) + 0.00000001) * max((_cse_730 - _cse_727) * _cse_728, 0.0) / max(abs((_cse_730 - _cse_727) * _cse_728), 0.00000001)) * 1.0 / _cse_672, normal_vec);
        f_r_0 = _cse_695 * dot(vec2<f32>(_cse_726 + _cse_731 * abs(_cse_723 - _cse_726) / max(abs(_cse_723 - _cse_726), abs(_cse_731) + 0.00000001) * max(_cse_733, 0.0) / max(abs(_cse_733), 0.00000001), _cse_730 + _cse_734 * abs(_cse_727 - _cse_730) / max(abs(_cse_727 - _cse_730), abs(_cse_734) + 0.00000001) * max((_cse_727 - _cse_730) * _cse_734, 0.0) / max(abs((_cse_727 - _cse_730) * _cse_734), 0.00000001)) * 1.0 / _cse_695, normal_vec);
    }
    fluxes[idx * 8u + 0u] = (a_plus * f_l_0 - a_minus * f_r_0 + a_plus * a_minus * (u_r_0 - u_l_0)) / denom * area;
    let _cse_738 = s_own_rho_u_x;
    let _cse_739 = s_own_rho_u_y;
    let _cse_737 = vec2<f32>(_cse_738, _cse_739);
    let _cse_736 = _cse_737.x;
    let _cse_742 = s_neigh_rho_u_x;
    let _cse_743 = s_neigh_rho_u_y;
    let _cse_741 = vec2<f32>(_cse_742, _cse_743);
    let _cse_740 = _cse_741.x;
    let _cse_744 = normal_vec.x;
    var u_l_1: f32 = _cse_736;
    var u_r_1: f32 = _cse_740;
    var f_l_1: f32 = _cse_736 * dot(_cse_737 * 1.0 / s_own_rho, normal_vec) + s_own_rho * constants.eos_r * s_own_T * _cse_744;
    var f_r_1: f32 = _cse_740 * dot(_cse_741 * 1.0 / s_neigh_rho, normal_vec) + s_neigh_rho * constants.eos_r * s_neigh_T * _cse_744;
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_748 = s_own_rho_u_x;
        let _cse_749 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_747 = _cse_748 + _cse_749;
        let _cse_751 = s_own_rho_u_y;
        let _cse_752 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_750 = _cse_751 + _cse_752;
        let _cse_746 = vec2<f32>(_cse_747, _cse_750);
        let _cse_745 = _cse_746.x;
        let _cse_756 = s_neigh_rho_u_x;
        let _cse_758 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_757 = dot(_cse_758, face_center_vec - c_neigh_cell_vec);
        let _cse_755 = _cse_756 + _cse_757;
        let _cse_760 = s_neigh_rho_u_y;
        let _cse_762 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_761 = dot(_cse_762, face_center_vec - c_neigh_cell_vec);
        let _cse_759 = _cse_760 + _cse_761;
        let _cse_754 = vec2<f32>(_cse_755, _cse_759);
        let _cse_753 = _cse_754.x;
        let _cse_764 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_763 = s_own_rho + _cse_764;
        let _cse_765 = normal_vec.x;
        let _cse_768 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_767 = dot(_cse_768, face_center_vec - c_neigh_cell_vec);
        let _cse_766 = s_neigh_rho + _cse_767;
        u_l_1 = _cse_745;
        u_r_1 = _cse_753;
        f_l_1 = _cse_745 * dot(_cse_746 * 1.0 / _cse_763, normal_vec) + _cse_763 * constants.eos_r * (s_own_T + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec)) * _cse_765;
        f_r_1 = _cse_753 * dot(_cse_754 * 1.0 / _cse_766, normal_vec) + _cse_766 * constants.eos_r * (s_neigh_T + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec)) * _cse_765;
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_772 = s_own_rho_u_x;
        let _cse_776 = _cse_772 * 0.625;
        let _cse_778 = s_neigh_rho_u_x;
        let _cse_777 = _cse_778 * 0.375;
        let _cse_775 = _cse_776 + _cse_777;
        let _cse_780 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_779 = _cse_780 * 0.125;
        let _cse_774 = _cse_775 + _cse_779;
        let _cse_773 = _cse_774 - _cse_772;
        let _cse_771 = _cse_772 + _cse_773;
        let _cse_782 = s_own_rho_u_y;
        let _cse_786 = _cse_782 * 0.625;
        let _cse_788 = s_neigh_rho_u_y;
        let _cse_787 = _cse_788 * 0.375;
        let _cse_785 = _cse_786 + _cse_787;
        let _cse_790 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_789 = _cse_790 * 0.125;
        let _cse_784 = _cse_785 + _cse_789;
        let _cse_783 = _cse_784 - _cse_782;
        let _cse_781 = _cse_782 + _cse_783;
        let _cse_770 = vec2<f32>(_cse_771, _cse_781);
        let _cse_769 = _cse_770.x;
        let _cse_797 = _cse_778 * 0.625;
        let _cse_798 = _cse_772 * 0.375;
        let _cse_796 = _cse_797 + _cse_798;
        let _cse_801 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_800 = dot(_cse_801, c_owner_vec - c_neigh_cell_vec);
        let _cse_799 = _cse_800 * 0.125;
        let _cse_795 = _cse_796 + _cse_799;
        let _cse_794 = _cse_795 - _cse_778;
        let _cse_793 = _cse_778 + _cse_794;
        let _cse_806 = _cse_788 * 0.625;
        let _cse_807 = _cse_782 * 0.375;
        let _cse_805 = _cse_806 + _cse_807;
        let _cse_810 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_809 = dot(_cse_810, c_owner_vec - c_neigh_cell_vec);
        let _cse_808 = _cse_809 * 0.125;
        let _cse_804 = _cse_805 + _cse_808;
        let _cse_803 = _cse_804 - _cse_788;
        let _cse_802 = _cse_788 + _cse_803;
        let _cse_792 = vec2<f32>(_cse_793, _cse_802);
        let _cse_791 = _cse_792.x;
        let _cse_814 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_816 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_815 = _cse_816 * 0.125;
        let _cse_813 = _cse_814 + _cse_815;
        let _cse_812 = _cse_813 - s_own_rho;
        let _cse_811 = s_own_rho + _cse_812;
        let _cse_817 = normal_vec.x;
        let _cse_821 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_824 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_823 = dot(_cse_824, c_owner_vec - c_neigh_cell_vec);
        let _cse_822 = _cse_823 * 0.125;
        let _cse_820 = _cse_821 + _cse_822;
        let _cse_819 = _cse_820 - s_neigh_rho;
        let _cse_818 = s_neigh_rho + _cse_819;
        u_l_1 = _cse_769;
        u_r_1 = _cse_791;
        f_l_1 = _cse_769 * dot(_cse_770 * 1.0 / _cse_811, normal_vec) + _cse_811 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * _cse_817;
        f_r_1 = _cse_791 * dot(_cse_792 * 1.0 / _cse_818, normal_vec) + _cse_818 * constants.eos_r * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * _cse_817;
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_828 = s_own_rho_u_x;
        let _cse_831 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_834 = s_neigh_rho_u_x;
        let _cse_833 = _cse_834 - _cse_828;
        let _cse_832 = min(_cse_833, 0.0);
        let _cse_830 = max(_cse_831, _cse_832);
        let _cse_835 = max(_cse_833, 0.0);
        let _cse_829 = min(_cse_830, _cse_835);
        let _cse_827 = _cse_828 + _cse_829;
        let _cse_837 = s_own_rho_u_y;
        let _cse_840 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_843 = s_neigh_rho_u_y;
        let _cse_842 = _cse_843 - _cse_837;
        let _cse_841 = min(_cse_842, 0.0);
        let _cse_839 = max(_cse_840, _cse_841);
        let _cse_844 = max(_cse_842, 0.0);
        let _cse_838 = min(_cse_839, _cse_844);
        let _cse_836 = _cse_837 + _cse_838;
        let _cse_826 = vec2<f32>(_cse_827, _cse_836);
        let _cse_825 = _cse_826.x;
        let _cse_851 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_850 = dot(_cse_851, face_center_vec - c_neigh_cell_vec);
        let _cse_853 = _cse_828 - _cse_834;
        let _cse_852 = min(_cse_853, 0.0);
        let _cse_849 = max(_cse_850, _cse_852);
        let _cse_854 = max(_cse_853, 0.0);
        let _cse_848 = min(_cse_849, _cse_854);
        let _cse_847 = _cse_834 + _cse_848;
        let _cse_859 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_858 = dot(_cse_859, face_center_vec - c_neigh_cell_vec);
        let _cse_861 = _cse_837 - _cse_843;
        let _cse_860 = min(_cse_861, 0.0);
        let _cse_857 = max(_cse_858, _cse_860);
        let _cse_862 = max(_cse_861, 0.0);
        let _cse_856 = min(_cse_857, _cse_862);
        let _cse_855 = _cse_843 + _cse_856;
        let _cse_846 = vec2<f32>(_cse_847, _cse_855);
        let _cse_845 = _cse_846.x;
        let _cse_866 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_867 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_865 = max(_cse_866, _cse_867);
        let _cse_868 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_864 = min(_cse_865, _cse_868);
        let _cse_863 = s_own_rho + _cse_864;
        let _cse_869 = normal_vec.x;
        let _cse_874 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_873 = dot(_cse_874, face_center_vec - c_neigh_cell_vec);
        let _cse_875 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_872 = max(_cse_873, _cse_875);
        let _cse_876 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_871 = min(_cse_872, _cse_876);
        let _cse_870 = s_neigh_rho + _cse_871;
        u_l_1 = _cse_825;
        u_r_1 = _cse_845;
        f_l_1 = _cse_825 * dot(_cse_826 * 1.0 / _cse_863, normal_vec) + _cse_863 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * _cse_869;
        f_r_1 = _cse_845 * dot(_cse_846 * 1.0 / _cse_870, normal_vec) + _cse_870 * constants.eos_r * (s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * _cse_869;
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_880 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_891 = vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_890 = dot(_cse_880, _cse_891);
        let _cse_892 = dot(_cse_880, _cse_880);
        let _cse_889 = _cse_890 * _cse_892;
        let _cse_894 = _cse_892 * _cse_892;
        let _cse_893 = _cse_894 + 0.000000000000000000000000000001;
        let _cse_888 = _cse_889 / _cse_893;
        let _cse_887 = 2.0 * _cse_888;
        let _cse_886 = _cse_887 - 1.0;
        let _cse_885 = min(_cse_886, 1999.0);
        let _cse_884 = max(-2001.0, _cse_885);
        let _cse_895 = abs(_cse_884);
        let _cse_883 = _cse_884 + _cse_895;
        let _cse_896 = 1.0 + _cse_895;
        let _cse_882 = _cse_883 / _cse_896;
        let _cse_881 = _cse_882 * lambda_other;
        let _cse_879 = _cse_880 * _cse_881;
        let _cse_878 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_879;
        let _cse_877 = _cse_878.x;
        let _cse_912 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_911 = dot(c_neigh_cell_vec - c_owner_vec, _cse_912);
        let _cse_914 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_913 = dot(c_neigh_cell_vec - c_owner_vec, _cse_914);
        let _cse_910 = vec2<f32>(_cse_911, _cse_913);
        let _cse_909 = dot(_cse_880, _cse_910);
        let _cse_908 = _cse_909 * _cse_892;
        let _cse_907 = _cse_908 / _cse_893;
        let _cse_906 = 2.0 * _cse_907;
        let _cse_905 = _cse_906 - 1.0;
        let _cse_904 = min(_cse_905, 1999.0);
        let _cse_903 = max(-2001.0, _cse_904);
        let _cse_915 = abs(_cse_903);
        let _cse_902 = _cse_903 + _cse_915;
        let _cse_916 = 1.0 + _cse_915;
        let _cse_901 = _cse_902 / _cse_916;
        let _cse_900 = _cse_901 * lambda;
        let _cse_899 = _cse_880 * _cse_900;
        let _cse_898 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_899;
        let _cse_897 = _cse_898.x;
        let _cse_926 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001;
        let _cse_925 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / _cse_926;
        let _cse_924 = 2.0 * _cse_925;
        let _cse_923 = _cse_924 - 1.0;
        let _cse_922 = min(_cse_923, 1999.0);
        let _cse_921 = max(-2001.0, _cse_922);
        let _cse_927 = abs(_cse_921);
        let _cse_920 = (_cse_921 + _cse_927) / (1.0 + _cse_927);
        let _cse_919 = _cse_920 * lambda_other;
        let _cse_918 = _cse_919 * (s_neigh_rho - s_own_rho);
        let _cse_917 = s_own_rho + _cse_918;
        let _cse_939 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)));
        let _cse_938 = _cse_939 * (s_neigh_rho - s_own_rho);
        let _cse_937 = _cse_938 / _cse_926;
        let _cse_936 = 2.0 * _cse_937;
        let _cse_935 = _cse_936 - 1.0;
        let _cse_934 = min(_cse_935, 1999.0);
        let _cse_933 = max(-2001.0, _cse_934);
        let _cse_940 = abs(_cse_933);
        let _cse_932 = _cse_933 + _cse_940;
        let _cse_931 = _cse_932 / (1.0 + _cse_940);
        let _cse_930 = _cse_931 * lambda;
        let _cse_929 = _cse_930 * (s_neigh_rho - s_own_rho);
        let _cse_928 = s_neigh_rho - _cse_929;
        u_l_1 = _cse_877;
        u_r_1 = _cse_897;
        f_l_1 = _cse_877 * dot(_cse_878 * 1.0 / _cse_917, normal_vec) + _cse_917 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) * normal_vec.x;
        f_r_1 = _cse_897 * dot(_cse_898 * 1.0 / _cse_928, normal_vec) + _cse_928 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) * normal_vec.x;
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_944 = s_own_rho_u_x;
        let _cse_950 = _cse_944 * 0.625;
        let _cse_952 = s_neigh_rho_u_x;
        let _cse_951 = _cse_952 * 0.375;
        let _cse_949 = _cse_950 + _cse_951;
        let _cse_948 = _cse_949 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_947 = _cse_948 - _cse_944;
        let _cse_954 = _cse_952 - _cse_944;
        let _cse_953 = min(_cse_954, 0.0);
        let _cse_946 = max(_cse_947, _cse_953);
        let _cse_955 = max(_cse_954, 0.0);
        let _cse_945 = min(_cse_946, _cse_955);
        let _cse_943 = _cse_944 + _cse_945;
        let _cse_957 = s_own_rho_u_y;
        let _cse_963 = _cse_957 * 0.625;
        let _cse_965 = s_neigh_rho_u_y;
        let _cse_964 = _cse_965 * 0.375;
        let _cse_962 = _cse_963 + _cse_964;
        let _cse_961 = _cse_962 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_960 = _cse_961 - _cse_957;
        let _cse_967 = _cse_965 - _cse_957;
        let _cse_966 = min(_cse_967, 0.0);
        let _cse_959 = max(_cse_960, _cse_966);
        let _cse_968 = max(_cse_967, 0.0);
        let _cse_958 = min(_cse_959, _cse_968);
        let _cse_956 = _cse_957 + _cse_958;
        let _cse_942 = vec2<f32>(_cse_943, _cse_956);
        let _cse_941 = _cse_942.x;
        let _cse_977 = _cse_952 * 0.625;
        let _cse_978 = _cse_944 * 0.375;
        let _cse_976 = _cse_977 + _cse_978;
        let _cse_981 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_980 = dot(_cse_981, c_owner_vec - c_neigh_cell_vec);
        let _cse_979 = _cse_980 * 0.125;
        let _cse_975 = _cse_976 + _cse_979;
        let _cse_974 = _cse_975 - _cse_952;
        let _cse_983 = _cse_944 - _cse_952;
        let _cse_982 = min(_cse_983, 0.0);
        let _cse_973 = max(_cse_974, _cse_982);
        let _cse_984 = max(_cse_983, 0.0);
        let _cse_972 = min(_cse_973, _cse_984);
        let _cse_971 = _cse_952 + _cse_972;
        let _cse_991 = _cse_965 * 0.625;
        let _cse_990 = _cse_991 + _cse_957 * 0.375;
        let _cse_993 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_992 = _cse_993 * 0.125;
        let _cse_989 = _cse_990 + _cse_992;
        let _cse_988 = _cse_989 - _cse_965;
        let _cse_995 = _cse_957 - _cse_965;
        let _cse_994 = min(_cse_995, 0.0);
        let _cse_987 = max(_cse_988, _cse_994);
        let _cse_996 = max(_cse_995, 0.0);
        let _cse_986 = min(_cse_987, _cse_996);
        let _cse_985 = _cse_965 + _cse_986;
        let _cse_970 = vec2<f32>(_cse_971, _cse_985);
        let _cse_969 = _cse_970.x;
        let _cse_999 = max(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho, min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_998 = min(_cse_999, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_997 = s_own_rho + _cse_998;
        let _cse_1004 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1003 = _cse_1004 - s_neigh_rho;
        let _cse_1002 = max(_cse_1003, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1001 = min(_cse_1002, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1000 = s_neigh_rho + _cse_1001;
        u_l_1 = _cse_941;
        u_r_1 = _cse_969;
        f_l_1 = _cse_941 * dot(_cse_942 * 1.0 / _cse_997, normal_vec) + _cse_997 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * normal_vec.x;
        f_r_1 = _cse_969 * dot(_cse_970 * 1.0 / _cse_1000, normal_vec) + _cse_1000 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * normal_vec.x;
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_1008 = s_own_rho_u_x;
        let _cse_1014 = s_neigh_rho_u_x;
        let _cse_1013 = _cse_1008 * 0.625 + _cse_1014 * 0.375;
        let _cse_1012 = _cse_1013 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1011 = _cse_1012 - _cse_1008;
        let _cse_1016 = _cse_1014 - _cse_1008;
        let _cse_1017 = max(abs(_cse_1016), abs(_cse_1011) + 0.00000001);
        let _cse_1015 = abs(_cse_1016) / _cse_1017;
        let _cse_1010 = _cse_1011 * _cse_1015;
        let _cse_1019 = _cse_1016 * _cse_1011;
        let _cse_1018 = max(_cse_1019, 0.0) / max(abs(_cse_1019), 0.00000001);
        let _cse_1009 = _cse_1010 * _cse_1018;
        let _cse_1007 = _cse_1008 + _cse_1009;
        let _cse_1021 = s_own_rho_u_y;
        let _cse_1027 = s_neigh_rho_u_y;
        let _cse_1026 = _cse_1021 * 0.625 + _cse_1027 * 0.375;
        let _cse_1025 = _cse_1026 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1024 = _cse_1025 - _cse_1021;
        let _cse_1029 = _cse_1027 - _cse_1021;
        let _cse_1030 = max(abs(_cse_1029), abs(_cse_1024) + 0.00000001);
        let _cse_1028 = abs(_cse_1029) / _cse_1030;
        let _cse_1023 = _cse_1024 * _cse_1028;
        let _cse_1032 = _cse_1029 * _cse_1024;
        let _cse_1031 = max(_cse_1032, 0.0) / max(abs(_cse_1032), 0.00000001);
        let _cse_1022 = _cse_1023 * _cse_1031;
        let _cse_1020 = _cse_1021 + _cse_1022;
        let _cse_1006 = vec2<f32>(_cse_1007, _cse_1020);
        let _cse_1005 = _cse_1006.x;
        let _cse_1040 = _cse_1014 * 0.625 + _cse_1008 * 0.375;
        let _cse_1042 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1041 = _cse_1042 * 0.125;
        let _cse_1039 = _cse_1040 + _cse_1041;
        let _cse_1038 = _cse_1039 - _cse_1014;
        let _cse_1044 = _cse_1008 - _cse_1014;
        let _cse_1045 = max(abs(_cse_1044), abs(_cse_1038) + 0.00000001);
        let _cse_1043 = abs(_cse_1044) / _cse_1045;
        let _cse_1037 = _cse_1038 * _cse_1043;
        let _cse_1048 = _cse_1044 * _cse_1038;
        let _cse_1047 = max(_cse_1048, 0.0);
        let _cse_1050 = abs(_cse_1048);
        let _cse_1049 = max(_cse_1050, 0.00000001);
        let _cse_1046 = _cse_1047 / _cse_1049;
        let _cse_1036 = _cse_1037 * _cse_1046;
        let _cse_1035 = _cse_1014 + _cse_1036;
        let _cse_1056 = _cse_1027 * 0.625 + _cse_1021 * 0.375;
        let _cse_1058 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1057 = _cse_1058 * 0.125;
        let _cse_1055 = _cse_1056 + _cse_1057;
        let _cse_1054 = _cse_1055 - _cse_1027;
        let _cse_1060 = _cse_1021 - _cse_1027;
        let _cse_1061 = max(abs(_cse_1060), abs(_cse_1054) + 0.00000001);
        let _cse_1059 = abs(_cse_1060) / _cse_1061;
        let _cse_1053 = _cse_1054 * _cse_1059;
        let _cse_1064 = _cse_1060 * _cse_1054;
        let _cse_1063 = max(_cse_1064, 0.0);
        let _cse_1066 = abs(_cse_1064);
        let _cse_1065 = max(_cse_1066, 0.00000001);
        let _cse_1062 = _cse_1063 / _cse_1065;
        let _cse_1052 = _cse_1053 * _cse_1062;
        let _cse_1051 = _cse_1027 + _cse_1052;
        let _cse_1034 = vec2<f32>(_cse_1035, _cse_1051);
        let _cse_1033 = _cse_1034.x;
        let _cse_1068 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1067 = _cse_1068 - s_neigh_rho;
        u_l_1 = _cse_1005;
        u_r_1 = _cse_1033;
        f_l_1 = _cse_1005 * dot(_cse_1006 * 1.0 / (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)), normal_vec) + (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)) * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) * normal_vec.x;
        f_r_1 = _cse_1033 * dot(_cse_1034 * 1.0 / (s_neigh_rho + _cse_1067 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1067) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1067, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1067), 0.00000001)), normal_vec) + (s_neigh_rho + _cse_1067 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1067) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1067, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1067), 0.00000001)) * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001)) * normal_vec.x;
    }
    fluxes[idx * 8u + 1u] = (a_plus * f_l_1 - a_minus * f_r_1 + a_plus * a_minus * (u_r_1 - u_l_1)) / denom * area;
    let _cse_1071 = s_own_rho_u_x;
    let _cse_1072 = s_own_rho_u_y;
    let _cse_1070 = vec2<f32>(_cse_1071, _cse_1072);
    let _cse_1069 = _cse_1070.y;
    let _cse_1075 = s_neigh_rho_u_x;
    let _cse_1076 = s_neigh_rho_u_y;
    let _cse_1074 = vec2<f32>(_cse_1075, _cse_1076);
    let _cse_1073 = _cse_1074.y;
    let _cse_1077 = normal_vec.y;
    var u_l_2: f32 = _cse_1069;
    var u_r_2: f32 = _cse_1073;
    var f_l_2: f32 = _cse_1069 * dot(_cse_1070 * 1.0 / s_own_rho, normal_vec) + s_own_rho * constants.eos_r * s_own_T * _cse_1077;
    var f_r_2: f32 = _cse_1073 * dot(_cse_1074 * 1.0 / s_neigh_rho, normal_vec) + s_neigh_rho * constants.eos_r * s_neigh_T * _cse_1077;
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_1081 = s_own_rho_u_x;
        let _cse_1082 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_1080 = _cse_1081 + _cse_1082;
        let _cse_1084 = s_own_rho_u_y;
        let _cse_1085 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_1083 = _cse_1084 + _cse_1085;
        let _cse_1079 = vec2<f32>(_cse_1080, _cse_1083);
        let _cse_1078 = _cse_1079.y;
        let _cse_1089 = s_neigh_rho_u_x;
        let _cse_1091 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1090 = dot(_cse_1091, face_center_vec - c_neigh_cell_vec);
        let _cse_1088 = _cse_1089 + _cse_1090;
        let _cse_1093 = s_neigh_rho_u_y;
        let _cse_1095 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1094 = dot(_cse_1095, face_center_vec - c_neigh_cell_vec);
        let _cse_1092 = _cse_1093 + _cse_1094;
        let _cse_1087 = vec2<f32>(_cse_1088, _cse_1092);
        let _cse_1086 = _cse_1087.y;
        let _cse_1097 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1096 = s_own_rho + _cse_1097;
        let _cse_1098 = normal_vec.y;
        let _cse_1101 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1100 = dot(_cse_1101, face_center_vec - c_neigh_cell_vec);
        let _cse_1099 = s_neigh_rho + _cse_1100;
        u_l_2 = _cse_1078;
        u_r_2 = _cse_1086;
        f_l_2 = _cse_1078 * dot(_cse_1079 * 1.0 / _cse_1096, normal_vec) + _cse_1096 * constants.eos_r * (s_own_T + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec)) * _cse_1098;
        f_r_2 = _cse_1086 * dot(_cse_1087 * 1.0 / _cse_1099, normal_vec) + _cse_1099 * constants.eos_r * (s_neigh_T + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec)) * _cse_1098;
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_1105 = s_own_rho_u_x;
        let _cse_1109 = _cse_1105 * 0.625;
        let _cse_1111 = s_neigh_rho_u_x;
        let _cse_1110 = _cse_1111 * 0.375;
        let _cse_1108 = _cse_1109 + _cse_1110;
        let _cse_1113 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_1112 = _cse_1113 * 0.125;
        let _cse_1107 = _cse_1108 + _cse_1112;
        let _cse_1106 = _cse_1107 - _cse_1105;
        let _cse_1104 = _cse_1105 + _cse_1106;
        let _cse_1115 = s_own_rho_u_y;
        let _cse_1119 = _cse_1115 * 0.625;
        let _cse_1121 = s_neigh_rho_u_y;
        let _cse_1120 = _cse_1121 * 0.375;
        let _cse_1118 = _cse_1119 + _cse_1120;
        let _cse_1123 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_1122 = _cse_1123 * 0.125;
        let _cse_1117 = _cse_1118 + _cse_1122;
        let _cse_1116 = _cse_1117 - _cse_1115;
        let _cse_1114 = _cse_1115 + _cse_1116;
        let _cse_1103 = vec2<f32>(_cse_1104, _cse_1114);
        let _cse_1102 = _cse_1103.y;
        let _cse_1130 = _cse_1111 * 0.625;
        let _cse_1131 = _cse_1105 * 0.375;
        let _cse_1129 = _cse_1130 + _cse_1131;
        let _cse_1134 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1133 = dot(_cse_1134, c_owner_vec - c_neigh_cell_vec);
        let _cse_1132 = _cse_1133 * 0.125;
        let _cse_1128 = _cse_1129 + _cse_1132;
        let _cse_1127 = _cse_1128 - _cse_1111;
        let _cse_1126 = _cse_1111 + _cse_1127;
        let _cse_1139 = _cse_1121 * 0.625;
        let _cse_1140 = _cse_1115 * 0.375;
        let _cse_1138 = _cse_1139 + _cse_1140;
        let _cse_1143 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1142 = dot(_cse_1143, c_owner_vec - c_neigh_cell_vec);
        let _cse_1141 = _cse_1142 * 0.125;
        let _cse_1137 = _cse_1138 + _cse_1141;
        let _cse_1136 = _cse_1137 - _cse_1121;
        let _cse_1135 = _cse_1121 + _cse_1136;
        let _cse_1125 = vec2<f32>(_cse_1126, _cse_1135);
        let _cse_1124 = _cse_1125.y;
        let _cse_1147 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_1149 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_1148 = _cse_1149 * 0.125;
        let _cse_1146 = _cse_1147 + _cse_1148;
        let _cse_1145 = _cse_1146 - s_own_rho;
        let _cse_1144 = s_own_rho + _cse_1145;
        let _cse_1150 = normal_vec.y;
        let _cse_1154 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_1157 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1156 = dot(_cse_1157, c_owner_vec - c_neigh_cell_vec);
        let _cse_1155 = _cse_1156 * 0.125;
        let _cse_1153 = _cse_1154 + _cse_1155;
        let _cse_1152 = _cse_1153 - s_neigh_rho;
        let _cse_1151 = s_neigh_rho + _cse_1152;
        u_l_2 = _cse_1102;
        u_r_2 = _cse_1124;
        f_l_2 = _cse_1102 * dot(_cse_1103 * 1.0 / _cse_1144, normal_vec) + _cse_1144 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * _cse_1150;
        f_r_2 = _cse_1124 * dot(_cse_1125 * 1.0 / _cse_1151, normal_vec) + _cse_1151 * constants.eos_r * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * _cse_1150;
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_1161 = s_own_rho_u_x;
        let _cse_1164 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_1167 = s_neigh_rho_u_x;
        let _cse_1166 = _cse_1167 - _cse_1161;
        let _cse_1165 = min(_cse_1166, 0.0);
        let _cse_1163 = max(_cse_1164, _cse_1165);
        let _cse_1168 = max(_cse_1166, 0.0);
        let _cse_1162 = min(_cse_1163, _cse_1168);
        let _cse_1160 = _cse_1161 + _cse_1162;
        let _cse_1170 = s_own_rho_u_y;
        let _cse_1173 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_1176 = s_neigh_rho_u_y;
        let _cse_1175 = _cse_1176 - _cse_1170;
        let _cse_1174 = min(_cse_1175, 0.0);
        let _cse_1172 = max(_cse_1173, _cse_1174);
        let _cse_1177 = max(_cse_1175, 0.0);
        let _cse_1171 = min(_cse_1172, _cse_1177);
        let _cse_1169 = _cse_1170 + _cse_1171;
        let _cse_1159 = vec2<f32>(_cse_1160, _cse_1169);
        let _cse_1158 = _cse_1159.y;
        let _cse_1184 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1183 = dot(_cse_1184, face_center_vec - c_neigh_cell_vec);
        let _cse_1186 = _cse_1161 - _cse_1167;
        let _cse_1185 = min(_cse_1186, 0.0);
        let _cse_1182 = max(_cse_1183, _cse_1185);
        let _cse_1187 = max(_cse_1186, 0.0);
        let _cse_1181 = min(_cse_1182, _cse_1187);
        let _cse_1180 = _cse_1167 + _cse_1181;
        let _cse_1192 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1191 = dot(_cse_1192, face_center_vec - c_neigh_cell_vec);
        let _cse_1194 = _cse_1170 - _cse_1176;
        let _cse_1193 = min(_cse_1194, 0.0);
        let _cse_1190 = max(_cse_1191, _cse_1193);
        let _cse_1195 = max(_cse_1194, 0.0);
        let _cse_1189 = min(_cse_1190, _cse_1195);
        let _cse_1188 = _cse_1176 + _cse_1189;
        let _cse_1179 = vec2<f32>(_cse_1180, _cse_1188);
        let _cse_1178 = _cse_1179.y;
        let _cse_1199 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1200 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_1198 = max(_cse_1199, _cse_1200);
        let _cse_1201 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_1197 = min(_cse_1198, _cse_1201);
        let _cse_1196 = s_own_rho + _cse_1197;
        let _cse_1202 = normal_vec.y;
        let _cse_1207 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1206 = dot(_cse_1207, face_center_vec - c_neigh_cell_vec);
        let _cse_1208 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_1205 = max(_cse_1206, _cse_1208);
        let _cse_1209 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_1204 = min(_cse_1205, _cse_1209);
        let _cse_1203 = s_neigh_rho + _cse_1204;
        u_l_2 = _cse_1158;
        u_r_2 = _cse_1178;
        f_l_2 = _cse_1158 * dot(_cse_1159 * 1.0 / _cse_1196, normal_vec) + _cse_1196 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * _cse_1202;
        f_r_2 = _cse_1178 * dot(_cse_1179 * 1.0 / _cse_1203, normal_vec) + _cse_1203 * constants.eos_r * (s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * _cse_1202;
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_1213 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_1224 = vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_1223 = dot(_cse_1213, _cse_1224);
        let _cse_1225 = dot(_cse_1213, _cse_1213);
        let _cse_1222 = _cse_1223 * _cse_1225;
        let _cse_1227 = _cse_1225 * _cse_1225;
        let _cse_1226 = _cse_1227 + 0.000000000000000000000000000001;
        let _cse_1221 = _cse_1222 / _cse_1226;
        let _cse_1220 = 2.0 * _cse_1221;
        let _cse_1219 = _cse_1220 - 1.0;
        let _cse_1218 = min(_cse_1219, 1999.0);
        let _cse_1217 = max(-2001.0, _cse_1218);
        let _cse_1228 = abs(_cse_1217);
        let _cse_1216 = _cse_1217 + _cse_1228;
        let _cse_1229 = 1.0 + _cse_1228;
        let _cse_1215 = _cse_1216 / _cse_1229;
        let _cse_1214 = _cse_1215 * lambda_other;
        let _cse_1212 = _cse_1213 * _cse_1214;
        let _cse_1211 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_1212;
        let _cse_1210 = _cse_1211.y;
        let _cse_1245 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1244 = dot(c_neigh_cell_vec - c_owner_vec, _cse_1245);
        let _cse_1247 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1246 = dot(c_neigh_cell_vec - c_owner_vec, _cse_1247);
        let _cse_1243 = vec2<f32>(_cse_1244, _cse_1246);
        let _cse_1242 = dot(_cse_1213, _cse_1243);
        let _cse_1241 = _cse_1242 * _cse_1225;
        let _cse_1240 = _cse_1241 / _cse_1226;
        let _cse_1239 = 2.0 * _cse_1240;
        let _cse_1238 = _cse_1239 - 1.0;
        let _cse_1237 = min(_cse_1238, 1999.0);
        let _cse_1236 = max(-2001.0, _cse_1237);
        let _cse_1248 = abs(_cse_1236);
        let _cse_1235 = _cse_1236 + _cse_1248;
        let _cse_1249 = 1.0 + _cse_1248;
        let _cse_1234 = _cse_1235 / _cse_1249;
        let _cse_1233 = _cse_1234 * lambda;
        let _cse_1232 = _cse_1213 * _cse_1233;
        let _cse_1231 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_1232;
        let _cse_1230 = _cse_1231.y;
        let _cse_1259 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001;
        let _cse_1258 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / _cse_1259;
        let _cse_1257 = 2.0 * _cse_1258;
        let _cse_1256 = _cse_1257 - 1.0;
        let _cse_1255 = min(_cse_1256, 1999.0);
        let _cse_1254 = max(-2001.0, _cse_1255);
        let _cse_1260 = abs(_cse_1254);
        let _cse_1253 = (_cse_1254 + _cse_1260) / (1.0 + _cse_1260);
        let _cse_1252 = _cse_1253 * lambda_other;
        let _cse_1251 = _cse_1252 * (s_neigh_rho - s_own_rho);
        let _cse_1250 = s_own_rho + _cse_1251;
        let _cse_1272 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)));
        let _cse_1271 = _cse_1272 * (s_neigh_rho - s_own_rho);
        let _cse_1270 = _cse_1271 / _cse_1259;
        let _cse_1269 = 2.0 * _cse_1270;
        let _cse_1268 = _cse_1269 - 1.0;
        let _cse_1267 = min(_cse_1268, 1999.0);
        let _cse_1266 = max(-2001.0, _cse_1267);
        let _cse_1273 = abs(_cse_1266);
        let _cse_1265 = _cse_1266 + _cse_1273;
        let _cse_1264 = _cse_1265 / (1.0 + _cse_1273);
        let _cse_1263 = _cse_1264 * lambda;
        let _cse_1262 = _cse_1263 * (s_neigh_rho - s_own_rho);
        let _cse_1261 = s_neigh_rho - _cse_1262;
        u_l_2 = _cse_1210;
        u_r_2 = _cse_1230;
        f_l_2 = _cse_1210 * dot(_cse_1211 * 1.0 / _cse_1250, normal_vec) + _cse_1250 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) * normal_vec.y;
        f_r_2 = _cse_1230 * dot(_cse_1231 * 1.0 / _cse_1261, normal_vec) + _cse_1261 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) * normal_vec.y;
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_1277 = s_own_rho_u_x;
        let _cse_1283 = _cse_1277 * 0.625;
        let _cse_1285 = s_neigh_rho_u_x;
        let _cse_1284 = _cse_1285 * 0.375;
        let _cse_1282 = _cse_1283 + _cse_1284;
        let _cse_1281 = _cse_1282 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1280 = _cse_1281 - _cse_1277;
        let _cse_1287 = _cse_1285 - _cse_1277;
        let _cse_1286 = min(_cse_1287, 0.0);
        let _cse_1279 = max(_cse_1280, _cse_1286);
        let _cse_1288 = max(_cse_1287, 0.0);
        let _cse_1278 = min(_cse_1279, _cse_1288);
        let _cse_1276 = _cse_1277 + _cse_1278;
        let _cse_1290 = s_own_rho_u_y;
        let _cse_1296 = _cse_1290 * 0.625;
        let _cse_1298 = s_neigh_rho_u_y;
        let _cse_1297 = _cse_1298 * 0.375;
        let _cse_1295 = _cse_1296 + _cse_1297;
        let _cse_1294 = _cse_1295 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1293 = _cse_1294 - _cse_1290;
        let _cse_1300 = _cse_1298 - _cse_1290;
        let _cse_1299 = min(_cse_1300, 0.0);
        let _cse_1292 = max(_cse_1293, _cse_1299);
        let _cse_1301 = max(_cse_1300, 0.0);
        let _cse_1291 = min(_cse_1292, _cse_1301);
        let _cse_1289 = _cse_1290 + _cse_1291;
        let _cse_1275 = vec2<f32>(_cse_1276, _cse_1289);
        let _cse_1274 = _cse_1275.y;
        let _cse_1310 = _cse_1285 * 0.625;
        let _cse_1311 = _cse_1277 * 0.375;
        let _cse_1309 = _cse_1310 + _cse_1311;
        let _cse_1314 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1313 = dot(_cse_1314, c_owner_vec - c_neigh_cell_vec);
        let _cse_1312 = _cse_1313 * 0.125;
        let _cse_1308 = _cse_1309 + _cse_1312;
        let _cse_1307 = _cse_1308 - _cse_1285;
        let _cse_1316 = _cse_1277 - _cse_1285;
        let _cse_1315 = min(_cse_1316, 0.0);
        let _cse_1306 = max(_cse_1307, _cse_1315);
        let _cse_1317 = max(_cse_1316, 0.0);
        let _cse_1305 = min(_cse_1306, _cse_1317);
        let _cse_1304 = _cse_1285 + _cse_1305;
        let _cse_1324 = _cse_1298 * 0.625;
        let _cse_1323 = _cse_1324 + _cse_1290 * 0.375;
        let _cse_1326 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1325 = _cse_1326 * 0.125;
        let _cse_1322 = _cse_1323 + _cse_1325;
        let _cse_1321 = _cse_1322 - _cse_1298;
        let _cse_1328 = _cse_1290 - _cse_1298;
        let _cse_1327 = min(_cse_1328, 0.0);
        let _cse_1320 = max(_cse_1321, _cse_1327);
        let _cse_1329 = max(_cse_1328, 0.0);
        let _cse_1319 = min(_cse_1320, _cse_1329);
        let _cse_1318 = _cse_1298 + _cse_1319;
        let _cse_1303 = vec2<f32>(_cse_1304, _cse_1318);
        let _cse_1302 = _cse_1303.y;
        let _cse_1332 = max(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho, min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1331 = min(_cse_1332, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1330 = s_own_rho + _cse_1331;
        let _cse_1337 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1336 = _cse_1337 - s_neigh_rho;
        let _cse_1335 = max(_cse_1336, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1334 = min(_cse_1335, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1333 = s_neigh_rho + _cse_1334;
        u_l_2 = _cse_1274;
        u_r_2 = _cse_1302;
        f_l_2 = _cse_1274 * dot(_cse_1275 * 1.0 / _cse_1330, normal_vec) + _cse_1330 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) * normal_vec.y;
        f_r_2 = _cse_1302 * dot(_cse_1303 * 1.0 / _cse_1333, normal_vec) + _cse_1333 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) * normal_vec.y;
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_1341 = s_own_rho_u_x;
        let _cse_1347 = s_neigh_rho_u_x;
        let _cse_1346 = _cse_1341 * 0.625 + _cse_1347 * 0.375;
        let _cse_1345 = _cse_1346 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1344 = _cse_1345 - _cse_1341;
        let _cse_1349 = _cse_1347 - _cse_1341;
        let _cse_1350 = max(abs(_cse_1349), abs(_cse_1344) + 0.00000001);
        let _cse_1348 = abs(_cse_1349) / _cse_1350;
        let _cse_1343 = _cse_1344 * _cse_1348;
        let _cse_1352 = _cse_1349 * _cse_1344;
        let _cse_1351 = max(_cse_1352, 0.0) / max(abs(_cse_1352), 0.00000001);
        let _cse_1342 = _cse_1343 * _cse_1351;
        let _cse_1340 = _cse_1341 + _cse_1342;
        let _cse_1354 = s_own_rho_u_y;
        let _cse_1360 = s_neigh_rho_u_y;
        let _cse_1359 = _cse_1354 * 0.625 + _cse_1360 * 0.375;
        let _cse_1358 = _cse_1359 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1357 = _cse_1358 - _cse_1354;
        let _cse_1362 = _cse_1360 - _cse_1354;
        let _cse_1363 = max(abs(_cse_1362), abs(_cse_1357) + 0.00000001);
        let _cse_1361 = abs(_cse_1362) / _cse_1363;
        let _cse_1356 = _cse_1357 * _cse_1361;
        let _cse_1365 = _cse_1362 * _cse_1357;
        let _cse_1364 = max(_cse_1365, 0.0) / max(abs(_cse_1365), 0.00000001);
        let _cse_1355 = _cse_1356 * _cse_1364;
        let _cse_1353 = _cse_1354 + _cse_1355;
        let _cse_1339 = vec2<f32>(_cse_1340, _cse_1353);
        let _cse_1338 = _cse_1339.y;
        let _cse_1373 = _cse_1347 * 0.625 + _cse_1341 * 0.375;
        let _cse_1375 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1374 = _cse_1375 * 0.125;
        let _cse_1372 = _cse_1373 + _cse_1374;
        let _cse_1371 = _cse_1372 - _cse_1347;
        let _cse_1377 = _cse_1341 - _cse_1347;
        let _cse_1378 = max(abs(_cse_1377), abs(_cse_1371) + 0.00000001);
        let _cse_1376 = abs(_cse_1377) / _cse_1378;
        let _cse_1370 = _cse_1371 * _cse_1376;
        let _cse_1381 = _cse_1377 * _cse_1371;
        let _cse_1380 = max(_cse_1381, 0.0);
        let _cse_1383 = abs(_cse_1381);
        let _cse_1382 = max(_cse_1383, 0.00000001);
        let _cse_1379 = _cse_1380 / _cse_1382;
        let _cse_1369 = _cse_1370 * _cse_1379;
        let _cse_1368 = _cse_1347 + _cse_1369;
        let _cse_1389 = _cse_1360 * 0.625 + _cse_1354 * 0.375;
        let _cse_1391 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1390 = _cse_1391 * 0.125;
        let _cse_1388 = _cse_1389 + _cse_1390;
        let _cse_1387 = _cse_1388 - _cse_1360;
        let _cse_1393 = _cse_1354 - _cse_1360;
        let _cse_1394 = max(abs(_cse_1393), abs(_cse_1387) + 0.00000001);
        let _cse_1392 = abs(_cse_1393) / _cse_1394;
        let _cse_1386 = _cse_1387 * _cse_1392;
        let _cse_1397 = _cse_1393 * _cse_1387;
        let _cse_1396 = max(_cse_1397, 0.0);
        let _cse_1399 = abs(_cse_1397);
        let _cse_1398 = max(_cse_1399, 0.00000001);
        let _cse_1395 = _cse_1396 / _cse_1398;
        let _cse_1385 = _cse_1386 * _cse_1395;
        let _cse_1384 = _cse_1360 + _cse_1385;
        let _cse_1367 = vec2<f32>(_cse_1368, _cse_1384);
        let _cse_1366 = _cse_1367.y;
        let _cse_1401 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1400 = _cse_1401 - s_neigh_rho;
        u_l_2 = _cse_1338;
        u_r_2 = _cse_1366;
        f_l_2 = _cse_1338 * dot(_cse_1339 * 1.0 / (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)), normal_vec) + (s_own_rho + (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001)) * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) * normal_vec.y;
        f_r_2 = _cse_1366 * dot(_cse_1367 * 1.0 / (s_neigh_rho + _cse_1400 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1400) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1400, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1400), 0.00000001)), normal_vec) + (s_neigh_rho + _cse_1400 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1400) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_1400, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_1400), 0.00000001)) * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001)) * normal_vec.y;
    }
    fluxes[idx * 8u + 2u] = (a_plus * f_l_2 - a_minus * f_r_2 + a_plus * a_minus * (u_r_2 - u_l_2)) / denom * area;
    let _cse_1404 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_1403 = _cse_1404 / max(constants.eos_gm1, 0.000000000001);
    let _cse_1409 = s_own_rho_u_x;
    let _cse_1410 = s_own_rho_u_y;
    let _cse_1408 = vec2<f32>(_cse_1409, _cse_1410);
    let _cse_1407 = _cse_1408 * 1.0 / s_own_rho;
    let _cse_1406 = dot(_cse_1407, _cse_1407);
    let _cse_1405 = 0.5 * s_own_rho * _cse_1406;
    let _cse_1402 = _cse_1403 + _cse_1405;
    let _cse_1413 = s_neigh_rho * constants.eos_r * s_neigh_T;
    let _cse_1412 = _cse_1413 / max(constants.eos_gm1, 0.000000000001);
    let _cse_1418 = s_neigh_rho_u_x;
    let _cse_1419 = s_neigh_rho_u_y;
    let _cse_1417 = vec2<f32>(_cse_1418, _cse_1419);
    let _cse_1416 = _cse_1417 * 1.0 / s_neigh_rho;
    let _cse_1415 = dot(_cse_1416, _cse_1416);
    let _cse_1414 = 0.5 * s_neigh_rho * _cse_1415;
    let _cse_1411 = _cse_1412 + _cse_1414;
    var u_l_3: f32 = _cse_1402;
    var u_r_3: f32 = _cse_1411;
    var f_l_3: f32 = (_cse_1402 + _cse_1404) * dot(_cse_1407, normal_vec);
    var f_r_3: f32 = (_cse_1411 + _cse_1413) * dot(_cse_1416, normal_vec);
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_1425 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1424 = s_own_rho + _cse_1425;
        let _cse_1423 = _cse_1424 * constants.eos_r;
        let _cse_1427 = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec);
        let _cse_1426 = s_own_T + _cse_1427;
        let _cse_1422 = _cse_1423 * _cse_1426;
        let _cse_1421 = _cse_1422 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1429 = 0.5 * _cse_1424;
        let _cse_1434 = s_own_rho_u_x;
        let _cse_1435 = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec);
        let _cse_1433 = _cse_1434 + _cse_1435;
        let _cse_1437 = s_own_rho_u_y;
        let _cse_1438 = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec);
        let _cse_1436 = _cse_1437 + _cse_1438;
        let _cse_1432 = vec2<f32>(_cse_1433, _cse_1436);
        let _cse_1439 = 1.0 / _cse_1424;
        let _cse_1431 = _cse_1432 * _cse_1439;
        let _cse_1430 = dot(_cse_1431, _cse_1431);
        let _cse_1428 = _cse_1429 * _cse_1430;
        let _cse_1420 = _cse_1421 + _cse_1428;
        let _cse_1446 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1445 = dot(_cse_1446, face_center_vec - c_neigh_cell_vec);
        let _cse_1444 = s_neigh_rho + _cse_1445;
        let _cse_1443 = _cse_1444 * constants.eos_r;
        let _cse_1449 = vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary));
        let _cse_1448 = dot(_cse_1449, face_center_vec - c_neigh_cell_vec);
        let _cse_1447 = s_neigh_T + _cse_1448;
        let _cse_1442 = _cse_1443 * _cse_1447;
        let _cse_1441 = _cse_1442 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1451 = 0.5 * _cse_1444;
        let _cse_1456 = s_neigh_rho_u_x;
        let _cse_1458 = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary));
        let _cse_1457 = dot(_cse_1458, face_center_vec - c_neigh_cell_vec);
        let _cse_1455 = _cse_1456 + _cse_1457;
        let _cse_1460 = s_neigh_rho_u_y;
        let _cse_1462 = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary));
        let _cse_1461 = dot(_cse_1462, face_center_vec - c_neigh_cell_vec);
        let _cse_1459 = _cse_1460 + _cse_1461;
        let _cse_1454 = vec2<f32>(_cse_1455, _cse_1459);
        let _cse_1463 = 1.0 / _cse_1444;
        let _cse_1453 = _cse_1454 * _cse_1463;
        let _cse_1452 = dot(_cse_1453, _cse_1453);
        let _cse_1450 = _cse_1451 * _cse_1452;
        let _cse_1440 = _cse_1441 + _cse_1450;
        u_l_3 = _cse_1420;
        u_r_3 = _cse_1440;
        f_l_3 = (_cse_1420 + _cse_1422) * dot(_cse_1431, normal_vec);
        f_r_3 = (_cse_1440 + _cse_1442) * dot(_cse_1453, normal_vec);
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_1471 = s_own_rho * 0.625 + s_neigh_rho * 0.375;
        let _cse_1473 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec);
        let _cse_1472 = _cse_1473 * 0.125;
        let _cse_1470 = _cse_1471 + _cse_1472;
        let _cse_1469 = _cse_1470 - s_own_rho;
        let _cse_1468 = s_own_rho + _cse_1469;
        let _cse_1467 = _cse_1468 * constants.eos_r;
        let _cse_1466 = _cse_1467 * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T);
        let _cse_1465 = _cse_1466 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1479 = s_own_rho_u_x;
        let _cse_1483 = _cse_1479 * 0.625;
        let _cse_1485 = s_neigh_rho_u_x;
        let _cse_1484 = _cse_1485 * 0.375;
        let _cse_1482 = _cse_1483 + _cse_1484;
        let _cse_1481 = _cse_1482 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1480 = _cse_1481 - _cse_1479;
        let _cse_1478 = _cse_1479 + _cse_1480;
        let _cse_1487 = s_own_rho_u_y;
        let _cse_1491 = _cse_1487 * 0.625;
        let _cse_1493 = s_neigh_rho_u_y;
        let _cse_1492 = _cse_1493 * 0.375;
        let _cse_1490 = _cse_1491 + _cse_1492;
        let _cse_1489 = _cse_1490 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1488 = _cse_1489 - _cse_1487;
        let _cse_1486 = _cse_1487 + _cse_1488;
        let _cse_1477 = vec2<f32>(_cse_1478, _cse_1486);
        let _cse_1494 = 1.0 / _cse_1468;
        let _cse_1476 = _cse_1477 * _cse_1494;
        let _cse_1475 = dot(_cse_1476, _cse_1476);
        let _cse_1474 = 0.5 * _cse_1468 * _cse_1475;
        let _cse_1464 = _cse_1465 + _cse_1474;
        let _cse_1502 = s_neigh_rho * 0.625 + s_own_rho * 0.375;
        let _cse_1505 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1504 = dot(_cse_1505, c_owner_vec - c_neigh_cell_vec);
        let _cse_1503 = _cse_1504 * 0.125;
        let _cse_1501 = _cse_1502 + _cse_1503;
        let _cse_1500 = _cse_1501 - s_neigh_rho;
        let _cse_1499 = s_neigh_rho + _cse_1500;
        let _cse_1498 = _cse_1499 * constants.eos_r;
        let _cse_1508 = s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1507 = _cse_1508 - s_neigh_T;
        let _cse_1506 = s_neigh_T + _cse_1507;
        let _cse_1497 = _cse_1498 * _cse_1506;
        let _cse_1496 = _cse_1497 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1517 = _cse_1485 * 0.625;
        let _cse_1518 = _cse_1479 * 0.375;
        let _cse_1516 = _cse_1517 + _cse_1518;
        let _cse_1520 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1519 = _cse_1520 * 0.125;
        let _cse_1515 = _cse_1516 + _cse_1519;
        let _cse_1514 = _cse_1515 - _cse_1485;
        let _cse_1513 = _cse_1485 + _cse_1514;
        let _cse_1524 = _cse_1493 * 0.625 + _cse_1487 * 0.375;
        let _cse_1526 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1525 = _cse_1526 * 0.125;
        let _cse_1523 = _cse_1524 + _cse_1525;
        let _cse_1522 = _cse_1523 - _cse_1493;
        let _cse_1521 = _cse_1493 + _cse_1522;
        let _cse_1512 = vec2<f32>(_cse_1513, _cse_1521);
        let _cse_1527 = 1.0 / _cse_1499;
        let _cse_1511 = _cse_1512 * _cse_1527;
        let _cse_1510 = dot(_cse_1511, _cse_1511);
        let _cse_1509 = 0.5 * _cse_1499 * _cse_1510;
        let _cse_1495 = _cse_1496 + _cse_1509;
        u_l_3 = _cse_1464;
        u_r_3 = _cse_1495;
        f_l_3 = (_cse_1464 + _cse_1466) * dot(_cse_1476, normal_vec);
        f_r_3 = (_cse_1495 + _cse_1497) * dot(_cse_1511, normal_vec);
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_1535 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_1536 = min(s_neigh_rho - s_own_rho, 0.0);
        let _cse_1534 = max(_cse_1535, _cse_1536);
        let _cse_1537 = max(s_neigh_rho - s_own_rho, 0.0);
        let _cse_1533 = min(_cse_1534, _cse_1537);
        let _cse_1532 = s_own_rho + _cse_1533;
        let _cse_1531 = _cse_1532 * constants.eos_r;
        let _cse_1538 = s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0));
        let _cse_1530 = _cse_1531 * _cse_1538;
        let _cse_1529 = _cse_1530 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1544 = s_own_rho_u_x;
        let _cse_1549 = s_neigh_rho_u_x;
        let _cse_1548 = _cse_1549 - _cse_1544;
        let _cse_1547 = min(_cse_1548, 0.0);
        let _cse_1546 = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), _cse_1547);
        let _cse_1550 = max(_cse_1548, 0.0);
        let _cse_1545 = min(_cse_1546, _cse_1550);
        let _cse_1543 = _cse_1544 + _cse_1545;
        let _cse_1552 = s_own_rho_u_y;
        let _cse_1557 = s_neigh_rho_u_y;
        let _cse_1556 = _cse_1557 - _cse_1552;
        let _cse_1555 = min(_cse_1556, 0.0);
        let _cse_1554 = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), _cse_1555);
        let _cse_1558 = max(_cse_1556, 0.0);
        let _cse_1553 = min(_cse_1554, _cse_1558);
        let _cse_1551 = _cse_1552 + _cse_1553;
        let _cse_1542 = vec2<f32>(_cse_1543, _cse_1551);
        let _cse_1559 = 1.0 / _cse_1532;
        let _cse_1541 = _cse_1542 * _cse_1559;
        let _cse_1540 = dot(_cse_1541, _cse_1541);
        let _cse_1539 = 0.5 * _cse_1532 * _cse_1540;
        let _cse_1528 = _cse_1529 + _cse_1539;
        let _cse_1568 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1567 = dot(_cse_1568, face_center_vec - c_neigh_cell_vec);
        let _cse_1569 = min(s_own_rho - s_neigh_rho, 0.0);
        let _cse_1566 = max(_cse_1567, _cse_1569);
        let _cse_1570 = max(s_own_rho - s_neigh_rho, 0.0);
        let _cse_1565 = min(_cse_1566, _cse_1570);
        let _cse_1564 = s_neigh_rho + _cse_1565;
        let _cse_1563 = _cse_1564 * constants.eos_r;
        let _cse_1572 = min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0));
        let _cse_1571 = s_neigh_T + _cse_1572;
        let _cse_1562 = _cse_1563 * _cse_1571;
        let _cse_1561 = _cse_1562 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1580 = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_1582 = _cse_1544 - _cse_1549;
        let _cse_1581 = min(_cse_1582, 0.0);
        let _cse_1579 = max(_cse_1580, _cse_1581);
        let _cse_1583 = max(_cse_1582, 0.0);
        let _cse_1578 = min(_cse_1579, _cse_1583);
        let _cse_1577 = _cse_1549 + _cse_1578;
        let _cse_1587 = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_1589 = _cse_1552 - _cse_1557;
        let _cse_1588 = min(_cse_1589, 0.0);
        let _cse_1586 = max(_cse_1587, _cse_1588);
        let _cse_1590 = max(_cse_1589, 0.0);
        let _cse_1585 = min(_cse_1586, _cse_1590);
        let _cse_1584 = _cse_1557 + _cse_1585;
        let _cse_1576 = vec2<f32>(_cse_1577, _cse_1584);
        let _cse_1591 = 1.0 / _cse_1564;
        let _cse_1575 = _cse_1576 * _cse_1591;
        let _cse_1574 = dot(_cse_1575, _cse_1575);
        let _cse_1573 = 0.5 * _cse_1564 * _cse_1574;
        let _cse_1560 = _cse_1561 + _cse_1573;
        u_l_3 = _cse_1528;
        u_r_3 = _cse_1560;
        f_l_3 = (_cse_1528 + _cse_1530) * dot(_cse_1541, normal_vec);
        f_r_3 = (_cse_1560 + _cse_1562) * dot(_cse_1575, normal_vec);
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_1603 = (s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001;
        let _cse_1602 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / _cse_1603;
        let _cse_1601 = 2.0 * _cse_1602;
        let _cse_1600 = _cse_1601 - 1.0;
        let _cse_1599 = min(_cse_1600, 1999.0);
        let _cse_1598 = max(-2001.0, _cse_1599);
        let _cse_1604 = abs(_cse_1598);
        let _cse_1597 = _cse_1598 + _cse_1604;
        let _cse_1596 = _cse_1597 / (1.0 + _cse_1604);
        let _cse_1595 = _cse_1596 * lambda_other;
        let _cse_1594 = _cse_1595 * (s_neigh_rho - s_own_rho);
        let _cse_1593 = s_own_rho + _cse_1594;
        let _cse_1610 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_1620 = dot(_cse_1610, _cse_1610);
        let _cse_1619 = dot(_cse_1610, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_1620;
        let _cse_1622 = _cse_1620 * _cse_1620;
        let _cse_1621 = _cse_1622 + 0.000000000000000000000000000001;
        let _cse_1618 = _cse_1619 / _cse_1621;
        let _cse_1617 = 2.0 * _cse_1618;
        let _cse_1616 = _cse_1617 - 1.0;
        let _cse_1615 = min(_cse_1616, 1999.0);
        let _cse_1614 = max(-2001.0, _cse_1615);
        let _cse_1623 = abs(_cse_1614);
        let _cse_1613 = _cse_1614 + _cse_1623;
        let _cse_1612 = _cse_1613 / (1.0 + _cse_1623);
        let _cse_1611 = _cse_1612 * lambda_other;
        let _cse_1609 = _cse_1610 * _cse_1611;
        let _cse_1608 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_1609;
        let _cse_1607 = _cse_1608 * 1.0 / _cse_1593;
        let _cse_1606 = dot(_cse_1607, _cse_1607);
        let _cse_1605 = 0.5 * _cse_1593 * _cse_1606;
        let _cse_1592 = _cse_1593 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / max(constants.eos_gm1, 0.000000000001) + _cse_1605;
        let _cse_1636 = dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho);
        let _cse_1635 = _cse_1636 / _cse_1603;
        let _cse_1634 = 2.0 * _cse_1635;
        let _cse_1633 = _cse_1634 - 1.0;
        let _cse_1632 = min(_cse_1633, 1999.0);
        let _cse_1631 = max(-2001.0, _cse_1632);
        let _cse_1637 = abs(_cse_1631);
        let _cse_1630 = _cse_1631 + _cse_1637;
        let _cse_1629 = _cse_1630 / (1.0 + _cse_1637);
        let _cse_1628 = _cse_1629 * lambda;
        let _cse_1627 = _cse_1628 * (s_neigh_rho - s_own_rho);
        let _cse_1626 = s_neigh_rho - _cse_1627;
        let _cse_1625 = _cse_1626 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T));
        let _cse_1653 = vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))));
        let _cse_1652 = dot(_cse_1610, _cse_1653);
        let _cse_1651 = _cse_1652 * _cse_1620;
        let _cse_1650 = _cse_1651 / _cse_1621;
        let _cse_1649 = 2.0 * _cse_1650;
        let _cse_1648 = _cse_1649 - 1.0;
        let _cse_1647 = min(_cse_1648, 1999.0);
        let _cse_1646 = max(-2001.0, _cse_1647);
        let _cse_1654 = abs(_cse_1646);
        let _cse_1645 = _cse_1646 + _cse_1654;
        let _cse_1644 = _cse_1645 / (1.0 + _cse_1654);
        let _cse_1643 = _cse_1644 * lambda;
        let _cse_1642 = _cse_1610 * _cse_1643;
        let _cse_1641 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_1642;
        let _cse_1655 = 1.0 / _cse_1626;
        let _cse_1640 = _cse_1641 * _cse_1655;
        let _cse_1639 = dot(_cse_1640, _cse_1640);
        let _cse_1638 = 0.5 * _cse_1626 * _cse_1639;
        let _cse_1624 = _cse_1625 / max(constants.eos_gm1, 0.000000000001) + _cse_1638;
        u_l_3 = _cse_1592;
        u_r_3 = _cse_1624;
        f_l_3 = (_cse_1592 + _cse_1593 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T))) * dot(_cse_1607, normal_vec);
        f_r_3 = (_cse_1624 + _cse_1625) * dot(_cse_1640, normal_vec);
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_1663 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1662 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + _cse_1663;
        let _cse_1661 = _cse_1662 - s_own_rho;
        let _cse_1660 = max(_cse_1661, min(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1659 = min(_cse_1660, max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_1658 = s_own_rho + _cse_1659;
        let _cse_1657 = _cse_1658 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)));
        let _cse_1669 = s_own_rho_u_x;
        let _cse_1675 = s_neigh_rho_u_x;
        let _cse_1674 = _cse_1669 * 0.625 + _cse_1675 * 0.375;
        let _cse_1673 = _cse_1674 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1672 = _cse_1673 - _cse_1669;
        let _cse_1677 = _cse_1675 - _cse_1669;
        let _cse_1676 = min(_cse_1677, 0.0);
        let _cse_1671 = max(_cse_1672, _cse_1676);
        let _cse_1678 = max(_cse_1677, 0.0);
        let _cse_1670 = min(_cse_1671, _cse_1678);
        let _cse_1668 = _cse_1669 + _cse_1670;
        let _cse_1680 = s_own_rho_u_y;
        let _cse_1686 = s_neigh_rho_u_y;
        let _cse_1685 = _cse_1680 * 0.625 + _cse_1686 * 0.375;
        let _cse_1684 = _cse_1685 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1683 = _cse_1684 - _cse_1680;
        let _cse_1687 = _cse_1686 - _cse_1680;
        let _cse_1682 = max(_cse_1683, min(_cse_1687, 0.0));
        let _cse_1681 = min(_cse_1682, max(_cse_1687, 0.0));
        let _cse_1679 = _cse_1680 + _cse_1681;
        let _cse_1667 = vec2<f32>(_cse_1668, _cse_1679);
        let _cse_1688 = 1.0 / _cse_1658;
        let _cse_1666 = _cse_1667 * _cse_1688;
        let _cse_1665 = dot(_cse_1666, _cse_1666);
        let _cse_1664 = 0.5 * _cse_1658 * _cse_1665;
        let _cse_1656 = _cse_1657 / max(constants.eos_gm1, 0.000000000001) + _cse_1664;
        let _cse_1700 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_1699 = dot(_cse_1700, c_owner_vec - c_neigh_cell_vec);
        let _cse_1698 = _cse_1699 * 0.125;
        let _cse_1697 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_1698;
        let _cse_1696 = _cse_1697 - s_neigh_rho;
        let _cse_1695 = max(_cse_1696, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1694 = min(_cse_1695, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_1693 = s_neigh_rho + _cse_1694;
        let _cse_1692 = _cse_1693 * constants.eos_r;
        let _cse_1691 = _cse_1692 * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_1690 = _cse_1691 / max(constants.eos_gm1, 0.000000000001);
        let _cse_1710 = _cse_1675 * 0.625 + _cse_1669 * 0.375;
        let _cse_1709 = _cse_1710 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1708 = _cse_1709 - _cse_1675;
        let _cse_1711 = _cse_1669 - _cse_1675;
        let _cse_1707 = max(_cse_1708, min(_cse_1711, 0.0));
        let _cse_1706 = min(_cse_1707, max(_cse_1711, 0.0));
        let _cse_1705 = _cse_1675 + _cse_1706;
        let _cse_1717 = _cse_1686 * 0.625 + _cse_1680 * 0.375;
        let _cse_1716 = _cse_1717 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1715 = _cse_1716 - _cse_1686;
        let _cse_1718 = _cse_1680 - _cse_1686;
        let _cse_1714 = max(_cse_1715, min(_cse_1718, 0.0));
        let _cse_1713 = min(_cse_1714, max(_cse_1718, 0.0));
        let _cse_1712 = _cse_1686 + _cse_1713;
        let _cse_1704 = vec2<f32>(_cse_1705, _cse_1712);
        let _cse_1719 = 1.0 / _cse_1693;
        let _cse_1703 = _cse_1704 * _cse_1719;
        let _cse_1702 = dot(_cse_1703, _cse_1703);
        let _cse_1701 = 0.5 * _cse_1693 * _cse_1702;
        let _cse_1689 = _cse_1690 + _cse_1701;
        u_l_3 = _cse_1656;
        u_r_3 = _cse_1689;
        f_l_3 = (_cse_1656 + _cse_1657) * dot(_cse_1666, normal_vec);
        f_r_3 = (_cse_1689 + _cse_1691) * dot(_cse_1703, normal_vec);
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_1726 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1725 = _cse_1726 - s_own_rho;
        let _cse_1724 = _cse_1725 * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(_cse_1725) + 0.00000001);
        let _cse_1728 = (s_neigh_rho - s_own_rho) * _cse_1725;
        let _cse_1727 = max(_cse_1728, 0.0) / max(abs(_cse_1728), 0.00000001);
        let _cse_1723 = _cse_1724 * _cse_1727;
        let _cse_1722 = s_own_rho + _cse_1723;
        let _cse_1721 = _cse_1722 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001));
        let _cse_1734 = s_own_rho_u_x;
        let _cse_1740 = s_neigh_rho_u_x;
        let _cse_1739 = _cse_1734 * 0.625 + _cse_1740 * 0.375;
        let _cse_1738 = _cse_1739 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1737 = _cse_1738 - _cse_1734;
        let _cse_1736 = _cse_1737 * abs(_cse_1740 - _cse_1734) / max(abs(_cse_1740 - _cse_1734), abs(_cse_1737) + 0.00000001);
        let _cse_1742 = (_cse_1740 - _cse_1734) * _cse_1737;
        let _cse_1741 = max(_cse_1742, 0.0) / max(abs(_cse_1742), 0.00000001);
        let _cse_1735 = _cse_1736 * _cse_1741;
        let _cse_1733 = _cse_1734 + _cse_1735;
        let _cse_1744 = s_own_rho_u_y;
        let _cse_1750 = s_neigh_rho_u_y;
        let _cse_1749 = _cse_1744 * 0.625 + _cse_1750 * 0.375;
        let _cse_1748 = _cse_1749 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_1747 = _cse_1748 - _cse_1744;
        let _cse_1746 = _cse_1747 * abs(_cse_1750 - _cse_1744) / max(abs(_cse_1750 - _cse_1744), abs(_cse_1747) + 0.00000001);
        let _cse_1752 = (_cse_1750 - _cse_1744) * _cse_1747;
        let _cse_1751 = max(_cse_1752, 0.0) / max(abs(_cse_1752), 0.00000001);
        let _cse_1745 = _cse_1746 * _cse_1751;
        let _cse_1743 = _cse_1744 + _cse_1745;
        let _cse_1732 = vec2<f32>(_cse_1733, _cse_1743);
        let _cse_1753 = 1.0 / _cse_1722;
        let _cse_1731 = _cse_1732 * _cse_1753;
        let _cse_1730 = dot(_cse_1731, _cse_1731);
        let _cse_1729 = 0.5 * _cse_1722 * _cse_1730;
        let _cse_1720 = _cse_1721 / max(constants.eos_gm1, 0.000000000001) + _cse_1729;
        let _cse_1762 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec);
        let _cse_1761 = _cse_1762 * 0.125;
        let _cse_1760 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_1761;
        let _cse_1759 = _cse_1760 - s_neigh_rho;
        let _cse_1758 = _cse_1759 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_1759) + 0.00000001);
        let _cse_1764 = (s_own_rho - s_neigh_rho) * _cse_1759;
        let _cse_1763 = max(_cse_1764, 0.0) / max(abs(_cse_1764), 0.00000001);
        let _cse_1757 = _cse_1758 * _cse_1763;
        let _cse_1756 = s_neigh_rho + _cse_1757;
        let _cse_1755 = _cse_1756 * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001));
        let _cse_1773 = _cse_1740 * 0.625 + _cse_1734 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1772 = _cse_1773 - _cse_1740;
        let _cse_1771 = _cse_1772 * abs(_cse_1734 - _cse_1740) / max(abs(_cse_1734 - _cse_1740), abs(_cse_1772) + 0.00000001);
        let _cse_1775 = (_cse_1734 - _cse_1740) * _cse_1772;
        let _cse_1774 = max(_cse_1775, 0.0) / max(abs(_cse_1775), 0.00000001);
        let _cse_1770 = _cse_1771 * _cse_1774;
        let _cse_1769 = _cse_1740 + _cse_1770;
        let _cse_1780 = _cse_1750 * 0.625 + _cse_1744 * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_1779 = _cse_1780 - _cse_1750;
        let _cse_1778 = _cse_1779 * abs(_cse_1744 - _cse_1750) / max(abs(_cse_1744 - _cse_1750), abs(_cse_1779) + 0.00000001);
        let _cse_1782 = (_cse_1744 - _cse_1750) * _cse_1779;
        let _cse_1781 = max(_cse_1782, 0.0) / max(abs(_cse_1782), 0.00000001);
        let _cse_1777 = _cse_1778 * _cse_1781;
        let _cse_1776 = _cse_1750 + _cse_1777;
        let _cse_1768 = vec2<f32>(_cse_1769, _cse_1776);
        let _cse_1783 = 1.0 / _cse_1756;
        let _cse_1767 = _cse_1768 * _cse_1783;
        let _cse_1766 = dot(_cse_1767, _cse_1767);
        let _cse_1765 = 0.5 * _cse_1756 * _cse_1766;
        let _cse_1754 = _cse_1755 / max(constants.eos_gm1, 0.000000000001) + _cse_1765;
        u_l_3 = _cse_1720;
        u_r_3 = _cse_1754;
        f_l_3 = (_cse_1720 + _cse_1721) * dot(_cse_1731, normal_vec);
        f_r_3 = (_cse_1754 + _cse_1755) * dot(_cse_1767, normal_vec);
    }
    fluxes[idx * 8u + 3u] = (a_plus * f_l_3 - a_minus * f_r_3 + a_plus * a_minus * (u_r_3 - u_l_3)) / denom * area;
    var u_l_4: f32 = 0.0;
    var u_r_4: f32 = 0.0;
    var f_l_4: f32 = 0.0;
    var f_r_4: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_4 = 0.0;
        u_r_4 = 0.0;
        f_l_4 = 0.0;
        f_r_4 = 0.0;
    }
    fluxes[idx * 8u + 4u] = (a_plus * f_l_4 - a_minus * f_r_4 + a_plus * a_minus * (u_r_4 - u_l_4)) / denom * area;
    var u_l_5: f32 = 0.0;
    var u_r_5: f32 = 0.0;
    var f_l_5: f32 = 0.0;
    var f_r_5: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_5 = 0.0;
        u_r_5 = 0.0;
        f_l_5 = 0.0;
        f_r_5 = 0.0;
    }
    fluxes[idx * 8u + 5u] = (a_plus * f_l_5 - a_minus * f_r_5 + a_plus * a_minus * (u_r_5 - u_l_5)) / denom * area;
    var u_l_6: f32 = 0.0;
    var u_r_6: f32 = 0.0;
    var f_l_6: f32 = 0.0;
    var f_r_6: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_6 = 0.0;
        u_r_6 = 0.0;
        f_l_6 = 0.0;
        f_r_6 = 0.0;
    }
    fluxes[idx * 8u + 6u] = (a_plus * f_l_6 - a_minus * f_r_6 + a_plus * a_minus * (u_r_6 - u_l_6)) / denom * area;
    var u_l_7: f32 = 0.0;
    var u_r_7: f32 = 0.0;
    var f_l_7: f32 = 0.0;
    var f_r_7: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        u_l_7 = 0.0;
        u_r_7 = 0.0;
        f_l_7 = 0.0;
        f_r_7 = 0.0;
    }
    fluxes[idx * 8u + 7u] = (a_plus * f_l_7 - a_minus * f_r_7 + a_plus * a_minus * (u_r_7 - u_l_7)) / denom * area;
}
