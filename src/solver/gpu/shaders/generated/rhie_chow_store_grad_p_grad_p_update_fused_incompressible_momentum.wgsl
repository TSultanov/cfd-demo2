// GENERATED BY CFD2 DSL FUSION (rhie_chow/store_grad_p_grad_p_update_fused)
// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}


@group(0) @binding(0) var<storage, read_write> state: array<f32>;
@group(0) @binding(1) var<uniform> constants: Constants;
@group(1) @binding(0) var<storage, read> face_owner: array<u32>;
@group(1) @binding(1) var<storage, read> face_neighbor: array<i32>;
@group(1) @binding(2) var<storage, read> face_areas: array<f32>;
@group(1) @binding(3) var<storage, read> face_normals: array<Vector2>;
@group(1) @binding(4) var<storage, read> cell_centers: array<Vector2>;
@group(1) @binding(5) var<storage, read> cell_vols: array<f32>;
@group(1) @binding(6) var<storage, read> cell_face_offsets: array<u32>;
@group(1) @binding(7) var<storage, read> cell_faces: array<u32>;
@group(1) @binding(12) var<storage, read> face_boundary: array<u32>;
@group(1) @binding(13) var<storage, read> face_centers: array<Vector2>;
@group(2) @binding(0) var<storage, read> bc_kind: array<u32>;
@group(2) @binding(1) var<storage, read> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= (arrayLength(&state) / 8u)) { return; }
    let base = idx * 8u;
    // synthesized by fusion rule: rhie_chow:store_grad_p_grad_p_update_v1
    // begin fused segment: rhie_chow/store_grad_p
    state[base + 6u] = state[base + 4u];
    state[base + 7u] = state[base + 5u];
    // end fused segment: rhie_chow/store_grad_p
    // begin fused segment: rhie_chow/grad_p_update
    let k1_cell_center = cell_centers[idx];
    let k1_cell_center_vec: vec2<f32> = vec2<f32>(k1_cell_center.x, k1_cell_center.y);
    let k1_vol = cell_vols[idx];
    let k1_start = cell_face_offsets[idx];
    let k1_end = cell_face_offsets[idx + 1u];
    var k1_grad_acc_p: vec2<f32> = vec2<f32>(0.0, 0.0);
    for (var k1_k = k1_start; k1_k < k1_end; k1_k++) {
        let k1_face_idx = cell_faces[k1_k];
        let k1_owner = face_owner[k1_face_idx];
        let k1_neighbor_raw = face_neighbor[k1_face_idx];
        let k1_is_boundary = k1_neighbor_raw == -1;
        let k1_boundary_type = face_boundary[k1_face_idx];
        let k1_area = face_areas[k1_face_idx];
        let k1_face_center = face_centers[k1_face_idx];
        let k1_face_center_vec: vec2<f32> = vec2<f32>(k1_face_center.x, k1_face_center.y);
        var k1_normal_vec: vec2<f32> = vec2<f32>(face_normals[k1_face_idx].x, face_normals[k1_face_idx].y);
        if (dot(k1_face_center_vec - k1_cell_center_vec, k1_normal_vec) < 0.0) {
            k1_normal_vec = -k1_normal_vec;
        }
        var k1_other_idx: u32 = idx;
        var k1_other_center_vec: vec2<f32> = k1_face_center_vec;
        if (k1_neighbor_raw != -1) {
            let k1_neighbor = u32(k1_neighbor_raw);
            k1_other_idx = k1_neighbor;
            if (k1_owner != idx) {
                k1_other_idx = k1_owner;
            }
            let k1_other_center = cell_centers[k1_other_idx];
            k1_other_center_vec = vec2<f32>(k1_other_center.x, k1_other_center.y);
        }
        let k1_d_own = abs(dot(k1_face_center_vec - k1_cell_center_vec, k1_normal_vec));
        let k1_d_neigh = abs(dot(k1_other_center_vec - k1_face_center_vec, k1_normal_vec));
        let k1_total_dist = k1_d_own + k1_d_neigh;
        var k1_lambda: f32 = 0.5;
        if (k1_total_dist > 0.000001) {
            k1_lambda = k1_d_neigh / k1_total_dist;
        }
        let k1_lambda_other = 1.0 - k1_lambda;
        let k1__unused_boundary_type = k1_boundary_type;
        k1_grad_acc_p += k1_normal_vec * (state[base + 2u] * k1_lambda + select(state[k1_other_idx * 8u + 2u], select(select(state[base + 2u], bc_value[k1_face_idx * 3u + 2u], bc_kind[k1_face_idx * 3u + 2u] == 1u), state[base + 2u] + bc_value[k1_face_idx * 3u + 2u] * k1_d_own, bc_kind[k1_face_idx * 3u + 2u] == 2u), k1_is_boundary) * k1_lambda_other) * k1_area;
    }
    let k1_grad_out_p: vec2<f32> = k1_grad_acc_p / max(k1_vol, 0.000000000001);
    state[base + 4u] = k1_grad_out_p.x;
    state[base + 5u] = k1_grad_out_p.y;
    // end fused segment: rhie_chow/grad_p_update
}
