// GENERATED BY CFD2 CODEGEN (unified_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<uniform> constants: Constants;

@group(1) @binding(4) 
var<storage, read> state_iter: array<f32>;

@group(1) @binding(5) 
var<storage, read> grad_state: array<Vector2>;

@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;

// Group 2: Solver (block CSR values + RHS)

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

// Group 3: Boundary conditions (per face x unknown)

@group(3) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(3) @binding(1) 
var<storage, read> bc_value: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let scalar_offset = scalar_row_offsets[idx];
    let diag_rank = diagonal_indices[idx] - scalar_offset;
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = scalar_offset * 64u;
    let start_row_1 = start_row_0 + num_neighbors * 8u * 1u;
    let start_row_2 = start_row_0 + num_neighbors * 8u * 2u;
    let start_row_3 = start_row_0 + num_neighbors * 8u * 3u;
    let start_row_4 = start_row_0 + num_neighbors * 8u * 4u;
    let start_row_5 = start_row_0 + num_neighbors * 8u * 5u;
    let start_row_6 = start_row_0 + num_neighbors * 8u * 6u;
    let start_row_7 = start_row_0 + num_neighbors * 8u * 7u;
    for (var rank = 0u; rank < num_neighbors; rank++) {
        matrix_values[start_row_0 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_0 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_1 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_2 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_3 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_4 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_5 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_6 + rank * 8u + 7u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 0u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 1u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 2u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 3u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 4u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 5u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 6u] = 0.0;
        matrix_values[start_row_7 + rank * 8u + 7u] = 0.0;
    }
    var diag_0: f32 = 0.0;
    var rhs_0: f32 = 0.0;
    var diag_1: f32 = 0.0;
    var rhs_1: f32 = 0.0;
    var diag_2: f32 = 0.0;
    var rhs_2: f32 = 0.0;
    var diag_3: f32 = 0.0;
    var rhs_3: f32 = 0.0;
    var diag_4: f32 = 0.0;
    var rhs_4: f32 = 0.0;
    var diag_5: f32 = 0.0;
    var rhs_5: f32 = 0.0;
    var diag_6: f32 = 0.0;
    var rhs_6: f32 = 0.0;
    var diag_7: f32 = 0.0;
    var rhs_7: f32 = 0.0;
    diag_0 += vol / constants.dt;
    rhs_0 += vol / constants.dt * state_old[idx * 22u + 0u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_0 = diag_0 - vol / constants.dt + diag_bdf2;
        rhs_0 = rhs_0 - vol / constants.dt * state_old[idx * 22u + 0u] + vol / constants.dt * (factor_n * state_old[idx * 22u + 0u] - factor_nm1 * state_old_old[idx * 22u + 0u]);
    }
    if (constants.dtau > 0.0) {
        diag_0 += vol / constants.dtau;
        rhs_0 += vol / constants.dtau * state_iter[idx * 22u + 0u];
    }
    diag_1 += vol / constants.dt;
    rhs_1 += vol / constants.dt * state_old[idx * 22u + 1u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_1 = diag_1 - vol / constants.dt + diag_bdf2;
        rhs_1 = rhs_1 - vol / constants.dt * state_old[idx * 22u + 1u] + vol / constants.dt * (factor_n * state_old[idx * 22u + 1u] - factor_nm1 * state_old_old[idx * 22u + 1u]);
    }
    if (constants.dtau > 0.0) {
        diag_1 += vol / constants.dtau;
        rhs_1 += vol / constants.dtau * state_iter[idx * 22u + 1u];
    }
    diag_2 += vol / constants.dt;
    rhs_2 += vol / constants.dt * state_old[idx * 22u + 2u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_2 = diag_2 - vol / constants.dt + diag_bdf2;
        rhs_2 = rhs_2 - vol / constants.dt * state_old[idx * 22u + 2u] + vol / constants.dt * (factor_n * state_old[idx * 22u + 2u] - factor_nm1 * state_old_old[idx * 22u + 2u]);
    }
    if (constants.dtau > 0.0) {
        diag_2 += vol / constants.dtau;
        rhs_2 += vol / constants.dtau * state_iter[idx * 22u + 2u];
    }
    diag_3 += vol / constants.dt;
    rhs_3 += vol / constants.dt * state_old[idx * 22u + 7u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_3 = diag_3 - vol / constants.dt + diag_bdf2;
        rhs_3 = rhs_3 - vol / constants.dt * state_old[idx * 22u + 7u] + vol / constants.dt * (factor_n * state_old[idx * 22u + 7u] - factor_nm1 * state_old_old[idx * 22u + 7u]);
    }
    if (constants.dtau > 0.0) {
        diag_3 += vol / constants.dtau;
        rhs_3 += vol / constants.dtau * state_iter[idx * 22u + 7u];
    }
    diag_4 -= -(state[idx * 22u + 0u] * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0)) * vol;
    diag_5 -= -(state[idx * 22u + 0u] * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0)) * vol;
    matrix_values[start_row_4 + diag_rank * 8u + 1u] -= 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    matrix_values[start_row_5 + diag_rank * 8u + 2u] -= 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    diag_6 -= 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    matrix_values[start_row_6 + diag_rank * 8u + 3u] -= -constants.eos_gm1 * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    matrix_values[start_row_6 + diag_rank * 8u + 0u] -= 0.5 * constants.eos_gm1 * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * (state[idx * 22u + 10u] * state[idx * 22u + 10u] + state[idx * 22u + 11u] * state[idx * 22u + 11u]) * vol;
    matrix_values[start_row_6 + diag_rank * 8u + 0u] -= -constants.eos_dp_drho * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    rhs_6 += -constants.eos_p_offset * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    diag_7 -= state[idx * 22u + 0u] * constants.eos_r * 1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0) * vol;
    matrix_values[start_row_7 + diag_rank * 8u + 6u] -= -(1.0 / select(constants.dt, constants.dtau, constants.dtau > 0.0)) * vol;
    for (var k = start; k < end; k++) {
        let face_idx = cell_faces[k];
        let owner = face_owner[face_idx];
        let neighbor_raw = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        let f_center = face_centers[face_idx];
        var normal: Vector2 = face_normals[face_idx];
        var is_boundary: bool = false;
        var other_idx: u32 = idx;
        var other_center: Vector2;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        if (neighbor_raw != -1) {
            let neighbor = u32(neighbor_raw);
            other_idx = neighbor;
            if (owner != idx) {
                other_idx = owner;
            }
            other_center = cell_centers[other_idx];
        } else {
            is_boundary = true;
            other_idx = idx;
            other_center = f_center;
        }
        let dx = other_center.x - center.x;
        let dy = other_center.y - center.y;
        let dist_proj = abs(dx * normal.x + dy * normal.y);
        let dist_euc = sqrt(dx * dx + dy * dy);
        var dist: f32 = max(dist_euc, 0.000001);
        if (dist_proj > 0.000001) {
            dist = dist_proj;
        }
        let scalar_mat_idx = cell_face_matrix_indices[k];
        let neighbor_rank = scalar_mat_idx - scalar_offset;
        var phi_0: f32 = fluxes[face_idx * 8u + 0u];
        if (owner != idx) {
            phi_0 -= phi_0 * 2.0;
        }
        rhs_0 -= phi_0;
        let diff_coeff_rho_u = select(constants.viscosity, (constants.viscosity + constants.viscosity) * 0.5, !is_boundary) * area / dist;
        if (!is_boundary) {
            matrix_values[start_row_1 + diag_rank * 8u + 4u] += diff_coeff_rho_u;
            matrix_values[start_row_1 + neighbor_rank * 8u + 4u] -= diff_coeff_rho_u;
        } else {
            if (boundary_type == 4u) {
                matrix_values[start_row_1 + diag_rank * 8u + 4u] += diff_coeff_rho_u;
                rhs_1 += diff_coeff_rho_u * (state[idx * 22u + 10u] - (state[idx * 22u + 10u] * normal.x + state[idx * 22u + 11u] * normal.y) * normal.x);
            } else {
                if (bc_kind[face_idx * 8u + 4u] == 1u) {
                    matrix_values[start_row_1 + diag_rank * 8u + 4u] += diff_coeff_rho_u;
                    rhs_1 += diff_coeff_rho_u * bc_value[face_idx * 8u + 4u];
                } else {
                    if (bc_kind[face_idx * 8u + 4u] == 2u) {
                        rhs_1 += -(select(constants.viscosity, (constants.viscosity + constants.viscosity) * 0.5, !is_boundary) * area * bc_value[face_idx * 8u + 4u]);
                    }
                }
            }
        }
        if (!is_boundary) {
            matrix_values[start_row_2 + diag_rank * 8u + 5u] += diff_coeff_rho_u;
            matrix_values[start_row_2 + neighbor_rank * 8u + 5u] -= diff_coeff_rho_u;
        } else {
            if (boundary_type == 4u) {
                matrix_values[start_row_2 + diag_rank * 8u + 5u] += diff_coeff_rho_u;
                rhs_2 += diff_coeff_rho_u * (state[idx * 22u + 11u] - (state[idx * 22u + 10u] * normal.x + state[idx * 22u + 11u] * normal.y) * normal.y);
            } else {
                if (bc_kind[face_idx * 8u + 5u] == 1u) {
                    matrix_values[start_row_2 + diag_rank * 8u + 5u] += diff_coeff_rho_u;
                    rhs_2 += diff_coeff_rho_u * bc_value[face_idx * 8u + 5u];
                } else {
                    if (bc_kind[face_idx * 8u + 5u] == 2u) {
                        rhs_2 += -(select(constants.viscosity, (constants.viscosity + constants.viscosity) * 0.5, !is_boundary) * area * bc_value[face_idx * 8u + 5u]);
                    }
                }
            }
        }
        var phi_1: f32 = fluxes[face_idx * 8u + 1u];
        if (owner != idx) {
            phi_1 -= phi_1 * 2.0;
        }
        rhs_1 -= phi_1;
        var phi_2: f32 = fluxes[face_idx * 8u + 2u];
        if (owner != idx) {
            phi_2 -= phi_2 * 2.0;
        }
        rhs_2 -= phi_2;
        var phi_3: f32 = fluxes[face_idx * 8u + 3u];
        if (owner != idx) {
            phi_3 -= phi_3 * 2.0;
        }
        rhs_3 -= phi_3;
    }
    matrix_values[start_row_0 + diag_rank * 8u + 0u] += diag_0;
    rhs[idx * 8u + 0u] = rhs_0;
    matrix_values[start_row_1 + diag_rank * 8u + 1u] += diag_1;
    rhs[idx * 8u + 1u] = rhs_1;
    matrix_values[start_row_2 + diag_rank * 8u + 2u] += diag_2;
    rhs[idx * 8u + 2u] = rhs_2;
    matrix_values[start_row_3 + diag_rank * 8u + 3u] += diag_3;
    rhs[idx * 8u + 3u] = rhs_3;
    matrix_values[start_row_4 + diag_rank * 8u + 4u] += diag_4;
    rhs[idx * 8u + 4u] = rhs_4;
    matrix_values[start_row_5 + diag_rank * 8u + 5u] += diag_5;
    rhs[idx * 8u + 5u] = rhs_5;
    matrix_values[start_row_6 + diag_rank * 8u + 6u] += diag_6;
    rhs[idx * 8u + 6u] = rhs_6;
    matrix_values[start_row_7 + diag_rank * 8u + 7u] += diag_7;
    rhs[idx * 8u + 7u] = rhs_7;
}
