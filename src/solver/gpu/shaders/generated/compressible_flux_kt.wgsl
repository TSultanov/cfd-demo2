// GENERATED BY CFD2 CODEGEN (compressible_flux_kt)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(8) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(9) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let center_owner = cell_centers[owner];
    var normal = face_normals[idx];
    let rho_l = state_old[owner * 7u + 0u];
    let rho_u_l = vec2<f32>(state_old[owner * 7u + 1u], state_old[owner * 7u + 2u]);
    let rho_e_l = state_old[owner * 7u + 3u];
    var rho_r = rho_l;
    var rho_u_r = rho_u_l;
    var rho_e_r = rho_e_l;
    var center_r = face_center;
    if (neighbor != -1) {
        let neigh_idx = u32(neighbor);
        let rho_neigh = state_old[neigh_idx * 7u + 0u];
        let rho_u_neigh = vec2<f32>(state_old[neigh_idx * 7u + 1u], state_old[neigh_idx * 7u + 2u]);
        let rho_e_neigh = state_old[neigh_idx * 7u + 3u];
        rho_r = rho_neigh;
        rho_u_r.x = rho_u_neigh.x;
        rho_u_r.y = rho_u_neigh.y;
        rho_e_r = rho_e_neigh;
        center_r = cell_centers[neigh_idx];
    } else {
        if (boundary_type == 1u) {
            rho_u_r.x = rho_r * constants.inlet_velocity;
            rho_u_r.y = 0.0;
        } else {
            if (boundary_type == 3u) {
                rho_u_r.x = -rho_u_l.x;
                rho_u_r.y = -rho_u_l.y;
            }
        }
    }
    let inv_rho_l = 1.0 / max(rho_l, 1e-8);
    let u_l_x = rho_u_l.x * inv_rho_l;
    let u_l_y = rho_u_l.y * inv_rho_l;
    let ke_l = 0.5 * rho_l * (u_l_x * u_l_x + u_l_y * u_l_y);
    let p_l = max(0.0, (1.4 - 1.0) * (rho_e_l - ke_l));
    let u_n_l = u_l_x * normal.x + u_l_y * normal.y;
    let c_l = sqrt(1.4 * p_l * inv_rho_l);
    let inv_rho_r = 1.0 / max(rho_r, 1e-8);
    let u_r_x = rho_u_r.x * inv_rho_r;
    let u_r_y = rho_u_r.y * inv_rho_r;
    let ke_r = 0.5 * rho_r * (u_r_x * u_r_x + u_r_y * u_r_y);
    let p_r = max(0.0, (1.4 - 1.0) * (rho_e_r - ke_r));
    let u_n_r = u_r_x * normal.x + u_r_y * normal.y;
    let c_r = sqrt(1.4 * p_r * inv_rho_r);
    let u_face_x = 0.5 * (u_l_x + u_r_x);
    let u_face_y = 0.5 * (u_l_y + u_r_y);
    let dx = center_r.x - center_owner.x;
    let dy = center_r.y - center_owner.y;
    let dist = max(sqrt(dx * dx + dy * dy), 1e-6);
    let mu = constants.viscosity;
    let a_plus = max(0.0, max(u_n_l + c_l, u_n_r + c_r));
    let a_minus = min(0.0, min(u_n_l - c_l, u_n_r - c_r));
    let denom = max(a_plus - a_minus, 1e-6);
    let a_prod = a_plus * a_minus;
    let f_rho_l = rho_l * u_n_l;
    let f_rho_r = rho_r * u_n_r;
    let flux_rho = (a_plus * f_rho_l - a_minus * f_rho_r + a_prod * (rho_r - rho_l)) / denom;
    let f_rho_u_l_x = rho_u_l.x * u_n_l + p_l * normal.x;
    let f_rho_u_l_y = rho_u_l.y * u_n_l + p_l * normal.y;
    let f_rho_u_r_x = rho_u_r.x * u_n_r + p_r * normal.x;
    let f_rho_u_r_y = rho_u_r.y * u_n_r + p_r * normal.y;
    var flux_rho_u_x = (a_plus * f_rho_u_l_x - a_minus * f_rho_u_r_x + a_prod * (rho_u_r.x - rho_u_l.x)) / denom;
    var flux_rho_u_y = (a_plus * f_rho_u_l_y - a_minus * f_rho_u_r_y + a_prod * (rho_u_r.y - rho_u_l.y)) / denom;
    let diff_u_x = -mu * (u_r_x - u_l_x) / dist;
    let diff_u_y = -mu * (u_r_y - u_l_y) / dist;
    flux_rho_u_x = flux_rho_u_x + diff_u_x;
    flux_rho_u_y = flux_rho_u_y + diff_u_y;
    let f_rho_e_l = (rho_e_l + p_l) * u_n_l;
    let f_rho_e_r = (rho_e_r + p_r) * u_n_r;
    var flux_rho_e = (a_plus * f_rho_e_l - a_minus * f_rho_e_r + a_prod * (rho_e_r - rho_e_l)) / denom;
    flux_rho_e = flux_rho_e + diff_u_x * u_face_x + diff_u_y * u_face_y;
    let base = idx * 4u;
    fluxes[base + 0u] = flux_rho * area;
    fluxes[base + 1u] = flux_rho_u_x * area;
    fluxes[base + 2u] = flux_rho_u_y * area;
    fluxes[base + 3u] = flux_rho_e * area;
}
