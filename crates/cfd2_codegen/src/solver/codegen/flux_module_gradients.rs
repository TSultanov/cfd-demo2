use super::dsl as typed;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::ir::{FieldKind, FluxLayout, StateLayout};

pub fn generate_flux_module_gradients_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
) -> Result<String, String> {
    let gradients = collect_gradients(layout)?;
    let specs = build_specs(layout, flux_layout, &gradients)?;

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module_gradients)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, flux_layout, &specs)));
    Ok(module.to_wgsl())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::ir::{vol_scalar, vol_vector, FluxComponent};
    use crate::solver::units::si;

    #[test]
    fn flux_module_gradients_accepts_vector_component_gradients() {
        let rho_u = vol_vector("rho_u", si::MOMENTUM_DENSITY);
        let grad_rho_u_x = vol_vector("grad_rho_u_x", si::MOMENTUM_DENSITY / si::LENGTH);
        let grad_rho_u_y = vol_vector("grad_rho_u_y", si::MOMENTUM_DENSITY / si::LENGTH);
        let rho = vol_scalar("rho", si::DENSITY);
        let grad_rho = vol_vector("grad_rho", si::DENSITY / si::LENGTH);

        let layout = StateLayout::new(vec![rho_u, grad_rho_u_x, grad_rho_u_y, rho, grad_rho]);

        let flux_layout = FluxLayout {
            stride: 3,
            components: vec![
                FluxComponent {
                    name: "rho".to_string(),
                    offset: 0,
                },
                FluxComponent {
                    name: "rho_u_x".to_string(),
                    offset: 1,
                },
                FluxComponent {
                    name: "rho_u_y".to_string(),
                    offset: 2,
                },
            ],
        };

        let wgsl = generate_flux_module_gradients_wgsl(&layout, &flux_layout)
            .expect("should generate gradients kernel");
        assert!(wgsl.contains("grad_acc_rho"));
        assert!(wgsl.contains("grad_acc_rho_u_x"));
        assert!(wgsl.contains("grad_acc_rho_u_y"));
    }
}

#[derive(Debug, Clone)]
struct GradientSpec {
    component: String,
    base_offset: u32,
    grad_x_offset: u32,
    grad_y_offset: u32,
    bc_unknown_offset: Option<u32>,
}

fn collect_gradients(layout: &StateLayout) -> Result<Vec<(String, String)>, String> {
    let mut out = Vec::new();
    for field in layout.fields() {
        let name = field.name();
        if !name.starts_with("grad_") {
            continue;
        }
        if field.kind() != FieldKind::Vector2 {
            continue;
        }
        let base = &name["grad_".len()..];
        if base.is_empty() {
            continue;
        }
        // Gradient targets are declared implicitly by naming convention:
        // - `grad_<scalar>` computes gradients for scalar fields.
        // - `grad_<vec>_x` / `grad_<vec>_y` compute gradients for individual components.
        //
        // This keeps flux-module reconstruction PDE-agnostic while allowing per-component
        // MUSCL reconstruction.
        if layout.field(base).is_some() {
            out.push((base.to_string(), name.to_string()));
            continue;
        }

        if let Some((base_field, component)) = base.rsplit_once('_') {
            let comp_ok = matches!(component, "x" | "y" | "z");
            if comp_ok && layout.field(base_field).is_some() {
                out.push((base.to_string(), name.to_string()));
            }
        }
    }

    if out.is_empty() {
        return Err(
            "flux_module_gradients requested but no grad_<field> fields found in state layout"
                .to_string(),
        );
    }

    Ok(out)
}

fn build_specs(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    gradients: &[(String, String)],
) -> Result<Vec<GradientSpec>, String> {
    let mut specs = Vec::new();
    for (component, grad) in gradients {
        let (base_field, base_component) = resolve_base_scalar(layout, component)?;
        let base_offset = layout
            .component_offset(&base_field, base_component)
            .ok_or_else(|| format!("state layout missing field '{base_field}[{base_component}]'"))?;
        let grad_x_offset = layout
            .component_offset(grad, 0)
            .ok_or_else(|| format!("state layout missing vector field '{grad}[0]'"))?;
        let grad_y_offset = layout
            .component_offset(grad, 1)
            .ok_or_else(|| format!("state layout missing vector field '{grad}[1]'"))?;
        let bc_unknown_offset = flux_layout.offset_for(component).map(|v| v as u32);

        specs.push(GradientSpec {
            component: component.clone(),
            base_offset,
            grad_x_offset,
            grad_y_offset,
            bc_unknown_offset,
        });
    }
    Ok(specs)
}

fn resolve_base_scalar(layout: &StateLayout, component: &str) -> Result<(String, u32), String> {
    if let Some(field) = layout.field(component) {
        if field.kind() != FieldKind::Scalar {
            return Err(format!(
                "flux_module_gradients expects '{component}' to be scalar or a <field>_<component> selector"
            ));
        }
        return Ok((component.to_string(), 0));
    }

    let (base, component_name) = component
        .rsplit_once('_')
        .ok_or_else(|| format!("flux_module_gradients: missing base field for '{component}'"))?;
    let component_idx = match component_name {
        "x" => 0,
        "y" => 1,
        "z" => 2,
        _ => {
            return Err(format!(
                "flux_module_gradients: unknown component suffix '{component_name}' in '{component}'"
            ))
        }
    };

    let Some(base_field) = layout.field(base) else {
        return Err(format!(
            "flux_module_gradients: base field '{base}' not found for '{component}'"
        ));
    };

    if component_idx as u32 >= base_field.component_count() {
        return Err(format!(
            "flux_module_gradients: base field '{base}' has {} components, cannot select '{component}'",
            base_field.component_count()
        ));
    }

    Ok((base.to_string(), component_idx))
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 1),
    ]
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(layout: &StateLayout, flux_layout: &FluxLayout, specs: &[GradientSpec]) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout, specs),
    )
}

fn main_body(layout: &StateLayout, flux_layout: &FluxLayout, specs: &[GradientSpec]) -> Block {
    let stride = layout.stride();
    let unknown_stride = flux_layout.stride;

    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "cell_center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_typed_expr(
        "cell_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("cell_center")).expr(),
    ));

    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));

    // Accumulators: one vec2 per gradient.
    for spec in specs {
        let var_name = format!("grad_acc_{}", spec.component);
        stmts.push(dsl::var_typed_expr(&var_name, Type::vec2_f32(), Some(dsl::vec2_f32(0.0, 0.0))));
    }

    // Face loop.
    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neighbor_raw",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "is_boundary",
            Expr::ident("neighbor_raw").eq(-1),
        ));
        body.push(dsl::let_expr(
            "boundary_type",
            dsl::array_access("face_boundary", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "face_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_typed_expr(
            "face_center_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
        ));
        body.push(dsl::var_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            Some(
                typed::VecExpr::<2>::from_xy_fields(
                    Expr::ident("face_normals").index(Expr::ident("face_idx")),
                )
                .expr(),
            ),
        ));
        let cell_to_face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("cell_center_vec")));
        body.push(dsl::if_block_expr(
            cell_to_face
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
                .lt(0.0),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("normal_vec"),
                typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .neg()
                    .expr(),
            )]),
            None,
        ));

        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center_vec",
            Type::vec2_f32(),
            Some(Expr::ident("face_center_vec")),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            dsl::block(vec![
                dsl::let_expr(
                    "neighbor",
                    Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
                ),
                dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
                dsl::if_block_expr(
                    Expr::ident("owner").ne(Expr::ident("idx")),
                    dsl::block(vec![dsl::assign_expr(
                        Expr::ident("other_idx"),
                        Expr::ident("owner"),
                    )]),
                    None,
                ),
                dsl::let_expr(
                    "other_center",
                    dsl::array_access("cell_centers", Expr::ident("other_idx")),
                ),
                dsl::assign_expr(
                    Expr::ident("other_center_vec"),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
                ),
            ]),
            None,
        ));

        body.push(dsl::let_expr(
            "d_own",
            dsl::distance(Expr::ident("cell_center_vec"), Expr::ident("face_center_vec")),
        ));
        body.push(dsl::let_expr(
            "d_neigh",
            dsl::distance(Expr::ident("other_center_vec"), Expr::ident("face_center_vec")),
        ));
        body.push(dsl::let_expr(
            "total_dist",
            Expr::ident("d_own") + Expr::ident("d_neigh"),
        ));
        body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
        body.push(dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ));
        body.push(dsl::let_expr(
            "lambda_other",
            Expr::from(1.0) - Expr::ident("lambda"),
        ));

        for spec in specs {
            let cell_val = Expr::ident("state").index(Expr::ident("idx") * stride + spec.base_offset);
            let interior_other = Expr::ident("state").index(Expr::ident("other_idx") * stride + spec.base_offset);

            let other_val = if let Some(off) = spec.bc_unknown_offset {
                let bc_table_idx = Expr::ident("face_idx") * Expr::from(unknown_stride) + Expr::from(off);
                let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
                let value = dsl::array_access("bc_value", bc_table_idx);
                let from_bc = dsl::select(
                    dsl::select(cell_val.clone(), value.clone(), kind.eq(Expr::from(1u32))),
                    cell_val.clone() + value * Expr::ident("d_own"),
                    kind.eq(Expr::from(2u32)),
                );
                dsl::select(interior_other, from_bc, Expr::ident("is_boundary"))
            } else {
                dsl::select(interior_other, cell_val.clone(), Expr::ident("is_boundary"))
            };

            let phi_face = cell_val * Expr::ident("lambda") + other_val * Expr::ident("lambda_other");

            let acc_name = format!("grad_acc_{}", spec.component);
            let contrib = typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .mul_scalar(phi_face * Expr::ident("area"))
                .expr();
            body.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(&acc_name),
                contrib,
            ));
        }

        dsl::block(body)
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        face_loop_body,
    ));

    // Write out gradients (divide by volume).
    for spec in specs {
        let acc_name = format!("grad_acc_{}", spec.component);
        let grad_vec = typed::VecExpr::<2>::from_expr(Expr::ident(&acc_name))
            .mul_scalar(Expr::from(1.0) / dsl::max(Expr::ident("vol"), 1e-12))
            .expr();
        stmts.push(dsl::let_typed_expr(
            &format!("grad_out_{}", spec.component),
            Type::vec2_f32(),
            grad_vec,
        ));

        let out = Expr::ident(&format!("grad_out_{}", spec.component));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + spec.grad_x_offset),
            out.clone().field("x"),
        ));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + spec.grad_y_offset),
            out.field("y"),
        ));
    }

    Block::new(stmts)
}
