use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use super::KernelWgsl;

pub fn generate_dp_init_wgsl(state_stride: u32, d_p_offset: u32) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN (dp_init)".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.push(Item::Struct(constants_struct()));
    module.push(storage_var(
        "cell_vols",
        Type::array(Type::F32),
        0,
        0,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        1,
        AccessMode::ReadWrite,
    ));
    module.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        2,
    ));
    module.push(Item::Function(main_fn(state_stride, d_p_offset)));
    KernelWgsl::from(module)
}

fn constants_struct() -> StructDef {
    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(state_stride: u32, d_p_offset: u32) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(state_stride, d_p_offset),
    )
}

fn main_body(state_stride: u32, d_p_offset: u32) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));

    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()])
            / dsl::max(Expr::lit_u32(state_stride), Expr::lit_u32(1)),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "rho",
        dsl::max(
            Expr::ident("constants").field("density"),
            Expr::lit_f32(1e-12),
        ),
    ));
    stmts.push(dsl::let_expr(
        "dt",
        dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
    ));

    // Kept for parity with the historical shader output (even though not currently used).
    stmts.push(dsl::let_expr(
        "vol",
        dsl::max(
            dsl::array_access("cell_vols", Expr::ident("idx")),
            Expr::lit_f32(1e-12),
        ),
    ));

    stmts.push(dsl::comment(
        "Seed Rhie–Chow mobility with a transient-scale approximation.",
    ));
    stmts.push(dsl::comment(
        "For integrated momentum diagonals A_U ~ rho*vol/dt (units: kg/s), a good first guess for",
    ));
    stmts.push(dsl::comment("the mobility-like coefficient is:"));
    stmts.push(dsl::comment("  d_p ≈ vol / A_U ≈ dt / rho"));
    stmts.push(dsl::comment(
        "Note: the solver applies velocity under-relaxation in the update stage rather than",
    ));
    stmts.push(dsl::comment(
        "modifying the assembled momentum diagonal. Match SIMPLE-like behavior by folding the",
    ));
    stmts.push(dsl::comment(
        "relaxation factor into the mobility: d_p ≈ alpha_u / A_U.",
    ));

    stmts.push(dsl::let_expr(
        "d_p",
        Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
    ));

    stmts.push(dsl::assign_array_access_linear(
        "state",
        Expr::ident("idx"),
        state_stride,
        d_p_offset,
        Expr::ident("d_p"),
    ));

    Block::new(stmts)
}
