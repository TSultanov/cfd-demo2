pub fn generate_dp_update_from_diag_wgsl(
    state_stride: u32,
    d_p_offset: u32,
    unknowns_per_cell: u32,
    u_indices: &[u32],
) -> Result<String, String> {
    if unknowns_per_cell == 0 {
        return Err("dp_update_from_diag requires unknowns_per_cell > 0".to_string());
    }
    if u_indices.is_empty() {
        return Err("dp_update_from_diag requires at least one momentum component index".to_string());
    }
    if u_indices.len() > 8 {
        return Err("dp_update_from_diag supports at most 8 momentum components".to_string());
    }
    if u_indices.iter().any(|&u| u >= unknowns_per_cell) {
        return Err(format!(
            "dp_update_from_diag: momentum indices {:?} out of range for unknowns_per_cell={unknowns_per_cell}",
            u_indices
        ));
    }

    let mut out = String::new();
    out.push_str("// GENERATED BY CFD2 CODEGEN (dp_update_from_diag)\n\n");
    out.push_str("// DO NOT EDIT MANUALLY\n\n");

    out.push_str(&format!(
        "const STATE_STRIDE: u32 = {state_stride}u;\n\
const D_P_OFFSET: u32 = {d_p_offset}u;\n\
const UNKNOWNS_PER_CELL: u32 = {unknowns_per_cell}u;\n\
const U_LEN: u32 = {}u;\n\n",
        u_indices.len()
    ));

    for (i, u) in u_indices.iter().enumerate() {
        out.push_str(&format!("const U_{i}: u32 = {u}u;\n"));
    }
    out.push('\n');

    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    out.push_str(
        "struct Constants {\n\
    dt: f32,\n\
    dt_old: f32,\n\
    dtau: f32,\n\
    time: f32,\n\
    viscosity: f32,\n\
    density: f32,\n\
    component: u32,\n\
    alpha_p: f32,\n\
    scheme: u32,\n\
    alpha_u: f32,\n\
    stride_x: u32,\n\
    time_scheme: u32,\n\
}\n\n",
    );

    out.push_str(
        "@group(0) @binding(0)\n\
var<storage, read> scalar_row_offsets: array<u32>;\n\n\
@group(0) @binding(1)\n\
var<storage, read> diagonal_indices: array<u32>;\n\n\
@group(0) @binding(2)\n\
var<storage, read> matrix_values: array<f32>;\n\n\
@group(0) @binding(3)\n\
var<storage, read_write> state: array<f32>;\n\n",
    );

    out.push_str("@group(0) @binding(4)\nvar<uniform> constants: Constants;\n\n");

    out.push_str(
        "fn safe_inverse(val: f32) -> f32 {\n\
    if (abs(val) > 1e-14) {\n\
        return 1.0 / val;\n\
    }\n\
    return 0.0;\n\
}\n\n",
    );

    out.push_str(
        "@compute\n\
@workgroup_size(64)\n\
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\
    let idx = global_id.y * constants.stride_x + global_id.x;\n\
    let num_cells = arrayLength(&scalar_row_offsets) - 1u;\n\
    if (idx >= num_cells) {\n\
        return;\n\
    }\n\
\n\
    let scalar_offset = scalar_row_offsets[idx];\n\
    let scalar_end = scalar_row_offsets[idx + 1u];\n\
    let num_neighbors = scalar_end - scalar_offset;\n\
    let diag_rank = diagonal_indices[idx] - scalar_offset;\n\
\n\
    let block_stride = UNKNOWNS_PER_CELL * UNKNOWNS_PER_CELL;\n\
    let start_row_0 = scalar_offset * block_stride;\n\
    let row_stride = num_neighbors * UNKNOWNS_PER_CELL;\n\
\n\
    var sum_u_inv: f32 = 0.0;\n",
    );

    for (i, _) in u_indices.iter().enumerate() {
        out.push_str(&format!(
            "    {{\n\
        let u = U_{i};\n\
        let start_row_u = start_row_0 + u * row_stride;\n\
        let diag_u = matrix_values[start_row_u + diag_rank * UNKNOWNS_PER_CELL + u];\n\
        sum_u_inv += safe_inverse(diag_u);\n\
    }}\n"
        ));
    }

    out.push_str(
        "\n\
    let d_p = sum_u_inv / max(f32(U_LEN), 1.0);\n\
    state[idx * STATE_STRIDE + D_P_OFFSET] = d_p;\n\
}\n",
    );

    Ok(out)
}
