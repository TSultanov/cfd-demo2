use super::state_access::{state_scalar_expr, state_vec2_expr};
use super::state_layout::StateLayout;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

const FIELD_D_P: &str = "d_p";
const FIELD_GRAD_P: &str = "grad_p";

pub fn generate_pressure_assembly_wgsl(layout: &StateLayout) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (pressure_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("padding", Type::U32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout),
    )
}

fn main_body(layout: &StateLayout) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_("idx", "global_id.x"));
    stmts.push(dsl::if_block(
        "idx >= arrayLength(&cell_vols)",
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_("start", "cell_face_offsets[idx]"));
    stmts.push(dsl::let_("end", "cell_face_offsets[idx + 1]"));
    stmts.push(dsl::let_("center", "cell_centers[idx]"));
    stmts.push(dsl::let_("vol", "cell_vols[idx]"));
    stmts.push(dsl::var_typed("diag_coeff", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("rhs_val", Type::F32, Some("0.0")));

    let d_p_idx_expr = state_scalar_expr(layout, "state", "idx", FIELD_D_P);
    let grad_p_idx_expr = state_vec2_expr(layout, "state", "idx", FIELD_GRAD_P);

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_("face_idx", "cell_faces[k]"));
    loop_body.push(dsl::let_("owner", "face_owner[face_idx]"));
    loop_body.push(dsl::let_("neigh_idx", "face_neighbor[face_idx]"));
    loop_body.push(dsl::let_("boundary_type", "face_boundary[face_idx]"));
    loop_body.push(dsl::var("normal", "face_normals[face_idx]"));
    loop_body.push(dsl::let_("area", "face_areas[face_idx]"));
    loop_body.push(dsl::let_("f_center", "face_centers[face_idx]"));
    loop_body.push(dsl::let_("c_owner", "cell_centers[owner]"));
    loop_body.push(dsl::let_("dx_vec", "f_center.x - c_owner.x"));
    loop_body.push(dsl::let_("dy_vec", "f_center.y - c_owner.y"));
    loop_body.push(dsl::if_block(
        "dx_vec * normal.x + dy_vec * normal.y < 0.0",
        dsl::block(vec![
            dsl::assign("normal.x", "-normal.x"),
            dsl::assign("normal.y", "-normal.y"),
        ]),
        None,
    ));
    loop_body.push(dsl::var_typed("normal_sign", Type::F32, Some("1.0")));
    loop_body.push(dsl::if_block(
        "owner != idx",
        dsl::block(vec![
            dsl::assign("normal.x", "-normal.x"),
            dsl::assign("normal.y", "-normal.y"),
            dsl::assign("normal_sign", "-1.0"),
        ]),
        None,
    ));
    loop_body.push(dsl::let_("flux", "fluxes[face_idx] * normal_sign"));
    loop_body.push(dsl::assign_op(AssignOp::Sub, "rhs_val", "flux"));
    loop_body.push(dsl::var_typed(
        "other_center",
        Type::Custom("Vector2".to_string()),
        None,
    ));
    loop_body.push(dsl::var("is_boundary", "false"));
    loop_body.push(dsl::var_typed("d_p_neigh", Type::F32, Some("0.0")));

    let d_p_other_expr = state_scalar_expr(layout, "state", "other_idx", FIELD_D_P);

    loop_body.push(dsl::if_block(
        "neigh_idx != -1",
        dsl::block(vec![
            dsl::var("other_idx", "u32(neigh_idx)"),
            dsl::if_block(
                "owner != idx",
                dsl::block(vec![dsl::assign("other_idx", "owner")]),
                None,
            ),
            dsl::assign("other_center", "cell_centers[other_idx]"),
            dsl::assign("d_p_neigh", &d_p_other_expr),
        ]),
        Some(dsl::block(vec![
            dsl::assign("is_boundary", "true"),
            dsl::assign("other_center", "f_center"),
            dsl::assign("d_p_neigh", &d_p_idx_expr),
        ])),
    ));

    let internal_block = dsl::block(vec![
        dsl::let_("d_vec_x", "other_center.x - center.x"),
        dsl::let_("d_vec_y", "other_center.y - center.y"),
        dsl::let_("dist", "sqrt(d_vec_x*d_vec_x + d_vec_y*d_vec_y)"),
        dsl::let_(
            "d_own",
            "distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y))",
        ),
        dsl::let_(
            "d_neigh",
            "distance(vec2<f32>(other_center.x, other_center.y), vec2<f32>(f_center.x, f_center.y))",
        ),
        dsl::let_("total_dist", "d_own + d_neigh"),
        dsl::var("lambda", "0.5"),
        dsl::if_block(
            "total_dist > 1e-6",
            dsl::block(vec![dsl::assign("lambda", "d_neigh / total_dist")]),
            None,
        ),
        dsl::let_("d_p_own", &d_p_idx_expr),
        dsl::let_("d_p_face", "lambda * d_p_own + (1.0 - lambda) * d_p_neigh"),
        dsl::let_("coeff", "constants.density * d_p_face * area / dist"),
        dsl::let_("mat_idx", "cell_face_matrix_indices[k]"),
        dsl::if_block(
            "mat_idx != 4294967295u",
            dsl::block(vec![dsl::assign("matrix_values[mat_idx]", "-coeff")]),
            None,
        ),
        dsl::assign_op(AssignOp::Add, "diag_coeff", "coeff"),
        dsl::let_("s_x", "normal.x * area"),
        dsl::let_("s_y", "normal.y * area"),
        dsl::let_("k_x_raw", "s_x - d_vec_x * (area / dist)"),
        dsl::let_("k_y_raw", "s_y - d_vec_y * (area / dist)"),
        dsl::let_("k_mag", "sqrt(k_x_raw * k_x_raw + k_y_raw * k_y_raw)"),
        dsl::let_("k_limit", "0.5 * area"),
        dsl::var("k_scale", "1.0"),
        dsl::if_block(
            "k_mag > k_limit",
            dsl::block(vec![dsl::assign("k_scale", "k_limit / k_mag")]),
            None,
        ),
        dsl::let_("k_x", "k_x_raw * k_scale"),
        dsl::let_("k_y", "k_y_raw * k_scale"),
        dsl::var("other_idx_p", "u32(neigh_idx)"),
        dsl::if_block(
            "owner != idx",
            dsl::block(vec![dsl::assign("other_idx_p", "owner")]),
            None,
        ),
        dsl::let_("grad_p_own", &grad_p_idx_expr),
        dsl::let_(
            "grad_p_neigh",
            &state_vec2_expr(layout, "state", "other_idx_p", FIELD_GRAD_P),
        ),
        dsl::var("interp_f", "0.5"),
        dsl::if_block(
            "total_dist > 1e-6",
            dsl::block(vec![dsl::assign("interp_f", "d_own / total_dist")]),
            None,
        ),
        dsl::let_(
            "grad_p_f_x",
            "grad_p_own.x + interp_f * (grad_p_neigh.x - grad_p_own.x)",
        ),
        dsl::let_(
            "grad_p_f_y",
            "grad_p_own.y + interp_f * (grad_p_neigh.y - grad_p_own.y)",
        ),
        dsl::let_(
            "correction_flux",
            "0.5 * constants.density * d_p_face * (grad_p_f_x * k_x + grad_p_f_y * k_y)",
        ),
        dsl::assign_op(AssignOp::Sub, "rhs_val", "correction_flux"),
    ]);

    let boundary_block = dsl::block(vec![dsl::if_block(
        "boundary_type == 2u",
        dsl::block(vec![
            dsl::let_("dx", "center.x - f_center.x"),
            dsl::let_("dy", "center.y - f_center.y"),
            dsl::let_("dist", "sqrt(dx*dx + dy*dy)"),
            dsl::let_("d_p_own", &d_p_idx_expr),
            dsl::let_("coeff", "constants.density * d_p_own * area / dist"),
            dsl::assign_op(AssignOp::Add, "diag_coeff", "coeff"),
        ]),
        None,
    )]);

    loop_body.push(dsl::if_block(
        "!is_boundary",
        internal_block,
        Some(boundary_block),
    ));

    stmts.push(dsl::for_loop(
        dsl::for_init_var("k", "start"),
        "k < end",
        dsl::for_step_increment("k"),
        dsl::block(loop_body),
    ));

    stmts.push(dsl::let_("diag_idx", "diagonal_indices[idx]"));
    stmts.push(dsl::assign("matrix_values[diag_idx]", "diag_coeff"));
    stmts.push(dsl::assign("rhs[idx]", "rhs_val"));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::ast::{vol_scalar, vol_vector};

    #[test]
    fn pressure_assembly_codegen_emits_state_arrays() {
        let layout = StateLayout::new(vec![
            vol_vector("U"),
            vol_scalar("p"),
            vol_scalar("d_p"),
            vol_vector("grad_p"),
        ]);
        let wgsl = generate_pressure_assembly_wgsl(&layout);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("matrix_values"));
        assert!(wgsl.contains("rhs"));
    }
}
