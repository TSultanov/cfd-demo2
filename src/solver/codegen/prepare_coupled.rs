use super::coeff_expr::{coeff_cell_expr, coeff_face_expr};
use super::dsl as typed;
use super::ir::DiscreteSystem;
use super::plan::{momentum_plan, MomentumPlan};
use super::state_access::{state_component, state_scalar, state_vec2};
use crate::solver::model::IncompressibleMomentumFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, BinaryOp, Block, Expr, Function, GlobalVar, Item, Module,
    Param, Stmt, StorageClass, StructDef, StructField, Type, UnaryOp,
};
use super::wgsl_dsl as dsl;

pub fn generate_prepare_coupled_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (prepare_coupled)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    let plan = momentum_plan(system, fields.u.name(), fields.p.name());
    module.push(Item::Function(main_fn(layout, &plan, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Solver (Coupled) - Must match coupled_assembly_merged.wgsl layout".to_string(),
    ));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "grad_u",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            3,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_v",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            4,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "scalar_matrix_values",
            Type::array(Type::F32),
            2,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_u_inv",
            Type::array(Type::F32),
            2,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_v_inv",
            Type::array(Type::F32),
            2,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_p_inv",
            Type::array(Type::F32),
            2,
            8,
            AccessMode::ReadWrite,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, plan, fields),
    )
}

fn main_body(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Block {
    let mut stmts = Vec::new();
    let u_field = fields.u.name();
    let p_field = fields.p.name();
    let d_p_field = fields.d_p.name();
    let grad_p_field = fields.grad_p.name();
    let u_old_expr = state_vec2(layout, "state_old", "idx", u_field);
    let u_idx_expr = state_vec2(layout, "state", "idx", u_field);
    let p_idx_expr = state_scalar(layout, "state", "idx", p_field);
    let rho_cell_expr = coeff_cell_expr(
        layout,
        plan.ddt.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        Expr::ident("constants").field("density"),
    );
    let rho_face_expr = coeff_face_expr(
        layout,
        plan.ddt.as_ref().and_then(|op| op.coeff.as_ref()),
        "owner",
        "n_idx",
        Expr::ident("lambda"),
        Expr::ident("rho_cell"),
    );
    let diff_coeff_cell_expr = coeff_cell_expr(
        layout,
        plan.diffusion.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        Expr::lit_f32(0.0),
    );
    let diff_coeff_expr = diff_coeff_cell_expr.clone() * Expr::ident("area") / Expr::ident("dist");

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::binary(
            Expr::ident("idx"),
            BinaryOp::GreaterEq,
            Expr::call_named(
                "arrayLength",
                vec![Expr::unary(UnaryOp::AddressOf, Expr::ident("cell_vols"))],
            ),
        ),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "center",
        Expr::ident("cell_centers").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_typed_expr(
        "center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("center")).expr(),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        Expr::ident("cell_vols").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx") + Expr::lit_u32(1)),
    ));

    stmts.push(dsl::var_typed_expr("diag_coeff", Type::F32, Some(Expr::lit_f32(0.0))));
    stmts.push(dsl::let_typed_expr("u_n_val", Type::vec2_f32(), u_old_expr));
    stmts.push(dsl::let_expr("rho_cell", rho_cell_expr));
    if plan.ddt.is_some() {
        stmts.push(dsl::var_typed_expr(
            "time_coeff",
            Type::F32,
            Some(Expr::ident("vol") * Expr::ident("rho_cell") / Expr::ident("constants").field("dt")),
        ));
        stmts.push(dsl::if_block_expr(
            Expr::binary(
                Expr::ident("constants").field("time_scheme"),
                BinaryOp::Equal,
                Expr::lit_u32(1),
            ),
            dsl::block(vec![
                dsl::let_expr("dt", Expr::ident("constants").field("dt")),
                dsl::let_expr("dt_old", Expr::ident("constants").field("dt_old")),
                dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
                dsl::assign_expr(
                    Expr::ident("time_coeff"),
                    Expr::ident("vol")
                        * Expr::ident("rho_cell")
                        / Expr::ident("dt")
                        * (Expr::lit_f32(1.0) + Expr::lit_f32(2.0) * Expr::ident("r"))
                        / (Expr::lit_f32(1.0) + Expr::ident("r")),
                ),
            ]),
            None,
        ));
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_coeff"),
            Expr::ident("time_coeff"),
        ));
    }

    stmts.push(dsl::let_expr("val_c_p", p_idx_expr));
    stmts.push(dsl::var_typed_expr(
        "grad_p_accum",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::zeros().expr()),
    ));

    stmts.push(dsl::let_typed_expr("u_val", Type::vec2_f32(), u_idx_expr));
    stmts.push(dsl::var_typed_expr(
        "g_u",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::zeros().expr()),
    ));
    stmts.push(dsl::var_typed_expr(
        "g_v",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::zeros().expr()),
    ));

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_expr(
        "face_idx",
        Expr::ident("cell_faces").index(Expr::ident("k")),
    ));
    loop_body.push(dsl::let_expr(
        "owner",
        Expr::ident("face_owner").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "neigh_idx",
        Expr::ident("face_neighbor").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "boundary_type",
        Expr::ident("face_boundary").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "area",
        Expr::ident("face_areas").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "f_center",
        Expr::ident("face_centers").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "c_owner",
        Expr::ident("cell_centers").index(Expr::ident("owner")),
    ));
    loop_body.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    loop_body.push(dsl::let_typed_expr(
        "f_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("f_center")).expr(),
    ));

    loop_body.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("face_idx")),
            )
            .expr(),
        ),
    ));
    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("owner"), BinaryOp::NotEqual, Expr::ident("idx")),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).neg().expr(),
        )]),
        None,
    ));
    loop_body.push(dsl::let_typed_expr(
        "face_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
            .mul_scalar(Expr::ident("area"))
            .expr(),
    ));

    loop_body.push(dsl::var_typed_expr(
        "normal_flux_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("face_idx")),
            )
            .expr(),
        ),
    ));
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("f_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    loop_body.push(dsl::if_block_expr(
        Expr::binary(
            owner_face_d_vec.dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_flux_vec"))),
            BinaryOp::Less,
            Expr::lit_f32(0.0),
        ),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_flux_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_flux_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    loop_body.push(dsl::var_typed_expr(
        "flux",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_face",
        Type::F32,
        Some(Expr::ident("rho_cell")),
    ));

    let u_owner_expr = state_vec2(layout, "state", "owner", u_field);
    let u_neigh_expr = state_vec2(layout, "state", "n_idx", u_field);
    let dp_owner_expr = state_scalar(layout, "state", "owner", d_p_field);
    let dp_neigh_expr = state_scalar(layout, "state", "n_idx", d_p_field);
    let gp_owner_expr = state_vec2(layout, "state", "owner", grad_p_field);
    let gp_neigh_expr = state_vec2(layout, "state", "n_idx", grad_p_field);
    let p_owner_expr = state_scalar(layout, "state", "owner", p_field);
    let p_neigh_expr = state_scalar(layout, "state", "n_idx", p_field);

    let inlet_block = dsl::block(vec![
        dsl::let_expr(
            "ramp",
            Expr::call_named(
                "smoothstep",
                vec![
                    Expr::lit_f32(0.0),
                    Expr::ident("constants").field("ramp_time"),
                    Expr::ident("constants").field("time"),
                ],
            ),
        ),
        dsl::let_typed_expr(
            "u_bc",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_components([
                Expr::binary(
                    Expr::ident("constants").field("inlet_velocity"),
                    BinaryOp::Mul,
                    Expr::ident("ramp"),
                ),
                Expr::lit_f32(0.0),
            ])
            .expr(),
        ),
        dsl::assign_expr(
            Expr::ident("flux"),
            Expr::binary(
                Expr::binary(
                    Expr::ident("rho_face"),
                    BinaryOp::Mul,
                    Expr::call_named(
                        "dot",
                        vec![Expr::ident("u_bc"), Expr::ident("normal_flux_vec")],
                    ),
                ),
                BinaryOp::Mul,
                Expr::ident("area"),
            ),
        ),
    ]);

    let wall_block = dsl::block(vec![dsl::assign_expr(Expr::ident("flux"), Expr::lit_f32(0.0))]);

    let outlet_block = dsl::block(vec![
        dsl::let_typed_expr("u_own", Type::vec2_f32(), u_owner_expr.clone()),
        dsl::let_expr(
            "u_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_own"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_flux_vec"))),
        ),
        dsl::let_expr(
            "raw_flux",
            Expr::ident("rho_face") * Expr::ident("u_n") * Expr::ident("area"),
        ),
        dsl::assign_expr(
            Expr::ident("flux"),
            Expr::call_named("max", vec![Expr::lit_f32(0.0), Expr::ident("raw_flux")]),
        ),
    ]);

    let boundary_flux = dsl::block(vec![dsl::if_block_expr(
        Expr::binary(
            Expr::ident("boundary_type"),
            BinaryOp::Equal,
            Expr::lit_u32(1),
        ),
        inlet_block,
        Some(dsl::block(vec![dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(3),
            ),
            wall_block,
            Some(dsl::block(vec![dsl::if_block_expr(
                Expr::binary(
                    Expr::ident("boundary_type"),
                    BinaryOp::Equal,
                    Expr::lit_u32(2),
                ),
                outlet_block,
                None,
            )])),
        )])),
    )]);

    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("neigh_idx"), BinaryOp::NotEqual, Expr::lit_i32(-1)),
        dsl::block(vec![
            dsl::let_typed_expr(
                "n_idx",
                Type::U32,
                Expr::call_named("u32", vec![Expr::ident("neigh_idx")]),
            ),
            dsl::let_expr(
                "c_neigh",
                Expr::ident("cell_centers").index(Expr::ident("n_idx")),
            ),
            dsl::let_typed_expr(
                "c_neigh_vec",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr(),
            ),
            dsl::let_typed_expr("u_own", Type::vec2_f32(), u_owner_expr.clone()),
            dsl::let_typed_expr("u_ngh", Type::vec2_f32(), u_neigh_expr.clone()),
            dsl::let_expr("dp_own", dp_owner_expr.clone()),
            dsl::let_expr("dp_ngh", dp_neigh_expr.clone()),
            dsl::let_typed_expr("gp_own", Type::vec2_f32(), gp_owner_expr.clone()),
            dsl::let_typed_expr("gp_ngh", Type::vec2_f32(), gp_neigh_expr.clone()),
            dsl::let_expr("p_own", p_owner_expr.clone()),
            dsl::let_expr("p_ngh", p_neigh_expr.clone()),
            dsl::let_expr(
                "d_own",
                Expr::call_named(
                    "distance",
                    vec![Expr::ident("c_owner_vec"), Expr::ident("f_center_vec")],
                ),
            ),
            dsl::let_expr(
                "d_ngh",
                Expr::call_named(
                    "distance",
                    vec![Expr::ident("c_neigh_vec"), Expr::ident("f_center_vec")],
                ),
            ),
            dsl::let_expr("total_dist", Expr::ident("d_own") + Expr::ident("d_ngh")),
            dsl::var_typed_expr("lambda", Type::F32, Some(Expr::lit_f32(0.5))),
            dsl::if_block_expr(
                Expr::binary(
                    Expr::ident("total_dist"),
                    BinaryOp::Greater,
                    Expr::lit_f32(1e-6),
                ),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("lambda"),
                    Expr::ident("d_ngh") / Expr::ident("total_dist"),
                )]),
                None,
            ),
            dsl::let_expr(
                "lambda_other",
                Expr::lit_f32(1.0) - Expr::ident("lambda"),
            ),
            dsl::assign_expr(Expr::ident("rho_face"), rho_face_expr),
            dsl::let_typed_expr(
                "u_face",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_expr(Expr::ident("u_own"))
                    .mul_scalar(Expr::ident("lambda"))
                    .add(
                        &typed::VecExpr::<2>::from_expr(Expr::ident("u_ngh"))
                            .mul_scalar(Expr::ident("lambda_other")),
                    )
                    .expr(),
            ),
            dsl::let_expr(
                "dp_face",
                Expr::ident("lambda") * Expr::ident("dp_own")
                    + Expr::ident("lambda_other") * Expr::ident("dp_ngh"),
            ),
            dsl::let_typed_expr(
                "gp_face",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_expr(Expr::ident("gp_own"))
                    .mul_scalar(Expr::ident("lambda"))
                    .add(
                        &typed::VecExpr::<2>::from_expr(Expr::ident("gp_ngh"))
                            .mul_scalar(Expr::ident("lambda_other")),
                    )
                    .expr(),
            ),
            dsl::let_typed_expr(
                "d_vec",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
                    .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
                    .expr(),
            ),
            dsl::let_expr(
                "dist_proj",
                Expr::call_named(
                    "abs",
                    vec![typed::VecExpr::<2>::from_expr(Expr::ident("d_vec")).dot(
                        &typed::VecExpr::<2>::from_expr(Expr::ident("normal_flux_vec")),
                    )],
                ),
            ),
            dsl::let_expr(
                "dist",
                Expr::call_named("max", vec![Expr::ident("dist_proj"), Expr::lit_f32(1e-6)]),
            ),
            dsl::let_expr(
                "grad_p_n",
                typed::VecExpr::<2>::from_expr(Expr::ident("gp_face"))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_flux_vec"))),
            ),
            dsl::let_expr(
                "p_grad_f",
                (Expr::ident("p_ngh") - Expr::ident("p_own")) / Expr::ident("dist"),
            ),
            dsl::let_expr(
                "rc_term",
                Expr::ident("dp_face")
                    * Expr::ident("area")
                    * (Expr::ident("grad_p_n") - Expr::ident("p_grad_f")),
            ),
            dsl::let_expr(
                "u_n",
                typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_flux_vec"))),
            ),
            dsl::assign_expr(
                Expr::ident("flux"),
                Expr::ident("rho_face")
                    * (Expr::ident("u_n") * Expr::ident("area") + Expr::ident("rc_term")),
            ),
        ]),
        Some(boundary_flux),
    ));

    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("owner"), BinaryOp::Equal, Expr::ident("idx")),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("fluxes").index(Expr::ident("face_idx")),
            Expr::ident("flux"),
        )]),
        None,
    ));

    loop_body.push(dsl::var_typed_expr(
        "flux_out",
        Type::F32,
        Some(Expr::ident("flux")),
    ));
    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("owner"), BinaryOp::NotEqual, Expr::ident("idx")),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("flux_out"),
            Expr::unary(UnaryOp::Negate, Expr::ident("flux")),
        )]),
        None,
    ));

    loop_body.push(dsl::var_typed_expr(
        "other_center",
        Type::Custom("Vector2".to_string()),
        None,
    ));
    loop_body.push(dsl::var_typed_expr(
        "is_boundary",
        Type::Bool,
        Some(Expr::lit_bool(false)),
    ));
    loop_body.push(dsl::var_typed_expr(
        "other_idx",
        Type::U32,
        Some(Expr::lit_u32(0)),
    ));
    loop_body.push(dsl::if_block_expr(
        Expr::binary(Expr::ident("neigh_idx"), BinaryOp::NotEqual, Expr::lit_i32(-1)),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("other_idx"),
                Expr::call_named("u32", vec![Expr::ident("neigh_idx")]),
            ),
            dsl::if_block_expr(
                Expr::binary(Expr::ident("owner"), BinaryOp::NotEqual, Expr::ident("idx")),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("other_idx"),
                    Expr::ident("owner"),
                )]),
                None,
            ),
            dsl::assign_expr(
                Expr::ident("other_center"),
                Expr::ident("cell_centers").index(Expr::ident("other_idx")),
            ),
        ]),
        Some(dsl::block(vec![
            dsl::assign_expr(Expr::ident("is_boundary"), Expr::lit_bool(true)),
            dsl::assign_expr(Expr::ident("other_center"), Expr::ident("f_center")),
        ])),
    ));

    loop_body.push(dsl::let_typed_expr(
        "other_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
    ));
    loop_body.push(dsl::let_typed_expr(
        "d_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("other_center_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("center_vec")))
            .expr(),
    ));
    loop_body.push(dsl::let_expr(
        "dist",
        Expr::call_named("length", vec![Expr::ident("d_vec")]),
    ));
    loop_body.push(dsl::let_expr("diff_coeff", diff_coeff_expr));
    loop_body.push(dsl::var_typed_expr(
        "conv_coeff_diag",
        Type::F32,
        Some(Expr::lit_f32(0.0)),
    ));
    loop_body.push(dsl::if_block_expr(
        Expr::binary(
            Expr::ident("flux_out"),
            BinaryOp::Greater,
            Expr::lit_f32(0.0),
        ),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("conv_coeff_diag"),
            Expr::ident("flux_out"),
        )]),
        None,
    ));

    let inlet_diag = dsl::block(vec![
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_coeff"),
            Expr::ident("diff_coeff"),
        ),
        dsl::if_block_expr(
            Expr::binary(
                Expr::ident("flux_out"),
                BinaryOp::Greater,
                Expr::lit_f32(0.0),
            ),
            dsl::block(vec![dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("diag_coeff"),
                Expr::ident("flux_out"),
            )]),
            None,
        ),
    ]);
    let wall_diag = inlet_diag.clone();
    let outlet_diag = dsl::block(vec![dsl::if_block_expr(
        Expr::binary(
            Expr::ident("flux_out"),
            BinaryOp::Greater,
            Expr::lit_f32(0.0),
        ),
        dsl::block(vec![dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_coeff"),
            Expr::ident("flux_out"),
        )]),
        None,
    )]);

    loop_body.push(dsl::if_block_expr(
        Expr::unary(UnaryOp::Not, Expr::ident("is_boundary")),
        dsl::block(vec![dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_coeff"),
            Expr::ident("diff_coeff") + Expr::ident("conv_coeff_diag"),
        )]),
        Some(dsl::block(vec![dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(1),
            ),
            inlet_diag,
            Some(dsl::block(vec![dsl::if_block_expr(
                Expr::binary(
                    Expr::ident("boundary_type"),
                    BinaryOp::Equal,
                    Expr::lit_u32(3),
                ),
                wall_diag,
                Some(dsl::block(vec![dsl::if_block_expr(
                    Expr::binary(
                        Expr::ident("boundary_type"),
                        BinaryOp::Equal,
                        Expr::lit_u32(2),
                    ),
                    outlet_diag,
                    None,
                )])),
            )])),
        )])),
    ));

    let val_other_p_expr = state_scalar(layout, "state", "other_idx", p_field);
    let grad_internal = dsl::block(vec![
        dsl::let_expr(
            "d_c",
            Expr::call_named(
                "distance",
                vec![Expr::ident("center_vec"), Expr::ident("f_center_vec")],
            ),
        ),
        dsl::let_expr(
            "d_o",
            Expr::call_named(
                "distance",
                vec![Expr::ident("other_center_vec"), Expr::ident("f_center_vec")],
            ),
        ),
        dsl::let_expr("total_dist_p", Expr::ident("d_c") + Expr::ident("d_o")),
        dsl::var_typed_expr("lambda_p", Type::F32, Some(Expr::lit_f32(0.5))),
        dsl::if_block_expr(
            Expr::binary(
                Expr::ident("total_dist_p"),
                BinaryOp::Greater,
                Expr::lit_f32(1e-6),
            ),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda_p"),
                Expr::ident("d_o") / Expr::ident("total_dist_p"),
            )]),
            None,
        ),
        dsl::let_expr("val_other_p", val_other_p_expr),
        dsl::let_expr(
            "val_f_p",
            Expr::ident("lambda_p") * Expr::ident("val_c_p")
                + (Expr::lit_f32(1.0) - Expr::ident("lambda_p")) * Expr::ident("val_other_p"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("grad_p_accum"),
            typed::VecExpr::<2>::from_expr(Expr::ident("face_vec"))
                .mul_scalar(Expr::ident("val_f_p"))
                .expr(),
        ),
    ]);
    let grad_boundary = dsl::block(vec![
        dsl::var_typed_expr("val_f_p", Type::F32, Some(Expr::ident("val_c_p"))),
        dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(2),
            ),
            dsl::block(vec![dsl::assign_expr(Expr::ident("val_f_p"), Expr::lit_f32(0.0))]),
            None,
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("grad_p_accum"),
            typed::VecExpr::<2>::from_expr(Expr::ident("face_vec"))
                .mul_scalar(Expr::ident("val_f_p"))
                .expr(),
        ),
    ]);
    loop_body.push(dsl::if_block_expr(
        Expr::unary(UnaryOp::Not, Expr::ident("is_boundary")),
        grad_internal,
        Some(grad_boundary),
    ));

    loop_body.push(dsl::var_typed_expr(
        "u_face_vel",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::zeros().expr()),
    ));

    let u_other_expr = state_vec2(layout, "state", "other_idx", u_field);
    let internal_vel = dsl::block(vec![
        dsl::let_typed_expr("u_other", Type::vec2_f32(), u_other_expr),
        dsl::let_expr(
            "d_c",
            Expr::call_named(
                "distance",
                vec![Expr::ident("center_vec"), Expr::ident("f_center_vec")],
            ),
        ),
        dsl::let_expr(
            "d_o",
            Expr::call_named(
                "distance",
                vec![Expr::ident("other_center_vec"), Expr::ident("f_center_vec")],
            ),
        ),
        dsl::let_expr("total_dist", Expr::ident("d_c") + Expr::ident("d_o")),
        dsl::if_block_expr(
            Expr::binary(Expr::ident("total_dist"), BinaryOp::Greater, Expr::lit_f32(1e-6)),
            dsl::block(vec![
                dsl::let_expr("lambda", Expr::ident("d_o") / Expr::ident("total_dist")),
                dsl::let_expr(
                    "lambda_other",
                    Expr::lit_f32(1.0) - Expr::ident("lambda"),
                ),
                dsl::assign_expr(
                    Expr::ident("u_face_vel"),
                    typed::VecExpr::<2>::from_expr(Expr::ident("u_val"))
                        .mul_scalar(Expr::ident("lambda"))
                        .add(
                            &typed::VecExpr::<2>::from_expr(Expr::ident("u_other"))
                                .mul_scalar(Expr::ident("lambda_other")),
                        )
                        .expr(),
                ),
            ]),
            Some(dsl::block(vec![
                dsl::assign_expr(
                    Expr::ident("u_face_vel"),
                    typed::VecExpr::<2>::from_expr(Expr::ident("u_val"))
                        .add(&typed::VecExpr::<2>::from_expr(Expr::ident("u_other")))
                        .mul_scalar(Expr::lit_f32(0.5))
                        .expr(),
                ),
            ])),
        ),
    ]);

    let inlet_vel = dsl::block(vec![
        dsl::let_expr(
            "ramp",
            Expr::call_named(
                "smoothstep",
                vec![
                    Expr::lit_f32(0.0),
                    Expr::ident("constants").field("ramp_time"),
                    Expr::ident("constants").field("time"),
                ],
            ),
        ),
        dsl::assign_expr(
            Expr::ident("u_face_vel"),
            typed::VecExpr::<2>::from_components([
                Expr::binary(
                    Expr::ident("constants").field("inlet_velocity"),
                    BinaryOp::Mul,
                    Expr::ident("ramp"),
                ),
                Expr::lit_f32(0.0),
            ])
            .expr(),
        ),
    ]);
    let wall_vel = dsl::block(vec![dsl::assign_expr(
        Expr::ident("u_face_vel"),
        typed::VecExpr::<2>::zeros().expr(),
    )]);
    let outlet_vel = dsl::block(vec![dsl::assign_expr(
        Expr::ident("u_face_vel"),
        Expr::ident("u_val"),
    )]);

    let boundary_vel = dsl::block(vec![dsl::if_block_expr(
        Expr::binary(
            Expr::ident("boundary_type"),
            BinaryOp::Equal,
            Expr::lit_u32(1),
        ),
        inlet_vel,
        Some(dsl::block(vec![dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(3),
            ),
            wall_vel,
            Some(outlet_vel),
        )])),
    )]);

    loop_body.push(dsl::if_block_expr(
        Expr::unary(UnaryOp::Not, Expr::ident("is_boundary")),
        internal_vel,
        Some(boundary_vel),
    ));

    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("g_u"),
        typed::VecExpr::<2>::from_expr(Expr::ident("face_vec"))
            .mul_scalar(Expr::ident("u_face_vel").field("x"))
            .expr(),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("g_v"),
        typed::VecExpr::<2>::from_expr(Expr::ident("face_vec"))
            .mul_scalar(Expr::ident("u_face_vel").field("y"))
            .expr(),
    ));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::binary(Expr::ident("k"), BinaryOp::Less, Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(loop_body),
    ));

    let d_p_target = state_component(layout, "state", "idx", d_p_field, 0);
    stmts.push(dsl::if_block_expr(
        Expr::binary(
            Expr::call_named("abs", vec![Expr::ident("diag_coeff")]),
            BinaryOp::Greater,
            Expr::lit_f32(1e-20),
        ),
        dsl::block(vec![dsl::assign_expr(
            d_p_target.clone(),
            Expr::ident("vol") / Expr::ident("diag_coeff"),
        )]),
        Some(dsl::block(vec![dsl::assign_expr(
            d_p_target,
            Expr::lit_f32(0.0),
        )])),
    ));

    stmts.push(dsl::assign_expr(
        Expr::ident("grad_p_accum"),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_accum"))
            .div_scalar(Expr::ident("vol"))
            .expr(),
    ));

    let grad_p_x = state_component(layout, "state", "idx", grad_p_field, 0);
    let grad_p_y = state_component(layout, "state", "idx", grad_p_field, 1);
    stmts.push(dsl::assign_expr(
        grad_p_x,
        Expr::ident("grad_p_accum").field("x"),
    ));
    stmts.push(dsl::assign_expr(
        grad_p_y,
        Expr::ident("grad_p_accum").field("y"),
    ));

    stmts.push(dsl::assign_expr(
        Expr::ident("g_u"),
        typed::VecExpr::<2>::from_expr(Expr::ident("g_u"))
            .div_scalar(Expr::ident("vol"))
            .expr(),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("g_v"),
        typed::VecExpr::<2>::from_expr(Expr::ident("g_v"))
            .div_scalar(Expr::ident("vol"))
            .expr(),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("grad_u").index(Expr::ident("idx")),
        typed::VecExpr::<2>::from_expr(Expr::ident("g_u")).to_vector2_struct(),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("grad_v").index(Expr::ident("idx")),
        typed::VecExpr::<2>::from_expr(Expr::ident("g_v")).to_vector2_struct(),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::lower_system;
    use crate::solver::model::incompressible_momentum_model;
    use crate::solver::model::backend::SchemeRegistry;
    use crate::solver::scheme::Scheme;

    #[test]
    fn prepare_coupled_codegen_emits_state_arrays() {
        let model = incompressible_momentum_model();
        let schemes = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&model.system, &schemes).unwrap();
        let fields = model.fields.incompressible().expect("incompressible fields");
        let wgsl = generate_prepare_coupled_wgsl(&discrete, &model.state_layout, fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("grad_u"));
        assert!(wgsl.contains("grad_v"));
    }
}
