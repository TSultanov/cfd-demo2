use super::coeff_expr::{coeff_cell_expr, coeff_face_expr};
use super::dsl as typed;
use super::ir::DiscreteSystem;
use super::plan::{momentum_plan, MomentumPlan};
use super::reconstruction::vec2_reconstruction_xy;
use super::state_access::{state_scalar, state_vec2};
use super::wgsl::generate_wgsl_library_items;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::gpu::enums::{GpuBoundaryType, TimeScheme};
use crate::solver::model::backend::StateLayout;
use crate::solver::model::IncompressibleMomentumFields;
use crate::solver::scheme::Scheme;

pub fn generate_coupled_assembly_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (coupled assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.extend(generate_wgsl_library_items(system));
    let plan = {
        let plan = momentum_plan(system, fields.u.name(), fields.p.name());
        if plan.pressure_diffusion.is_none() {
            panic!(
                "missing pressure diffusion term for field '{}'",
                fields.p.name()
            );
        }
        plan
    };
    module.push(Item::Function(main_fn(layout, &plan, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver (Coupled)".to_string()));
    items.extend(solver_bindings());
    items.push(Item::Function(safe_inverse_fn()));
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "grad_u",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            3,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_v",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            4,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "scalar_matrix_values",
            Type::array(Type::F32),
            2,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_u_inv",
            Type::array(Type::F32),
            2,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_v_inv",
            Type::array(Type::F32),
            2,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_p_inv",
            Type::array(Type::F32),
            2,
            8,
            AccessMode::ReadWrite,
        ),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn safe_inverse_fn() -> Function {
    let params = vec![Param::new("val", Type::F32, Vec::new())];
    let body = Block::new(vec![
        dsl::if_block_expr(
            dsl::abs("val").gt(1e-14),
            dsl::block(vec![Stmt::Return(Some(Expr::from(1.0) / "val"))]),
            None,
        ),
        Stmt::Return(Some(0.0.into())),
    ]);
    Function::new("safe_inverse", params, Some(Type::F32), Vec::new(), body)
}

fn main_fn(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    let body = main_body(layout, plan, fields);
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        body,
    )
}

fn main_body(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Block {
    let mut stmts = Vec::new();
    let u_field = fields.u.name();
    let d_p_field = fields.d_p.name();
    let u_components = fields.u.kind().component_count();
    let p_components = fields.p.kind().component_count();
    if u_components != 2 {
        panic!(
            "expected vector2 velocity field, got {} components",
            u_components
        );
    }
    if p_components != 1 {
        panic!(
            "expected scalar pressure field, got {} components",
            p_components
        );
    }
    let coupled_stride = u_components + p_components;
    let p_offset = u_components;
    let coupled_stride_u32 = coupled_stride as u32;
    let p_offset_u32 = p_offset as u32;
    let row_stride_2 = coupled_stride * 2;
    let block_stride = coupled_stride * coupled_stride;
    let block_shape = typed::BlockShape::new(coupled_stride as u8, coupled_stride as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );
    let u_old_expr = state_vec2(layout, "state_old", "idx", u_field);
    let u_old_old_expr = state_vec2(layout, "state_old_old", "idx", u_field);

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx") + 1u32)
            - Expr::ident("scalar_offset"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::ident("scalar_offset") * block_stride as u32,
    ));
    stmts.push(dsl::let_expr(
        "start_row_1",
        Expr::ident("start_row_0") + Expr::ident("num_neighbors") * coupled_stride as u32,
    ));
    stmts.push(dsl::let_expr(
        "start_row_2",
        Expr::ident("start_row_0") + Expr::ident("num_neighbors") * row_stride_2 as u32,
    ));
    let zero_vec2 = typed::VecExpr::<2>::zeros().expr();
    stmts.push(dsl::var_typed_expr(
        "diag_uv",
        Type::vec2_f32(),
        Some(zero_vec2),
    ));
    stmts.push(dsl::var_typed_expr("diag_p", Type::F32, Some(0.0.into())));
    stmts.push(dsl::var_typed_expr(
        "sum_diag_uv_p",
        Type::vec2_f32(),
        Some(zero_vec2),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_diag_p_uv",
        Type::vec2_f32(),
        Some(zero_vec2),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_diag_pp",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_uv",
        Type::vec2_f32(),
        Some(zero_vec2),
    ));
    stmts.push(dsl::var_typed_expr("rhs_p", Type::F32, Some(0.0.into())));
    stmts.push(dsl::var_typed_expr(
        "scalar_diag_p",
        Type::F32,
        Some(0.0.into()),
    ));
    if let Some(ddt_op) = &plan.ddt {
        let rho_expr = coeff_cell_expr(
            layout,
            ddt_op.coeff.as_ref(),
            "idx",
            Expr::ident("constants").field("density"),
        );
        stmts.push(dsl::let_typed_expr("u_n", Type::vec2_f32(), u_old_expr));
        stmts.push(dsl::let_expr("rho", rho_expr));
        stmts.push(dsl::var_typed_expr(
            "coeff_time",
            Type::F32,
            Some(Expr::ident("vol") * Expr::ident("rho") / Expr::ident("constants").field("dt")),
        ));
        stmts.push(dsl::var_typed_expr(
            "rhs_time",
            Type::vec2_f32(),
            Some(Expr::ident("u_n") * Expr::ident("coeff_time")),
        ));
        stmts.push(dsl::if_block_expr(
            typed::EnumExpr::<TimeScheme>::from_expr(Expr::ident("constants").field("time_scheme"))
                .eq(TimeScheme::BDF2),
            dsl::block(vec![
                dsl::let_expr("dt", Expr::ident("constants").field("dt")),
                dsl::let_expr("dt_old", Expr::ident("constants").field("dt_old")),
                dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
                dsl::let_typed_expr("u_nm1", Type::vec2_f32(), u_old_old_expr),
                dsl::assign_expr(
                    Expr::ident("coeff_time"),
                    Expr::ident("vol") * Expr::ident("rho") / Expr::ident("dt")
                        * (Expr::ident("r") * 2.0 + 1.0)
                        / (Expr::ident("r") + 1.0),
                ),
                dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
                dsl::let_expr(
                    "factor_nm1",
                    (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
                ),
                dsl::assign_expr(Expr::ident("rhs_time"), {
                    let coeff = Expr::ident("vol") * Expr::ident("rho") / Expr::ident("dt");
                    let term_n = Expr::ident("factor_n") * Expr::ident("u_n");
                    let term_nm1 = Expr::ident("factor_nm1") * Expr::ident("u_nm1");
                    coeff * (term_n - term_nm1)
                }),
            ]),
            None,
        ));
        let coeff_time = Expr::ident("coeff_time");
        let diag_time = typed::VecExpr::<2>::from_components([coeff_time, coeff_time]).expr();
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_uv"),
            diag_time,
        ));
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("rhs_uv"),
            Expr::ident("rhs_time"),
        ));
    }

    let d_p_idx_expr = state_scalar(layout, "state", "idx", d_p_field);
    let pressure_coeff_face_expr = coeff_face_expr(
        layout,
        plan.pressure_diffusion
            .as_ref()
            .and_then(|op| op.coeff.as_ref()),
        "idx",
        "other_idx",
        Expr::ident("lambda"),
        Expr::ident("d_p_face"),
    );
    let pressure_coeff_cell_expr = coeff_cell_expr(
        layout,
        plan.pressure_diffusion
            .as_ref()
            .and_then(|op| op.coeff.as_ref()),
        "idx",
        Expr::ident("d_p_own"),
    );

    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neigh_idx",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "boundary_type",
            dsl::array_access("face_boundary", Expr::ident("face_idx")),
        ));
        body.push(dsl::var_typed_expr(
            "normal",
            Type::Custom("Vector2".to_string()),
            Some(dsl::array_access("face_normals", Expr::ident("face_idx"))),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "f_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::var_typed_expr(
            "normal_sign",
            Type::F32,
            Some(1.0.into()),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("owner").ne(Expr::ident("idx")),
            dsl::block(vec![
                dsl::assign_expr(
                    Expr::ident("normal").field("x"),
                    -Expr::ident("normal").field("x"),
                ),
                dsl::assign_expr(
                    Expr::ident("normal").field("y"),
                    -Expr::ident("normal").field("y"),
                ),
                dsl::assign_expr(Expr::ident("normal_sign"), -1.0),
            ]),
            None,
        ));
        let normal_vec_expr = typed::VecExpr::<2>::from_xy_fields(Expr::ident("normal")).expr();
        body.push(dsl::let_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            normal_vec_expr.clone(),
        ));
        body.push(dsl::let_typed_expr(
            "face_vec",
            Type::vec2_f32(),
            normal_vec_expr * Expr::ident("area"),
        ));
        body.push(dsl::let_expr(
            "flux",
            dsl::array_access("fluxes", Expr::ident("face_idx")) * Expr::ident("normal_sign"),
        ));
        body.push(dsl::var_typed_expr(
            "other_center",
            Type::Custom("Vector2".to_string()),
            None,
        ));
        body.push(dsl::var_typed_expr(
            "is_boundary",
            Type::Bool,
            Some(false.into()),
        ));
        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(0u32.into()),
        ));
        body.push(dsl::var_typed_expr(
            "d_p_neigh",
            Type::F32,
            Some(0.0.into()),
        ));

        let d_p_other_expr = state_scalar(layout, "state", "other_idx", d_p_field);
        body.push(dsl::if_block_expr(
            Expr::ident("neigh_idx").ne(-1),
            dsl::block(vec![
                dsl::assign_expr(
                    Expr::ident("other_idx"),
                    Expr::call_named("u32", vec![Expr::ident("neigh_idx")]),
                ),
                dsl::if_block_expr(
                    Expr::ident("owner").ne(Expr::ident("idx")),
                    dsl::block(vec![dsl::assign_expr(
                        Expr::ident("other_idx"),
                        Expr::ident("owner"),
                    )]),
                    None,
                ),
                dsl::assign_expr(
                    Expr::ident("other_center"),
                    dsl::array_access("cell_centers", Expr::ident("other_idx")),
                ),
                dsl::assign_expr(Expr::ident("d_p_neigh"), d_p_other_expr),
            ]),
            Some(dsl::block(vec![
                dsl::assign_expr(Expr::ident("is_boundary"), true),
                dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("idx")),
                dsl::assign_expr(Expr::ident("other_center"), Expr::ident("f_center")),
                dsl::assign_expr(Expr::ident("d_p_neigh"), d_p_idx_expr),
            ])),
        ));

        body.push(dsl::let_expr("dist_proj", {
            let d_vec = typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center"))
                .sub(&typed::VecExpr::<2>::from_xy_fields(Expr::ident("center")));
            let normal_vec = typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"));
            dsl::abs(d_vec.dot(&normal_vec))
        }));
        body.push(dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)));
        if let Some(diff_op) = &plan.diffusion {
            let mu_expr = coeff_face_expr(
                layout,
                diff_op.coeff.as_ref(),
                "idx",
                "other_idx",
                0.5.into(),
                1.0.into(),
            );
            body.push(dsl::let_expr(
                "diff_coeff",
                Expr::call_named(
                    "codegen_diff_coeff",
                    vec![mu_expr, Expr::ident("area"), Expr::ident("dist")],
                ),
            ));
        } else {
            body.push(dsl::let_expr("diff_coeff", 0.0));
        }

        if plan.convection.is_some() {
            body.push(dsl::let_expr(
                "conv_coeff",
                Expr::call_named("codegen_conv_coeff", vec![Expr::ident("flux")]),
            ));
            body.push(dsl::let_expr(
                "conv_coeff_diag",
                Expr::ident("conv_coeff").field("x"),
            ));
            body.push(dsl::let_expr(
                "conv_coeff_off",
                Expr::ident("conv_coeff").field("y"),
            ));
        } else {
            body.push(dsl::let_expr("conv_coeff_diag", 0.0));
            body.push(dsl::let_expr("conv_coeff_off", 0.0));
        }
        body.push(dsl::let_expr(
            "scalar_mat_idx",
            dsl::array_access("cell_face_matrix_indices", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ));
        let neighbor_entry = block_matrix.row_entry(&Expr::ident("neighbor_rank"));

        let d_p_idx_expr = state_scalar(layout, "state", "idx", d_p_field);

        let mut inlet_stmts = vec![
            dsl::let_expr(
                "ramp",
                dsl::smoothstep(
                    0.0,
                    Expr::ident("constants").field("ramp_time"),
                    Expr::ident("constants").field("time"),
                ),
            ),
            dsl::let_typed_expr(
                "u_bc",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_components([
                    Expr::ident("constants").field("inlet_velocity") * Expr::ident("ramp"),
                    0.0.into(),
                ])
                .expr(),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("diag_uv"),
                typed::VecExpr::<2>::from_components([
                    Expr::ident("diff_coeff"),
                    Expr::ident("diff_coeff"),
                ])
                .expr(),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("rhs_uv"),
                typed::VecExpr::<2>::from_expr(Expr::ident("u_bc"))
                    .mul_scalar(Expr::ident("diff_coeff"))
                    .expr(),
            ),
            dsl::if_block_expr(
                Expr::ident("flux").gt(0.0),
                dsl::block(vec![dsl::assign_op_expr(
                    AssignOp::Add,
                    Expr::ident("diag_uv"),
                    typed::VecExpr::<2>::from_components([
                        Expr::ident("flux"),
                        Expr::ident("flux"),
                    ])
                    .expr(),
                )]),
                Some(dsl::block(vec![dsl::assign_op_expr(
                    AssignOp::Sub,
                    Expr::ident("rhs_uv"),
                    typed::VecExpr::<2>::from_expr(Expr::ident("u_bc"))
                        .mul_scalar(Expr::ident("flux"))
                        .expr(),
                )])),
            ),
        ];
        if plan.gradient.is_some() {
            inlet_stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_uv_p"),
                Expr::ident("face_vec"),
            ));
        }
        inlet_stmts.extend(vec![
            dsl::let_expr(
                "flux_bc",
                typed::VecExpr::<2>::from_expr(Expr::ident("u_bc"))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("face_vec"))),
            ),
            dsl::assign_op_expr(AssignOp::Sub, Expr::ident("rhs_p"), Expr::ident("flux_bc")),
        ]);
        let inlet_block = dsl::block(inlet_stmts);

        let mut wall_stmts = vec![dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_uv"),
            typed::VecExpr::<2>::from_components([
                Expr::ident("diff_coeff"),
                Expr::ident("diff_coeff"),
            ])
            .expr(),
        )];
        if plan.gradient.is_some() {
            wall_stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_uv_p"),
                Expr::ident("face_vec"),
            ));
        }
        let wall_block = dsl::block(wall_stmts);

        let outlet_block = dsl::block(vec![
            dsl::if_block_expr(
                Expr::ident("flux").gt(0.0),
                dsl::block(vec![dsl::assign_op_expr(
                    AssignOp::Add,
                    Expr::ident("diag_uv"),
                    typed::VecExpr::<2>::from_components([
                        Expr::ident("flux"),
                        Expr::ident("flux"),
                    ])
                    .expr(),
                )]),
                None,
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_p_uv"),
                Expr::ident("face_vec"),
            ),
            dsl::let_expr("d_p_own", d_p_idx_expr.clone()),
            dsl::let_expr("pressure_coeff_cell", pressure_coeff_cell_expr.clone()),
            dsl::let_expr(
                "lapl_coeff",
                Expr::ident("pressure_coeff_cell") * Expr::ident("area") / Expr::ident("dist"),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_pp"),
                Expr::ident("lapl_coeff"),
            ),
            dsl::let_expr(
                "scalar_coeff",
                Expr::ident("pressure_coeff_cell") * Expr::ident("area") / Expr::ident("dist"),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("scalar_diag_p"),
                Expr::ident("scalar_coeff"),
            ),
        ]);

        let boundary_stmt = dsl::if_block_expr(
            typed::EnumExpr::<GpuBoundaryType>::from_expr(Expr::ident("boundary_type"))
                .eq(GpuBoundaryType::Inlet),
            inlet_block,
            Some(dsl::block(vec![dsl::if_block_expr(
                typed::EnumExpr::<GpuBoundaryType>::from_expr(Expr::ident("boundary_type"))
                    .eq(GpuBoundaryType::Wall),
                wall_block,
                Some(dsl::block(vec![dsl::if_block_expr(
                    typed::EnumExpr::<GpuBoundaryType>::from_expr(Expr::ident("boundary_type"))
                        .eq(GpuBoundaryType::Outlet),
                    outlet_block,
                    None,
                )])),
            )])),
        );

        let mut interior_stmts = vec![
            dsl::let_expr(
                "coeff",
                Expr::ident("conv_coeff_off") - Expr::ident("diff_coeff"),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("diag_uv"),
                typed::VecExpr::<2>::from_components({
                    let diag_inc = Expr::ident("diff_coeff") + Expr::ident("conv_coeff_diag");
                    [diag_inc.clone(), diag_inc]
                })
                .expr(),
            ),
        ];

        if let Some(conv_op) = &plan.convection {
            let scheme_id = conv_op.scheme.gpu_id();
            interior_stmts.push(dsl::let_typed_expr("scheme_id", Type::U32, scheme_id));
            let scheme = typed::EnumExpr::<Scheme>::from_expr(Expr::ident("scheme_id"));
            interior_stmts.push(dsl::if_block_expr(
                scheme.ne(Scheme::Upwind),
                {
                    let mut ho_block = vec![
                        dsl::let_expr("u_own", state_vec2(layout, "state", "idx", u_field)),
                        dsl::let_expr("u_neigh", state_vec2(layout, "state", "other_idx", u_field)),
                    ];
                    let recon = vec2_reconstruction_xy(
                        scheme,
                        Expr::ident("flux"),
                        typed::VecExpr::<2>::from_expr(Expr::ident("u_own")),
                        typed::VecExpr::<2>::from_expr(Expr::ident("u_neigh")),
                        [
                            Expr::ident("grad_u").index(Expr::ident("idx")),
                            Expr::ident("grad_v").index(Expr::ident("idx")),
                        ],
                        [
                            Expr::ident("grad_u").index(Expr::ident("other_idx")),
                            Expr::ident("grad_v").index(Expr::ident("other_idx")),
                        ],
                        Expr::ident("center"),
                        Expr::ident("other_center"),
                        Expr::ident("f_center"),
                    );
                    let correction = recon
                        .phi_ho
                        .sub(&recon.phi_upwind)
                        .mul_scalar(Expr::ident("flux"));
                    ho_block.push(dsl::assign_op_expr(
                        AssignOp::Sub,
                        Expr::ident("rhs_uv"),
                        correction.expr(),
                    ));
                    dsl::block(ho_block)
                },
                None,
            ));
        }

        interior_stmts.push(dsl::let_expr(
            "d_own",
            Expr::call_named(
                "distance",
                vec![
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("center")).expr(),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("f_center")).expr(),
                ],
            ),
        ));
        interior_stmts.push(dsl::let_expr(
            "d_neigh",
            Expr::call_named(
                "distance",
                vec![
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("f_center")).expr(),
                ],
            ),
        ));
        interior_stmts.push(dsl::let_expr(
            "total_dist",
            Expr::ident("d_own") + Expr::ident("d_neigh"),
        ));
        interior_stmts.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
        interior_stmts.push(dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ));

        if plan.gradient.is_some() {
            interior_stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_uv_p"),
                Expr::ident("face_vec") * Expr::ident("lambda"),
            ));
        }

        interior_stmts.extend(vec![
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_p_uv"),
                Expr::ident("face_vec") * Expr::ident("lambda"),
            ),
            dsl::let_expr("d_p_own", d_p_idx_expr),
            dsl::let_expr(
                "d_p_face",
                Expr::ident("lambda") * Expr::ident("d_p_own")
                    + (Expr::from(1.0) - Expr::ident("lambda")) * Expr::ident("d_p_neigh"),
            ),
            dsl::let_expr("pressure_coeff_face", pressure_coeff_face_expr.clone()),
            dsl::let_expr(
                "lapl_coeff",
                Expr::ident("pressure_coeff_face") * Expr::ident("area") / Expr::ident("dist"),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum_diag_pp"),
                Expr::ident("lapl_coeff"),
            ),
            dsl::let_expr(
                "scalar_coeff",
                Expr::ident("pressure_coeff_face") * Expr::ident("area") / Expr::ident("dist"),
            ),
            dsl::if_block_expr(
                Expr::ident("scalar_mat_idx").ne(u32::MAX),
                dsl::block(vec![dsl::assign_array_access(
                    "scalar_matrix_values",
                    Expr::ident("scalar_mat_idx"),
                    -Expr::ident("scalar_coeff"),
                )]),
                None,
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("scalar_diag_p"),
                Expr::ident("scalar_coeff"),
            ),
        ]);

        let one_minus_lambda: Expr = Expr::from(1.0) - Expr::ident("lambda");
        let zero: Expr = 0.0.into();
        let face_x = Expr::ident("face_vec").field("x");
        let face_y = Expr::ident("face_vec").field("y");
        let pg_off_x = if plan.gradient.is_some() {
            one_minus_lambda * face_x
        } else {
            zero
        };
        let pg_off_y = if plan.gradient.is_some() {
            one_minus_lambda * face_y
        } else {
            zero
        };
        let offdiag_block = typed::MatExpr::<3, 3>::from_entries([
            [Expr::ident("coeff"), zero, pg_off_x],
            [zero, Expr::ident("coeff"), pg_off_y],
            [
                one_minus_lambda * face_x,
                one_minus_lambda * face_y,
                -Expr::ident("lapl_coeff"),
            ],
        ]);
        interior_stmts
            .extend(offdiag_block.scatter_assign_to_block_entry_scaled(&neighbor_entry, None));

        body.push(dsl::if_block_expr(
            !Expr::ident("is_boundary"),
            dsl::block(interior_stmts),
            Some(dsl::block(vec![boundary_stmt])),
        ));

        body
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(face_loop_body),
    ));

    stmts.push(dsl::let_expr(
        "scalar_diag_idx",
        dsl::array_access("diagonal_indices", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "diag_rank",
        Expr::ident("scalar_diag_idx") - Expr::ident("scalar_offset"),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    let diag_block = typed::MatExpr::<3, 3>::from_entries([
        [
            Expr::ident("diag_uv").field("x"),
            0.0.into(),
            Expr::ident("sum_diag_uv_p").field("x"),
        ],
        [
            0.0.into(),
            Expr::ident("diag_uv").field("y"),
            Expr::ident("sum_diag_uv_p").field("y"),
        ],
        [
            Expr::ident("sum_diag_p_uv").field("x"),
            Expr::ident("sum_diag_p_uv").field("y"),
            Expr::ident("diag_p") + Expr::ident("sum_diag_pp"),
        ],
    ]);
    stmts.extend(diag_block.scatter_assign_to_block_entry_scaled(&diag_entry, None));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        coupled_stride_u32,
        0,
        Expr::ident("rhs_uv").field("x"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        coupled_stride_u32,
        1,
        Expr::ident("rhs_uv").field("y"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        coupled_stride_u32,
        p_offset_u32,
        Expr::ident("rhs_p"),
    ));
    stmts.push(dsl::assign_array_access(
        "scalar_matrix_values",
        Expr::ident("scalar_diag_idx"),
        Expr::ident("scalar_diag_p"),
    ));
    stmts.push(dsl::assign_array_access(
        "diag_u_inv",
        Expr::ident("idx"),
        Expr::call_named("safe_inverse", vec![Expr::ident("diag_uv").field("x")]),
    ));
    stmts.push(dsl::assign_array_access(
        "diag_v_inv",
        Expr::ident("idx"),
        Expr::call_named("safe_inverse", vec![Expr::ident("diag_uv").field("y")]),
    ));
    stmts.push(dsl::assign_array_access(
        "diag_p_inv",
        Expr::ident("idx"),
        Expr::call_named("safe_inverse", vec![Expr::ident("scalar_diag_p")]),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::ir::lower_system;
    use crate::solver::model::backend::ast::{
        fvm, surface_scalar, vol_scalar, vol_vector, Coefficient,
    };
    use crate::solver::model::backend::SchemeRegistry;
    use crate::solver::model::IncompressibleMomentumFields;
    use crate::solver::scheme::Scheme;
    use crate::solver::units::si;

    fn default_layout() -> StateLayout {
        StateLayout::new(vec![
            vol_vector("U", si::VELOCITY),
            vol_scalar("p", si::PRESSURE),
            vol_scalar("d_p", si::D_P),
            vol_vector("grad_p", si::PRESSURE_GRADIENT),
            vol_vector("grad_component", si::INV_TIME),
        ])
    }

    fn default_fields() -> IncompressibleMomentumFields {
        IncompressibleMomentumFields::new()
    }

    #[test]
    fn generate_coupled_assembly_wgsl_includes_codegen_helpers() {
        let u = vol_vector("U", si::VELOCITY);
        let phi = surface_scalar("phi", si::MASS_FLUX);
        let mu = vol_scalar("mu", si::DYNAMIC_VISCOSITY);
        let p = vol_scalar("p", si::PRESSURE);
        let d_p = vol_scalar("d_p", si::D_P);
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi, u.clone()))
            .with_term(fvm::laplacian(Coefficient::field(mu).unwrap(), u.clone()));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone())
                .with_term(fvm::laplacian(Coefficient::field(d_p).unwrap(), p)),
        );

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let layout = default_layout();
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &layout, &fields);

        assert!(wgsl.contains("codegen_conv_coeff"));
        assert!(wgsl.contains("codegen_diff_coeff"));
        assert!(wgsl.contains("state: array<f32>"));
    }

    #[test]
    fn coupled_assembly_codegen_embeds_scheme_id_from_registry() {
        let u = vol_vector("U", si::VELOCITY);
        let phi = surface_scalar("phi", si::MASS_FLUX);
        let p = vol_scalar("p", si::PRESSURE);
        let d_p = vol_scalar("d_p", si::D_P);
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi.clone(), u.clone()));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone())
                .with_term(fvm::laplacian(Coefficient::field(d_p).unwrap(), p)),
        );

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::model::backend::ast::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry).unwrap();
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &default_layout(), &fields);

        assert!(wgsl.contains("scheme_id: u32 = 2u"));
    }

    #[test]
    fn coupled_assembly_codegen_zeros_diffusion_when_missing() {
        let u = vol_vector("U", si::VELOCITY);
        let p = vol_scalar("p", si::PRESSURE);
        let d_p = vol_scalar("d_p", si::D_P);
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone())
                .with_term(fvm::laplacian(Coefficient::field(d_p).unwrap(), p)),
        );

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &default_layout(), &fields);

        assert!(wgsl.contains("let diff_coeff = 0.0"));
    }

    #[test]
    fn coupled_assembly_codegen_maps_named_coefficients() {
        let u = vol_vector("U", si::VELOCITY);
        let mu = vol_scalar("mu", si::DYNAMIC_VISCOSITY);
        let rho = vol_scalar("rho", si::DENSITY);
        let p = vol_scalar("p", si::PRESSURE);
        let d_p = vol_scalar("d_p", si::D_P);
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::ddt_coeff(Coefficient::field(rho).unwrap(), u.clone()))
            .with_term(fvm::laplacian(Coefficient::field(mu).unwrap(), u.clone()));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone())
                .with_term(fvm::laplacian(Coefficient::field(d_p).unwrap(), p)),
        );

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry).unwrap();
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &default_layout(), &fields);

        assert!(wgsl.contains("let rho = constants.density"));
        assert!(wgsl.contains("codegen_diff_coeff(constants.viscosity, area, dist)"));
    }
}
