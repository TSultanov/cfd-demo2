// GENERATED BY CFD2 CODEGEN (flux_rhie_chow)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let c_owner = cell_centers[owner];
    let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    if (dot(face_center_vec - c_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    var u_face = vec2<f32>(state[owner * 8u + 0u], state[owner * 8u + 1u]);
    var d_p_face = state[owner * 8u + 3u];
    var grad_p_avg = vec2<f32>(state[owner * 8u + 4u], state[owner * 8u + 5u]);
    var rho_face = constants.density;
    if (neighbor != -1) {
        let neigh_idx = u32(neighbor);
        let u_neigh = vec2<f32>(state[neigh_idx * 8u + 0u], state[neigh_idx * 8u + 1u]);
        let d_p_neigh = state[neigh_idx * 8u + 3u];
        let grad_p_neigh = vec2<f32>(state[neigh_idx * 8u + 4u], state[neigh_idx * 8u + 5u]);
        let c_neigh = cell_centers[neigh_idx];
        let c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
        let d_own = distance(c_owner_vec, face_center_vec);
        let d_neigh = distance(c_neigh_vec, face_center_vec);
        let total_dist = d_own + d_neigh;
        var lambda: f32 = 0.5;
        if (total_dist > 1e-6) {
            lambda = d_neigh / total_dist;
        }
        let lambda_other = 1.0 - lambda;
        rho_face = constants.density;
        let u_central: vec2<f32> = u_face * lambda + u_neigh * lambda_other;
        u_face = u_central;
        d_p_face = lambda * d_p_face + lambda_other * d_p_neigh;
        grad_p_avg = grad_p_avg * lambda + grad_p_neigh * lambda_other;
        let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
        let dist_proj = abs(dot(d_vec, normal_vec));
        let dist = max(dist_proj, 1e-6);
        let p_own = state[owner * 8u + 2u];
        let p_neigh = state[neigh_idx * 8u + 2u];
        let grad_p_n = dot(grad_p_avg, normal_vec);
        let p_grad_f = (p_neigh - p_own) / dist;
        let rc_term = d_p_face * area * (grad_p_n - p_grad_f);
        let u_n = dot(u_face, normal_vec);
        fluxes[idx] = rho_face * (u_n * area + rc_term);
    } else {
        if (boundary_type == 1u) {
            let ramp = smoothstep(0.0, constants.ramp_time, constants.time);
            let u_bc: vec2<f32> = vec2<f32>(constants.inlet_velocity * ramp, 0.0);
            fluxes[idx] = rho_face * dot(u_bc, normal_vec) * area;
        } else {
            if (boundary_type == 3u) {
                fluxes[idx] = 0.0;
            } else {
                if (boundary_type == 2u) {
                    let u_n = dot(u_face, normal_vec);
                    var rc_term: f32 = 0.0;
                    let dist_face = distance(c_owner_vec, face_center_vec);
                    if (dist_face > 1e-6) {
                        rc_term = 0.0;
                    }
                    let raw_flux = rho_face * (u_n * area + rc_term);
                    fluxes[idx] = max(0.0, raw_flux);
                } else {
                    fluxes[idx] = 0.0;
                }
            }
        }
    }
}
