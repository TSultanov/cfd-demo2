use super::coeff_expr::{coeff_cell_expr, coeff_face_expr};
use super::dsl as typed;
use super::ir::{DiscreteOp, DiscreteOpKind, DiscreteSystem};
use super::state_access::{state_scalar, state_vec2};
use crate::solver::model::IncompressibleMomentumFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_pressure_assembly_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (pressure_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    let plan = pressure_plan(system, fields.p.name());
    module.push(Item::Function(main_fn(layout, &plan, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("padding", Type::U32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(
    layout: &StateLayout,
    plan: &PressurePlan,
    fields: &IncompressibleMomentumFields,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, plan, fields),
    )
}

#[derive(Debug, Clone)]
struct PressurePlan {
    diffusion: Option<DiscreteOp>,
}

fn pressure_plan(system: &DiscreteSystem, pressure_field: &str) -> PressurePlan {
    let mut plan = PressurePlan { diffusion: None };

    let mut found = false;
    for equation in &system.equations {
        if equation.target.name() != pressure_field {
            continue;
        }
        found = true;
        for op in &equation.ops {
            if op.kind == DiscreteOpKind::Diffusion {
                plan.diffusion = Some(op.clone());
                break;
            }
        }
    }

    if !found {
        panic!("missing pressure equation for field '{}'", pressure_field);
    }
    if plan.diffusion.is_none() {
        panic!(
            "pressure equation for '{}' must include a laplacian term",
            pressure_field
        );
    }

    plan
}

fn main_body(
    layout: &StateLayout,
    plan: &PressurePlan,
    fields: &IncompressibleMomentumFields,
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_typed_expr(
        "center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("center")).expr(),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::var_typed_expr("diag_coeff", Type::F32, Some(0.0.into())));
    stmts.push(dsl::var_typed_expr("rhs_val", Type::F32, Some(0.0.into())));

    let d_p_field = fields.d_p.name();
    let grad_p_field = fields.grad_p.name();
    let d_p_idx_expr = state_scalar(layout, "state", "idx", d_p_field);
    let grad_p_idx_expr = state_vec2(layout, "state", "idx", grad_p_field);
    let pressure_coeff_face_expr = coeff_face_expr(
        layout,
        plan.diffusion.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        "other_idx",
        Expr::ident("lambda"),
        Expr::ident("d_p_face"),
    );
    let pressure_coeff_cell_expr = coeff_cell_expr(
        layout,
        plan.diffusion.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        Expr::ident("d_p_own"),
    );

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_expr(
        "face_idx",
        dsl::array_access("cell_faces", Expr::ident("k")),
    ));
    loop_body.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "neigh_idx",
        dsl::array_access("face_neighbor", Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "f_center",
        dsl::array_access("face_centers", Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    loop_body.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    loop_body.push(dsl::let_typed_expr(
        "f_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("f_center")).expr(),
    ));
    loop_body.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("face_idx")),
            )
            .expr(),
        ),
    ));
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("f_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    loop_body.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).neg().expr(),
        )]),
        None,
    ));
    loop_body.push(dsl::var_typed_expr(
        "normal_sign",
        Type::F32,
        Some(1.0.into()),
    ));
    loop_body.push(dsl::if_block_expr(
        Expr::ident("owner").ne(Expr::ident("idx")),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("normal_vec"),
                typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).neg().expr(),
            ),
            dsl::assign_expr(Expr::ident("normal_sign"), -1.0),
        ]),
        None,
    ));
    loop_body.push(dsl::let_typed_expr(
        "face_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
            .mul_scalar(Expr::ident("area"))
            .expr(),
    ));
    loop_body.push(dsl::let_expr(
        "flux",
        dsl::array_access("fluxes", Expr::ident("face_idx")) * Expr::ident("normal_sign"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Sub,
        Expr::ident("rhs_val"),
        Expr::ident("flux"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "other_center",
        Type::Custom("Vector2".to_string()),
        None,
    ));
    loop_body.push(dsl::var_typed_expr(
        "is_boundary",
        Type::Bool,
        Some(false.into()),
    ));
    loop_body.push(dsl::var_typed_expr("other_idx", Type::U32, Some(Expr::ident("idx"))));
    loop_body.push(dsl::var_typed_expr("d_p_neigh", Type::F32, Some(0.0.into())));

    let d_p_other_expr = state_scalar(layout, "state", "other_idx", d_p_field);

    loop_body.push(dsl::if_block_expr(
        Expr::ident("neigh_idx").ne(-1),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("other_idx"),
                Expr::call_named("u32", vec![Expr::ident("neigh_idx")]),
            ),
            dsl::if_block_expr(
                Expr::ident("owner").ne(Expr::ident("idx")),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("other_idx"),
                    Expr::ident("owner"),
                )]),
                None,
            ),
            dsl::assign_expr(
                Expr::ident("other_center"),
                dsl::array_access("cell_centers", Expr::ident("other_idx")),
            ),
            dsl::assign_expr(Expr::ident("d_p_neigh"), d_p_other_expr),
        ]),
        Some(dsl::block(vec![
            dsl::assign_expr(Expr::ident("is_boundary"), true),
            dsl::assign_expr(Expr::ident("other_center"), Expr::ident("f_center")),
            dsl::assign_expr(Expr::ident("d_p_neigh"), d_p_idx_expr),
        ])),
    ));

    let internal_block = dsl::block(vec![
        dsl::let_typed_expr(
            "other_center_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
        ),
        dsl::let_typed_expr(
            "d_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("other_center_vec"))
                .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("center_vec")))
                .expr(),
        ),
        dsl::let_expr("dist", dsl::length("d_vec")),
        dsl::let_expr(
            "d_own",
            dsl::distance("center_vec", "f_center_vec"),
        ),
        dsl::let_expr(
            "d_neigh",
            dsl::distance("other_center_vec", "f_center_vec"),
        ),
        dsl::let_expr("total_dist", Expr::ident("d_own") + Expr::ident("d_neigh")),
        dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())),
        dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ),
        dsl::let_expr("d_p_own", d_p_idx_expr.clone()),
        dsl::let_expr(
            "d_p_face",
            Expr::ident("lambda") * Expr::ident("d_p_own")
                + (Expr::from(1.0) - Expr::ident("lambda")) * Expr::ident("d_p_neigh"),
        ),
        dsl::let_expr("pressure_coeff_face", pressure_coeff_face_expr.clone()),
        dsl::let_expr(
            "coeff",
            Expr::ident("pressure_coeff_face") * Expr::ident("area") / Expr::ident("dist"),
        ),
        dsl::let_expr(
            "mat_idx",
            dsl::array_access("cell_face_matrix_indices", Expr::ident("k")),
        ),
        dsl::if_block_expr(
            Expr::ident("mat_idx").ne(u32::MAX),
            dsl::block(vec![dsl::assign_array_access(
                "matrix_values",
                Expr::ident("mat_idx"),
                -Expr::ident("coeff"),
            )]),
            None,
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("diag_coeff"),
            Expr::ident("coeff"),
        ),
        dsl::let_expr(
            "area_over_dist",
            Expr::ident("area") / Expr::ident("dist"),
        ),
        dsl::let_typed_expr(
            "k_raw",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("face_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                        .mul_scalar(Expr::ident("area_over_dist")),
                )
                .expr(),
        ),
        dsl::let_expr("k_mag", dsl::length("k_raw")),
        dsl::let_expr("k_limit", Expr::ident("area") * 0.5),
        dsl::var_typed_expr("k_scale", Type::F32, Some(1.0.into())),
        dsl::if_block_expr(
            Expr::ident("k_mag").gt(Expr::ident("k_limit")),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("k_scale"),
                Expr::ident("k_limit") / Expr::ident("k_mag"),
            )]),
            None,
        ),
        dsl::let_typed_expr(
            "k_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("k_raw"))
                .mul_scalar(Expr::ident("k_scale"))
                .expr(),
        ),
        dsl::var_typed_expr(
            "other_idx_p",
            Type::U32,
            Some(Expr::call_named("u32", vec![Expr::ident("neigh_idx")])),
        ),
        dsl::if_block_expr(
            Expr::ident("owner").ne(Expr::ident("idx")),
            dsl::block(vec![dsl::assign_expr(Expr::ident("other_idx_p"), Expr::ident("owner"))]),
            None,
        ),
        dsl::let_typed_expr("grad_p_own", Type::vec2_f32(), grad_p_idx_expr.clone()),
        dsl::let_typed_expr(
            "grad_p_neigh",
            Type::vec2_f32(),
            state_vec2(layout, "state", "other_idx_p", grad_p_field),
        ),
        dsl::var_typed_expr("interp_f", Type::F32, Some(0.5.into())),
        dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("interp_f"),
                Expr::ident("d_own") / Expr::ident("total_dist"),
            )]),
            None,
        ),
        dsl::let_typed_expr(
            "grad_p_f",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_own"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_neigh"))
                        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_own")))
                        .mul_scalar(Expr::ident("interp_f")),
                )
                .expr(),
        ),
        dsl::let_expr(
            "correction_flux",
            Expr::ident("pressure_coeff_face")
                * typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_f"))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("k_vec")))
                * 0.5,
        ),
        dsl::assign_op_expr(
            AssignOp::Sub,
            Expr::ident("rhs_val"),
            Expr::ident("correction_flux"),
        ),
    ]);

    let boundary_block = dsl::block(vec![dsl::if_block_expr(
        Expr::ident("boundary_type").eq(2u32),
        dsl::block(vec![
            dsl::let_expr(
                "dx",
                Expr::ident("center").field("x") - Expr::ident("f_center").field("x"),
            ),
            dsl::let_expr(
                "dy",
                Expr::ident("center").field("y") - Expr::ident("f_center").field("y"),
            ),
            dsl::let_expr(
                "dist",
                dsl::sqrt(Expr::ident("dx") * Expr::ident("dx") + Expr::ident("dy") * Expr::ident("dy")),
            ),
            dsl::let_expr("d_p_own", d_p_idx_expr.clone()),
            dsl::let_expr("pressure_coeff_cell", pressure_coeff_cell_expr.clone()),
            dsl::let_expr(
                "coeff",
                Expr::ident("pressure_coeff_cell") * Expr::ident("area") / Expr::ident("dist"),
            ),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("diag_coeff"),
                Expr::ident("coeff"),
            ),
        ]),
        None,
    )]);

    loop_body.push(dsl::if_block_expr(
        !Expr::ident("is_boundary"),
        internal_block,
        Some(boundary_block),
    ));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(loop_body),
    ));

    stmts.push(dsl::let_expr(
        "diag_idx",
        dsl::array_access("diagonal_indices", Expr::ident("idx")),
    ));
    stmts.push(dsl::assign_array_access(
        "matrix_values",
        Expr::ident("diag_idx"),
        Expr::ident("diag_coeff"),
    ));
    stmts.push(dsl::assign_array_access(
        "rhs",
        Expr::ident("idx"),
        Expr::ident("rhs_val"),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::incompressible_momentum_model;
    use crate::solver::codegen::ir::lower_system;
    use crate::solver::model::backend::SchemeRegistry;
    use crate::solver::scheme::Scheme;

    #[test]
    fn pressure_assembly_codegen_emits_state_arrays() {
        let model = incompressible_momentum_model();
        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&model.system, &registry).unwrap();
        let fields = model.fields.incompressible().expect("incompressible fields");
        let wgsl = generate_pressure_assembly_wgsl(&discrete, &model.state_layout, fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("matrix_values"));
        assert!(wgsl.contains("rhs"));
    }
}
