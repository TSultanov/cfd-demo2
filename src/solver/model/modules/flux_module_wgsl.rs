use std::collections::{HashMap, HashSet};

use crate::solver::ir::{
    FaceScalarBuiltin, FaceScalarExpr, FaceSide, FaceVec2Builtin, FaceVec2Expr, FieldKind,
    FluxLayout, FluxModuleKernelSpec, LowMachParam, StateLayout,
};
use crate::solver::scheme::Scheme;
use crate::solver::shared::PrimitiveExpr;
use cfd2_codegen::solver::codegen::dsl as typed;
use cfd2_codegen::solver::codegen::wgsl_ast::{
    AccessMode, Attribute, Block, CseBuilder, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use cfd2_codegen::solver::codegen::wgsl_dsl as dsl;
use cfd2_codegen::solver::codegen::KernelWgsl;

pub fn generate_flux_module_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &[(String, PrimitiveExpr)],
    spec: &FluxModuleKernelSpec,
) -> KernelWgsl {
    assert!(flux_stride > 0, "flux_module requires flux_stride > 0");
    assert_eq!(
        flux_stride, flux_layout.stride,
        "flux_stride must match FluxLayout.stride"
    );

    let primitive_map: HashMap<&str, &PrimitiveExpr> =
        primitives.iter().map(|(k, v)| (k.as_str(), v)).collect();

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items(flux_spec_uses_low_mach(spec)));
    module.push(Item::Function(main_fn(
        layout,
        flux_layout,
        flux_stride,
        &primitive_map,
        spec,
    )));
    KernelWgsl::from(module)
}

/// Generate a flux module WGSL kernel that selects reconstruction at runtime via
/// `constants.scheme`.
///
/// The per-`Scheme` variants are provided as IR specs. This emits a single WGSL entrypoint that
/// selects between the variants per face invocation, while guarding boundary faces to remain
/// first-order.
pub fn generate_flux_module_wgsl_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &[(String, PrimitiveExpr)],
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> KernelWgsl {
    assert!(flux_stride > 0, "flux_module requires flux_stride > 0");
    assert_eq!(
        flux_stride, flux_layout.stride,
        "flux_stride must match FluxLayout.stride"
    );

    let primitive_map: HashMap<&str, &PrimitiveExpr> =
        primitives.iter().map(|(k, v)| (k.as_str(), v)).collect();

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items(
        variants
            .iter()
            .any(|(_, spec)| flux_spec_uses_low_mach(spec)),
    ));
    module.push(Item::Function(main_fn_runtime_scheme(
        layout,
        flux_layout,
        flux_stride,
        &primitive_map,
        variants,
    )));
    KernelWgsl::from(module)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::ir::{vol_scalar, vol_vector, FaceSide, FluxComponent};
    use crate::solver::scheme::Scheme;
    use crate::solver::units::si;

    #[test]
    fn flux_module_codegen_accepts_cell_to_face_reconstruction_exprs() {
        let phi = vol_scalar("phi", si::DIMENSIONLESS);
        let grad_phi = vol_vector("grad_phi", si::DIMENSIONLESS);
        let layout = StateLayout::new(vec![phi, grad_phi]);
        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "phi".to_string(),
                offset: 0,
            }],
        };

        let reconstruct = |side: FaceSide, other: FaceSide| -> FaceScalarExpr {
            let phi_cell = FaceScalarExpr::state(side, "phi");
            let phi_other = FaceScalarExpr::state(other, "phi");
            let grad = FaceVec2Expr::state_vec2(side, "grad_phi");
            let r = FaceVec2Expr::cell_to_face(side);
            let delta = FaceScalarExpr::Dot(Box::new(grad), Box::new(r));
            let diff = FaceScalarExpr::Sub(Box::new(phi_other), Box::new(phi_cell.clone()));
            let min_diff =
                FaceScalarExpr::Min(Box::new(diff.clone()), Box::new(FaceScalarExpr::lit(0.0)));
            let max_diff = FaceScalarExpr::Max(Box::new(diff), Box::new(FaceScalarExpr::lit(0.0)));
            let delta_limited = FaceScalarExpr::Min(
                Box::new(FaceScalarExpr::Max(Box::new(delta), Box::new(min_diff))),
                Box::new(max_diff),
            );
            FaceScalarExpr::Add(Box::new(phi_cell), Box::new(delta_limited))
        };

        let left = reconstruct(FaceSide::Owner, FaceSide::Neighbor);
        let right = reconstruct(FaceSide::Neighbor, FaceSide::Owner);

        let spec = FluxModuleKernelSpec::CentralUpwind {
            reconstruction: Scheme::SecondOrderUpwindMinMod,
            components: vec!["phi".to_string()],
            u_left: vec![left.clone()],
            u_right: vec![right.clone()],
            flux_left: vec![left],
            flux_right: vec![right],
            a_plus: FaceScalarExpr::lit(1.0),
            a_minus: FaceScalarExpr::lit(-1.0),
        };

        let wgsl = generate_flux_module_wgsl(&layout, &flux_layout, 1, &[], &spec).to_wgsl();
        assert!(wgsl.contains("cell_centers"));
        assert!(wgsl.contains("face_centers"));
    }

    #[test]
    fn muscl_does_not_reconstruct_boundary_neighbor_state() {
        // Regression test: when MUSCL reconstruction is enabled, the boundary neighbor value
        // (Dirichlet/Neumann ghost) must not be modified by reconstruction.
        //
        // The simplest way to ensure this in codegen is to force neighbor-side gradients to
        // zero on boundary faces, so `phi_cell + dot(grad, r)` collapses to `phi_cell`.
        let phi = vol_scalar("phi", si::DIMENSIONLESS);
        let grad_phi = vol_vector("grad_phi", si::DIMENSIONLESS);
        let layout = StateLayout::new(vec![phi, grad_phi]);
        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "phi".to_string(),
                offset: 0,
            }],
        };

        // Force the kernel to read neighbor-side gradients (which previously used the owner
        // gradient on boundary faces), so we can assert boundary-specific zeroing exists.
        let phi_expr = FaceScalarExpr::Dot(
            Box::new(FaceVec2Expr::state_vec2(FaceSide::Neighbor, "grad_phi")),
            Box::new(FaceVec2Expr::cell_to_face(FaceSide::Neighbor)),
        );
        let spec = FluxModuleKernelSpec::ScalarReplicated { phi: phi_expr };

        let wgsl = generate_flux_module_wgsl(&layout, &flux_layout, 1, &[], &spec).to_wgsl();

        // `phi`(scalar) + `grad_phi`(vec2) => stride=3; grad_phi.x is at offset 1.
        assert!(wgsl.contains("state[neigh_idx * 3u + 1u]"));
        assert!(
            wgsl.contains(", 0.0, is_boundary)"),
            "expected boundary neighbor gradient to be zeroed via select(..., 0.0, is_boundary)"
        );
    }
}

fn base_items(include_low_mach_params: bool) -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    if include_low_mach_params {
        items.push(Item::Struct(low_mach_params_struct()));
    }
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings(include_low_mach_params));
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items.push(Item::Function(bc_neighbor_scalar_fn()));
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    // Keep the same layout as other generated kernels for now.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("eos_gamma", Type::F32),
            StructField::new("eos_gm1", Type::F32),
            StructField::new("eos_r", Type::F32),
            StructField::new("eos_dp_drho", Type::F32),
            StructField::new("eos_p_offset", Type::F32),
            StructField::new("eos_theta_ref", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn bc_neighbor_scalar_fn() -> Function {
    Function::new(
        "bc_neighbor_scalar",
        vec![
            Param::new("interior", Type::F32, Vec::new()),
            Param::new("owner", Type::F32, Vec::new()),
            Param::new("kind", Type::U32, Vec::new()),
            Param::new("value", Type::F32, Vec::new()),
            Param::new("d_own", Type::F32, Vec::new()),
            Param::new("is_boundary", Type::Bool, Vec::new()),
        ],
        Some(Type::F32),
        Vec::new(),
        Block::new(vec![
            dsl::var_typed_expr("boundary", Type::F32, Some(Expr::ident("owner"))),
            dsl::if_block_expr(
                Expr::ident("kind").eq(Expr::from(1u32)),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("boundary"),
                    Expr::ident("value"),
                )]),
                None,
            ),
            dsl::if_block_expr(
                Expr::ident("kind").eq(Expr::from(2u32)),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("boundary"),
                    Expr::ident("owner") + Expr::ident("value") * Expr::ident("d_own"),
                )]),
                None,
            ),
            Stmt::Return(Some(dsl::select(
                Expr::ident("interior"),
                Expr::ident("boundary"),
                Expr::ident("is_boundary"),
            ))),
        ]),
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings(include_low_mach_params: bool) -> Vec<Item> {
    let mut bindings = vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ];
    if include_low_mach_params {
        bindings.push(uniform_var(
            "low_mach_params",
            Type::Custom("LowMachParams".to_string()),
            1,
            5,
        ));
    }
    bindings
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout, flux_stride, primitives, spec),
    )
}

fn main_fn_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body_runtime_scheme(layout, flux_layout, flux_stride, primitives, variants),
    )
}

fn main_body(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        dsl::array_access("face_neighbor", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr("is_boundary", Expr::ident("neighbor").eq(-1)));
    // For boundary faces, we treat the "neighbor" side as the owner cell (zero-gradient
    // extrapolation). Boundary-aware flux formulas can still use `boundary_type`.
    stmts.push(dsl::var_typed_expr(
        "neigh_idx",
        Type::U32,
        Some(Expr::ident("owner")),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("neigh_idx"),
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        )]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        dsl::array_access("face_centers", Expr::ident("idx")),
    ));

    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));

    stmts.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));

    // Ensure the face normal is oriented outward from the owner cell.
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    stmts.extend(face_stmts(
        layout,
        flux_layout,
        flux_stride,
        primitives,
        spec,
    ));

    Block::new(stmts)
}

fn main_body_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        dsl::array_access("face_neighbor", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr("is_boundary", Expr::ident("neighbor").eq(-1)));
    // For boundary faces, we treat the "neighbor" side as the owner cell (zero-gradient
    // extrapolation). Boundary-aware flux formulas can still use `boundary_type`.
    stmts.push(dsl::var_typed_expr(
        "neigh_idx",
        Type::U32,
        Some(Expr::ident("owner")),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("neigh_idx"),
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        )]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        dsl::array_access("face_centers", Expr::ident("idx")),
    ));

    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));

    stmts.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));

    // Ensure the face normal is oriented outward from the owner cell.
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    stmts.extend(face_stmts_runtime_scheme(
        layout,
        flux_layout,
        flux_stride,
        primitives,
        variants,
    ));

    Block::new(stmts)
}

fn face_stmts(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Vec<Stmt> {
    let mut body = Vec::new();

    body.push(dsl::let_expr(
        "c_neigh",
        dsl::array_access("cell_centers", Expr::ident("neigh_idx")),
    ));
    body.push(dsl::var_typed_expr(
        "c_neigh_vec",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr()),
    ));

    // Preserve the true neighbor-cell center even on boundary faces.
    //
    // For boundary faces, we sometimes override `c_neigh_vec` for interpolation convenience,
    // but geometry builtins (e.g. `CellToFace{Neighbor}`) should still reference the neighbor
    // cell center (which degenerates to the owner cell for boundary faces).
    body.push(dsl::let_typed_expr(
        "c_neigh_cell_vec",
        Type::vec2_f32(),
        Expr::ident("c_neigh_vec"),
    ));
    body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("c_neigh_vec"),
            Expr::ident("face_center_vec"),
        )]),
        None,
    ));

    // Match OpenFOAM's `surfaceInterpolation::weights()` (basicFvGeometryScheme):
    //   w = mag(Sf · (Cf - Cown)) / (mag(Sf · (Cf - Cown)) + mag(Sf · (Cnei - Cf)))
    //
    // Since `normal_vec` is unit-length and `Sf = area * normal_vec`, the area cancels.
    let d_own = dsl::abs(
        typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    );
    body.push(dsl::let_expr("d_own", d_own));

    let d_neigh = dsl::abs(
        typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                "face_center_vec",
            )))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    );
    body.push(dsl::let_expr("d_neigh", d_neigh));
    body.push(dsl::let_expr(
        "total_dist",
        Expr::ident("d_own") + Expr::ident("d_neigh"),
    ));
    body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
    body.push(dsl::if_block_expr(
        Expr::ident("total_dist").gt(1e-6),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("lambda"),
            Expr::ident("d_neigh") / Expr::ident("total_dist"),
        )]),
        None,
    ));
    body.push(dsl::let_expr(
        "lambda_other",
        Expr::from(1.0) - Expr::ident("lambda"),
    ));

    let d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
        .expr();
    body.push(dsl::let_typed_expr("d_vec", Type::vec2_f32(), d_vec));
    body.push(dsl::let_expr(
        "dist_proj",
        dsl::abs(
            typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
    ));
    body.push(dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)));

    let mut state_keys = HashSet::new();
    collect_state_keys_from_flux_spec(spec, primitives, layout, &mut state_keys);
    let (state_vars, state_var_stmts) = precompute_state_vars(layout, flux_layout, &state_keys);
    body.extend(state_var_stmts);
    let ctx = LowerCtx::new(layout, primitives, flux_layout, state_vars);
    let mut cse = CseBuilder::new("_cse_");

    match spec {
        FluxModuleKernelSpec::ScalarReplicated { phi } => {
            let phi_expr = lower_scalar(phi, &ctx);
            body.push(dsl::var_typed_expr("phi", Type::F32, Some(phi_expr)));

            for u_idx in 0..flux_stride {
                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, u_idx),
                    Expr::ident("phi"),
                ));
            }
        }
        FluxModuleKernelSpec::ScalarPerComponent { components, flux } => {
            if components.len() != flux_layout.components.len() {
                panic!("ScalarPerComponent spec component count does not match FluxLayout");
            }
            if flux.len() != components.len() {
                panic!("ScalarPerComponent spec arrays must match component count");
            }

            for (i, comp_name) in components.iter().enumerate() {
                let off = flux_layout
                    .offset_for(comp_name)
                    .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));
                let flux_expr = lower_scalar(&flux[i], &ctx);
                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
                    flux_expr,
                ));
            }
        }
        FluxModuleKernelSpec::CentralUpwind {
            reconstruction: _,
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
        } => {
            if components.len() != flux_layout.components.len() {
                panic!("CentralUpwind spec component count does not match FluxLayout");
            }
            if u_left.len() != components.len()
                || u_right.len() != components.len()
                || flux_left.len() != components.len()
                || flux_right.len() != components.len()
            {
                panic!("CentralUpwind spec arrays must match component count");
            }

            let a_p = lower_scalar(a_plus, &ctx);
            let a_m = lower_scalar(a_minus, &ctx);
            let (cse_stmts, exprs) = cse.eliminate(&[a_p, a_m]);
            body.extend(cse_stmts);
            let [a_p, a_m] = exprs
                .try_into()
                .expect("CSE returned unexpected number of expressions");
            body.push(dsl::let_expr("a_plus", a_p));
            body.push(dsl::let_expr("a_minus", a_m));
            body.push(dsl::let_expr(
                "denom",
                dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
            ));

            for (i, comp_name) in components.iter().enumerate() {
                let off = flux_layout
                    .offset_for(comp_name)
                    .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));
                let u_l = lower_scalar(&u_left[i], &ctx);
                let u_r = lower_scalar(&u_right[i], &ctx);
                let f_l = lower_scalar(&flux_left[i], &ctx);
                let f_r = lower_scalar(&flux_right[i], &ctx);
                let (cse_stmts, exprs) = cse.eliminate(&[u_l, u_r, f_l, f_r]);
                body.extend(cse_stmts);
                let [u_l, u_r, f_l, f_r] = exprs
                    .try_into()
                    .expect("CSE returned unexpected number of expressions");

                let num = Expr::ident("a_plus") * f_l - Expr::ident("a_minus") * f_r
                    + (Expr::ident("a_plus") * Expr::ident("a_minus")) * (u_r - u_l);
                let flux = num / Expr::ident("denom");

                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
                    flux * Expr::ident("area"),
                ));
            }
        }
    }

    body
}

fn face_stmts_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> Vec<Stmt> {
    #[derive(Clone, Copy)]
    struct CentralUpwindVariant<'a> {
        components: &'a [String],
        u_left: &'a [FaceScalarExpr],
        u_right: &'a [FaceScalarExpr],
        flux_left: &'a [FaceScalarExpr],
        flux_right: &'a [FaceScalarExpr],
        a_plus: &'a FaceScalarExpr,
        a_minus: &'a FaceScalarExpr,
    }

    let mut body = Vec::new();

    // --- Geometry preamble (kept in sync with `face_stmts`) ---
    body.push(dsl::let_expr(
        "c_neigh",
        dsl::array_access("cell_centers", Expr::ident("neigh_idx")),
    ));
    body.push(dsl::var_typed_expr(
        "c_neigh_vec",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr()),
    ));
    body.push(dsl::let_typed_expr(
        "c_neigh_cell_vec",
        Type::vec2_f32(),
        Expr::ident("c_neigh_vec"),
    ));
    body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("c_neigh_vec"),
            Expr::ident("face_center_vec"),
        )]),
        None,
    ));

    // Match OpenFOAM's `surfaceInterpolation::weights()` (basicFvGeometryScheme).
    let d_own = dsl::abs(
        typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    );
    body.push(dsl::let_expr("d_own", d_own));

    let d_neigh = dsl::abs(
        typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                "face_center_vec",
            )))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    );
    body.push(dsl::let_expr("d_neigh", d_neigh));
    body.push(dsl::let_expr(
        "total_dist",
        Expr::ident("d_own") + Expr::ident("d_neigh"),
    ));
    body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
    body.push(dsl::if_block_expr(
        Expr::ident("total_dist").gt(1e-6),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("lambda"),
            Expr::ident("d_neigh") / Expr::ident("total_dist"),
        )]),
        None,
    ));
    body.push(dsl::let_expr(
        "lambda_other",
        Expr::from(1.0) - Expr::ident("lambda"),
    ));

    let d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
        .expr();
    body.push(dsl::let_typed_expr("d_vec", Type::vec2_f32(), d_vec));
    body.push(dsl::let_expr(
        "dist_proj",
        dsl::abs(
            typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
    ));
    body.push(dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)));

    let mut state_keys = HashSet::new();
    for (_, spec) in variants {
        collect_state_keys_from_flux_spec(spec, primitives, layout, &mut state_keys);
    }
    let (state_vars, state_var_stmts) = precompute_state_vars(layout, flux_layout, &state_keys);
    body.extend(state_var_stmts);
    let ctx = LowerCtx::new(layout, primitives, flux_layout, state_vars);
    let mut cse = CseBuilder::new("_cse_");

    // --- Runtime scheme selection ---
    if variants.is_empty() {
        panic!("runtime scheme flux module requires at least one variant spec");
    }

    // Fast-path for runtime scheme selection with pre-integrated per-component fluxes.
    //
    // This is used by the compressible Kurganov/rhoCentralFoam-style flux lowering, which
    // computes integrated face fluxes directly and does not use the CentralUpwind KT form.
    if matches!(
        &variants[0].1,
        FluxModuleKernelSpec::ScalarPerComponent { .. }
    ) {
        #[derive(Clone, Copy)]
        struct ScalarPerComponentVariant<'a> {
            components: &'a [String],
            flux: &'a [FaceScalarExpr],
        }

        let mut by_gpu_id: Vec<Option<ScalarPerComponentVariant<'_>>> = vec![None; 7];
        for (scheme, spec) in variants {
            let FluxModuleKernelSpec::ScalarPerComponent { components, flux } = spec else {
                panic!("runtime scheme flux module requires ScalarPerComponent variants");
            };

            let idx = scheme.gpu_id() as usize;
            if idx >= by_gpu_id.len() {
                continue;
            }
            if by_gpu_id[idx].is_some() {
                panic!("duplicate ScalarPerComponent variant for scheme {scheme:?}");
            }
            by_gpu_id[idx] = Some(ScalarPerComponentVariant { components, flux });
        }

        let upwind = by_gpu_id[Scheme::Upwind.gpu_id() as usize]
            .unwrap_or_else(|| panic!("runtime scheme flux module requires an Upwind variant"));

        if upwind.components.len() != flux_layout.components.len() {
            panic!("ScalarPerComponent spec component count does not match FluxLayout");
        }
        if upwind.flux.len() != upwind.components.len() {
            panic!("ScalarPerComponent spec arrays must match component count");
        }

        // Ensure all variants share the same component list/order.
        for v in by_gpu_id.iter().flatten() {
            if v.components != upwind.components {
                panic!("ScalarPerComponent variant components must match across schemes");
            }
            if v.flux.len() != v.components.len() {
                panic!("ScalarPerComponent spec arrays must match component count");
            }
        }

        let scheme_lit =
            typed::EnumExpr::<Scheme>::from_expr(Expr::ident("constants").field("scheme"));
        let is_interior = !Expr::ident("is_boundary");
        let cond_for = |scheme: Scheme| scheme_lit.eq(scheme) & is_interior;

        // Declare one mutable flux var per component, initialized from the Upwind variant.
        let mut var_names: Vec<String> = Vec::with_capacity(upwind.components.len());
        let mut upwind_flux_exprs: Vec<Expr> = Vec::with_capacity(upwind.components.len());
        for (i, comp_name) in upwind.components.iter().enumerate() {
            let off = flux_layout
                .offset_for(comp_name)
                .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));
            var_names.push(format!("phi_{off}"));
            upwind_flux_exprs.push(lower_scalar(&upwind.flux[i], &ctx));
        }

        let (cse_stmts, upwind_flux_exprs) = cse.eliminate(&upwind_flux_exprs);
        body.extend(cse_stmts);
        for (name, expr) in var_names.iter().zip(upwind_flux_exprs.into_iter()) {
            body.push(dsl::var_typed_expr(name, Type::F32, Some(expr)));
        }

        for scheme in [
            Scheme::SecondOrderUpwind,
            Scheme::QUICK,
            Scheme::SecondOrderUpwindMinMod,
            Scheme::SecondOrderUpwindVanLeer,
            Scheme::QUICKMinMod,
            Scheme::QUICKVanLeer,
        ] {
            let Some(v) = by_gpu_id.get(scheme.gpu_id() as usize).and_then(|v| *v) else {
                continue;
            };

            let cond = cond_for(scheme);
            let mut scheme_flux_exprs: Vec<Expr> = Vec::with_capacity(v.components.len());
            for i in 0..v.components.len() {
                scheme_flux_exprs.push(lower_scalar(&v.flux[i], &ctx));
            }
            let (cse_stmts, scheme_flux_exprs) = cse.eliminate(&scheme_flux_exprs);

            body.push(dsl::if_block_expr(
                cond,
                dsl::block(
                    cse_stmts
                        .into_iter()
                        .chain(
                            var_names.iter().zip(scheme_flux_exprs.into_iter()).map(
                                |(name, expr)| dsl::assign_expr(Expr::ident(name.clone()), expr),
                            ),
                        )
                        .collect(),
                ),
                None,
            ));
        }

        // Write the selected component fluxes into the packed flux table.
        for (name, comp_name) in var_names.iter().zip(upwind.components.iter()) {
            let off = flux_layout
                .offset_for(comp_name)
                .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));
            body.push(dsl::assign_expr(
                dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
                Expr::ident(name.clone()),
            ));
        }

        return body;
    }

    let mut by_gpu_id: Vec<Option<CentralUpwindVariant<'_>>> = vec![None; 7];
    for (scheme, spec) in variants {
        let FluxModuleKernelSpec::CentralUpwind {
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
            ..
        } = spec
        else {
            panic!("runtime scheme flux module requires CentralUpwind variants");
        };

        let idx = scheme.gpu_id() as usize;
        if idx >= by_gpu_id.len() {
            continue;
        }
        if by_gpu_id[idx].is_some() {
            panic!("duplicate CentralUpwind variant for scheme {scheme:?}");
        }
        by_gpu_id[idx] = Some(CentralUpwindVariant {
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
        });
    }

    let upwind = by_gpu_id[Scheme::Upwind.gpu_id() as usize]
        .unwrap_or_else(|| panic!("runtime scheme flux module requires an Upwind variant"));

    if upwind.components.len() != flux_layout.components.len() {
        panic!("CentralUpwind spec component count does not match FluxLayout");
    }
    if upwind.u_left.len() != upwind.components.len()
        || upwind.u_right.len() != upwind.components.len()
        || upwind.flux_left.len() != upwind.components.len()
        || upwind.flux_right.len() != upwind.components.len()
    {
        panic!("CentralUpwind spec arrays must match component count");
    }

    // Ensure all variants share the same component list/order.
    for v in by_gpu_id.iter().flatten() {
        if v.components != upwind.components {
            panic!("CentralUpwind variant components must match across schemes");
        }
    }

    let scheme_lit = typed::EnumExpr::<Scheme>::from_expr(Expr::ident("constants").field("scheme"));
    let is_interior = !Expr::ident("is_boundary");
    let cond_for = |scheme: Scheme| scheme_lit.eq(scheme) & is_interior;

    // Wave speed selection.
    let a_plus_upwind = lower_scalar(upwind.a_plus, &ctx);
    let a_minus_upwind = lower_scalar(upwind.a_minus, &ctx);
    let (cse_stmts, exprs) = cse.eliminate(&[a_plus_upwind, a_minus_upwind]);
    body.extend(cse_stmts);
    let [a_plus_upwind, a_minus_upwind] = exprs
        .try_into()
        .expect("CSE returned unexpected number of expressions");
    body.push(dsl::var_typed_expr(
        "a_plus",
        Type::F32,
        Some(a_plus_upwind),
    ));
    body.push(dsl::var_typed_expr(
        "a_minus",
        Type::F32,
        Some(a_minus_upwind),
    ));

    for scheme in [
        Scheme::SecondOrderUpwind,
        Scheme::QUICK,
        Scheme::SecondOrderUpwindMinMod,
        Scheme::SecondOrderUpwindVanLeer,
        Scheme::QUICKMinMod,
        Scheme::QUICKVanLeer,
    ] {
        let Some(v) = by_gpu_id.get(scheme.gpu_id() as usize).and_then(|v| *v) else {
            continue;
        };

        let cond = cond_for(scheme);
        let a_p = lower_scalar(v.a_plus, &ctx);
        let a_m = lower_scalar(v.a_minus, &ctx);
        let (cse_stmts, exprs) = cse.eliminate(&[a_p, a_m]);
        let [a_p, a_m] = exprs
            .try_into()
            .expect("CSE returned unexpected number of expressions");

        body.push(dsl::if_block_expr(
            cond,
            dsl::block(
                cse_stmts
                    .into_iter()
                    .chain([
                        dsl::assign_expr(Expr::ident("a_plus"), a_p),
                        dsl::assign_expr(Expr::ident("a_minus"), a_m),
                    ])
                    .collect(),
            ),
            None,
        ));
    }

    body.push(dsl::let_expr(
        "denom",
        dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
    ));

    for (i, comp_name) in upwind.components.iter().enumerate() {
        let off = flux_layout
            .offset_for(comp_name)
            .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));

        let u_l = format!("u_l_{off}");
        let u_r = format!("u_r_{off}");
        let f_l = format!("f_l_{off}");
        let f_r = format!("f_r_{off}");

        let u_l_upwind = lower_scalar(&upwind.u_left[i], &ctx);
        let u_r_upwind = lower_scalar(&upwind.u_right[i], &ctx);
        let f_l_upwind = lower_scalar(&upwind.flux_left[i], &ctx);
        let f_r_upwind = lower_scalar(&upwind.flux_right[i], &ctx);
        let (cse_stmts, exprs) = cse.eliminate(&[u_l_upwind, u_r_upwind, f_l_upwind, f_r_upwind]);
        body.extend(cse_stmts);
        let [u_l_upwind, u_r_upwind, f_l_upwind, f_r_upwind] = exprs
            .try_into()
            .expect("CSE returned unexpected number of expressions");

        body.push(dsl::var_typed_expr(&u_l, Type::F32, Some(u_l_upwind)));
        body.push(dsl::var_typed_expr(&u_r, Type::F32, Some(u_r_upwind)));
        body.push(dsl::var_typed_expr(&f_l, Type::F32, Some(f_l_upwind)));
        body.push(dsl::var_typed_expr(&f_r, Type::F32, Some(f_r_upwind)));

        for scheme in [
            Scheme::SecondOrderUpwind,
            Scheme::QUICK,
            Scheme::SecondOrderUpwindMinMod,
            Scheme::SecondOrderUpwindVanLeer,
            Scheme::QUICKMinMod,
            Scheme::QUICKVanLeer,
        ] {
            let Some(v) = by_gpu_id.get(scheme.gpu_id() as usize).and_then(|v| *v) else {
                continue;
            };

            let cond = cond_for(scheme);
            let u_l_expr = lower_scalar(&v.u_left[i], &ctx);
            let u_r_expr = lower_scalar(&v.u_right[i], &ctx);
            let f_l_expr = lower_scalar(&v.flux_left[i], &ctx);
            let f_r_expr = lower_scalar(&v.flux_right[i], &ctx);
            let (cse_stmts, exprs) = cse.eliminate(&[u_l_expr, u_r_expr, f_l_expr, f_r_expr]);
            let [u_l_expr, u_r_expr, f_l_expr, f_r_expr] = exprs
                .try_into()
                .expect("CSE returned unexpected number of expressions");

            body.push(dsl::if_block_expr(
                cond,
                dsl::block(
                    cse_stmts
                        .into_iter()
                        .chain([
                            dsl::assign_expr(Expr::ident(&u_l), u_l_expr),
                            dsl::assign_expr(Expr::ident(&u_r), u_r_expr),
                            dsl::assign_expr(Expr::ident(&f_l), f_l_expr),
                            dsl::assign_expr(Expr::ident(&f_r), f_r_expr),
                        ])
                        .collect(),
                ),
                None,
            ));
        }

        let num = Expr::ident("a_plus") * Expr::ident(&f_l)
            - Expr::ident("a_minus") * Expr::ident(&f_r)
            + (Expr::ident("a_plus") * Expr::ident("a_minus"))
                * (Expr::ident(&u_r) - Expr::ident(&u_l));
        let flux = num / Expr::ident("denom");

        body.push(dsl::assign_expr(
            dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
            flux * Expr::ident("area"),
        ));
    }

    body
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct StateKey<'a> {
    side: FaceSide,
    field: &'a str,
    component: u32,
}

fn sanitize_ident(raw: &str) -> String {
    let mut out: String = raw
        .chars()
        .map(|c| {
            if c.is_ascii_alphanumeric() || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect();
    if out.chars().next().is_some_and(|c| c.is_ascii_digit()) {
        out.insert(0, '_');
    }
    out
}

fn state_var_name(layout: &StateLayout, key: StateKey<'_>) -> String {
    let side = match key.side {
        FaceSide::Owner => "own",
        FaceSide::Neighbor => "neigh",
    };

    let mut name = format!("s_{side}_{}", sanitize_ident(key.field));

    let suffix = layout.field(key.field).map(|f| f.kind());
    match suffix {
        Some(FieldKind::Vector2) => {
            name.push_str(match key.component {
                0 => "_x",
                1 => "_y",
                _ => return format!("{name}_c{}", key.component),
            });
        }
        Some(FieldKind::Vector3) => {
            name.push_str(match key.component {
                0 => "_x",
                1 => "_y",
                2 => "_z",
                _ => return format!("{name}_c{}", key.component),
            });
        }
        _ => {
            if key.component != 0 {
                name.push_str(&format!("_c{}", key.component));
            }
        }
    }

    name
}

fn collect_state_keys_from_flux_spec<'a>(
    spec: &'a FluxModuleKernelSpec,
    primitives: &'a HashMap<&'a str, &'a PrimitiveExpr>,
    state_layout: &'a StateLayout,
    out: &mut HashSet<StateKey<'a>>,
) {
    match spec {
        FluxModuleKernelSpec::ScalarReplicated { phi } => {
            collect_state_keys_from_scalar(phi, primitives, state_layout, out);
        }
        FluxModuleKernelSpec::ScalarPerComponent { flux, .. } => {
            for expr in flux {
                collect_state_keys_from_scalar(expr, primitives, state_layout, out);
            }
        }
        FluxModuleKernelSpec::CentralUpwind {
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
            ..
        } => {
            for expr in u_left {
                collect_state_keys_from_scalar(expr, primitives, state_layout, out);
            }
            for expr in u_right {
                collect_state_keys_from_scalar(expr, primitives, state_layout, out);
            }
            for expr in flux_left {
                collect_state_keys_from_scalar(expr, primitives, state_layout, out);
            }
            for expr in flux_right {
                collect_state_keys_from_scalar(expr, primitives, state_layout, out);
            }
            collect_state_keys_from_scalar(a_plus, primitives, state_layout, out);
            collect_state_keys_from_scalar(a_minus, primitives, state_layout, out);
        }
    }
}

fn collect_state_keys_from_vec2<'a>(
    expr: &'a FaceVec2Expr,
    primitives: &'a HashMap<&'a str, &'a PrimitiveExpr>,
    state_layout: &'a StateLayout,
    out: &mut HashSet<StateKey<'a>>,
) {
    match expr {
        FaceVec2Expr::Builtin(_) => {}
        FaceVec2Expr::CellStateVec2 { .. } => {}
        FaceVec2Expr::Vec2(x, y) => {
            collect_state_keys_from_scalar(x, primitives, state_layout, out);
            collect_state_keys_from_scalar(y, primitives, state_layout, out);
        }
        FaceVec2Expr::StateVec2 { side, field } => {
            // `FaceVec2Expr` is always `vec2`, so we only materialize x/y.
            out.insert(StateKey {
                side: *side,
                field: field.as_str(),
                component: 0,
            });
            out.insert(StateKey {
                side: *side,
                field: field.as_str(),
                component: 1,
            });
        }
        FaceVec2Expr::Add(a, b) | FaceVec2Expr::Sub(a, b) | FaceVec2Expr::Lerp(a, b) => {
            collect_state_keys_from_vec2(a, primitives, state_layout, out);
            collect_state_keys_from_vec2(b, primitives, state_layout, out);
        }
        FaceVec2Expr::Neg(a) => collect_state_keys_from_vec2(a, primitives, state_layout, out),
        FaceVec2Expr::MulScalar(v, s) => {
            collect_state_keys_from_vec2(v, primitives, state_layout, out);
            collect_state_keys_from_scalar(s, primitives, state_layout, out);
        }
    }
}

fn collect_state_keys_from_primitive_expr<'a>(
    expr: &'a PrimitiveExpr,
    side: FaceSide,
    state_layout: &'a StateLayout,
    out: &mut HashSet<StateKey<'a>>,
) {
    match expr {
        PrimitiveExpr::Literal(_) => {}
        PrimitiveExpr::Field(name) => {
            let (base, component) = resolve_state_field_component(state_layout, name);
            out.insert(StateKey {
                side,
                field: base,
                component,
            });
        }
        PrimitiveExpr::Add(a, b)
        | PrimitiveExpr::Sub(a, b)
        | PrimitiveExpr::Mul(a, b)
        | PrimitiveExpr::Div(a, b) => {
            collect_state_keys_from_primitive_expr(a, side, state_layout, out);
            collect_state_keys_from_primitive_expr(b, side, state_layout, out);
        }
        PrimitiveExpr::Sqrt(inner) | PrimitiveExpr::Neg(inner) => {
            collect_state_keys_from_primitive_expr(inner, side, state_layout, out);
        }
    }
}

fn collect_state_keys_from_scalar<'a>(
    expr: &'a FaceScalarExpr,
    primitives: &'a HashMap<&'a str, &'a PrimitiveExpr>,
    state_layout: &'a StateLayout,
    out: &mut HashSet<StateKey<'a>>,
) {
    match expr {
        FaceScalarExpr::Literal(_)
        | FaceScalarExpr::Builtin(_)
        | FaceScalarExpr::Constant { .. }
        | FaceScalarExpr::LowMachParam(_) => {}
        FaceScalarExpr::State { side, name } => {
            out.insert(StateKey {
                side: *side,
                field: name.as_str(),
                component: 0,
            });
        }
        FaceScalarExpr::Primitive { side, name } => {
            let prim = primitives.get(name.as_str()).unwrap_or_else(|| {
                panic!("primitive '{}' not found in PrimitiveDerivations", name)
            });
            collect_state_keys_from_primitive_expr(prim, *side, state_layout, out);
        }
        FaceScalarExpr::Add(a, b)
        | FaceScalarExpr::Sub(a, b)
        | FaceScalarExpr::Mul(a, b)
        | FaceScalarExpr::Div(a, b)
        | FaceScalarExpr::Max(a, b)
        | FaceScalarExpr::Min(a, b)
        | FaceScalarExpr::Lerp(a, b) => {
            collect_state_keys_from_scalar(a, primitives, state_layout, out);
            collect_state_keys_from_scalar(b, primitives, state_layout, out);
        }
        FaceScalarExpr::Neg(a) | FaceScalarExpr::Abs(a) | FaceScalarExpr::Sqrt(a) => {
            collect_state_keys_from_scalar(a, primitives, state_layout, out);
        }
        FaceScalarExpr::Dot(a, b) => {
            collect_state_keys_from_vec2(a, primitives, state_layout, out);
            collect_state_keys_from_vec2(b, primitives, state_layout, out);
        }
    }
}

fn precompute_state_vars<'a>(
    layout: &'a StateLayout,
    flux_layout: &'a FluxLayout,
    keys: &HashSet<StateKey<'a>>,
) -> (HashMap<StateKey<'a>, String>, Vec<Stmt>) {
    let mut vars = HashMap::new();
    let mut stmts = Vec::new();

    let mut ordered: Vec<StateKey<'a>> = keys.iter().copied().collect();
    ordered.sort_by(|a, b| {
        let side_rank = |s: FaceSide| if s == FaceSide::Owner { 0 } else { 1 };
        side_rank(a.side)
            .cmp(&side_rank(b.side))
            .then_with(|| a.field.cmp(b.field))
            .then_with(|| a.component.cmp(&b.component))
    });

    for key in ordered {
        let name = state_var_name(layout, key);
        let expr = state_component_at_side(
            layout,
            "state",
            key.side,
            key.field,
            key.component,
            flux_layout,
        );
        stmts.push(dsl::let_expr(&name, expr));
        vars.insert(key, name);
    }

    (vars, stmts)
}

struct LowerCtx<'a> {
    layout: &'a StateLayout,
    primitives: &'a HashMap<&'a str, &'a PrimitiveExpr>,
    flux_layout: &'a FluxLayout,
    state_vars: HashMap<StateKey<'a>, String>,
}

impl<'a> LowerCtx<'a> {
    fn new(
        layout: &'a StateLayout,
        primitives: &'a HashMap<&'a str, &'a PrimitiveExpr>,
        flux_layout: &'a FluxLayout,
        state_vars: HashMap<StateKey<'a>, String>,
    ) -> Self {
        Self {
            layout,
            primitives,
            flux_layout,
            state_vars,
        }
    }

    fn state_scalar(&self, side: FaceSide, field: &'a str, component: u32) -> Expr {
        let key = StateKey {
            side,
            field,
            component,
        };
        if let Some(name) = self.state_vars.get(&key) {
            return Expr::ident(name.clone());
        }
        state_component_at_side(
            self.layout,
            "state",
            side,
            field,
            component,
            self.flux_layout,
        )
    }
}

fn lower_vec2<'a>(expr: &'a FaceVec2Expr, ctx: &LowerCtx<'a>) -> typed::VecExpr<2> {
    match expr {
        FaceVec2Expr::Builtin(FaceVec2Builtin::Normal) => {
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
        }
        FaceVec2Expr::Builtin(FaceVec2Builtin::CellToFace { side }) => {
            let face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"));
            let center = match side {
                FaceSide::Owner => typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")),
                FaceSide::Neighbor => {
                    typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_cell_vec"))
                }
            };
            face.sub(&center)
        }
        FaceVec2Expr::Vec2(x, y) => {
            typed::VecExpr::<2>::from_components([lower_scalar(x, ctx), lower_scalar(y, ctx)])
        }
        FaceVec2Expr::StateVec2 { side, field } => {
            let x = ctx.state_scalar(*side, field.as_str(), 0);
            let y = ctx.state_scalar(*side, field.as_str(), 1);

            // Boundary regression guard for MUSCL reconstruction:
            //
            // When higher-order reconstruction is enabled, models conventionally use `grad_*`
            // state fields to reconstruct face states. On boundary faces, neighbor-side state
            // reads are replaced with Dirichlet/Neumann "ghost" values via `bc_kind/bc_value`.
            // If we also use non-zero neighbor-side gradients, the reconstruction step can modify
            // those ghost values and violate boundary semantics.
            //
            // To keep the IR PDE-agnostic and preserve existing BC semantics, treat neighbor-side
            // `grad_*` vectors as zero on boundary faces.
            //
            // Exception: for Rhie–Chow-style mass fluxes, `grad_p` participates in the HbyA
            // predictor. On outlet faces (zero-gradient velocity), we allow `grad_p` to be
            // non-zero so the pressure equation sees the same predictor term OpenFOAM uses,
            // while still forcing it to zero on other boundary types (e.g. walls/inlets) to
            // avoid injecting normal flux where the velocity BC is Dirichlet.
            if *side == FaceSide::Neighbor && field.starts_with("grad_") {
                let is_boundary = Expr::ident("is_boundary");
                let zero_cond = if field == "grad_p" {
                    let is_outlet = Expr::ident("boundary_type").eq(Expr::from(2u32));
                    is_boundary.clone() & !is_outlet
                } else {
                    is_boundary.clone()
                };
                return typed::VecExpr::<2>::from_components([
                    dsl::select(x, Expr::from(0.0), zero_cond.clone()),
                    dsl::select(y, Expr::from(0.0), zero_cond),
                ]);
            }

            typed::VecExpr::<2>::from_components([x, y])
        }
        FaceVec2Expr::CellStateVec2 { side, field } => {
            let idx = match side {
                FaceSide::Owner => Expr::ident("owner"),
                FaceSide::Neighbor => Expr::ident("neigh_idx"),
            };
            typed::VecExpr::<2>::from_components([
                state_component_at(ctx.layout, "state", idx.clone(), field.as_str(), 0),
                state_component_at(ctx.layout, "state", idx, field.as_str(), 1),
            ])
        }
        FaceVec2Expr::Add(a, b) => {
            let a = lower_vec2(a, ctx);
            let b = lower_vec2(b, ctx);
            a.add(&b)
        }
        FaceVec2Expr::Sub(a, b) => {
            // DSL-aware geometry simplification:
            //   (face - center_a) - (face - center_b) == center_b - center_a
            // This pattern appears frequently in gradient approximations and QUICK stencils.
            if let (
                FaceVec2Expr::Builtin(FaceVec2Builtin::CellToFace { side: a_side }),
                FaceVec2Expr::Builtin(FaceVec2Builtin::CellToFace { side: b_side }),
            ) = (&**a, &**b)
            {
                let center_for = |side: FaceSide| match side {
                    FaceSide::Owner => Expr::ident("c_owner_vec"),
                    FaceSide::Neighbor => Expr::ident("c_neigh_cell_vec"),
                };
                let a_center = typed::VecExpr::<2>::from_expr(center_for(*a_side));
                let b_center = typed::VecExpr::<2>::from_expr(center_for(*b_side));
                return b_center.sub(&a_center);
            }

            let a = lower_vec2(a, ctx);
            let b = lower_vec2(b, ctx);
            a.sub(&b)
        }
        FaceVec2Expr::Neg(a) => lower_vec2(a, ctx).neg(),
        FaceVec2Expr::MulScalar(v, s) => lower_vec2(v, ctx).mul_scalar(lower_scalar(s, ctx)),
        FaceVec2Expr::Lerp(a, b) => {
            let a = lower_vec2(a, ctx);
            let b = lower_vec2(b, ctx);
            let l = Expr::ident("lambda");
            let lo = Expr::ident("lambda_other");
            a.mul_scalar(l).add(&b.mul_scalar(lo))
        }
    }
}

fn state_component_at(
    layout: &StateLayout,
    buffer: &str,
    idx: Expr,
    field: &str,
    component: u32,
) -> Expr {
    let offset = layout
        .component_offset(field, component)
        .unwrap_or_else(|| {
            panic!(
                "missing field '{}' component {} in state layout",
                field, component
            )
        });
    let stride = layout.stride();
    Expr::ident(buffer).index(idx * stride + offset)
}

fn state_component_at_side(
    layout: &StateLayout,
    buffer: &str,
    side: FaceSide,
    field: &str,
    component: u32,
    flux_layout: &FluxLayout,
) -> Expr {
    let owner = state_component_at(layout, buffer, Expr::ident("owner"), field, component);

    // Interior neighbor value (for boundary faces, `neigh_idx` is set to `owner`).
    let interior = state_component_at(layout, buffer, Expr::ident("neigh_idx"), field, component);

    let Some(state_field) = layout.field(field) else {
        panic!("missing field '{field}' in state layout");
    };
    let comp_name = match state_field.kind() {
        FieldKind::Scalar => {
            if component != 0 {
                return owner;
            }
            field.to_string()
        }
        FieldKind::Vector2 => {
            let suffix = match component {
                0 => "x",
                1 => "y",
                _ => return owner,
            };
            format!("{field}_{suffix}")
        }
        FieldKind::Vector3 => {
            let suffix = match component {
                0 => "x",
                1 => "y",
                2 => "z",
                _ => return owner,
            };
            format!("{field}_{suffix}")
        }
    };

    if let Some(unknown_offset) = flux_layout.offset_for(&comp_name) {
        let bc_table_idx =
            Expr::ident("idx") * Expr::from(flux_layout.stride) + Expr::from(unknown_offset);
        let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
        let value = dsl::array_access("bc_value", bc_table_idx);

        let base = if side == FaceSide::Owner {
            // OpenFOAM's `fvc::interpolate(...)` sets non-coupled patch face values to the patch
            // field value directly, independent of the upwind direction. Mirror this by applying
            // the boundary condition to the owner-side evaluation as well, so that boundary faces
            // see identical left/right states (and thus no artificial dissipation across the
            // boundary).
            Expr::call_named(
                "bc_neighbor_scalar",
                vec![
                    owner.clone(),
                    owner.clone(),
                    kind,
                    value,
                    Expr::ident("d_own"),
                    Expr::ident("is_boundary"),
                ],
            )
        } else {
            Expr::call_named(
                "bc_neighbor_scalar",
                vec![
                    interior,
                    owner.clone(),
                    kind,
                    value,
                    Expr::ident("d_own"),
                    Expr::ident("is_boundary"),
                ],
            )
        };

        return apply_slipwall_velocity_reflection(layout, buffer, field, component, base);
    }

    if side == FaceSide::Owner {
        // No BC entry (auxiliary state): boundary faces use the owner cell value on both sides.
        return owner;
    }

    let base = dsl::select(interior, owner, Expr::ident("is_boundary"));
    apply_slipwall_velocity_reflection(layout, buffer, field, component, base)
}

fn apply_slipwall_velocity_reflection(
    layout: &StateLayout,
    buffer: &str,
    field: &str,
    component: u32,
    base: Expr,
) -> Expr {
    // SlipWall boundary conditions are not representable as per-component Dirichlet/Neumann.
    // Emulate OpenFOAM `type slip` (basicSymmetry) by projecting out the normal component at
    // boundary faces:
    //   u_patch = u_owner - (u_owner · n) n
    //
    // This ensures no-penetration (zero normal mass flux) while preserving tangential velocity.
    let is_velocity_field = matches!(field, "u" | "U" | "rho_u" | "rhoU");
    if !is_velocity_field || component > 1 {
        return base;
    }

    let is_boundary = Expr::ident("is_boundary");
    let boundary_type = Expr::ident("boundary_type");

    // SlipWall: enforce no-penetration for convective fluxes by projecting out the
    // normal component at boundary faces:
    //   u_patch = u_owner - (u_owner · n) n
    //
    // For Wall (no-slip) boundaries, respect the scalar BC table (typically Dirichlet=0 for
    // both components). Projecting the owner-cell velocity would incorrectly introduce
    // tangential slip into the convective flux.
    let is_slipwall = is_boundary.clone() & boundary_type.clone().eq(Expr::from(4u32));
    let ux = state_component_at(layout, buffer, Expr::ident("owner"), field, 0);
    let uy = state_component_at(layout, buffer, Expr::ident("owner"), field, 1);
    let nx = Expr::ident("normal_vec").field("x");
    let ny = Expr::ident("normal_vec").field("y");
    let un = ux.clone() * nx.clone() + uy.clone() * ny.clone();

    let slip_projected = match component {
        0 => ux.clone() - un.clone() * nx.clone(),
        1 => uy.clone() - un.clone() * ny.clone(),
        _ => return base,
    };

    dsl::select(base, slip_projected, is_slipwall)
}

fn lower_scalar<'a>(expr: &'a FaceScalarExpr, ctx: &LowerCtx<'a>) -> Expr {
    match expr {
        FaceScalarExpr::Literal(v) => Expr::lit_f32(*v),
        FaceScalarExpr::Builtin(b) => match b {
            FaceScalarBuiltin::Area => Expr::ident("area"),
            FaceScalarBuiltin::Dist => Expr::ident("dist"),
            FaceScalarBuiltin::Lambda => Expr::ident("lambda"),
            FaceScalarBuiltin::LambdaOther => Expr::ident("lambda_other"),
            FaceScalarBuiltin::IsBoundary => dsl::select(0.0, 1.0, Expr::ident("is_boundary")),
        },
        FaceScalarExpr::Constant { name } => Expr::ident("constants").field(name.clone()),
        FaceScalarExpr::LowMachParam(param) => match param {
            LowMachParam::Model => {
                Expr::call_named("f32", vec![Expr::ident("low_mach_params").field("model")])
            }
            LowMachParam::ThetaFloor => Expr::ident("low_mach_params").field("theta_floor"),
            LowMachParam::PressureCouplingAlpha => {
                Expr::ident("low_mach_params").field("pressure_coupling_alpha")
            }
        },
        FaceScalarExpr::State { side, name } => ctx.state_scalar(*side, name.as_str(), 0),
        FaceScalarExpr::Primitive { side, name } => {
            let prim = ctx.primitives.get(name.as_str()).unwrap_or_else(|| {
                panic!("primitive '{}' not found in PrimitiveDerivations", name)
            });
            lower_primitive_expr_at_side(prim, ctx, *side)
        }
        FaceScalarExpr::Add(a, b) => lower_scalar(a, ctx) + lower_scalar(b, ctx),
        FaceScalarExpr::Sub(a, b) => lower_scalar(a, ctx) - lower_scalar(b, ctx),
        FaceScalarExpr::Mul(a, b) => lower_scalar(a, ctx) * lower_scalar(b, ctx),
        FaceScalarExpr::Div(a, b) => lower_scalar(a, ctx) / lower_scalar(b, ctx),
        FaceScalarExpr::Neg(a) => -lower_scalar(a, ctx),
        FaceScalarExpr::Abs(a) => dsl::abs(lower_scalar(a, ctx)),
        FaceScalarExpr::Sqrt(a) => Expr::call_named("sqrt", vec![lower_scalar(a, ctx)]),
        FaceScalarExpr::Max(a, b) => dsl::max(lower_scalar(a, ctx), lower_scalar(b, ctx)),
        FaceScalarExpr::Min(a, b) => {
            Expr::call_named("min", vec![lower_scalar(a, ctx), lower_scalar(b, ctx)])
        }
        FaceScalarExpr::Lerp(a, b) => {
            lower_scalar(a, ctx) * Expr::ident("lambda")
                + lower_scalar(b, ctx) * Expr::ident("lambda_other")
        }
        FaceScalarExpr::Dot(a, b) => {
            let a = lower_vec2(a, ctx);
            let b = lower_vec2(b, ctx);
            a.dot(&b)
        }
    }
}

fn flux_spec_uses_low_mach(spec: &FluxModuleKernelSpec) -> bool {
    match spec {
        FluxModuleKernelSpec::ScalarReplicated { phi } => scalar_uses_low_mach(phi),
        FluxModuleKernelSpec::ScalarPerComponent { flux, .. } => {
            flux.iter().any(scalar_uses_low_mach)
        }
        FluxModuleKernelSpec::CentralUpwind {
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
            ..
        } => {
            u_left.iter().any(scalar_uses_low_mach)
                || u_right.iter().any(scalar_uses_low_mach)
                || flux_left.iter().any(scalar_uses_low_mach)
                || flux_right.iter().any(scalar_uses_low_mach)
                || scalar_uses_low_mach(a_plus)
                || scalar_uses_low_mach(a_minus)
        }
    }
}

fn vec2_uses_low_mach(expr: &FaceVec2Expr) -> bool {
    match expr {
        FaceVec2Expr::Builtin(_)
        | FaceVec2Expr::StateVec2 { .. }
        | FaceVec2Expr::CellStateVec2 { .. } => false,
        FaceVec2Expr::Vec2(x, y) => scalar_uses_low_mach(x) || scalar_uses_low_mach(y),
        FaceVec2Expr::Add(a, b) | FaceVec2Expr::Sub(a, b) | FaceVec2Expr::Lerp(a, b) => {
            vec2_uses_low_mach(a) || vec2_uses_low_mach(b)
        }
        FaceVec2Expr::Neg(a) => vec2_uses_low_mach(a),
        FaceVec2Expr::MulScalar(a, b) => vec2_uses_low_mach(a) || scalar_uses_low_mach(b),
    }
}

fn scalar_uses_low_mach(expr: &FaceScalarExpr) -> bool {
    match expr {
        FaceScalarExpr::LowMachParam(_) => true,
        FaceScalarExpr::Literal(_)
        | FaceScalarExpr::Builtin(_)
        | FaceScalarExpr::Constant { .. }
        | FaceScalarExpr::State { .. }
        | FaceScalarExpr::Primitive { .. } => false,
        FaceScalarExpr::Add(a, b)
        | FaceScalarExpr::Sub(a, b)
        | FaceScalarExpr::Mul(a, b)
        | FaceScalarExpr::Div(a, b)
        | FaceScalarExpr::Max(a, b)
        | FaceScalarExpr::Min(a, b)
        | FaceScalarExpr::Lerp(a, b) => scalar_uses_low_mach(a) || scalar_uses_low_mach(b),
        FaceScalarExpr::Neg(a) | FaceScalarExpr::Abs(a) | FaceScalarExpr::Sqrt(a) => {
            scalar_uses_low_mach(a)
        }
        FaceScalarExpr::Dot(a, b) => vec2_uses_low_mach(a) || vec2_uses_low_mach(b),
    }
}

fn lower_primitive_expr_at_side<'a>(
    expr: &'a PrimitiveExpr,
    ctx: &LowerCtx<'a>,
    side: FaceSide,
) -> Expr {
    match expr {
        PrimitiveExpr::Literal(val) => Expr::lit_f32(*val),

        PrimitiveExpr::Field(name) => {
            let (base, component) = resolve_state_field_component(ctx.layout, name);
            ctx.state_scalar(side, base, component)
        }

        PrimitiveExpr::Add(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, ctx, side)
                + lower_primitive_expr_at_side(rhs, ctx, side)
        }
        PrimitiveExpr::Sub(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, ctx, side)
                - lower_primitive_expr_at_side(rhs, ctx, side)
        }
        PrimitiveExpr::Mul(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, ctx, side)
                * lower_primitive_expr_at_side(rhs, ctx, side)
        }
        PrimitiveExpr::Div(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, ctx, side)
                / lower_primitive_expr_at_side(rhs, ctx, side)
        }

        PrimitiveExpr::Sqrt(inner) => {
            Expr::call_named("sqrt", vec![lower_primitive_expr_at_side(inner, ctx, side)])
        }
        PrimitiveExpr::Neg(inner) => -lower_primitive_expr_at_side(inner, ctx, side),
    }
}

fn resolve_state_field_component<'a>(state_layout: &StateLayout, name: &'a str) -> (&'a str, u32) {
    if state_layout.offset_for(name).is_some() {
        return (name, 0);
    }

    let (base, component) = name
        .rsplit_once('_')
        .unwrap_or_else(|| panic!("primitive field '{}' not found in state layout", name));

    let component = match component {
        "x" => 0,
        "y" => 1,
        "z" => 2,
        _ => panic!("primitive field '{}' not found in state layout", name),
    };

    if state_layout.component_offset(base, component).is_none() {
        panic!("primitive field '{}' not found in state layout", name);
    }

    (base, component)
}
