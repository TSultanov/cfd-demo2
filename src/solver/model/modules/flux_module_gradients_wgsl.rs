use crate::solver::ir::FluxLayout;
use crate::solver::model::modules::flux_module::ResolvedGradientTarget;
use cfd2_codegen::solver::codegen::constants::constants_struct;
use cfd2_codegen::solver::codegen::dsl as typed;
use cfd2_codegen::solver::codegen::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, Item, Module, Param, Stmt, Type,
};
use cfd2_codegen::solver::codegen::wgsl_bindings::{
    boundary_bindings, storage_var, uniform_var, vector2_struct,
};
use cfd2_codegen::solver::codegen::wgsl_dsl as dsl;
use cfd2_codegen::solver::codegen::KernelWgsl;

/// Generate flux module gradients WGSL kernel from pre-resolved gradient targets.
///
/// This function no longer scans StateLayout; all offsets and metadata must be
/// pre-resolved into `targets` via `resolve_flux_module_gradients_targets()`.
pub fn generate_flux_module_gradients_wgsl(
    stride: u32,
    flux_layout: &FluxLayout,
    targets: &[ResolvedGradientTarget],
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module_gradients)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(stride, flux_layout, targets)));
    KernelWgsl::from(module)
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(base_constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items
}

fn base_constants_struct() -> cfd2_codegen::solver::codegen::wgsl_ast::StructDef {
    // Use shared helper for base Constants struct (no extra params)
    constants_struct(&[])
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 1),
    ]
}

fn main_fn(stride: u32, flux_layout: &FluxLayout, targets: &[ResolvedGradientTarget]) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(stride, flux_layout, targets),
    )
}

fn main_body(stride: u32, flux_layout: &FluxLayout, targets: &[ResolvedGradientTarget]) -> Block {
    let unknown_stride = flux_layout.stride;

    let mut stmts = vec![
        dsl::let_expr(
            "idx",
            Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
                + Expr::ident("global_id").field("x"),
        ),
        dsl::if_block_expr(
            Expr::ident("idx").ge(Expr::call_named(
                "arrayLength",
                vec![Expr::ident("cell_vols").addr_of()],
            )),
            dsl::block(vec![Stmt::Return(None)]),
            None,
        ),
        dsl::let_expr(
            "cell_center",
            dsl::array_access("cell_centers", Expr::ident("idx")),
        ),
        dsl::let_typed_expr(
            "cell_center_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("cell_center")).expr(),
        ),
        dsl::let_expr("vol", dsl::array_access("cell_vols", Expr::ident("idx"))),
        dsl::let_expr(
            "start",
            dsl::array_access("cell_face_offsets", Expr::ident("idx")),
        ),
        dsl::let_expr(
            "end",
            dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
        ),
    ];

    // Accumulators: one vec2 per gradient.
    for target in targets {
        let var_name = format!("grad_acc_{}", target.component);
        stmts.push(dsl::var_typed_expr(
            &var_name,
            Type::vec2_f32(),
            Some(dsl::vec2_f32(0.0, 0.0)),
        ));
    }

    // Face loop.
    let face_loop_body = {
        let mut body = vec![
            dsl::let_expr(
                "face_idx",
                dsl::array_access("cell_faces", Expr::ident("k")),
            ),
            dsl::let_expr(
                "owner",
                dsl::array_access("face_owner", Expr::ident("face_idx")),
            ),
            dsl::let_expr(
                "neighbor_raw",
                dsl::array_access("face_neighbor", Expr::ident("face_idx")),
            ),
            dsl::let_expr("is_boundary", Expr::ident("neighbor_raw").eq(-1)),
            dsl::let_expr(
                "boundary_type",
                dsl::array_access("face_boundary", Expr::ident("face_idx")),
            ),
            dsl::let_expr(
                "area",
                dsl::array_access("face_areas", Expr::ident("face_idx")),
            ),
            dsl::let_expr(
                "face_center",
                dsl::array_access("face_centers", Expr::ident("face_idx")),
            ),
            dsl::let_typed_expr(
                "face_center_vec",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
            ),
            dsl::var_typed_expr(
                "normal_vec",
                Type::vec2_f32(),
                Some(
                    typed::VecExpr::<2>::from_xy_fields(
                        Expr::ident("face_normals").index(Expr::ident("face_idx")),
                    )
                    .expr(),
                ),
            ),
        ];
        let cell_to_face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec")).sub(
            &typed::VecExpr::<2>::from_expr(Expr::ident("cell_center_vec")),
        );
        body.push(dsl::if_block_expr(
            cell_to_face
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
                .lt(0.0),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("normal_vec"),
                typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .neg()
                    .expr(),
            )]),
            None,
        ));

        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center_vec",
            Type::vec2_f32(),
            Some(Expr::ident("face_center_vec")),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            dsl::block(vec![
                dsl::let_expr(
                    "neighbor",
                    Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
                ),
                dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
                dsl::if_block_expr(
                    Expr::ident("owner").ne(Expr::ident("idx")),
                    dsl::block(vec![dsl::assign_expr(
                        Expr::ident("other_idx"),
                        Expr::ident("owner"),
                    )]),
                    None,
                ),
                dsl::let_expr(
                    "other_center",
                    dsl::array_access("cell_centers", Expr::ident("other_idx")),
                ),
                dsl::assign_expr(
                    Expr::ident("other_center_vec"),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
                ),
            ]),
            None,
        ));

        // Match OpenFOAM's linear interpolation weights (basicFvGeometryScheme) by using
        // projected distances along the face normal (area cancels out).
        body.push(dsl::let_expr(
            "d_own",
            dsl::abs(
                typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
                    .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                        "cell_center_vec",
                    )))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            ),
        ));
        body.push(dsl::let_expr(
            "d_neigh",
            dsl::abs(
                typed::VecExpr::<2>::from_expr(Expr::ident("other_center_vec"))
                    .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                        "face_center_vec",
                    )))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            ),
        ));
        body.push(dsl::let_expr(
            "total_dist",
            Expr::ident("d_own") + Expr::ident("d_neigh"),
        ));
        body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
        body.push(dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ));
        body.push(dsl::let_expr(
            "lambda_other",
            Expr::from(1.0) - Expr::ident("lambda"),
        ));

        for target in targets {
            let cell_val =
                Expr::ident("state").index(Expr::ident("idx") * stride + target.base_offset);
            let interior_other =
                Expr::ident("state").index(Expr::ident("other_idx") * stride + target.base_offset);

            let mut other_val = if let Some(off) = target.bc_unknown_offset {
                let bc_table_idx =
                    Expr::ident("face_idx") * Expr::from(unknown_stride) + Expr::from(off);
                let kind = dsl::array_access("bc_kind", bc_table_idx);
                let value = dsl::array_access("bc_value", bc_table_idx);
                let from_bc = dsl::select(
                    dsl::select(cell_val, value, kind.eq(Expr::from(1u32))),
                    cell_val + value * Expr::ident("d_own"),
                    kind.eq(Expr::from(2u32)),
                );
                dsl::select(interior_other, from_bc, Expr::ident("is_boundary"))
            } else {
                dsl::select(interior_other, cell_val, Expr::ident("is_boundary"))
            };

            // SlipWall projection for velocity-like vec2 fields: enforce zero normal component at
            // boundary faces by overriding the boundary face value.
            if target.base_component <= 1 {
                if let (Some(vec_x_off), Some(vec_y_off)) =
                    (target.slip_vec2_x_offset, target.slip_vec2_y_offset)
                {
                    let slip_mask = Expr::ident("is_boundary")
                        & Expr::ident("boundary_type").eq(Expr::from(4u32));

                    let vx = Expr::ident("state").index(Expr::ident("idx") * stride + vec_x_off);
                    let vy = Expr::ident("state").index(Expr::ident("idx") * stride + vec_y_off);
                    let nx = Expr::ident("normal_vec").field("x");
                    let ny = Expr::ident("normal_vec").field("y");
                    let un = vx * nx + vy * ny;

                    let projected = match target.base_component {
                        0 => vx - un * nx,
                        1 => vy - un * ny,
                        _ => unreachable!("base_component <= 1 guarded above"),
                    };

                    other_val = dsl::select(other_val, projected, slip_mask);
                }
            }

            let phi_face =
                cell_val * Expr::ident("lambda") + other_val * Expr::ident("lambda_other");

            let acc_name = format!("grad_acc_{}", target.component);
            let contrib = typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .mul_scalar(phi_face * Expr::ident("area"))
                .expr();
            body.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(&acc_name),
                contrib,
            ));
        }

        dsl::block(body)
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        face_loop_body,
    ));

    // Write out gradients (divide by volume).
    for target in targets {
        let acc_name = format!("grad_acc_{}", target.component);
        let grad_vec = typed::VecExpr::<2>::from_expr(Expr::ident(&acc_name))
            .mul_scalar(Expr::from(1.0) / dsl::max(Expr::ident("vol"), 1e-12))
            .expr();
        stmts.push(dsl::let_typed_expr(
            &format!("grad_out_{}", target.component),
            Type::vec2_f32(),
            grad_vec,
        ));

        let out = Expr::ident(format!("grad_out_{}", target.component));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + target.grad_x_offset),
            out.field("x"),
        ));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + target.grad_y_offset),
            out.field("y"),
        ));
    }

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::dimensions::{Density, DivDim, Length, MomentumDensity};
    use crate::solver::ir::{vol_scalar_dim, vol_vector_dim, FluxComponent, StateLayout};
    use crate::solver::model::modules::flux_module::resolve_flux_module_gradients_targets;

    #[test]
    fn flux_module_gradients_wgsl_matches_committed_incompressible_momentum() {
        use crate::solver::ir::SchemeRegistry;
        use crate::solver::model::incompressible_momentum_model;
        use crate::solver::model::kernel::{generate_kernel_wgsl_for_model_by_id, KernelId};

        let model = incompressible_momentum_model();
        let schemes = SchemeRegistry::default();
        let generated =
            generate_kernel_wgsl_for_model_by_id(&model, &schemes, KernelId::FLUX_MODULE_GRADIENTS)
                .expect("should generate flux_module_gradients WGSL");

        let committed = include_str!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/src/solver/gpu/shaders/generated/flux_module_gradients_incompressible_momentum.wgsl"
        ));

        assert_eq!(
            generated.trim_end(),
            committed.trim_end(),
            "generated flux_module_gradients WGSL for incompressible_momentum does not match committed file"
        );
    }

    #[test]
    fn flux_module_gradients_wgsl_matches_committed_compressible() {
        use crate::solver::ir::SchemeRegistry;
        use crate::solver::model::compressible_model;
        use crate::solver::model::kernel::{generate_kernel_wgsl_for_model_by_id, KernelId};

        let model = compressible_model();
        let schemes = SchemeRegistry::default();
        let generated =
            generate_kernel_wgsl_for_model_by_id(&model, &schemes, KernelId::FLUX_MODULE_GRADIENTS)
                .expect("should generate flux_module_gradients WGSL");

        let committed = include_str!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/src/solver/gpu/shaders/generated/flux_module_gradients_compressible.wgsl"
        ));

        assert_eq!(
            generated.trim_end(),
            committed.trim_end(),
            "generated flux_module_gradients WGSL for compressible does not match committed file"
        );
    }

    #[test]
    fn flux_module_gradients_accepts_vector_component_gradients() {
        let rho_u = vol_vector_dim::<MomentumDensity>("rho_u");
        let grad_rho_u_x = vol_vector_dim::<DivDim<MomentumDensity, Length>>("grad_rho_u_x");
        let grad_rho_u_y = vol_vector_dim::<DivDim<MomentumDensity, Length>>("grad_rho_u_y");
        let rho = vol_scalar_dim::<Density>("rho");
        let grad_rho = vol_vector_dim::<DivDim<Density, Length>>("grad_rho");

        let layout = StateLayout::new(vec![rho_u, grad_rho_u_x, grad_rho_u_y, rho, grad_rho]);

        let flux_layout = FluxLayout {
            stride: 3,
            components: vec![
                FluxComponent {
                    name: "rho".to_string(),
                    offset: 0,
                },
                FluxComponent {
                    name: "rho_u_x".to_string(),
                    offset: 1,
                },
                FluxComponent {
                    name: "rho_u_y".to_string(),
                    offset: 2,
                },
            ],
        };

        // Use resolver -> generator pattern
        let targets = resolve_flux_module_gradients_targets(&layout, &flux_layout)
            .expect("should resolve gradient targets");
        let wgsl =
            generate_flux_module_gradients_wgsl(layout.stride(), &flux_layout, &targets).to_wgsl();
        assert!(wgsl.contains("grad_acc_rho"));
        assert!(wgsl.contains("grad_acc_rho_u_x"));
        assert!(wgsl.contains("grad_acc_rho_u_y"));
    }

    #[test]
    fn missing_grad_field_component_returns_clear_error() {
        // Regression test: when a grad_<field> exists and base field exists,
        // but the base field component is missing (e.g., trying to access component 5 of a vec2),
        // the resolver should return a clear error containing the field name.
        let rho = vol_scalar_dim::<Density>("rho");
        let grad_rho = vol_vector_dim::<DivDim<Density, Length>>("grad_rho");

        let layout = StateLayout::new(vec![rho, grad_rho]);

        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "rho".to_string(),
                offset: 0,
            }],
        };

        // This should succeed since rho is a scalar (component 0)
        let result = resolve_flux_module_gradients_targets(&layout, &flux_layout);
        assert!(
            result.is_ok(),
            "should succeed for scalar field: {:?}",
            result.err()
        );

        // Now test with a vector component selector that exceeds the field's component count
        let rho_u = vol_vector_dim::<MomentumDensity>("rho_u");
        let grad_rho_u_z = vol_vector_dim::<DivDim<MomentumDensity, Length>>("grad_rho_u_z");
        // Note: rho_u only has x,y components (0,1), but we're requesting z (component 2)

        let layout2 = StateLayout::new(vec![rho_u, grad_rho_u_z]);
        let flux_layout2 = FluxLayout {
            stride: 2,
            components: vec![
                FluxComponent {
                    name: "rho_u_x".to_string(),
                    offset: 0,
                },
                FluxComponent {
                    name: "rho_u_y".to_string(),
                    offset: 1,
                },
            ],
        };

        let result2 = resolve_flux_module_gradients_targets(&layout2, &flux_layout2);
        let err = result2.expect_err("should fail when requesting component z of vec2 field");
        assert!(
            err.contains("rho_u_z") || err.contains("rho_u") || err.contains("component"),
            "error should contain field name or component info: {err}"
        );
    }
}
