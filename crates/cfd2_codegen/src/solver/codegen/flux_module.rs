use std::collections::HashMap;

use super::dsl as typed;
use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::ir::{
    FaceScalarBuiltin, FaceScalarExpr, FaceSide, FaceVec2Builtin, FaceVec2Expr, FieldKind,
    FluxLayout, FluxModuleKernelSpec, StateLayout,
};
use crate::solver::shared::PrimitiveExpr;

pub fn generate_flux_module_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &[(String, PrimitiveExpr)],
    spec: &FluxModuleKernelSpec,
) -> String {
    assert!(flux_stride > 0, "flux_module requires flux_stride > 0");
    assert_eq!(
        flux_stride, flux_layout.stride,
        "flux_stride must match FluxLayout.stride"
    );

    let primitive_map: HashMap<&str, &PrimitiveExpr> =
        primitives.iter().map(|(k, v)| (k.as_str(), v)).collect();

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(
        layout,
        flux_layout,
        flux_stride,
        &primitive_map,
        spec,
    )));
    module.to_wgsl()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::ir::{vol_scalar, vol_vector, FaceSide, FluxComponent};
    use crate::solver::scheme::Scheme;
    use crate::solver::units::si;

    #[test]
    fn flux_module_codegen_accepts_cell_to_face_reconstruction_exprs() {
        let phi = vol_scalar("phi", si::DIMENSIONLESS);
        let grad_phi = vol_vector("grad_phi", si::DIMENSIONLESS);
        let layout = StateLayout::new(vec![phi, grad_phi]);
        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "phi".to_string(),
                offset: 0,
            }],
        };

        let reconstruct = |side: FaceSide, other: FaceSide| -> FaceScalarExpr {
            let phi_cell = FaceScalarExpr::state(side, "phi");
            let phi_other = FaceScalarExpr::state(other, "phi");
            let grad = FaceVec2Expr::state_vec2(side, "grad_phi");
            let r = FaceVec2Expr::cell_to_face(side);
            let delta = FaceScalarExpr::Dot(Box::new(grad), Box::new(r));
            let diff = FaceScalarExpr::Sub(Box::new(phi_other), Box::new(phi_cell.clone()));
            let min_diff = FaceScalarExpr::Min(Box::new(diff.clone()), Box::new(FaceScalarExpr::lit(0.0)));
            let max_diff = FaceScalarExpr::Max(Box::new(diff), Box::new(FaceScalarExpr::lit(0.0)));
            let delta_limited = FaceScalarExpr::Min(
                Box::new(FaceScalarExpr::Max(Box::new(delta), Box::new(min_diff))),
                Box::new(max_diff),
            );
            FaceScalarExpr::Add(Box::new(phi_cell), Box::new(delta_limited))
        };

        let left = reconstruct(FaceSide::Owner, FaceSide::Neighbor);
        let right = reconstruct(FaceSide::Neighbor, FaceSide::Owner);

        let spec = FluxModuleKernelSpec::CentralUpwind {
            reconstruction: Scheme::SecondOrderUpwindMinMod,
            components: vec!["phi".to_string()],
            u_left: vec![left.clone()],
            u_right: vec![right.clone()],
            flux_left: vec![left],
            flux_right: vec![right],
            a_plus: FaceScalarExpr::lit(1.0),
            a_minus: FaceScalarExpr::lit(-1.0),
        };

        let wgsl = generate_flux_module_wgsl(&layout, &flux_layout, 1, &[], &spec);
        assert!(wgsl.contains("cell_centers"));
        assert!(wgsl.contains("face_centers"));
    }

    #[test]
    fn muscl_does_not_reconstruct_boundary_neighbor_state() {
        // Regression test: when MUSCL reconstruction is enabled, the boundary neighbor value
        // (Dirichlet/Neumann ghost) must not be modified by reconstruction.
        //
        // The simplest way to ensure this in codegen is to force neighbor-side gradients to
        // zero on boundary faces, so `phi_cell + dot(grad, r)` collapses to `phi_cell`.
        let phi = vol_scalar("phi", si::DIMENSIONLESS);
        let grad_phi = vol_vector("grad_phi", si::DIMENSIONLESS);
        let layout = StateLayout::new(vec![phi, grad_phi]);
        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "phi".to_string(),
                offset: 0,
            }],
        };

        // Force the kernel to read neighbor-side gradients (which previously used the owner
        // gradient on boundary faces), so we can assert boundary-specific zeroing exists.
        let phi_expr = FaceScalarExpr::Dot(
            Box::new(FaceVec2Expr::state_vec2(FaceSide::Neighbor, "grad_phi")),
            Box::new(FaceVec2Expr::normal()),
        );
        let spec = FluxModuleKernelSpec::ScalarReplicated { phi: phi_expr };

        let wgsl = generate_flux_module_wgsl(&layout, &flux_layout, 1, &[], &spec);

        // `phi`(scalar) + `grad_phi`(vec2) => stride=3; grad_phi.x is at offset 1.
        assert!(wgsl.contains("state[neigh_idx * 3u + 1u]"));
        assert!(
            wgsl.contains(", 0.0, is_boundary)"),
            "expected boundary neighbor gradient to be zeroed via select(..., 0.0, is_boundary)"
        );
    }
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
        items.push(Item::Comment(
            "Group 2: Boundary conditions (per face x unknown)".to_string(),
        ));
    items.extend(boundary_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    // Keep the same layout as other generated kernels for now.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("eos_gamma", Type::F32),
            StructField::new("eos_gm1", Type::F32),
            StructField::new("eos_r", Type::F32),
            StructField::new("eos_dp_drho", Type::F32),
            StructField::new("eos_p_offset", Type::F32),
            StructField::new("eos_theta_ref", Type::F32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout, flux_stride, primitives, spec),
    )
}

fn main_body(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        dsl::array_access("face_neighbor", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr("is_boundary", Expr::ident("neighbor").eq(-1)));
    // For boundary faces, we treat the "neighbor" side as the owner cell (zero-gradient
    // extrapolation). Boundary-aware flux formulas can still use `boundary_type`.
    stmts.push(dsl::var_typed_expr(
        "neigh_idx",
        Type::U32,
        Some(Expr::ident("owner")),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("neigh_idx"),
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        )]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        dsl::array_access("face_centers", Expr::ident("idx")),
    ));

    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));

    stmts.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));

    // Ensure the face normal is oriented outward from the owner cell.
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    stmts.extend(face_stmts(
        layout,
        flux_layout,
        flux_stride,
        primitives,
        spec,
    ));

    Block::new(stmts)
}

fn face_stmts(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Vec<Stmt> {
    let mut body = Vec::new();

    body.push(dsl::let_expr(
        "c_neigh",
        dsl::array_access("cell_centers", Expr::ident("neigh_idx")),
    ));
    body.push(dsl::var_typed_expr(
        "c_neigh_vec",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr()),
    ));

    // Preserve the true neighbor-cell center even on boundary faces.
    //
    // For boundary faces, we sometimes override `c_neigh_vec` for interpolation convenience,
    // but geometry builtins (e.g. `CellToFace{Neighbor}`) should still reference the neighbor
    // cell center (which degenerates to the owner cell for boundary faces).
    body.push(dsl::let_typed_expr(
        "c_neigh_cell_vec",
        Type::vec2_f32(),
        Expr::ident("c_neigh_vec"),
    ));
    body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("c_neigh_vec"),
            Expr::ident("face_center_vec"),
        )]),
        None,
    ));

    body.push(dsl::let_expr(
        "d_own",
        dsl::distance("c_owner_vec", "face_center_vec"),
    ));
    body.push(dsl::let_expr(
        "d_neigh",
        dsl::distance("c_neigh_vec", "face_center_vec"),
    ));
    body.push(dsl::let_expr(
        "total_dist",
        Expr::ident("d_own") + Expr::ident("d_neigh"),
    ));
    body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
    body.push(dsl::if_block_expr(
        Expr::ident("total_dist").gt(1e-6),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("lambda"),
            Expr::ident("d_neigh") / Expr::ident("total_dist"),
        )]),
        None,
    ));
    body.push(dsl::let_expr(
        "lambda_other",
        Expr::from(1.0) - Expr::ident("lambda"),
    ));

    let d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
        .expr();
    body.push(dsl::let_typed_expr("d_vec", Type::vec2_f32(), d_vec));
    body.push(dsl::let_expr(
        "dist_proj",
        dsl::abs(
            typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
    ));
    body.push(dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)));

    match spec {
        FluxModuleKernelSpec::ScalarReplicated { phi } => {
            let phi_expr = lower_scalar(phi, layout, primitives, flux_layout);
            body.push(dsl::var_typed_expr("phi", Type::F32, Some(phi_expr)));

            for u_idx in 0..flux_stride {
                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, u_idx),
                    Expr::ident("phi"),
                ));
            }
        }
        FluxModuleKernelSpec::CentralUpwind {
            reconstruction: _,
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
        } => {
            if components.len() != flux_layout.components.len() {
                panic!("CentralUpwind spec component count does not match FluxLayout");
            }
            if u_left.len() != components.len()
                || u_right.len() != components.len()
                || flux_left.len() != components.len()
                || flux_right.len() != components.len()
            {
                panic!("CentralUpwind spec arrays must match component count");
            }

            let a_p = lower_scalar(a_plus, layout, primitives, flux_layout);
            let a_m = lower_scalar(a_minus, layout, primitives, flux_layout);
            body.push(dsl::let_expr("a_plus", a_p));
            body.push(dsl::let_expr("a_minus", a_m));
            body.push(dsl::let_expr(
                "denom",
                dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
            ));

            for (i, comp_name) in components.iter().enumerate() {
                let off = flux_layout
                    .offset_for(comp_name)
                    .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));
                let u_l = lower_scalar(&u_left[i], layout, primitives, flux_layout);
                let u_r = lower_scalar(&u_right[i], layout, primitives, flux_layout);
                let f_l = lower_scalar(&flux_left[i], layout, primitives, flux_layout);
                let f_r = lower_scalar(&flux_right[i], layout, primitives, flux_layout);

                let num = Expr::ident("a_plus") * f_l - Expr::ident("a_minus") * f_r
                    + (Expr::ident("a_plus") * Expr::ident("a_minus")) * (u_r - u_l);
                let flux = num / Expr::ident("denom");

                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
                    flux * Expr::ident("area"),
                ));
            }
        }
    }

    body
}

fn lower_vec2(
    expr: &FaceVec2Expr,
    layout: &StateLayout,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    flux_layout: &FluxLayout,
) -> typed::VecExpr<2> {
    match expr {
        FaceVec2Expr::Builtin(FaceVec2Builtin::Normal) => {
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
        }
        FaceVec2Expr::Builtin(FaceVec2Builtin::CellToFace { side }) => {
            let face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"));
            let center = match side {
                FaceSide::Owner => typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")),
                FaceSide::Neighbor => {
                    typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_cell_vec"))
                }
            };
            face.sub(&center)
        }
        FaceVec2Expr::Vec2(x, y) => typed::VecExpr::<2>::from_components([
            lower_scalar(x, layout, primitives, flux_layout),
            lower_scalar(y, layout, primitives, flux_layout),
        ]),
        FaceVec2Expr::StateVec2 { side, field } => {
            let x = state_component_at_side(layout, "state", *side, field, 0, flux_layout);
            let y = state_component_at_side(layout, "state", *side, field, 1, flux_layout);

            // Boundary regression guard for MUSCL reconstruction:
            //
            // When higher-order reconstruction is enabled, models conventionally use `grad_*`
            // state fields to reconstruct face states. On boundary faces, neighbor-side
            // state reads are replaced with Dirichlet/Neumann "ghost" values via `bc_kind/bc_value`.
            // If we also use non-zero neighbor-side gradients, the reconstruction step can modify
            // those ghost values and violate boundary semantics.
            //
            // To keep the IR PDE-agnostic and preserve existing BC semantics, treat neighbor-side
            // `grad_*` vectors as zero on boundary faces.
            if *side == FaceSide::Neighbor && field.starts_with("grad_") {
                let is_boundary = Expr::ident("is_boundary");
                return typed::VecExpr::<2>::from_components([
                    dsl::select(x, Expr::from(0.0), is_boundary.clone()),
                    dsl::select(y, Expr::from(0.0), is_boundary),
                ]);
            }

            typed::VecExpr::<2>::from_components([x, y])
        }
        FaceVec2Expr::Add(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            a.add(&b)
        }
        FaceVec2Expr::Sub(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            a.sub(&b)
        }
        FaceVec2Expr::Neg(a) => lower_vec2(a, layout, primitives, flux_layout).neg(),
        FaceVec2Expr::MulScalar(v, s) => lower_vec2(v, layout, primitives, flux_layout)
            .mul_scalar(lower_scalar(s, layout, primitives, flux_layout)),
        FaceVec2Expr::Lerp(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            let l = Expr::ident("lambda");
            let lo = Expr::ident("lambda_other");
            a.mul_scalar(l).add(&b.mul_scalar(lo))
        }
    }
}

fn state_component_at(
    layout: &StateLayout,
    buffer: &str,
    idx: Expr,
    field: &str,
    component: u32,
) -> Expr {
    let offset = layout
        .component_offset(field, component)
        .unwrap_or_else(|| {
            panic!(
                "missing field '{}' component {} in state layout",
                field, component
            )
        });
    let stride = layout.stride();
    Expr::ident(buffer).index(idx * stride + offset)
}

fn state_component_at_side(
    layout: &StateLayout,
    buffer: &str,
    side: FaceSide,
    field: &str,
    component: u32,
    flux_layout: &FluxLayout,
) -> Expr {
    if side == FaceSide::Owner {
        return state_component_at(layout, buffer, Expr::ident("owner"), field, component);
    }

    // Interior neighbor value.
    let interior = state_component_at(layout, buffer, Expr::ident("neigh_idx"), field, component);

    // Boundary neighbor uses BC tables (if the field is an unknown); otherwise fall back to owner.
    //
    // Important: for *interior* faces, we always want the true neighbor cell value, even for
    // auxiliary state fields (e.g. `d_p`, `grad_p`) that are not part of the solved-for unknown
    // set. Only boundary faces need special handling.
    let owner = state_component_at(layout, buffer, Expr::ident("owner"), field, component);

    let Some(state_field) = layout.field(field) else {
        panic!("missing field '{field}' in state layout");
    };
    let comp_name = match state_field.kind() {
        FieldKind::Scalar => {
            if component != 0 {
                return owner;
            }
            field.to_string()
        }
        FieldKind::Vector2 => {
            let suffix = match component {
                0 => "x",
                1 => "y",
                _ => return owner,
            };
            format!("{field}_{suffix}")
        }
        FieldKind::Vector3 => {
            let suffix = match component {
                0 => "x",
                1 => "y",
                2 => "z",
                _ => return owner,
            };
            format!("{field}_{suffix}")
        }
    };

        let boundary_neighbor = if let Some(unknown_offset) = flux_layout.offset_for(&comp_name) {
            let bc_table_idx = Expr::ident("idx") * Expr::from(flux_layout.stride)
                + Expr::from(unknown_offset);
        let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
        let value = dsl::array_access("bc_value", bc_table_idx);

        // GpuBcKind: ZeroGradient=0, Dirichlet=1, Neumann=2 (value is dphi/dn).
        dsl::select(
            dsl::select(owner.clone(), value.clone(), kind.eq(Expr::from(1u32))),
            owner.clone() + value * Expr::ident("d_own"),
            kind.eq(Expr::from(2u32)),
        )
    } else {
        owner.clone()
    };

    dsl::select(interior, boundary_neighbor, Expr::ident("is_boundary"))
}

fn lower_scalar(
    expr: &FaceScalarExpr,
    layout: &StateLayout,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    flux_layout: &FluxLayout,
) -> Expr {
    match expr {
        FaceScalarExpr::Literal(v) => Expr::lit_f32(*v),
        FaceScalarExpr::Builtin(b) => match b {
            FaceScalarBuiltin::Area => Expr::ident("area"),
            FaceScalarBuiltin::Dist => Expr::ident("dist"),
            FaceScalarBuiltin::Lambda => Expr::ident("lambda"),
            FaceScalarBuiltin::LambdaOther => Expr::ident("lambda_other"),
        },
        FaceScalarExpr::Constant { name } => Expr::ident("constants").field(name.clone()),
        FaceScalarExpr::State { side, name } => {
            state_component_at_side(layout, "state", *side, name, 0, flux_layout)
        }
        FaceScalarExpr::Primitive { side, name } => {
            let prim = primitives.get(name.as_str()).unwrap_or_else(|| {
                panic!("primitive '{}' not found in PrimitiveDerivations", name)
            });
            lower_primitive_expr_at_side(prim, layout, *side, flux_layout)
        }
        FaceScalarExpr::Add(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                + lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Sub(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                - lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Mul(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                * lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Div(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                / lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Neg(a) => -lower_scalar(a, layout, primitives, flux_layout),
        FaceScalarExpr::Abs(a) => dsl::abs(lower_scalar(a, layout, primitives, flux_layout)),
        FaceScalarExpr::Sqrt(a) => Expr::call_named(
            "sqrt",
            vec![lower_scalar(a, layout, primitives, flux_layout)],
        ),
        FaceScalarExpr::Max(a, b) => dsl::max(
            lower_scalar(a, layout, primitives, flux_layout),
            lower_scalar(b, layout, primitives, flux_layout),
        ),
        FaceScalarExpr::Min(a, b) => Expr::call_named(
            "min",
            vec![
                lower_scalar(a, layout, primitives, flux_layout),
                lower_scalar(b, layout, primitives, flux_layout),
            ],
        ),
        FaceScalarExpr::Lerp(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout) * Expr::ident("lambda")
                + lower_scalar(b, layout, primitives, flux_layout) * Expr::ident("lambda_other")
        }
        FaceScalarExpr::Dot(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            a.dot(&b)
        }
    }
}

fn lower_primitive_expr_at_side(
    expr: &PrimitiveExpr,
    state_layout: &StateLayout,
    side: FaceSide,
    flux_layout: &FluxLayout,
) -> Expr {
    match expr {
        PrimitiveExpr::Literal(val) => Expr::lit_f32(*val),

        PrimitiveExpr::Field(name) => {
            let (base, component) = resolve_state_field_component(state_layout, name);
            state_component_at_side(state_layout, "state", side, base, component, flux_layout)
        }

        PrimitiveExpr::Add(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                + lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }
        PrimitiveExpr::Sub(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                - lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }
        PrimitiveExpr::Mul(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                * lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }
        PrimitiveExpr::Div(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                / lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }

        PrimitiveExpr::Sqrt(inner) => Expr::call_named(
            "sqrt",
            vec![lower_primitive_expr_at_side(inner, state_layout, side, flux_layout)],
        ),
        PrimitiveExpr::Neg(inner) => -lower_primitive_expr_at_side(inner, state_layout, side, flux_layout),
    }
}

fn resolve_state_field_component<'a>(
    state_layout: &StateLayout,
    name: &'a str,
) -> (&'a str, u32) {
    if state_layout.offset_for(name).is_some() {
        return (name, 0);
    }

    let (base, component) = name
        .rsplit_once('_')
        .unwrap_or_else(|| panic!("primitive field '{}' not found in state layout", name));

    let component = match component {
        "x" => 0,
        "y" => 1,
        "z" => 2,
        _ => panic!("primitive field '{}' not found in state layout", name),
    };

    if state_layout.component_offset(base, component).is_none() {
        panic!("primitive field '{}' not found in state layout", name);
    }

    (base, component)
}
