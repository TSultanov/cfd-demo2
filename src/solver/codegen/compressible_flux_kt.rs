use super::state_access::{state_scalar_expr, state_vec2_expr};
use super::reconstruction::limited_linear_reconstruct_face;
use super::dsl as typed;
use crate::solver::model::CompressibleFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl_ast::{
    AccessMode, Attribute, BinaryOp, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_compressible_flux_kt_wgsl(
    layout: &StateLayout,
    fields: &CompressibleFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (compressible_flux_kt)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("precond_type", Type::U32),
            StructField::new("precond_model", Type::U32),
            StructField::new("precond_theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_iter",
            Type::array(Type::F32),
            1,
            9,
            AccessMode::Read,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CompressibleFields) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CompressibleFields) -> Block {
    let mut stmts = Vec::new();
    let rho_field = fields.rho.name();
    let rho_u_field = fields.rho_u.name();
    let rho_e_field = fields.rho_e.name();
    let gamma = "1.4";
    let flux_stride = 4u32;

    stmts.push(dsl::let_(
        "idx",
        "global_id.y * constants.stride_x + global_id.x",
    ));
    stmts.push(dsl::if_block(
        "idx >= arrayLength(&face_areas)",
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_("owner", "face_owner[idx]"));
    stmts.push(dsl::let_("neighbor", "face_neighbor[idx]"));
    stmts.push(dsl::let_("area", "face_areas[idx]"));
    stmts.push(dsl::let_("boundary_type", "face_boundary[idx]"));
    stmts.push(dsl::let_("face_center", "face_centers[idx]"));
    stmts.push(dsl::let_("center_owner", "cell_centers[owner]"));
    stmts.push(dsl::let_typed_expr(
        "center_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("center_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));
    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("center_owner_vec")));
    stmts.push(dsl::if_block_expr(
        Expr::binary(
            owner_face_d_vec.dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            BinaryOp::Less,
            Expr::lit_f32(0.0),
        ),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).neg().expr(),
        )]),
        None,
    ));
    stmts.push(dsl::var("is_boundary", "false"));
    stmts.push(dsl::var("other_idx", "owner"));

    let rho_l_expr = state_scalar_expr(layout, "state_old", "owner", rho_field);
    let rho_u_l_expr = state_vec2_expr(layout, "state_old", "owner", rho_u_field);
    let rho_e_l_expr = state_scalar_expr(layout, "state_old", "owner", rho_e_field);
    stmts.push(dsl::let_("rho_l_cell", &rho_l_expr));
    stmts.push(dsl::let_("rho_u_l_cell", &rho_u_l_expr));
    stmts.push(dsl::let_("rho_e_l_cell", &rho_e_l_expr));
    stmts.push(dsl::var("rho_l", "rho_l_cell"));
    stmts.push(dsl::var("rho_u_l", "rho_u_l_cell"));
    stmts.push(dsl::var("rho_e_l", "rho_e_l_cell"));
    stmts.push(dsl::var("rho_r", "rho_l"));
    stmts.push(dsl::var("rho_u_r", "rho_u_l"));
    stmts.push(dsl::var("rho_e_r", "rho_e_l"));
    stmts.push(dsl::var("center_r", "face_center"));

    let interior_block = {
        let rho_neigh_expr = state_scalar_expr(layout, "state_old", "neigh_idx", rho_field);
        let rho_u_neigh_expr = state_vec2_expr(layout, "state_old", "neigh_idx", rho_u_field);
        let rho_e_neigh_expr = state_scalar_expr(layout, "state_old", "neigh_idx", rho_e_field);
        dsl::block(vec![
            dsl::let_("neigh_idx", "u32(neighbor)"),
            dsl::assign("other_idx", "neigh_idx"),
            dsl::let_("rho_neigh", &rho_neigh_expr),
            dsl::let_("rho_u_neigh", &rho_u_neigh_expr),
            dsl::let_("rho_e_neigh", &rho_e_neigh_expr),
            dsl::assign("rho_r", "rho_neigh"),
            dsl::assign("rho_u_r", "rho_u_neigh"),
            dsl::assign("rho_e_r", "rho_e_neigh"),
            dsl::assign("center_r", "cell_centers[neigh_idx]"),
        ])
    };

    let boundary_block = dsl::block(vec![
        dsl::assign("is_boundary", "true"),
        dsl::if_block(
            "boundary_type == 1u",
            dsl::block(vec![
                dsl::assign_expr(
                    Expr::ident("rho_u_r"),
                    typed::VecExpr::<2>::from_components([
                        Expr::binary(
                            Expr::ident("rho_r"),
                            BinaryOp::Mul,
                            Expr::ident("constants").field("inlet_velocity"),
                        ),
                        Expr::lit_f32(0.0),
                    ])
                    .expr(),
                ),
            ]),
            Some(dsl::block(vec![dsl::if_block(
                "boundary_type == 3u",
                dsl::block(vec![
                    // Slip wall: reflect only the normal component of momentum.
                    dsl::let_expr(
                        "m_dot_n",
                        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l")).dot(
                            &typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")),
                        ),
                    ),
                    dsl::assign_expr(
                        Expr::ident("rho_u_r"),
                        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
                            .sub(
                                &typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).mul_scalar(
                                    Expr::binary(
                                        Expr::lit_f32(2.0),
                                        BinaryOp::Mul,
                                        Expr::ident("m_dot_n"),
                                    ),
                                ),
                            )
                            .expr(),
                    ),
                ]),
                None,
            )])),
        ),
    ]);

    stmts.push(dsl::if_block(
        "neighbor != -1",
        interior_block,
        Some(boundary_block),
    ));

    stmts.push(dsl::let_("rho_r_cell", "rho_r"));
    stmts.push(dsl::let_("rho_u_r_cell", "rho_u_r"));
    stmts.push(dsl::let_("rho_e_r_cell", "rho_e_r"));

    let reconstruct_block = {
        let mut block = Vec::new();
        block.push(dsl::let_expr(
            "r_l_x",
            Expr::binary(
                Expr::ident("face_center").field("x"),
                BinaryOp::Sub,
                Expr::ident("center_owner").field("x"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_l_y",
            Expr::binary(
                Expr::ident("face_center").field("y"),
                BinaryOp::Sub,
                Expr::ident("center_owner").field("y"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_r_x",
            Expr::binary(
                Expr::ident("face_center").field("x"),
                BinaryOp::Sub,
                Expr::ident("center_r").field("x"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_r_y",
            Expr::binary(
                Expr::ident("face_center").field("y"),
                BinaryOp::Sub,
                Expr::ident("center_r").field("y"),
            ),
        ));

        // Reconstruct conservative variables directly for robustness.
        block.push(dsl::let_expr(
            "grad_rho_l",
            Expr::ident("grad_rho").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_l",
            Expr::ident("grad_rho_u_x").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_l",
            Expr::ident("grad_rho_u_y").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_l",
            Expr::ident("grad_rho_e").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_r",
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_r",
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_r",
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_r",
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        ));

        let (rho_l_stmts, rho_l_face) = limited_linear_reconstruct_face(
            "rho",
            "l",
            Expr::ident("rho_l_cell"),
            Expr::ident("rho_r_cell"),
            Expr::ident("grad_rho_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_l_stmts);
        let (rho_u_x_l_stmts, rho_u_x_l_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "l",
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("grad_rho_u_x_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_x_l_stmts);
        let (rho_u_y_l_stmts, rho_u_y_l_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "l",
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("grad_rho_u_y_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_y_l_stmts);
        let (rho_e_l_stmts, rho_e_l_face) = limited_linear_reconstruct_face(
            "rho_e",
            "l",
            Expr::ident("rho_e_l_cell"),
            Expr::ident("rho_e_r_cell"),
            Expr::ident("grad_rho_e_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_e_l_stmts);

        let (rho_r_stmts, rho_r_face) = limited_linear_reconstruct_face(
            "rho",
            "r",
            Expr::ident("rho_r_cell"),
            Expr::ident("rho_l_cell"),
            Expr::ident("grad_rho_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_r_stmts);
        let (rho_u_x_r_stmts, rho_u_x_r_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "r",
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("grad_rho_u_x_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_x_r_stmts);
        let (rho_u_y_r_stmts, rho_u_y_r_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "r",
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("grad_rho_u_y_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_y_r_stmts);
        let (rho_e_r_stmts, rho_e_r_face) = limited_linear_reconstruct_face(
            "rho_e",
            "r",
            Expr::ident("rho_e_r_cell"),
            Expr::ident("rho_e_l_cell"),
            Expr::ident("grad_rho_e_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_e_r_stmts);

        block.push(dsl::assign_expr(Expr::ident("rho_l"), rho_l_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_l"),
            dsl::vec2_f32(rho_u_x_l_face, rho_u_y_l_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_l"), rho_e_l_face));
        block.push(dsl::assign_expr(Expr::ident("rho_r"), rho_r_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_r"),
            dsl::vec2_f32(rho_u_x_r_face, rho_u_y_r_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_r"), rho_e_r_face));

        dsl::block(block)
    };

    // For compressible KT fluxes, keep reconstruction conservative and stable:
    // - `scheme=0` and `scheme=2` default to piecewise-constant states.
    // - `scheme=1` enables limited linear reconstruction.
    stmts.push(dsl::if_block(
        "!is_boundary && constants.scheme == 1u",
        reconstruct_block,
        None,
    ));

    stmts.push(dsl::let_("inv_rho_l", "1.0 / max(rho_l, 1e-8)"));
    stmts.push(dsl::let_typed_expr(
        "u_l",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
            .mul_scalar(Expr::ident("inv_rho_l"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "ke_l",
        Expr::binary(
            Expr::binary(Expr::lit_f32(0.5), BinaryOp::Mul, Expr::ident("rho_l")),
            BinaryOp::Mul,
            typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))),
        ),
    ));
    stmts.push(dsl::let_(
        "p_l",
        &format!("max(0.0, ({gamma} - 1.0) * (rho_e_l - ke_l))"),
    ));
    stmts.push(dsl::let_expr(
        "u_n_l",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_("c_l", &format!("sqrt({gamma} * p_l * inv_rho_l)")));

    stmts.push(dsl::let_("inv_rho_r", "1.0 / max(rho_r, 1e-8)"));
    stmts.push(dsl::let_typed_expr(
        "u_r",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r"))
            .mul_scalar(Expr::ident("inv_rho_r"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "ke_r",
        Expr::binary(
            Expr::binary(Expr::lit_f32(0.5), BinaryOp::Mul, Expr::ident("rho_r")),
            BinaryOp::Mul,
            typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))),
        ),
    ));
    stmts.push(dsl::let_(
        "p_r",
        &format!("max(0.0, ({gamma} - 1.0) * (rho_e_r - ke_r))"),
    ));
    stmts.push(dsl::let_expr(
        "u_n_r",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_("c_r", &format!("sqrt({gamma} * p_r * inv_rho_r)")));
    stmts.push(dsl::let_typed_expr(
        "u_face",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))
            .add(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r")))
            .mul_scalar(Expr::lit_f32(0.5))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "u_face_n",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_("c_bar", "0.5 * (c_l + c_r)"));
    stmts.push(dsl::let_("mach", "abs(u_face_n) / max(c_bar, 1e-6)"));
    stmts.push(dsl::let_("mach2", "mach * mach"));
    // Low-Mach preconditioning (optional). Default is `precond_model=2` (off) for
    // rhoCentralFoam-like transient behavior (e.g., acoustics).
    stmts.push(dsl::var("c_l_eff", "c_l"));
    stmts.push(dsl::var("c_r_eff", "c_r"));
    let precond_legacy_block = dsl::block(vec![
        dsl::assign("c_l_eff", "c_l * mach"),
        dsl::assign("c_r_eff", "c_r * mach"),
    ]);
    let precond_weiss_smith_block = dsl::block(vec![
        dsl::let_(
            "theta",
            "min(1.0, max(mach2, constants.precond_theta_floor))",
        ),
        dsl::let_("one_minus_theta", "1.0 - theta"),
        dsl::assign(
            "c_l_eff",
            "sqrt(theta * c_l * c_l + one_minus_theta * u_n_l * u_n_l)",
        ),
        dsl::assign(
            "c_r_eff",
            "sqrt(theta * c_r * c_r + one_minus_theta * u_n_r * u_n_r)",
        ),
    ]);
    let precond_else_block = dsl::block(vec![dsl::if_block(
        "constants.precond_model == 1u",
        precond_weiss_smith_block,
        None,
    )]);
    stmts.push(dsl::if_block(
        "constants.precond_model == 0u",
        precond_legacy_block,
        Some(precond_else_block),
    ));
    stmts.push(dsl::let_typed_expr(
        "center_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("center_r")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "d_center",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("center_r_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("center_owner_vec")))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "dist",
        Expr::call_named(
            "max",
            vec![
                Expr::call_named("length", vec![Expr::ident("d_center")]),
                Expr::lit_f32(1e-6),
            ],
        ),
    ));
    stmts.push(dsl::let_("mu", "constants.viscosity"));

    stmts.push(dsl::let_(
        "a_plus",
        "max(0.0, max(u_n_l + c_l_eff, u_n_r + c_r_eff))",
    ));
    stmts.push(dsl::let_(
        "a_minus",
        "min(0.0, min(u_n_l - c_l_eff, u_n_r - c_r_eff))",
    ));
    stmts.push(dsl::let_("denom", "max(a_plus - a_minus, 1e-6)"));
    stmts.push(dsl::let_("a_prod", "a_plus * a_minus"));
    stmts.push(dsl::let_("a_pos", "a_plus / denom"));
    stmts.push(dsl::let_("a_neg", "1.0 - a_pos"));
    stmts.push(dsl::let_("a_prod_scaled", "a_prod / denom"));

    stmts.push(dsl::let_("flux_rho_l", "rho_l * u_n_l"));
    stmts.push(dsl::let_("flux_rho_r", "rho_r * u_n_r"));
    stmts.push(dsl::var(
        "flux_rho",
        "a_pos * flux_rho_l + a_neg * flux_rho_r + a_prod_scaled * (rho_r - rho_l)",
    ));
    stmts.push(dsl::let_typed_expr(
        "flux_rho_u_l",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
            .mul_scalar(Expr::ident("u_n_l"))
            .add(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).mul_scalar(Expr::ident("p_l")))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "flux_rho_u_r",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r"))
            .mul_scalar(Expr::ident("u_n_r"))
            .add(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")).mul_scalar(Expr::ident("p_r")))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "rho_u_jump",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l")))
            .expr(),
    ));
    stmts.push(dsl::var_typed_expr(
        "flux_rho_u",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u_l"))
                .mul_scalar(Expr::ident("a_pos"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u_r"))
                        .mul_scalar(Expr::ident("a_neg")),
                )
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_jump"))
                        .mul_scalar(Expr::ident("a_prod_scaled")),
                )
                .expr(),
        ),
    ));
    stmts.push(dsl::let_expr(
        "visc_scale",
        Expr::binary(
            Expr::binary(Expr::lit_f32(-1.0), BinaryOp::Mul, Expr::ident("mu")),
            BinaryOp::Div,
            Expr::ident("dist"),
        ),
    ));
    stmts.push(dsl::let_typed_expr(
        "diff_u",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l")))
            .mul_scalar(Expr::ident("visc_scale"))
            .expr(),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("flux_rho_u"),
        typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u"))
            .add(&typed::VecExpr::<2>::from_expr(Expr::ident("diff_u")))
            .expr(),
    ));

    stmts.push(dsl::let_(
        "flux_rho_e_l",
        "(rho_e_l + p_l) * u_n_l",
    ));
    stmts.push(dsl::let_(
        "flux_rho_e_r",
        "(rho_e_r + p_r) * u_n_r",
    ));
    stmts.push(dsl::var(
        "flux_rho_e",
        "a_pos * flux_rho_e_l + a_neg * flux_rho_e_r + a_prod_scaled * (rho_e_r - rho_e_l)",
    ));
    stmts.push(dsl::let_("inv_rho_l_cell", "1.0 / max(rho_l_cell, 1e-8)"));
    stmts.push(dsl::let_("inv_rho_r_cell", "1.0 / max(rho_r_cell, 1e-8)"));
    stmts.push(dsl::let_typed_expr(
        "u_l_cell",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l_cell"))
            .mul_scalar(Expr::ident("inv_rho_l_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "u_r_cell",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r_cell"))
            .mul_scalar(Expr::ident("inv_rho_r_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "u2_l_cell",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))),
    ));
    stmts.push(dsl::let_expr(
        "u2_r_cell",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_rho_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho").index(Expr::ident("owner")))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_x_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_x").index(Expr::ident("owner")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_y_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_y").index(Expr::ident("owner")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_e_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho_e").index(Expr::ident("owner")))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_x_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_y_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_e_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_u_x_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_l_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                    .mul_scalar(Expr::ident("u_l_cell").field("x")),
            )
            .mul_scalar(Expr::ident("inv_rho_l_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u_y_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_l_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                    .mul_scalar(Expr::ident("u_l_cell").field("y")),
            )
            .mul_scalar(Expr::ident("inv_rho_l_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u_x_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_r_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                    .mul_scalar(Expr::ident("u_r_cell").field("x")),
            )
            .mul_scalar(Expr::ident("inv_rho_r_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u_y_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_r_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                    .mul_scalar(Expr::ident("u_r_cell").field("y")),
            )
            .mul_scalar(Expr::ident("inv_rho_r_cell"))
            .expr(),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_u2_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_l_vec"))
            .mul_scalar(Expr::binary(
                Expr::lit_f32(2.0),
                BinaryOp::Mul,
                Expr::ident("u_l_cell").field("x"),
            ))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_l_vec")).mul_scalar(
                    Expr::binary(
                        Expr::lit_f32(2.0),
                        BinaryOp::Mul,
                        Expr::ident("u_l_cell").field("y"),
                    ),
                ),
            )
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u2_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_r_vec"))
            .mul_scalar(Expr::binary(
                Expr::lit_f32(2.0),
                BinaryOp::Mul,
                Expr::ident("u_r_cell").field("x"),
            ))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_r_vec")).mul_scalar(
                    Expr::binary(
                        Expr::lit_f32(2.0),
                        BinaryOp::Mul,
                        Expr::ident("u_r_cell").field("y"),
                    ),
                ),
            )
            .expr(),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_rho_u2_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
            .mul_scalar(Expr::ident("u2_l_cell"))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_l_vec"))
                    .mul_scalar(Expr::ident("rho_l_cell")),
            )
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u2_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
            .mul_scalar(Expr::ident("u2_r_cell"))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_r_vec"))
                    .mul_scalar(Expr::ident("rho_r_cell")),
            )
            .expr(),
    ));

    stmts.push(dsl::let_("gamma_minus_1", &format!("({gamma} - 1.0)")));
    stmts.push(dsl::let_typed_expr(
        "grad_p_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_l_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_l_vec"))
                    .mul_scalar(Expr::lit_f32(0.5)),
            )
            .mul_scalar(Expr::ident("gamma_minus_1"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_p_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_r_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_r_vec"))
                    .mul_scalar(Expr::lit_f32(0.5)),
            )
            .mul_scalar(Expr::ident("gamma_minus_1"))
            .expr(),
    ));

    stmts.push(dsl::let_expr(
        "grad_p_l_n",
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_l_vec"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_expr(
        "grad_p_r_n",
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_r_vec"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_("grad_p_face_n", "0.5 * (grad_p_l_n + grad_p_r_n)"));
    stmts.push(dsl::let_("grad_p_jump_n", "(p_r - p_l) / dist"));
    stmts.push(dsl::let_("rho_face", "0.5 * (rho_l + rho_r)"));
    stmts.push(dsl::let_("p_bar", "0.5 * (p_l + p_r)"));
    stmts.push(dsl::let_("dp_rel", "abs(p_r - p_l) / max(p_bar, 1e-6)"));
    // Rhieâ€“Chow-style pressure flux coupling is only used with low-Mach preconditioning.
    // (In the pure KT mode it can introduce dispersive/odd-even pressure ringing.)
    let pressure_coupling_block = dsl::block(vec![
        dsl::let_(
            "pc_theta",
            "min(1.0, max(mach2, constants.precond_theta_floor))",
        ),
        dsl::let_("pc_low_mach", "1.0 - pc_theta"),
        dsl::let_(
            "pc_smooth",
            "1.0 / (1.0 + (dp_rel / 0.2) * (dp_rel / 0.2))",
        ),
        dsl::let_(
            "pc_alpha",
            "constants.pressure_coupling_alpha * pc_low_mach * pc_smooth",
        ),
        dsl::let_(
            "m_corr",
            "pc_alpha * constants.dt / max(rho_face, 1e-8) * (grad_p_face_n - grad_p_jump_n)",
        ),
        dsl::let_("h_l", "(rho_e_l + p_l) * inv_rho_l"),
        dsl::let_("h_r", "(rho_e_r + p_r) * inv_rho_r"),
        dsl::let_("h_face", "0.5 * (h_l + h_r)"),
        dsl::assign("flux_rho", "flux_rho + m_corr"),
        dsl::assign_expr(
            Expr::ident("flux_rho_u"),
            typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u"))
                .add(&typed::VecExpr::<2>::from_expr(Expr::ident("u_face")).mul_scalar(Expr::ident("m_corr")))
                .expr(),
        ),
        dsl::assign("flux_rho_e", "flux_rho_e + m_corr * h_face"),
    ]);
    stmts.push(dsl::if_block(
        "!is_boundary && constants.precond_model != 2u && constants.pressure_coupling_alpha > 0.0",
        pressure_coupling_block,
        None,
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("flux_rho_e"),
        Expr::binary(
            Expr::ident("flux_rho_e"),
            BinaryOp::Add,
            typed::VecExpr::<2>::from_expr(Expr::ident("diff_u"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))),
        ),
    ));

    stmts.push(dsl::let_("base", &format!("idx * {}u", flux_stride)));
    stmts.push(dsl::assign("fluxes[base + 0u]", "flux_rho * area"));
    stmts.push(dsl::assign("fluxes[base + 1u]", "flux_rho_u.x * area"));
    stmts.push(dsl::assign("fluxes[base + 2u]", "flux_rho_u.y * area"));
    stmts.push(dsl::assign("fluxes[base + 3u]", "flux_rho_e * area"));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_flux_kt_codegen_emits_state_arrays() {
        let model = compressible_model();
        let fields = model.fields.compressible().expect("compressible fields");
        let wgsl = generate_compressible_flux_kt_wgsl(&model.state_layout, fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("face_owner"));
        assert!(wgsl.contains("fluxes"));
        assert!(wgsl.contains("a_plus"));
        assert!(wgsl.contains("flux_rho_e"));
        assert!(wgsl.contains("constants.viscosity"));
        assert!(wgsl.contains("diff_u"));
    }
}
