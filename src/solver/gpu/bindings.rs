// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: 933c9465ad8ca332bb64dd3eaf2ccca867d6573aeaa651c32b479213a4c8c8c2

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    AmgPack,
    BlockPrecond,
    DotProduct,
    DotProductPair,
    GeneratedDpInitIncompressibleMomentum,
    GeneratedDpUpdateFromDiagIncompressibleMomentum,
    GeneratedFluxModuleCompressible,
    GeneratedFluxModuleGradientsIncompressibleMomentum,
    GeneratedFluxModuleIncompressibleMomentum,
    GeneratedGenericCoupledApply,
    GeneratedGenericCoupledAssemblyCompressible,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateCompressible,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum,
    GeneratedGenericCoupledAssemblyIncompressibleMomentum,
    GeneratedGenericCoupledUpdateCompressible,
    GeneratedGenericCoupledUpdateGenericDiffusionDemo,
    GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledUpdateIncompressibleMomentum,
    GeneratedPackedStateGradientsCompressible,
    GeneratedPackedStateGradientsGenericDiffusionDemo,
    GeneratedPackedStateGradientsGenericDiffusionDemoNeumann,
    GeneratedPackedStateGradientsIncompressibleMomentum,
    GeneratedRhieChowCorrectVelocityIncompressibleMomentum,
    GenericCoupledSchurSetup,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    OuterConvergence,
    Scalars,
    SchurPrecond,
    SchurPrecondGeneric,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self { Self :: Amg => amg :: create_pipeline_layout (device) , Self :: AmgPack => amg_pack :: create_pipeline_layout (device) , Self :: BlockPrecond => block_precond :: create_pipeline_layout (device) , Self :: DotProduct => dot_product :: create_pipeline_layout (device) , Self :: DotProductPair => dot_product_pair :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentum => generated :: dp_init_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => generated :: dp_update_from_diag_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleCompressible => generated :: flux_module_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => generated :: flux_module_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentum => generated :: flux_module_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledApply => generated :: generic_coupled_apply :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyCompressible => generated :: generic_coupled_assembly_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => generated :: generic_coupled_assembly_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => generated :: generic_coupled_assembly_grad_state_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => generated :: generic_coupled_assembly_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateCompressible => generated :: generic_coupled_update_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => generated :: generic_coupled_update_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => generated :: generic_coupled_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsCompressible => generated :: packed_state_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => generated :: packed_state_gradients_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => generated :: packed_state_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentum => generated :: rhie_chow_correct_velocity_incompressible_momentum :: create_pipeline_layout (device) , Self :: GenericCoupledSchurSetup => generic_coupled_schur_setup :: create_pipeline_layout (device) , Self :: GmresCgs => gmres_cgs :: create_pipeline_layout (device) , Self :: GmresLogic => gmres_logic :: create_pipeline_layout (device) , Self :: GmresOps => gmres_ops :: create_pipeline_layout (device) , Self :: LinearSolver => linear_solver :: create_pipeline_layout (device) , Self :: OuterConvergence => outer_convergence :: create_pipeline_layout (device) , Self :: Scalars => scalars :: create_pipeline_layout (device) , Self :: SchurPrecond => schur_precond :: create_pipeline_layout (device) , Self :: SchurPrecondGeneric => schur_precond_generic :: create_pipeline_layout (device) , }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self { Self :: Amg => { amg :: create_shader_module_embed_source (device) } , Self :: AmgPack => { amg_pack :: create_shader_module_embed_source (device) } , Self :: BlockPrecond => { block_precond :: create_shader_module_embed_source (device) } , Self :: DotProduct => { dot_product :: create_shader_module_embed_source (device) } , Self :: DotProductPair => { dot_product_pair :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentum => { generated :: dp_init_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => { generated :: dp_update_from_diag_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleCompressible => { generated :: flux_module_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => { generated :: flux_module_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentum => { generated :: flux_module_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledApply => { generated :: generic_coupled_apply :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyCompressible => { generated :: generic_coupled_assembly_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => { generated :: generic_coupled_assembly_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => { generated :: generic_coupled_assembly_grad_state_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => { generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => { generated :: generic_coupled_assembly_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateCompressible => { generated :: generic_coupled_update_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => { generated :: generic_coupled_update_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => { generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => { generated :: generic_coupled_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsCompressible => { generated :: packed_state_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => { generated :: packed_state_gradients_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => { generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => { generated :: packed_state_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentum => { generated :: rhie_chow_correct_velocity_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GenericCoupledSchurSetup => { generic_coupled_schur_setup :: create_shader_module_embed_source (device) } , Self :: GmresCgs => { gmres_cgs :: create_shader_module_embed_source (device) } , Self :: GmresLogic => { gmres_logic :: create_shader_module_embed_source (device) } , Self :: GmresOps => { gmres_ops :: create_shader_module_embed_source (device) } , Self :: LinearSolver => { linear_solver :: create_shader_module_embed_source (device) } , Self :: OuterConvergence => { outer_convergence :: create_shader_module_embed_source (device) } , Self :: Scalars => { scalars :: create_shader_module_embed_source (device) } , Self :: SchurPrecond => { schur_precond :: create_shader_module_embed_source (device) } , Self :: SchurPrecondGeneric => { schur_precond_generic :: create_shader_module_embed_source (device) } , }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const AMG_PACK_PACK_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg_pack::PackParams, num_cells) == 0);
        assert!(std::mem::offset_of!(amg_pack::PackParams, component) == 4);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad1) == 8);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad2) == 12);
        assert!(std::mem::size_of::<amg_pack::PackParams>() == 16);
    };
    const BLOCK_PRECOND_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(block_precond::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(block_precond::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<block_precond::GmresParams>() == 32);
    };
    const BLOCK_PRECOND_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(block_precond::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<block_precond::IterParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 16);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 16);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dtau) == 8
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, time) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(std::mem::size_of::<generated::dp_init_incompressible_momentum::Constants>() == 48);
    };
    const GENERATED_DP_UPDATE_FROM_DIAG_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::dp_update_from_diag_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_module_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_p) == 28
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gamma) == 48
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gm1) == 52
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_p_offset)
                == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::Constants>() == 72);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_LOW_MACH_PARAMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, model) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                theta_floor
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                pressure_coupling_alpha
            ) == 8
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, _pad0) == 12
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::LowMachParams>() == 16);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Vector2>() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_APPLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, time_scheme) == 44
        );
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gamma) == 48);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gm1) == 52);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_p_offset) == 64
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_theta_ref) == 68
        );
        assert!(std::mem::size_of::<generated::generic_coupled_apply::Constants>() == 72);
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Vector2>() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Constants>()
                == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_grad_state_compressible::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , x) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , y) == 4) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 > () == 8) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_compressible::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Vector2>() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Constants>() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_RHIE_CHOW_CORRECT_VELOCITY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERIC_COUPLED_SCHUR_SETUP_SETUP_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, num_cells) == 0);
        assert!(
            std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, unknowns_per_cell) == 4
        );
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, p) == 8);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u_len) == 12);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u0123) == 16);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u4567) == 32);
        assert!(std::mem::size_of::<generic_coupled_schur_setup::SetupParams>() == 48);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 24);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const OUTER_CONVERGENCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::Params, num_cells) == 0);
        assert!(std::mem::offset_of!(outer_convergence::Params, stride) == 4);
        assert!(std::mem::offset_of!(outer_convergence::Params, num_targets) == 8);
        assert!(std::mem::offset_of!(outer_convergence::Params, _pad0) == 12);
        assert!(std::mem::size_of::<outer_convergence::Params>() == 16);
    };
    const OUTER_CONVERGENCE_TARGET_DESC_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, offsets) == 0);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, num_comps) == 16);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, _pad0) == 20);
        assert!(std::mem::size_of::<outer_convergence::TargetDesc>() == 32);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 24);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, unknowns_per_cell) == 12);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u0) == 16);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u1) == 20);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, p) == 24);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, _pad0) == 28);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 32);
    };
    const SCHUR_PRECOND_GENERIC_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, omega) == 8);
        assert!(
            std::mem::offset_of!(schur_precond_generic::PrecondParams, unknowns_per_cell) == 12
        );
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, p) == 16);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u_len) == 20);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad0) == 24);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad1) == 28);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u0123) == 32);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u4567) == 48);
        assert!(std::mem::size_of::<schur_precond_generic::PrecondParams>() == 64);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.coarse_vec]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let stride_x = (num_workgroups.x * 64u);
    let i = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.n;
    if (i >= _e13) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e24 = k;
        if (_e24 < end) {
        } else {
            break;
        }
        {
            let _e27 = k;
            let col = col_indices[_e27];
            let _e31 = k;
            let val = values[_e31];
            if (col == i) {
                diag = val;
            } else {
                let _e39 = x[col];
                let _e41 = sigma;
                sigma = (_e41 + (val * _e39));
            }
        }
        continuing {
            let _e44 = k;
            k = (_e44 + 1u);
        }
    }
    let _e46 = diag;
    if (abs(_e46) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e53 = b[i];
    let _e54 = sigma;
    let _e56 = diag;
    let x_new = ((_e53 - _e54) / _e56);
    let _e62 = x[i];
    let _e65 = params.omega;
    x[i] = mix(_e62, x_new, _e65);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let i_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.n;
    if (i_1 >= _e12) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e23 = k_1;
        if (_e23 < end_1) {
        } else {
            break;
        }
        {
            let _e26 = k_1;
            let coarse_idx = op_col_indices[_e26];
            let _e30 = k_1;
            let val_1 = op_values[_e30];
            let _e36 = coarse_vec[coarse_idx];
            let _e38 = correction;
            correction = (_e38 + (val_1 * _e36));
        }
        continuing {
            let _e41 = k_1;
            k_1 = (_e41 + 1u);
        }
    }
    let _e45 = correction;
    let _e46 = x[i_1];
    x[i_1] = (_e46 + _e45);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let stride_x_2 = (num_workgroups_2.x * 64u);
    let i_2 = ((global_id_2.y * stride_x_2) + global_id_2.x);
    let _e12 = params.n;
    if (i_2 >= _e12) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e23 = k_2;
        if (_e23 < end_2) {
        } else {
            break;
        }
        {
            let _e26 = k_2;
            let fine_idx = op_col_indices[_e26];
            let _e30 = k_2;
            let r_val = op_values[_e30];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e44 = j;
                if (_e44 < a_end) {
                } else {
                    break;
                }
                {
                    let _e47 = j;
                    let _e49 = values[_e47];
                    let _e52 = j;
                    let _e54 = col_indices[_e52];
                    let _e56 = x[_e54];
                    let _e58 = ax;
                    ax = (_e58 + (_e49 * _e56));
                }
                continuing {
                    let _e61 = j;
                    j = (_e61 + 1u);
                }
            }
            let _e65 = b[fine_idx];
            let _e66 = ax;
            let fine_r = (_e65 - _e66);
            let _e70 = sum;
            sum = (_e70 + (r_val * fine_r));
        }
        continuing {
            let _e73 = k_2;
            k_2 = (_e73 + 1u);
        }
    }
    let _e77 = sum;
    coarse_vec[i_2] = _e77;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let stride_x_3 = (num_workgroups_3.x * 64u);
    let i_3 = ((global_id_3.y * stride_x_3) + global_id_3.x);
    let _e11 = params.n;
    if (i_3 >= _e11) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for amg_pack::PackParams {}
    unsafe impl bytemuck::Pod for amg_pack::PackParams {}
    unsafe impl bytemuck::Zeroable for block_precond::GmresParams {}
    unsafe impl bytemuck::Pod for block_precond::GmresParams {}
    unsafe impl bytemuck::Zeroable for block_precond::IterParams {}
    unsafe impl bytemuck::Pod for block_precond::IterParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::dp_update_from_diag_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::dp_update_from_diag_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_grad_state_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_correct_velocity_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_correct_velocity_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Pod for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for outer_convergence::Params {}
    unsafe impl bytemuck::Pod for outer_convergence::Params {}
    unsafe impl bytemuck::Zeroable for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Pod for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Zeroable for schur_precond_generic::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond_generic::PrecondParams {}
}
pub mod amg_pack {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PackParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub component: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PackParams {
        pub const fn new(num_cells: u32, component: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                num_cells,
                component,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const PACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_pack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline pack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("pack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UNPACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_unpack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline unpack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("unpack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_PACK_COMPONENT: &str = "pack_component";
    pub const ENTRY_UNPACK_COMPONENT: &str = "unpack_component";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input_buf: wgpu::BufferBinding<'a>,
        pub output_buf: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input_buf: wgpu::BindGroupEntry<'a>,
        pub output_buf: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input_buf: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input_buf),
                },
                output_buf: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.output_buf),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.input_buf, self.output_buf]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"output_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg_pack::PackParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AmgPack::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg_pack.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PackParams {
    num_cells: u32,
    component: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> input_buf: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> output_buf: array<f32>;
@group(1) @binding(0) 
var<uniform> params: PackParams;

@compute @workgroup_size(64, 1, 1) 
fn pack_component(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let _e11 = params.num_cells;
    if (idx >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base = ((idx * 4u) + _e17);
    let _e23 = input_buf[base];
    output_buf[idx] = _e23;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn unpack_component(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let stride_x_1 = (num_workgroups_1.x * 64u);
    let idx_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e11 = params.num_cells;
    if (idx_1 >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base_1 = ((idx_1 * 4u) + _e17);
    let _e23 = input_buf[idx_1];
    output_buf[base_1] = _e23;
    return;
}
"#;
}
pub mod block_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const MAX_BLOCK: u32 = 16u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_BLOCK_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_block_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_block_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_block_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_BLOCK_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_block_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_block_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_block_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_BLOCK_INV: &str = "build_block_inv";
    pub const ENTRY_APPLY_BLOCK_PRECOND: &str = "apply_block_precond";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.block_inv]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("BlockPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("block_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const MAX_BLOCK: u32 = 16u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

fn swap_rows(a_1: ptr<function, array<array<f32, 16>, 16>>, b: ptr<function, array<array<f32, 16>, 16>>, r0_: u32, r1_: u32, n: u32) {
    var c_6: u32 = 0u;

    if (r0_ == r1_) {
        return;
    }
    loop {
        let _e6 = c_6;
        if (_e6 < n) {
        } else {
            break;
        }
        {
            let _e10 = c_6;
            let tmp = (*a_1)[r0_][_e10];
            let _e14 = c_6;
            let _e17 = c_6;
            let _e19 = (*a_1)[r1_][_e17];
            (*a_1)[r0_][_e14] = _e19;
            let _e21 = c_6;
            (*a_1)[r1_][_e21] = tmp;
            let _e25 = c_6;
            let tmp_b = (*b)[r0_][_e25];
            let _e29 = c_6;
            let _e32 = c_6;
            let _e34 = (*b)[r1_][_e32];
            (*b)[r0_][_e29] = _e34;
            let _e36 = c_6;
            (*b)[r1_][_e36] = tmp_b;
        }
        continuing {
            let _e38 = c_6;
            c_6 = (_e38 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn build_block_inv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var a: array<array<f32, 16>, 16>;
    var inv: array<array<f32, 16>, 16>;
    var diag_orig: array<f32, 16>;
    var r: u32 = 0u;
    var c: u32;
    var k: u32;
    var singular: bool = false;
    var i: u32 = 0u;
    var pivot: u32;
    var pivot_val: f32;
    var r_1: u32;
    var piv: f32;
    var c_1: u32;
    var r_2: u32;
    var c_2: u32;
    var r_3: u32 = 0u;
    var c_3: u32;
    var r_4: u32 = 0u;
    var c_4: u32;

    let stride_x = (num_workgroups.x * 64u);
    let cell = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.num_cells;
    if (cell >= _e13) {
        return;
    }
    let _e17 = params.num_cells;
    if (_e17 == 0u) {
        return;
    }
    let _e22 = params.n;
    let _e25 = params.num_cells;
    let b_1 = (_e22 / _e25);
    if ((b_1 == 0u) || (b_1 > MAX_BLOCK)) {
        return;
    }
    let base = (cell * b_1);
    loop {
        let _e34 = r;
        if (_e34 < b_1) {
        } else {
            break;
        }
        {
            c = 0u;
            loop {
                let _e38 = c;
                if (_e38 < b_1) {
                } else {
                    break;
                }
                {
                    let _e41 = r;
                    let _e43 = c;
                    a[_e41][_e43] = 0f;
                    let _e47 = r;
                    let _e49 = c;
                    inv[_e47][_e49] = 0f;
                }
                continuing {
                    let _e52 = c;
                    c = (_e52 + 1u);
                }
            }
            let _e55 = r;
            let row = (base + _e55);
            let start = row_offsets[row];
            let end = row_offsets[(row + 1u)];
            k = start;
            loop {
                let _e66 = k;
                if (_e66 < end) {
                } else {
                    break;
                }
                {
                    let _e69 = k;
                    let col = col_indices[_e69];
                    if ((col >= base) && (col < (base + b_1))) {
                        let local = (col - base);
                        let _e77 = r;
                        let _e81 = k;
                        let _e83 = matrix_values[_e81];
                        a[_e77][local] = _e83;
                    }
                }
                continuing {
                    let _e84 = k;
                    k = (_e84 + 1u);
                }
            }
            let _e87 = r;
            let _e89 = r;
            inv[_e87][_e89] = 1f;
            let _e93 = r;
            let _e95 = r;
            let _e97 = r;
            let _e99 = a[_e95][_e97];
            diag_orig[_e93] = _e99;
        }
        continuing {
            let _e100 = r;
            r = (_e100 + 1u);
        }
    }
    loop {
        let _e104 = i;
        if (_e104 < b_1) {
        } else {
            break;
        }
        {
            let _e106 = i;
            pivot = _e106;
            let _e108 = i;
            let _e110 = i;
            let _e112 = a[_e108][_e110];
            pivot_val = abs(_e112);
            let _e115 = i;
            r_1 = (_e115 + 1u);
            loop {
                let _e119 = r_1;
                if (_e119 < b_1) {
                } else {
                    break;
                }
                {
                    let _e121 = r_1;
                    let _e123 = i;
                    let _e125 = a[_e121][_e123];
                    let val_1 = abs(_e125);
                    let _e127 = pivot_val;
                    if (val_1 > _e127) {
                        pivot_val = val_1;
                        let _e129 = r_1;
                        pivot = _e129;
                    }
                }
                continuing {
                    let _e130 = r_1;
                    r_1 = (_e130 + 1u);
                }
            }
            let _e133 = pivot_val;
            if (_e133 < 0.000000000001f) {
                singular = true;
            }
            let _e138 = i;
            let _e139 = pivot;
            swap_rows((&a), (&inv), _e138, _e139, b_1);
            let _e140 = i;
            let _e142 = i;
            let _e144 = a[_e140][_e142];
            piv = _e144;
            let _e146 = piv;
            if (abs(_e146) < 0.000000000001f) {
                let _e150 = piv;
                piv = select(0.000000000001f, -0.000000000001f, (_e150 < 0f));
            }
            let _e156 = piv;
            let inv_piv = (1f / _e156);
            c_1 = 0u;
            loop {
                let _e161 = c_1;
                if (_e161 < b_1) {
                } else {
                    break;
                }
                {
                    let _e163 = i;
                    let _e165 = c_1;
                    let _e167 = i;
                    let _e169 = c_1;
                    let _e171 = a[_e167][_e169];
                    a[_e163][_e165] = (_e171 * inv_piv);
                    let _e173 = i;
                    let _e175 = c_1;
                    let _e177 = i;
                    let _e179 = c_1;
                    let _e181 = inv[_e177][_e179];
                    inv[_e173][_e175] = (_e181 * inv_piv);
                }
                continuing {
                    let _e183 = c_1;
                    c_1 = (_e183 + 1u);
                }
            }
            r_2 = 0u;
            loop {
                let _e188 = r_2;
                if (_e188 < b_1) {
                } else {
                    break;
                }
                {
                    let _e190 = r_2;
                    let _e191 = i;
                    if (_e190 == _e191) {
                        continue;
                    }
                    let _e193 = r_2;
                    let _e195 = i;
                    let factor = a[_e193][_e195];
                    c_2 = 0u;
                    loop {
                        let _e200 = c_2;
                        if (_e200 < b_1) {
                        } else {
                            break;
                        }
                        {
                            let _e202 = r_2;
                            let _e204 = c_2;
                            let _e206 = r_2;
                            let _e208 = c_2;
                            let _e210 = a[_e206][_e208];
                            let _e211 = i;
                            let _e213 = c_2;
                            let _e215 = a[_e211][_e213];
                            a[_e202][_e204] = (_e210 - (factor * _e215));
                            let _e218 = r_2;
                            let _e220 = c_2;
                            let _e222 = r_2;
                            let _e224 = c_2;
                            let _e226 = inv[_e222][_e224];
                            let _e227 = i;
                            let _e229 = c_2;
                            let _e231 = inv[_e227][_e229];
                            inv[_e218][_e220] = (_e226 - (factor * _e231));
                        }
                        continuing {
                            let _e234 = c_2;
                            c_2 = (_e234 + 1u);
                        }
                    }
                }
                continuing {
                    let _e237 = r_2;
                    r_2 = (_e237 + 1u);
                }
            }
        }
        continuing {
            let _e240 = i;
            i = (_e240 + 1u);
        }
    }
    let _e243 = singular;
    if _e243 {
        loop {
            let _e245 = r_3;
            if (_e245 < b_1) {
            } else {
                break;
            }
            {
                c_3 = 0u;
                loop {
                    let _e249 = c_3;
                    if (_e249 < b_1) {
                    } else {
                        break;
                    }
                    {
                        let _e251 = r_3;
                        let _e253 = c_3;
                        inv[_e251][_e253] = 0f;
                    }
                    continuing {
                        let _e256 = c_3;
                        c_3 = (_e256 + 1u);
                    }
                }
                let _e259 = r_3;
                let _e261 = r_3;
                let _e263 = r_3;
                let _e265 = diag_orig[_e263];
                let _e266 = safe_inverse(_e265);
                inv[_e259][_e261] = _e266;
            }
            continuing {
                let _e267 = r_3;
                r_3 = (_e267 + 1u);
            }
        }
    }
    let offset = (cell * (b_1 * b_1));
    loop {
        let _e273 = r_4;
        if (_e273 < b_1) {
        } else {
            break;
        }
        {
            c_4 = 0u;
            loop {
                let _e277 = c_4;
                if (_e277 < b_1) {
                } else {
                    break;
                }
                {
                    let _e280 = r_4;
                    let _e283 = c_4;
                    let _e286 = r_4;
                    let _e288 = c_4;
                    let _e290 = inv[_e286][_e288];
                    block_inv[((offset + (_e280 * b_1)) + _e283)] = _e290;
                }
                continuing {
                    let _e291 = c_4;
                    c_4 = (_e291 + 1u);
                }
            }
        }
        continuing {
            let _e294 = r_4;
            r_4 = (_e294 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_block_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var r_5: u32 = 0u;
    var sum: f32;
    var c_5: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let cell_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.num_cells;
    if (cell_1 >= _e12) {
        return;
    }
    let _e16 = params.num_cells;
    if (_e16 == 0u) {
        return;
    }
    let _e21 = params.n;
    let _e24 = params.num_cells;
    let b_2 = (_e21 / _e24);
    if ((b_2 == 0u) || (b_2 > MAX_BLOCK)) {
        return;
    }
    let base_1 = (cell_1 * b_2);
    let offset_1 = (cell_1 * (b_2 * b_2));
    loop {
        let _e35 = r_5;
        if (_e35 < b_2) {
        } else {
            break;
        }
        {
            sum = 0f;
            c_5 = 0u;
            loop {
                let _e41 = c_5;
                if (_e41 < b_2) {
                } else {
                    break;
                }
                {
                    let _e44 = r_5;
                    let _e47 = c_5;
                    let _e50 = block_inv[((offset_1 + (_e44 * b_2)) + _e47)];
                    let _e52 = c_5;
                    let _e55 = vec_x[(base_1 + _e52)];
                    let _e57 = sum;
                    sum = (_e57 + (_e50 * _e55));
                }
                continuing {
                    let _e59 = c_5;
                    c_5 = (_e59 + 1u);
                }
            }
            let _e63 = r_5;
            let _e66 = sum;
            vec_y[(base_1 + _e63)] = _e66;
        }
        continuing {
            let _e67 = r_5;
            r_5 = (_e67 + 1u);
        }
    }
    return;
}
"#;
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a[idx];
        let _e22 = dot_b[idx];
        val = (_e19 * _e22);
    }
    let _e27 = val;
    scratch[lid] = _e27;
    workgroupBarrier();
    loop {
        let _e29 = i;
        if (_e29 > 0u) {
        } else {
            break;
        }
        {
            let _e32 = i;
            if (lid < _e32) {
                let _e37 = i;
                let _e40 = scratch[(lid + _e37)];
                let _e41 = scratch[lid];
                scratch[lid] = (_e41 + _e40);
            }
            workgroupBarrier();
        }
        continuing {
            let _e44 = i;
            i = (_e44 >> 1u);
        }
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e56 = params.num_groups;
        if (group_flat < _e56) {
            let _e62 = scratch[0];
            dot_result[group_flat] = _e62;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a0_[idx];
        let _e22 = dot_b0_[idx];
        val0_ = (_e19 * _e22);
        let _e27 = dot_a1_[idx];
        let _e30 = dot_b1_[idx];
        val1_ = (_e27 * _e30);
    }
    let _e35 = val0_;
    scratch_a[lid] = _e35;
    let _e38 = val1_;
    scratch_b[lid] = _e38;
    workgroupBarrier();
    loop {
        let _e40 = offset;
        if (lid < _e40) {
            let _e45 = offset;
            let _e48 = scratch_a[(lid + _e45)];
            let _e49 = scratch_a[lid];
            scratch_a[lid] = (_e49 + _e48);
            let _e54 = offset;
            let _e57 = scratch_b[(lid + _e54)];
            let _e58 = scratch_b[lid];
            scratch_b[lid] = (_e58 + _e57);
        }
        workgroupBarrier();
        let _e60 = offset;
        if (_e60 == 1u) {
            break;
        }
        let _e63 = offset;
        offset = (_e63 >> 1u);
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e76 = params.num_groups;
        if (group_flat < _e76) {
            let _e82 = scratch_a[0];
            dot_result_a[group_flat] = _e82;
            let _e87 = scratch_b[0];
            dot_result_b[group_flat] = _e87;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod dp_init_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedDpInitIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::dp_init_incompressible_momentum::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = cell_vols[idx];
    let vol = max(_e25, 0.000000000001f);
    let d_p = (dt / (rho * vol));
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const UNKNOWNS_PER_CELL: u32 = 3u32;
        pub const U_LEN: u32 = 2u32;
        pub const U_0: u32 = 0u32;
        pub const U_1: u32 = 1u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: dp_update_from_diag_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;
const UNKNOWNS_PER_CELL: u32 = 3u;
const U_LEN: u32 = 2u;
const U_0_: u32 = 0u;
const U_1_: u32 = 1u;

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum_u_inv: f32 = 0f;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let scalar_offset = scalar_row_offsets[idx];
    let scalar_end = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[idx];
    let diag_rank = (_e25 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let row_stride = (num_neighbors * UNKNOWNS_PER_CELL);
    {
        let start_row_u = (start_row_0_ + (U_0_ * row_stride));
        let diag_u = matrix_values[((start_row_u + (diag_rank * UNKNOWNS_PER_CELL)) + U_0_)];
        let _e41 = safe_inverse(diag_u);
        let _e43 = sum_u_inv;
        sum_u_inv = (_e43 + _e41);
    }
    {
        let start_row_u_1 = (start_row_0_ + (U_1_ * row_stride));
        let diag_u_1 = matrix_values[((start_row_u_1 + (diag_rank * UNKNOWNS_PER_CELL)) + U_1_)];
        let _e55 = safe_inverse(diag_u_1);
        let _e56 = sum_u_inv;
        sum_u_inv = (_e56 + _e55);
    }
    let _e58 = sum_u_inv;
    let d_p = (_e58 / 2f);
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod flux_module_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct LowMachParams {
            #[doc = "offset: 0, size: 4, type: `u32`"]
            pub model: u32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub theta_floor: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub pressure_coupling_alpha: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub _pad0: f32,
        }
        impl LowMachParams {
            pub const fn new(
                model: u32,
                theta_floor: f32,
                pressure_coupling_alpha: f32,
                _pad0: f32,
            ) -> Self {
                Self {
                    model,
                    theta_floor,
                    pressure_coupling_alpha,
                    _pad0,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub low_mach_params: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub low_mach_params: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    low_mach_params: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.low_mach_params),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.low_mach_params,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"low_mach_params\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::LowMachParams,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0_: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var a_plus: f32;
    var a_minus: f32;
    var u_l_0_: f32;
    var u_r_0_: f32;
    var f_l_0_: f32;
    var f_r_0_: f32;
    var u_l_1_: f32;
    var u_r_1_: f32;
    var f_l_1_: f32;
    var f_r_1_: f32;
    var u_l_2_: f32;
    var u_r_2_: f32;
    var f_l_2_: f32;
    var f_r_2_: f32;
    var u_l_3_: f32;
    var u_r_3_: f32;
    var f_l_3_: f32;
    var f_r_3_: f32;
    var u_l_4_: f32 = 0f;
    var u_r_4_: f32 = 0f;
    var f_l_4_: f32 = 0f;
    var f_r_4_: f32 = 0f;
    var u_l_5_: f32 = 0f;
    var u_r_5_: f32 = 0f;
    var f_l_5_: f32 = 0f;
    var f_r_5_: f32 = 0f;
    var u_l_6_: f32 = 0f;
    var u_r_6_: f32 = 0f;
    var f_l_6_: f32 = 0f;
    var f_r_6_: f32 = 0f;
    var u_l_7_: f32 = 0f;
    var u_r_7_: f32 = 0f;
    var f_l_7_: f32 = 0f;
    var f_r_7_: f32 = 0f;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e37 = face_normals[idx].x;
    let _e41 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e37, _e41);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e54 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e54) < 0f) {
        let _e58 = normal_vec;
        normal_vec = -(_e58);
    }
    let _e61 = neigh_idx;
    let c_neigh = cell_centers[_e61];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let d_own_1 = distance(c_owner_vec, face_center_vec);
    let _e70 = c_neigh_vec;
    let d_neigh = distance(_e70, face_center_vec);
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e77 = lambda;
    let lambda_other = (1f - _e77);
    let _e80 = c_neigh_vec;
    let d_vec = (_e80 - c_owner_vec);
    let _e82 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e82));
    let dist = max(dist_proj, 0.000001f);
    let s_own_T = state[((owner_1 * 8u) + 5u)];
    let s_own_rho = state[((owner_1 * 8u) + 0u)];
    let s_own_rho_e = state[((owner_1 * 8u) + 3u)];
    let _cse_1610_ = state[((owner_1 * 8u) + 6u)];
    let _cse_1619_ = state[((owner_1 * 8u) + 7u)];
    let _e122 = neigh_idx;
    let _e129 = state[((_e122 * 8u) + 5u)];
    let _e136 = state[((owner_1 * 8u) + 5u)];
    let _e143 = bc_kind[((idx * 8u) + 7u)];
    let _e150 = bc_value[((idx * 8u) + 7u)];
    let _e151 = bc_neighbor_scalar(_e129, _e136, _e143, _e150, d_own_1, is_boundary_1);
    let _e152 = neigh_idx;
    let _e159 = state[((_e152 * 8u) + 0u)];
    let _e166 = state[((owner_1 * 8u) + 0u)];
    let _e173 = bc_kind[((idx * 8u) + 0u)];
    let _e180 = bc_value[((idx * 8u) + 0u)];
    let _e181 = bc_neighbor_scalar(_e159, _e166, _e173, _e180, d_own_1, is_boundary_1);
    let _e182 = neigh_idx;
    let _e189 = state[((_e182 * 8u) + 3u)];
    let _e196 = state[((owner_1 * 8u) + 3u)];
    let _e203 = bc_kind[((idx * 8u) + 3u)];
    let _e210 = bc_value[((idx * 8u) + 3u)];
    let _e211 = bc_neighbor_scalar(_e189, _e196, _e203, _e210, d_own_1, is_boundary_1);
    let _e212 = neigh_idx;
    let _e219 = state[((_e212 * 8u) + 6u)];
    let _e226 = state[((owner_1 * 8u) + 6u)];
    let _e233 = bc_kind[((idx * 8u) + 4u)];
    let _e240 = bc_value[((idx * 8u) + 4u)];
    let _e241 = bc_neighbor_scalar(_e219, _e226, _e233, _e240, d_own_1, is_boundary_1);
    let _e248 = state[((owner_1 * 8u) + 6u)];
    let _e255 = state[((owner_1 * 8u) + 6u)];
    let _e257 = normal_vec.x;
    let _e265 = state[((owner_1 * 8u) + 7u)];
    let _e267 = normal_vec.y;
    let _e273 = normal_vec.x;
    let _cse_1613_ = select(_e241, (_e248 - ((2f * ((_e255 * _e257) + (_e265 * _e267))) * _e273)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _e283 = neigh_idx;
    let _e290 = state[((_e283 * 8u) + 7u)];
    let _e297 = state[((owner_1 * 8u) + 7u)];
    let _e304 = bc_kind[((idx * 8u) + 5u)];
    let _e311 = bc_value[((idx * 8u) + 5u)];
    let _e312 = bc_neighbor_scalar(_e290, _e297, _e304, _e311, d_own_1, is_boundary_1);
    let _e319 = state[((owner_1 * 8u) + 7u)];
    let _e326 = state[((owner_1 * 8u) + 6u)];
    let _e328 = normal_vec.x;
    let _e336 = state[((owner_1 * 8u) + 7u)];
    let _e338 = normal_vec.y;
    let _e344 = normal_vec.y;
    let _cse_1622_ = select(_e312, (_e319 - ((2f * ((_e326 * _e328) + (_e336 * _e338))) * _e344)), (is_boundary_1 && ((boundary_type == 3u) || (boundary_type == 4u))));
    let _cse_1_ = vec2<f32>(_cse_1610_, _cse_1619_);
    let _e355 = normal_vec;
    let _cse_0_ = dot(_cse_1_, _e355);
    let _e359 = low_mach_params.model;
    let _cse_11_ = (f32(_e359) - 2f);
    let _cse_10_ = abs(_cse_11_);
    let _cse_9_ = (1f - _cse_10_);
    let _cse_8_ = max(0f, _cse_9_);
    let _e370 = constants.eos_r;
    let _cse_15_ = ((s_own_rho * _e370) * s_own_T);
    let _e375 = constants.eos_gamma;
    let _cse_14_ = (_e375 * _cse_15_);
    let _cse_13_ = (_cse_14_ / s_own_rho);
    let _e380 = constants.eos_dp_drho;
    let _cse_12_ = (_cse_13_ + _e380);
    let _cse_7_ = (_cse_8_ * _cse_12_);
    let _e385 = low_mach_params.model;
    let _cse_20_ = f32(_e385);
    let _cse_19_ = abs(_cse_20_);
    let _cse_18_ = (1f - _cse_19_);
    let _cse_17_ = max(0f, _cse_18_);
    let _cse_22_ = (_cse_0_ * _cse_0_);
    let _cse_21_ = min(_cse_22_, _cse_12_);
    let _cse_16_ = (_cse_17_ * _cse_21_);
    let _cse_6_ = (_cse_7_ + _cse_16_);
    let _e398 = low_mach_params.model;
    let _cse_27_ = (f32(_e398) - 1f);
    let _cse_26_ = abs(_cse_27_);
    let _cse_25_ = (1f - _cse_26_);
    let _cse_24_ = max(0f, _cse_25_);
    let _e409 = low_mach_params.theta_floor;
    let _cse_30_ = (_e409 * _cse_12_);
    let _cse_29_ = max(_cse_22_, _cse_30_);
    let _cse_28_ = min(_cse_29_, _cse_12_);
    let _cse_23_ = (_cse_24_ * _cse_28_);
    let _cse_5_ = (_cse_6_ + _cse_23_);
    let _cse_4_ = sqrt(_cse_5_);
    let _cse_32_ = vec2<f32>(_cse_1613_, _cse_1622_);
    let _e417 = normal_vec;
    let _cse_31_ = dot(_cse_32_, _e417);
    let _e421 = constants.eos_r;
    let _cse_42_ = ((_e181 * _e421) * _e151);
    let _e426 = constants.eos_gamma;
    let _cse_41_ = (_e426 * _cse_42_);
    let _cse_40_ = (_cse_41_ / _e181);
    let _e431 = constants.eos_dp_drho;
    let _cse_39_ = (_cse_40_ + _e431);
    let _cse_38_ = (_cse_8_ * _cse_39_);
    let _cse_45_ = (_cse_31_ * _cse_31_);
    let _cse_44_ = min(_cse_45_, _cse_39_);
    let _cse_43_ = (_cse_17_ * _cse_44_);
    let _cse_37_ = (_cse_38_ + _cse_43_);
    let _e440 = low_mach_params.theta_floor;
    let _cse_49_ = (_e440 * _cse_39_);
    let _cse_48_ = max(_cse_45_, _cse_49_);
    let _cse_47_ = min(_cse_48_, _cse_39_);
    let _cse_46_ = (_cse_24_ * _cse_47_);
    let _cse_36_ = (_cse_37_ + _cse_46_);
    let _cse_35_ = sqrt(_cse_36_);
    a_plus = max(0f, max((_cse_0_ + _cse_4_), (_cse_31_ + _cse_35_)));
    a_minus = min(0f, min((_cse_0_ - _cse_4_), (_cse_31_ - _cse_35_)));
    let _e461 = constants.scheme;
    if ((_e461 == 1u) && !(is_boundary_1)) {
        let _cse_59_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_58_ = max(_cse_59_, 0.000000000001f);
        let _cse_56_ = ((_cse_1613_ - _cse_1610_) / _cse_58_);
        let _cse_55_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_56_);
        let _cse_54_ = dot(_cse_55_, (face_center_vec - c_owner_vec));
        let _cse_52_ = (_cse_1610_ + _cse_54_);
        let _cse_64_ = ((_cse_1622_ - _cse_1619_) / _cse_58_);
        let _cse_63_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_64_);
        let _cse_62_ = dot(_cse_63_, (face_center_vec - c_owner_vec));
        let _cse_60_ = (_cse_1619_ + _cse_62_);
        let _cse_51_ = vec2<f32>(_cse_52_, _cse_60_);
        let _e486 = normal_vec;
        let _cse_50_ = dot(_cse_51_, _e486);
        let _cse_77_ = ((_e181 - s_own_rho) / _cse_58_);
        let _cse_76_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_77_);
        let _cse_75_ = dot(_cse_76_, (face_center_vec - c_owner_vec));
        let _cse_74_ = (s_own_rho + _cse_75_);
        let _e497 = constants.eos_r;
        let _cse_73_ = (_cse_74_ * _e497);
        let _cse_72_ = (_cse_73_ * (s_own_T + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_58_)), (face_center_vec - c_owner_vec))));
        let _e510 = constants.eos_gamma;
        let _cse_71_ = (_e510 * _cse_72_);
        let _cse_70_ = (_cse_71_ / _cse_74_);
        let _e515 = constants.eos_dp_drho;
        let _cse_69_ = (_cse_70_ + _e515);
        let _cse_80_ = (_cse_50_ * _cse_50_);
        let _cse_79_ = min(_cse_80_, _cse_69_);
        let _e521 = low_mach_params.model;
        let _cse_78_ = (max(0f, (1f - abs(f32(_e521)))) * _cse_79_);
        let _e531 = low_mach_params.model;
        let _cse_68_ = ((max(0f, (1f - abs((f32(_e531) - 2f)))) * _cse_69_) + _cse_78_);
        let _e544 = low_mach_params.theta_floor;
        let _cse_83_ = max(_cse_80_, (_e544 * _cse_69_));
        let _cse_82_ = min(_cse_83_, _cse_69_);
        let _e550 = low_mach_params.model;
        let _cse_81_ = (max(0f, (1f - abs((f32(_e550) - 1f)))) * _cse_82_);
        let _cse_67_ = (_cse_68_ + _cse_81_);
        let _cse_66_ = sqrt(_cse_67_);
        let _cse_91_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_90_ = max(_cse_91_, 0.000000000001f);
        let _cse_89_ = ((_cse_1610_ - _cse_1613_) / _cse_90_);
        let _cse_88_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_89_);
        let _cse_87_ = dot(_cse_88_, (face_center_vec - c_neigh_cell_vec));
        let _cse_86_ = (_cse_1613_ + _cse_87_);
        let _cse_95_ = ((_cse_1619_ - _cse_1622_) / _cse_90_);
        let _cse_94_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_95_);
        let _cse_93_ = dot(_cse_94_, (face_center_vec - c_neigh_cell_vec));
        let _cse_92_ = (_cse_1622_ + _cse_93_);
        let _cse_85_ = vec2<f32>(_cse_86_, _cse_92_);
        let _e582 = normal_vec;
        let _cse_84_ = dot(_cse_85_, _e582);
        let _cse_107_ = ((s_own_rho - _e181) / _cse_90_);
        let _cse_106_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_107_);
        let _cse_105_ = dot(_cse_106_, (face_center_vec - c_neigh_cell_vec));
        let _cse_104_ = (_e181 + _cse_105_);
        let _e593 = constants.eos_r;
        let _cse_103_ = (_cse_104_ * _e593);
        let _cse_102_ = (_cse_103_ * (_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_90_)), (face_center_vec - c_neigh_cell_vec))));
        let _e606 = constants.eos_gamma;
        let _cse_101_ = (_e606 * _cse_102_);
        let _cse_100_ = (_cse_101_ / _cse_104_);
        let _e611 = constants.eos_dp_drho;
        let _cse_99_ = (_cse_100_ + _e611);
        let _cse_110_ = (_cse_84_ * _cse_84_);
        let _cse_109_ = min(_cse_110_, _cse_99_);
        let _e617 = low_mach_params.model;
        let _cse_108_ = (max(0f, (1f - abs(f32(_e617)))) * _cse_109_);
        let _e627 = low_mach_params.model;
        let _cse_98_ = ((max(0f, (1f - abs((f32(_e627) - 2f)))) * _cse_99_) + _cse_108_);
        let _e640 = low_mach_params.theta_floor;
        let _cse_113_ = max(_cse_110_, (_e640 * _cse_99_));
        let _cse_112_ = min(_cse_113_, _cse_99_);
        let _e646 = low_mach_params.model;
        let _cse_111_ = (max(0f, (1f - abs((f32(_e646) - 1f)))) * _cse_112_);
        let _cse_97_ = (_cse_98_ + _cse_111_);
        let _cse_96_ = sqrt(_cse_97_);
        a_plus = max(0f, max((_cse_50_ + _cse_66_), (_cse_84_ + _cse_96_)));
        a_minus = min(0f, min((_cse_50_ - _cse_66_), (_cse_84_ - _cse_96_)));
    }
    let _e670 = constants.scheme;
    if ((_e670 == 2u) && !(is_boundary_1)) {
        let _cse_123_ = max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f);
        let _cse_122_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_123_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_121_ = (_cse_122_ * 0.125f);
        let _cse_119_ = (((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + _cse_121_);
        let _cse_118_ = (_cse_119_ - _cse_1610_);
        let _cse_116_ = (_cse_1610_ + _cse_118_);
        let _cse_130_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_123_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_129_ = (_cse_130_ * 0.125f);
        let _cse_127_ = (((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + _cse_129_);
        let _cse_126_ = (_cse_127_ - _cse_1619_);
        let _cse_124_ = (_cse_1619_ + _cse_126_);
        let _cse_115_ = vec2<f32>(_cse_116_, _cse_124_);
        let _e715 = normal_vec;
        let _cse_114_ = dot(_cse_115_, _e715);
        let _cse_141_ = (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_123_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f);
        let _cse_140_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + _cse_141_);
        let _cse_139_ = (_cse_140_ - s_own_rho);
        let _cse_138_ = (s_own_rho + _cse_139_);
        let _e736 = constants.eos_r;
        let _cse_137_ = ((_cse_138_ * _e736) * ((((s_own_T + (s_own_T * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_123_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T));
        let _e758 = constants.eos_gamma;
        let _cse_136_ = (_e758 * _cse_137_);
        let _cse_135_ = (_cse_136_ / _cse_138_);
        let _e763 = constants.eos_dp_drho;
        let _cse_134_ = (_cse_135_ + _e763);
        let _cse_144_ = (_cse_114_ * _cse_114_);
        let _cse_143_ = min(_cse_144_, _cse_134_);
        let _e769 = low_mach_params.model;
        let _cse_142_ = (max(0f, (1f - abs(f32(_e769)))) * _cse_143_);
        let _e779 = low_mach_params.model;
        let _cse_133_ = ((max(0f, (1f - abs((f32(_e779) - 2f)))) * _cse_134_) + _cse_142_);
        let _e792 = low_mach_params.theta_floor;
        let _cse_147_ = max(_cse_144_, (_e792 * _cse_134_));
        let _cse_146_ = min(_cse_147_, _cse_134_);
        let _e798 = low_mach_params.model;
        let _cse_145_ = (max(0f, (1f - abs((f32(_e798) - 1f)))) * _cse_146_);
        let _cse_132_ = (_cse_133_ + _cse_145_);
        let _cse_131_ = sqrt(_cse_132_);
        let _cse_155_ = max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f);
        let _cse_154_ = dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_155_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_153_ = (_cse_154_ * 0.125f);
        let _cse_152_ = (((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + _cse_153_);
        let _cse_151_ = (_cse_152_ - _cse_1613_);
        let _cse_150_ = (_cse_1613_ + _cse_151_);
        let _cse_160_ = dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_155_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_159_ = (_cse_160_ * 0.125f);
        let _cse_158_ = (((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + _cse_159_);
        let _cse_157_ = (_cse_158_ - _cse_1622_);
        let _cse_156_ = (_cse_1622_ + _cse_157_);
        let _cse_149_ = vec2<f32>(_cse_150_, _cse_156_);
        let _e850 = normal_vec;
        let _cse_148_ = dot(_cse_149_, _e850);
        let _cse_171_ = (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_155_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_170_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + _cse_171_);
        let _cse_169_ = (_cse_170_ - _e181);
        let _cse_168_ = (_e181 + _cse_169_);
        let _e871 = constants.eos_r;
        let _cse_167_ = ((_cse_168_ * _e871) * ((((_e151 + (_e151 * 0.625f)) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_155_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151));
        let _e893 = constants.eos_gamma;
        let _cse_166_ = (_e893 * _cse_167_);
        let _cse_165_ = (_cse_166_ / _cse_168_);
        let _e898 = constants.eos_dp_drho;
        let _cse_164_ = (_cse_165_ + _e898);
        let _cse_174_ = (_cse_148_ * _cse_148_);
        let _cse_173_ = min(_cse_174_, _cse_164_);
        let _e904 = low_mach_params.model;
        let _cse_172_ = (max(0f, (1f - abs(f32(_e904)))) * _cse_173_);
        let _e914 = low_mach_params.model;
        let _cse_163_ = ((max(0f, (1f - abs((f32(_e914) - 2f)))) * _cse_164_) + _cse_172_);
        let _e927 = low_mach_params.theta_floor;
        let _cse_177_ = max(_cse_174_, (_e927 * _cse_164_));
        let _cse_176_ = min(_cse_177_, _cse_164_);
        let _e933 = low_mach_params.model;
        let _cse_175_ = (max(0f, (1f - abs((f32(_e933) - 1f)))) * _cse_176_);
        let _cse_162_ = (_cse_163_ + _cse_175_);
        let _cse_161_ = sqrt(_cse_162_);
        a_plus = max(0f, max((_cse_114_ + _cse_131_), (_cse_148_ + _cse_161_)));
        a_minus = min(0f, min((_cse_114_ - _cse_131_), (_cse_148_ - _cse_161_)));
    }
    let _e957 = constants.scheme;
    if ((_e957 == 3u) && !(is_boundary_1)) {
        let _cse_185_ = (_cse_1613_ - _cse_1610_);
        let _cse_187_ = max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f);
        let _cse_184_ = dot((((c_neigh_cell_vec - c_owner_vec) * _cse_185_) / vec2(_cse_187_)), (face_center_vec - c_owner_vec));
        let _cse_183_ = max(_cse_184_, min(_cse_185_, 0f));
        let _cse_182_ = min(_cse_183_, max(_cse_185_, 0f));
        let _cse_180_ = (_cse_1610_ + _cse_182_);
        let _cse_193_ = (_cse_1622_ - _cse_1619_);
        let _cse_192_ = dot((((c_neigh_cell_vec - c_owner_vec) * _cse_193_) / vec2(_cse_187_)), (face_center_vec - c_owner_vec));
        let _cse_191_ = max(_cse_192_, min(_cse_193_, 0f));
        let _cse_190_ = min(_cse_191_, max(_cse_193_, 0f));
        let _cse_188_ = (_cse_1619_ + _cse_190_);
        let _cse_179_ = vec2<f32>(_cse_180_, _cse_188_);
        let _e996 = normal_vec;
        let _cse_178_ = dot(_cse_179_, _e996);
        let _cse_205_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_187_)), (face_center_vec - c_owner_vec));
        let _cse_204_ = max(_cse_205_, min((_e181 - s_own_rho), 0f));
        let _cse_203_ = min(_cse_204_, max((_e181 - s_own_rho), 0f));
        let _cse_202_ = (s_own_rho + _cse_203_);
        let _e1016 = constants.eos_r;
        let _cse_201_ = ((_cse_202_ * _e1016) * (s_own_T + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_187_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f))));
        let _e1037 = constants.eos_gamma;
        let _cse_200_ = (_e1037 * _cse_201_);
        let _cse_199_ = (_cse_200_ / _cse_202_);
        let _e1042 = constants.eos_dp_drho;
        let _cse_198_ = (_cse_199_ + _e1042);
        let _cse_208_ = (_cse_178_ * _cse_178_);
        let _cse_207_ = min(_cse_208_, _cse_198_);
        let _e1048 = low_mach_params.model;
        let _cse_206_ = (max(0f, (1f - abs(f32(_e1048)))) * _cse_207_);
        let _e1058 = low_mach_params.model;
        let _cse_197_ = ((max(0f, (1f - abs((f32(_e1058) - 2f)))) * _cse_198_) + _cse_206_);
        let _e1071 = low_mach_params.theta_floor;
        let _cse_211_ = max(_cse_208_, (_e1071 * _cse_198_));
        let _cse_210_ = min(_cse_211_, _cse_198_);
        let _e1077 = low_mach_params.model;
        let _cse_209_ = (max(0f, (1f - abs((f32(_e1077) - 1f)))) * _cse_210_);
        let _cse_196_ = (_cse_197_ + _cse_209_);
        let _cse_195_ = sqrt(_cse_196_);
        let _cse_218_ = (_cse_1610_ - _cse_1613_);
        let _cse_219_ = max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f);
        let _cse_217_ = dot((((c_owner_vec - c_neigh_cell_vec) * _cse_218_) / vec2(_cse_219_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_216_ = max(_cse_217_, min(_cse_218_, 0f));
        let _cse_215_ = min(_cse_216_, max(_cse_218_, 0f));
        let _cse_214_ = (_cse_1613_ + _cse_215_);
        let _cse_224_ = (_cse_1619_ - _cse_1622_);
        let _cse_223_ = dot((((c_owner_vec - c_neigh_cell_vec) * _cse_224_) / vec2(_cse_219_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_222_ = max(_cse_223_, min(_cse_224_, 0f));
        let _cse_221_ = min(_cse_222_, max(_cse_224_, 0f));
        let _cse_220_ = (_cse_1622_ + _cse_221_);
        let _cse_213_ = vec2<f32>(_cse_214_, _cse_220_);
        let _e1123 = normal_vec;
        let _cse_212_ = dot(_cse_213_, _e1123);
        let _cse_235_ = dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_219_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_234_ = max(_cse_235_, min((s_own_rho - _e181), 0f));
        let _cse_233_ = min(_cse_234_, max((s_own_rho - _e181), 0f));
        let _cse_232_ = (_e181 + _cse_233_);
        let _e1143 = constants.eos_r;
        let _cse_231_ = ((_cse_232_ * _e1143) * (_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_219_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f))));
        let _e1164 = constants.eos_gamma;
        let _cse_230_ = (_e1164 * _cse_231_);
        let _cse_229_ = (_cse_230_ / _cse_232_);
        let _e1169 = constants.eos_dp_drho;
        let _cse_228_ = (_cse_229_ + _e1169);
        let _cse_238_ = (_cse_212_ * _cse_212_);
        let _cse_237_ = min(_cse_238_, _cse_228_);
        let _e1175 = low_mach_params.model;
        let _cse_236_ = (max(0f, (1f - abs(f32(_e1175)))) * _cse_237_);
        let _e1185 = low_mach_params.model;
        let _cse_227_ = ((max(0f, (1f - abs((f32(_e1185) - 2f)))) * _cse_228_) + _cse_236_);
        let _e1198 = low_mach_params.theta_floor;
        let _cse_241_ = max(_cse_238_, (_e1198 * _cse_228_));
        let _cse_240_ = min(_cse_241_, _cse_228_);
        let _e1204 = low_mach_params.model;
        let _cse_239_ = (max(0f, (1f - abs((f32(_e1204) - 1f)))) * _cse_240_);
        let _cse_226_ = (_cse_227_ + _cse_239_);
        let _cse_225_ = sqrt(_cse_226_);
        a_plus = max(0f, max((_cse_178_ + _cse_195_), (_cse_212_ + _cse_225_)));
        a_minus = min(0f, min((_cse_178_ - _cse_195_), (_cse_212_ - _cse_225_)));
    }
    let _e1228 = constants.scheme;
    if ((_e1228 == 4u) && !(is_boundary_1)) {
        let _cse_249_ = (_cse_1613_ - _cse_1610_);
        let _cse_252_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_251_ = max(_cse_252_, 0.000000000001f);
        let _cse_248_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_249_) / vec2(_cse_251_));
        let _cse_247_ = dot(_cse_248_, (face_center_vec - c_owner_vec));
        let _cse_246_ = ((((_cse_247_ * abs(_cse_249_)) / max(abs(_cse_249_), (abs(_cse_247_) + 0.00000001f))) * max((_cse_249_ * _cse_247_), 0f)) / max(abs((_cse_249_ * _cse_247_)), 0.00000001f));
        let _cse_244_ = (_cse_1610_ + _cse_246_);
        let _cse_258_ = (_cse_1622_ - _cse_1619_);
        let _cse_257_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_258_) / vec2(_cse_251_));
        let _cse_256_ = dot(_cse_257_, (face_center_vec - c_owner_vec));
        let _cse_255_ = ((((_cse_256_ * abs(_cse_258_)) / max(abs(_cse_258_), (abs(_cse_256_) + 0.00000001f))) * max((_cse_258_ * _cse_256_), 0f)) / max(abs((_cse_258_ * _cse_256_)), 0.00000001f));
        let _cse_253_ = (_cse_1619_ + _cse_255_);
        let _cse_243_ = vec2<f32>(_cse_244_, _cse_253_);
        let _e1289 = normal_vec;
        let _cse_242_ = dot(_cse_243_, _e1289);
        let _cse_269_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_251_)), (face_center_vec - c_owner_vec));
        let _cse_268_ = ((((_cse_269_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_269_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_269_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_269_)), 0.00000001f));
        let _cse_267_ = (s_own_rho + _cse_268_);
        let _e1322 = constants.eos_r;
        let _cse_266_ = ((_cse_267_ * _e1322) * (s_own_T + ((((dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_251_)), (face_center_vec - c_owner_vec)) * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_251_)), (face_center_vec - c_owner_vec))) + 0.00000001f))) * max(((_e151 - s_own_T) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_251_)), (face_center_vec - c_owner_vec))), 0f)) / max(abs(((_e151 - s_own_T) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_251_)), (face_center_vec - c_owner_vec)))), 0.00000001f))));
        let _e1377 = constants.eos_gamma;
        let _cse_265_ = (_e1377 * _cse_266_);
        let _cse_264_ = (_cse_265_ / _cse_267_);
        let _e1382 = constants.eos_dp_drho;
        let _cse_263_ = (_cse_264_ + _e1382);
        let _cse_272_ = (_cse_242_ * _cse_242_);
        let _cse_271_ = min(_cse_272_, _cse_263_);
        let _e1388 = low_mach_params.model;
        let _cse_270_ = (max(0f, (1f - abs(f32(_e1388)))) * _cse_271_);
        let _e1398 = low_mach_params.model;
        let _cse_262_ = ((max(0f, (1f - abs((f32(_e1398) - 2f)))) * _cse_263_) + _cse_270_);
        let _e1411 = low_mach_params.theta_floor;
        let _cse_275_ = max(_cse_272_, (_e1411 * _cse_263_));
        let _cse_274_ = min(_cse_275_, _cse_263_);
        let _e1417 = low_mach_params.model;
        let _cse_273_ = (max(0f, (1f - abs((f32(_e1417) - 1f)))) * _cse_274_);
        let _cse_261_ = (_cse_262_ + _cse_273_);
        let _cse_260_ = sqrt(_cse_261_);
        let _cse_282_ = (_cse_1610_ - _cse_1613_);
        let _cse_284_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_283_ = max(_cse_284_, 0.000000000001f);
        let _cse_281_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_282_) / vec2(_cse_283_));
        let _cse_280_ = dot(_cse_281_, (face_center_vec - c_neigh_cell_vec));
        let _cse_279_ = ((((_cse_280_ * abs(_cse_282_)) / max(abs(_cse_282_), (abs(_cse_280_) + 0.00000001f))) * max((_cse_282_ * _cse_280_), 0f)) / max(abs((_cse_282_ * _cse_280_)), 0.00000001f));
        let _cse_278_ = (_cse_1613_ + _cse_279_);
        let _cse_289_ = (_cse_1619_ - _cse_1622_);
        let _cse_288_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_289_) / vec2(_cse_283_));
        let _cse_287_ = dot(_cse_288_, (face_center_vec - c_neigh_cell_vec));
        let _cse_286_ = ((((_cse_287_ * abs(_cse_289_)) / max(abs(_cse_289_), (abs(_cse_287_) + 0.00000001f))) * max((_cse_289_ * _cse_287_), 0f)) / max(abs((_cse_289_ * _cse_287_)), 0.00000001f));
        let _cse_285_ = (_cse_1622_ + _cse_286_);
        let _cse_277_ = vec2<f32>(_cse_278_, _cse_285_);
        let _e1485 = normal_vec;
        let _cse_276_ = dot(_cse_277_, _e1485);
        let _cse_299_ = dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_283_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_298_ = ((((_cse_299_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_299_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_299_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_299_)), 0.00000001f));
        let _cse_297_ = (_e181 + _cse_298_);
        let _e1518 = constants.eos_r;
        let _cse_296_ = ((_cse_297_ * _e1518) * (_e151 + ((((dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_283_)), (face_center_vec - c_neigh_cell_vec)) * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_283_)), (face_center_vec - c_neigh_cell_vec))) + 0.00000001f))) * max(((s_own_T - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_283_)), (face_center_vec - c_neigh_cell_vec))), 0f)) / max(abs(((s_own_T - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_283_)), (face_center_vec - c_neigh_cell_vec)))), 0.00000001f))));
        let _e1573 = constants.eos_gamma;
        let _cse_295_ = (_e1573 * _cse_296_);
        let _cse_294_ = (_cse_295_ / _cse_297_);
        let _e1578 = constants.eos_dp_drho;
        let _cse_293_ = (_cse_294_ + _e1578);
        let _cse_302_ = (_cse_276_ * _cse_276_);
        let _cse_301_ = min(_cse_302_, _cse_293_);
        let _e1584 = low_mach_params.model;
        let _cse_300_ = (max(0f, (1f - abs(f32(_e1584)))) * _cse_301_);
        let _e1594 = low_mach_params.model;
        let _cse_292_ = ((max(0f, (1f - abs((f32(_e1594) - 2f)))) * _cse_293_) + _cse_300_);
        let _e1607 = low_mach_params.theta_floor;
        let _cse_305_ = max(_cse_302_, (_e1607 * _cse_293_));
        let _cse_304_ = min(_cse_305_, _cse_293_);
        let _e1613 = low_mach_params.model;
        let _cse_303_ = (max(0f, (1f - abs((f32(_e1613) - 1f)))) * _cse_304_);
        let _cse_291_ = (_cse_292_ + _cse_303_);
        let _cse_290_ = sqrt(_cse_291_);
        a_plus = max(0f, max((_cse_242_ + _cse_260_), (_cse_276_ + _cse_290_)));
        a_minus = min(0f, min((_cse_242_ - _cse_260_), (_cse_276_ - _cse_290_)));
    }
    let _e1637 = constants.scheme;
    if ((_e1637 == 5u) && !(is_boundary_1)) {
        let _cse_315_ = (_cse_1613_ - _cse_1610_);
        let _cse_313_ = (((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_315_) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_312_ = (_cse_313_ - _cse_1610_);
        let _cse_311_ = max(_cse_312_, min(_cse_315_, 0f));
        let _cse_310_ = min(_cse_311_, max(_cse_315_, 0f));
        let _cse_308_ = (_cse_1610_ + _cse_310_);
        let _cse_323_ = (_cse_1622_ - _cse_1619_);
        let _cse_321_ = (((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_323_) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_320_ = (_cse_321_ - _cse_1619_);
        let _cse_319_ = max(_cse_320_, min(_cse_323_, 0f));
        let _cse_318_ = min(_cse_319_, max(_cse_323_, 0f));
        let _cse_316_ = (_cse_1619_ + _cse_318_);
        let _cse_307_ = vec2<f32>(_cse_308_, _cse_316_);
        let _e1699 = normal_vec;
        let _cse_306_ = dot(_cse_307_, _e1699);
        let _cse_333_ = max(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho), min((_e181 - s_own_rho), 0f));
        let _cse_332_ = min(_cse_333_, max((_e181 - s_own_rho), 0f));
        let _cse_331_ = (s_own_rho + _cse_332_);
        let _e1733 = constants.eos_r;
        let _cse_330_ = ((_cse_331_ * _e1733) * (s_own_T + min(max(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f))));
        let _e1768 = constants.eos_gamma;
        let _cse_329_ = (_e1768 * _cse_330_);
        let _cse_328_ = (_cse_329_ / _cse_331_);
        let _e1773 = constants.eos_dp_drho;
        let _cse_327_ = (_cse_328_ + _e1773);
        let _cse_336_ = (_cse_306_ * _cse_306_);
        let _cse_335_ = min(_cse_336_, _cse_327_);
        let _e1779 = low_mach_params.model;
        let _cse_334_ = (max(0f, (1f - abs(f32(_e1779)))) * _cse_335_);
        let _e1789 = low_mach_params.model;
        let _cse_326_ = ((max(0f, (1f - abs((f32(_e1789) - 2f)))) * _cse_327_) + _cse_334_);
        let _e1802 = low_mach_params.theta_floor;
        let _cse_339_ = max(_cse_336_, (_e1802 * _cse_327_));
        let _cse_338_ = min(_cse_339_, _cse_327_);
        let _e1808 = low_mach_params.model;
        let _cse_337_ = (max(0f, (1f - abs((f32(_e1808) - 1f)))) * _cse_338_);
        let _cse_325_ = (_cse_326_ + _cse_337_);
        let _cse_324_ = sqrt(_cse_325_);
        let _cse_347_ = (_cse_1610_ - _cse_1613_);
        let _cse_346_ = (((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_347_) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_345_ = (_cse_346_ - _cse_1613_);
        let _cse_344_ = max(_cse_345_, min(_cse_347_, 0f));
        let _cse_343_ = min(_cse_344_, max(_cse_347_, 0f));
        let _cse_342_ = (_cse_1613_ + _cse_343_);
        let _cse_353_ = (_cse_1619_ - _cse_1622_);
        let _cse_352_ = (((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_353_) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_351_ = (_cse_352_ - _cse_1622_);
        let _cse_350_ = max(_cse_351_, min(_cse_353_, 0f));
        let _cse_349_ = min(_cse_350_, max(_cse_353_, 0f));
        let _cse_348_ = (_cse_1622_ + _cse_349_);
        let _cse_341_ = vec2<f32>(_cse_342_, _cse_348_);
        let _e1877 = normal_vec;
        let _cse_340_ = dot(_cse_341_, _e1877);
        let _cse_363_ = max(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181), min((s_own_rho - _e181), 0f));
        let _cse_362_ = min(_cse_363_, max((s_own_rho - _e181), 0f));
        let _cse_361_ = (_e181 + _cse_362_);
        let _e1911 = constants.eos_r;
        let _cse_360_ = ((_cse_361_ * _e1911) * (_e151 + min(max(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f))));
        let _e1946 = constants.eos_gamma;
        let _cse_359_ = (_e1946 * _cse_360_);
        let _cse_358_ = (_cse_359_ / _cse_361_);
        let _e1951 = constants.eos_dp_drho;
        let _cse_357_ = (_cse_358_ + _e1951);
        let _cse_366_ = (_cse_340_ * _cse_340_);
        let _cse_365_ = min(_cse_366_, _cse_357_);
        let _e1957 = low_mach_params.model;
        let _cse_364_ = (max(0f, (1f - abs(f32(_e1957)))) * _cse_365_);
        let _e1967 = low_mach_params.model;
        let _cse_356_ = ((max(0f, (1f - abs((f32(_e1967) - 2f)))) * _cse_357_) + _cse_364_);
        let _e1980 = low_mach_params.theta_floor;
        let _cse_369_ = max(_cse_366_, (_e1980 * _cse_357_));
        let _cse_368_ = min(_cse_369_, _cse_357_);
        let _e1986 = low_mach_params.model;
        let _cse_367_ = (max(0f, (1f - abs((f32(_e1986) - 1f)))) * _cse_368_);
        let _cse_355_ = (_cse_356_ + _cse_367_);
        let _cse_354_ = sqrt(_cse_355_);
        a_plus = max(0f, max((_cse_306_ + _cse_324_), (_cse_340_ + _cse_354_)));
        a_minus = min(0f, min((_cse_306_ - _cse_324_), (_cse_340_ - _cse_354_)));
    }
    let _e2010 = constants.scheme;
    if ((_e2010 == 6u) && !(is_boundary_1)) {
        let _cse_376_ = (((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_375_ = (_cse_376_ - _cse_1610_);
        let _cse_378_ = ((_cse_1613_ - _cse_1610_) * _cse_375_);
        let _cse_374_ = ((((_cse_375_ * abs((_cse_1613_ - _cse_1610_))) / max(abs((_cse_1613_ - _cse_1610_)), (abs(_cse_375_) + 0.00000001f))) * max(_cse_378_, 0f)) / max(abs(_cse_378_), 0.00000001f));
        let _cse_372_ = (_cse_1610_ + _cse_374_);
        let _cse_383_ = (((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_382_ = (_cse_383_ - _cse_1619_);
        let _cse_385_ = ((_cse_1622_ - _cse_1619_) * _cse_382_);
        let _cse_381_ = ((((_cse_382_ * abs((_cse_1622_ - _cse_1619_))) / max(abs((_cse_1622_ - _cse_1619_)), (abs(_cse_382_) + 0.00000001f))) * max(_cse_385_, 0f)) / max(abs(_cse_385_), 0.00000001f));
        let _cse_379_ = (_cse_1619_ + _cse_381_);
        let _cse_371_ = vec2<f32>(_cse_372_, _cse_379_);
        let _e2098 = normal_vec;
        let _cse_370_ = dot(_cse_371_, _e2098);
        let _cse_396_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_395_ = (_cse_396_ - s_own_rho);
        let _cse_394_ = ((((_cse_395_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_395_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_395_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_395_)), 0.00000001f));
        let _cse_393_ = (s_own_rho + _cse_394_);
        let _e2145 = constants.eos_r;
        let _cse_392_ = ((_cse_393_ * _e2145) * (s_own_T + ((((((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T) * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)) + 0.00000001f))) * max(((_e151 - s_own_T) * ((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)), 0f)) / max(abs(((_e151 - s_own_T) * ((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T))), 0.00000001f))));
        let _e2256 = constants.eos_gamma;
        let _cse_391_ = (_e2256 * _cse_392_);
        let _cse_390_ = (_cse_391_ / _cse_393_);
        let _e2261 = constants.eos_dp_drho;
        let _cse_389_ = (_cse_390_ + _e2261);
        let _cse_399_ = (_cse_370_ * _cse_370_);
        let _cse_398_ = min(_cse_399_, _cse_389_);
        let _e2267 = low_mach_params.model;
        let _cse_397_ = (max(0f, (1f - abs(f32(_e2267)))) * _cse_398_);
        let _e2277 = low_mach_params.model;
        let _cse_388_ = ((max(0f, (1f - abs((f32(_e2277) - 2f)))) * _cse_389_) + _cse_397_);
        let _e2290 = low_mach_params.theta_floor;
        let _cse_402_ = max(_cse_399_, (_e2290 * _cse_389_));
        let _cse_401_ = min(_cse_402_, _cse_389_);
        let _e2296 = low_mach_params.model;
        let _cse_400_ = (max(0f, (1f - abs((f32(_e2296) - 1f)))) * _cse_401_);
        let _cse_387_ = (_cse_388_ + _cse_400_);
        let _cse_386_ = sqrt(_cse_387_);
        let _cse_409_ = (((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_408_ = (_cse_409_ - _cse_1613_);
        let _cse_407_ = ((_cse_408_ * abs((_cse_1610_ - _cse_1613_))) / max(abs((_cse_1610_ - _cse_1613_)), (abs(_cse_408_) + 0.00000001f)));
        let _cse_410_ = ((_cse_1610_ - _cse_1613_) * _cse_408_);
        let _cse_406_ = ((_cse_407_ * max(_cse_410_, 0f)) / max(abs(_cse_410_), 0.00000001f));
        let _cse_405_ = (_cse_1613_ + _cse_406_);
        let _cse_415_ = (((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_414_ = (_cse_415_ - _cse_1622_);
        let _cse_413_ = ((_cse_414_ * abs((_cse_1619_ - _cse_1622_))) / max(abs((_cse_1619_ - _cse_1622_)), (abs(_cse_414_) + 0.00000001f)));
        let _cse_416_ = ((_cse_1619_ - _cse_1622_) * _cse_414_);
        let _cse_412_ = ((_cse_413_ * max(_cse_416_, 0f)) / max(abs(_cse_416_), 0.00000001f));
        let _cse_411_ = (_cse_1622_ + _cse_412_);
        let _cse_404_ = vec2<f32>(_cse_405_, _cse_411_);
        let _e2391 = normal_vec;
        let _cse_403_ = dot(_cse_404_, _e2391);
        let _cse_427_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_426_ = (_cse_427_ - _e181);
        let _cse_425_ = ((((_cse_426_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_426_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_426_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_426_)), 0.00000001f));
        let _cse_424_ = (_e181 + _cse_425_);
        let _e2438 = constants.eos_r;
        let _cse_423_ = ((_cse_424_ * _e2438) * (_e151 + ((((((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) + 0.00000001f))) * max(((s_own_T - _e151) * ((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)), 0f)) / max(abs(((s_own_T - _e151) * ((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))), 0.00000001f))));
        let _e2549 = constants.eos_gamma;
        let _cse_422_ = (_e2549 * _cse_423_);
        let _cse_421_ = (_cse_422_ / _cse_424_);
        let _e2554 = constants.eos_dp_drho;
        let _cse_420_ = (_cse_421_ + _e2554);
        let _cse_430_ = (_cse_403_ * _cse_403_);
        let _cse_429_ = min(_cse_430_, _cse_420_);
        let _e2560 = low_mach_params.model;
        let _cse_428_ = (max(0f, (1f - abs(f32(_e2560)))) * _cse_429_);
        let _e2570 = low_mach_params.model;
        let _cse_419_ = ((max(0f, (1f - abs((f32(_e2570) - 2f)))) * _cse_420_) + _cse_428_);
        let _e2583 = low_mach_params.theta_floor;
        let _cse_433_ = max(_cse_430_, (_e2583 * _cse_420_));
        let _cse_432_ = min(_cse_433_, _cse_420_);
        let _e2589 = low_mach_params.model;
        let _cse_431_ = (max(0f, (1f - abs((f32(_e2589) - 1f)))) * _cse_432_);
        let _cse_418_ = (_cse_419_ + _cse_431_);
        let _cse_417_ = sqrt(_cse_418_);
        a_plus = max(0f, max((_cse_370_ + _cse_386_), (_cse_403_ + _cse_417_)));
        a_minus = min(0f, min((_cse_370_ - _cse_386_), (_cse_403_ - _cse_417_)));
    }
    let _e2611 = a_plus;
    let _e2612 = a_minus;
    let denom = max((_e2611 - _e2612), 0.000001f);
    let _e2618 = low_mach_params.model;
    let _cse_439_ = (f32(_e2618) - 2f);
    let _cse_438_ = abs(_cse_439_);
    let _cse_437_ = (1f - _cse_438_);
    let _cse_436_ = max(0f, _cse_437_);
    let _cse_435_ = (1f - _cse_436_);
    let _e2631 = low_mach_params.pressure_coupling_alpha;
    let _cse_434_ = (_cse_435_ * _e2631);
    let _e2635 = constants.eos_r;
    let _cse_440_ = ((s_own_rho * _e2635) * s_own_T);
    let _e2640 = constants.eos_r;
    let _cse_441_ = ((_e181 * _e2640) * _e151);
    let _e2646 = constants.eos_gamma;
    let _e2651 = constants.eos_dp_drho;
    u_l_0_ = (s_own_rho + ((_cse_434_ * _cse_440_) / max((((_e2646 * _cse_440_) / s_own_rho) + _e2651), 0.000000000001f)));
    let _e2661 = constants.eos_gamma;
    let _e2666 = constants.eos_dp_drho;
    u_r_0_ = (_e181 + ((_cse_434_ * _cse_441_) / max((((_e2661 * _cse_441_) / _e181) + _e2666), 0.000000000001f)));
    let _e2674 = normal_vec;
    f_l_0_ = (s_own_rho * dot(vec2<f32>(_cse_1610_, _cse_1619_), _e2674));
    let _e2679 = normal_vec;
    f_r_0_ = (_e181 * dot(vec2<f32>(_cse_1613_, _cse_1622_), _e2679));
    let _e2685 = constants.scheme;
    if ((_e2685 == 1u) && !(is_boundary_1)) {
        let _cse_447_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_446_ = max(_cse_447_, 0.000000000001f);
        let _cse_445_ = ((_e181 - s_own_rho) / _cse_446_);
        let _cse_444_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_445_);
        let _cse_443_ = dot(_cse_444_, (face_center_vec - c_owner_vec));
        let _cse_442_ = (s_own_rho + _cse_443_);
        let _e2704 = low_mach_params.model;
        let _cse_453_ = (f32(_e2704) - 2f);
        let _cse_452_ = abs(_cse_453_);
        let _cse_451_ = (1f - _cse_452_);
        let _cse_450_ = max(0f, _cse_451_);
        let _cse_449_ = (1f - _cse_450_);
        let _e2717 = low_mach_params.pressure_coupling_alpha;
        let _cse_448_ = (_cse_449_ * _e2717);
        let _e2721 = constants.eos_r;
        let _cse_455_ = (_cse_442_ * _e2721);
        let _cse_459_ = ((_e151 - s_own_T) / _cse_446_);
        let _cse_458_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_459_);
        let _cse_457_ = dot(_cse_458_, (face_center_vec - c_owner_vec));
        let _cse_456_ = (s_own_T + _cse_457_);
        let _cse_454_ = (_cse_455_ * _cse_456_);
        let _cse_465_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_464_ = max(_cse_465_, 0.000000000001f);
        let _cse_463_ = ((s_own_rho - _e181) / _cse_464_);
        let _cse_462_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_463_);
        let _cse_461_ = dot(_cse_462_, (face_center_vec - c_neigh_cell_vec));
        let _cse_460_ = (_e181 + _cse_461_);
        let _e2745 = constants.eos_r;
        let _cse_467_ = (_cse_460_ * _e2745);
        let _cse_471_ = ((s_own_T - _e151) / _cse_464_);
        let _cse_470_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_471_);
        let _cse_469_ = dot(_cse_470_, (face_center_vec - c_neigh_cell_vec));
        let _cse_468_ = (_e151 + _cse_469_);
        let _cse_466_ = (_cse_467_ * _cse_468_);
        let _e2758 = constants.eos_gamma;
        let _e2763 = constants.eos_dp_drho;
        u_l_0_ = (_cse_442_ + ((_cse_448_ * _cse_454_) / max((((_e2758 * _cse_454_) / _cse_442_) + _e2763), 0.000000000001f)));
        let _e2772 = constants.eos_gamma;
        let _e2777 = constants.eos_dp_drho;
        u_r_0_ = (_cse_460_ + ((_cse_448_ * _cse_466_) / max((((_e2772 * _cse_466_) / _cse_460_) + _e2777), 0.000000000001f)));
        let _e2800 = normal_vec;
        f_l_0_ = (_cse_442_ * dot(vec2<f32>((_cse_1610_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_446_)), (face_center_vec - c_owner_vec))), (_cse_1619_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_446_)), (face_center_vec - c_owner_vec)))), _e2800));
        let _e2820 = normal_vec;
        f_r_0_ = (_cse_460_ * dot(vec2<f32>((_cse_1613_ + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_464_)), (face_center_vec - c_neigh_cell_vec))), (_cse_1622_ + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_464_)), (face_center_vec - c_neigh_cell_vec)))), _e2820));
    }
    let _e2825 = constants.scheme;
    if ((_e2825 == 2u) && !(is_boundary_1)) {
        let _cse_479_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_485_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_484_ = max(_cse_485_, 0.000000000001f);
        let _cse_483_ = ((_e181 - s_own_rho) / _cse_484_);
        let _cse_482_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_483_);
        let _cse_481_ = dot(_cse_482_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_480_ = (_cse_481_ * 0.125f);
        let _cse_478_ = (_cse_479_ + _cse_480_);
        let _cse_477_ = (_cse_478_ - s_own_rho);
        let _cse_476_ = (s_own_rho + _cse_477_);
        let _e2853 = low_mach_params.model;
        let _cse_491_ = (f32(_e2853) - 2f);
        let _cse_490_ = abs(_cse_491_);
        let _cse_489_ = (1f - _cse_490_);
        let _cse_488_ = max(0f, _cse_489_);
        let _cse_487_ = (1f - _cse_488_);
        let _e2866 = low_mach_params.pressure_coupling_alpha;
        let _cse_486_ = (_cse_487_ * _e2866);
        let _e2870 = constants.eos_r;
        let _cse_493_ = (_cse_476_ * _e2870);
        let _cse_497_ = ((s_own_T * 0.625f) + (_e151 * 0.375f));
        let _cse_501_ = ((_e151 - s_own_T) / _cse_484_);
        let _cse_500_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_501_);
        let _cse_499_ = dot(_cse_500_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_498_ = (_cse_499_ * 0.125f);
        let _cse_496_ = (_cse_497_ + _cse_498_);
        let _cse_495_ = (_cse_496_ - s_own_T);
        let _cse_494_ = (s_own_T + _cse_495_);
        let _cse_492_ = (_cse_493_ * _cse_494_);
        let _cse_505_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_511_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_510_ = max(_cse_511_, 0.000000000001f);
        let _cse_509_ = ((s_own_rho - _e181) / _cse_510_);
        let _cse_508_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_509_);
        let _cse_507_ = dot(_cse_508_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_506_ = (_cse_507_ * 0.125f);
        let _cse_504_ = (_cse_505_ + _cse_506_);
        let _cse_503_ = (_cse_504_ - _e181);
        let _cse_502_ = (_e181 + _cse_503_);
        let _e2912 = constants.eos_r;
        let _cse_513_ = (_cse_502_ * _e2912);
        let _cse_517_ = ((_e151 * 0.625f) + (s_own_T * 0.375f));
        let _cse_521_ = ((s_own_T - _e151) / _cse_510_);
        let _cse_520_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_521_);
        let _cse_519_ = dot(_cse_520_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_518_ = (_cse_519_ * 0.125f);
        let _cse_516_ = (_cse_517_ + _cse_518_);
        let _cse_515_ = (_cse_516_ - _e151);
        let _cse_514_ = (_e151 + _cse_515_);
        let _cse_512_ = (_cse_513_ * _cse_514_);
        let _e2934 = constants.eos_gamma;
        let _e2939 = constants.eos_dp_drho;
        u_l_0_ = (_cse_476_ + ((_cse_486_ * _cse_492_) / max((((_e2934 * _cse_492_) / _cse_476_) + _e2939), 0.000000000001f)));
        let _e2948 = constants.eos_gamma;
        let _e2953 = constants.eos_dp_drho;
        u_r_0_ = (_cse_502_ + ((_cse_486_ * _cse_512_) / max((((_e2948 * _cse_512_) / _cse_502_) + _e2953), 0.000000000001f)));
        let _e2994 = normal_vec;
        f_l_0_ = (_cse_476_ * dot(vec2<f32>(((((_cse_1610_ + (_cse_1610_ * 0.625f)) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_484_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1610_), ((((_cse_1619_ + (_cse_1619_ * 0.625f)) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_484_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1619_)), _e2994));
        let _e3032 = normal_vec;
        f_r_0_ = (_cse_502_ * dot(vec2<f32>(((((_cse_1613_ + (_cse_1613_ * 0.625f)) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_510_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1613_), ((((_cse_1622_ + (_cse_1622_ * 0.625f)) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_510_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1622_)), _e3032));
    }
    let _e3037 = constants.scheme;
    if ((_e3037 == 3u) && !(is_boundary_1)) {
        let _cse_533_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_532_ = max(_cse_533_, 0.000000000001f);
        let _cse_531_ = ((_e181 - s_own_rho) / _cse_532_);
        let _cse_530_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_531_);
        let _cse_529_ = dot(_cse_530_, (face_center_vec - c_owner_vec));
        let _cse_534_ = min((_e181 - s_own_rho), 0f);
        let _cse_528_ = max(_cse_529_, _cse_534_);
        let _cse_535_ = max((_e181 - s_own_rho), 0f);
        let _cse_527_ = min(_cse_528_, _cse_535_);
        let _cse_526_ = (s_own_rho + _cse_527_);
        let _e3064 = low_mach_params.model;
        let _cse_541_ = (f32(_e3064) - 2f);
        let _cse_540_ = abs(_cse_541_);
        let _cse_539_ = (1f - _cse_540_);
        let _cse_538_ = max(0f, _cse_539_);
        let _cse_537_ = (1f - _cse_538_);
        let _e3077 = low_mach_params.pressure_coupling_alpha;
        let _cse_536_ = (_cse_537_ * _e3077);
        let _e3081 = constants.eos_r;
        let _cse_543_ = (_cse_526_ * _e3081);
        let _cse_549_ = ((_e151 - s_own_T) / _cse_532_);
        let _cse_548_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_549_);
        let _cse_547_ = dot(_cse_548_, (face_center_vec - c_owner_vec));
        let _cse_550_ = min((_e151 - s_own_T), 0f);
        let _cse_546_ = max(_cse_547_, _cse_550_);
        let _cse_551_ = max((_e151 - s_own_T), 0f);
        let _cse_545_ = min(_cse_546_, _cse_551_);
        let _cse_544_ = (s_own_T + _cse_545_);
        let _cse_542_ = (_cse_543_ * _cse_544_);
        let _cse_559_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_558_ = max(_cse_559_, 0.000000000001f);
        let _cse_557_ = ((s_own_rho - _e181) / _cse_558_);
        let _cse_556_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_557_);
        let _cse_555_ = dot(_cse_556_, (face_center_vec - c_neigh_cell_vec));
        let _cse_560_ = min((s_own_rho - _e181), 0f);
        let _cse_554_ = max(_cse_555_, _cse_560_);
        let _cse_561_ = max((s_own_rho - _e181), 0f);
        let _cse_553_ = min(_cse_554_, _cse_561_);
        let _cse_552_ = (_e181 + _cse_553_);
        let _e3121 = constants.eos_r;
        let _cse_563_ = (_cse_552_ * _e3121);
        let _cse_569_ = ((s_own_T - _e151) / _cse_558_);
        let _cse_568_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_569_);
        let _cse_567_ = dot(_cse_568_, (face_center_vec - c_neigh_cell_vec));
        let _cse_570_ = min((s_own_T - _e151), 0f);
        let _cse_566_ = max(_cse_567_, _cse_570_);
        let _cse_571_ = max((s_own_T - _e151), 0f);
        let _cse_565_ = min(_cse_566_, _cse_571_);
        let _cse_564_ = (_e151 + _cse_565_);
        let _cse_562_ = (_cse_563_ * _cse_564_);
        let _cse_573_ = (_cse_1613_ - _cse_1610_);
        let _cse_576_ = (_cse_1622_ - _cse_1619_);
        let _cse_578_ = (_cse_1610_ - _cse_1613_);
        let _cse_579_ = (_cse_1619_ - _cse_1622_);
        let _e3146 = constants.eos_gamma;
        let _e3151 = constants.eos_dp_drho;
        u_l_0_ = (_cse_526_ + ((_cse_536_ * _cse_542_) / max((((_e3146 * _cse_542_) / _cse_526_) + _e3151), 0.000000000001f)));
        let _e3160 = constants.eos_gamma;
        let _e3165 = constants.eos_dp_drho;
        u_r_0_ = (_cse_552_ + ((_cse_536_ * _cse_562_) / max((((_e3160 * _cse_562_) / _cse_552_) + _e3165), 0.000000000001f)));
        let _e3198 = normal_vec;
        f_l_0_ = (_cse_526_ * dot(vec2<f32>((_cse_1610_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_573_) / vec2(_cse_532_)), (face_center_vec - c_owner_vec)), min(_cse_573_, 0f)), max(_cse_573_, 0f))), (_cse_1619_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_576_) / vec2(_cse_532_)), (face_center_vec - c_owner_vec)), min(_cse_576_, 0f)), max(_cse_576_, 0f)))), _e3198));
        let _e3228 = normal_vec;
        f_r_0_ = (_cse_552_ * dot(vec2<f32>((_cse_1613_ + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_578_) / vec2(_cse_558_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_578_, 0f)), max(_cse_578_, 0f))), (_cse_1622_ + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_579_) / vec2(_cse_558_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_579_, 0f)), max(_cse_579_, 0f)))), _e3228));
    }
    let _e3233 = constants.scheme;
    if ((_e3233 == 4u) && !(is_boundary_1)) {
        let _cse_587_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_586_ = max(_cse_587_, 0.000000000001f);
        let _cse_585_ = ((_e181 - s_own_rho) / _cse_586_);
        let _cse_584_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_585_);
        let _cse_583_ = dot(_cse_584_, (face_center_vec - c_owner_vec));
        let _cse_591_ = abs(_cse_583_);
        let _cse_590_ = (_cse_591_ + 0.00000001f);
        let _cse_589_ = max(abs((_e181 - s_own_rho)), _cse_590_);
        let _cse_588_ = (abs((_e181 - s_own_rho)) / _cse_589_);
        let _cse_582_ = (_cse_583_ * _cse_588_);
        let _cse_594_ = ((_e181 - s_own_rho) * _cse_583_);
        let _cse_593_ = max(_cse_594_, 0f);
        let _cse_596_ = abs(_cse_594_);
        let _cse_595_ = max(_cse_596_, 0.00000001f);
        let _cse_592_ = (_cse_593_ / _cse_595_);
        let _cse_581_ = (_cse_582_ * _cse_592_);
        let _cse_580_ = (s_own_rho + _cse_581_);
        let _e3271 = constants.eos_r;
        let _cse_598_ = (_cse_580_ * _e3271);
        let _cse_603_ = ((_e151 - s_own_T) / _cse_586_);
        let _cse_602_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_603_);
        let _cse_601_ = dot(_cse_602_, (face_center_vec - c_owner_vec));
        let _cse_600_ = ((((_cse_601_ * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(_cse_601_) + 0.00000001f))) * max(((_e151 - s_own_T) * _cse_601_), 0f)) / max(abs(((_e151 - s_own_T) * _cse_601_)), 0.00000001f));
        let _cse_599_ = (s_own_T + _cse_600_);
        let _cse_597_ = (_cse_598_ * _cse_599_);
        let _cse_611_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_610_ = max(_cse_611_, 0.000000000001f);
        let _cse_609_ = ((s_own_rho - _e181) / _cse_610_);
        let _cse_608_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_609_);
        let _cse_607_ = dot(_cse_608_, (face_center_vec - c_neigh_cell_vec));
        let _cse_615_ = abs(_cse_607_);
        let _cse_614_ = (_cse_615_ + 0.00000001f);
        let _cse_613_ = max(abs((s_own_rho - _e181)), _cse_614_);
        let _cse_612_ = (abs((s_own_rho - _e181)) / _cse_613_);
        let _cse_606_ = (_cse_607_ * _cse_612_);
        let _cse_618_ = ((s_own_rho - _e181) * _cse_607_);
        let _cse_617_ = max(_cse_618_, 0f);
        let _cse_620_ = abs(_cse_618_);
        let _cse_619_ = max(_cse_620_, 0.00000001f);
        let _cse_616_ = (_cse_617_ / _cse_619_);
        let _cse_605_ = (_cse_606_ * _cse_616_);
        let _cse_604_ = (_e181 + _cse_605_);
        let _e3335 = constants.eos_r;
        let _cse_622_ = (_cse_604_ * _e3335);
        let _cse_627_ = ((s_own_T - _e151) / _cse_610_);
        let _cse_626_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_627_);
        let _cse_625_ = dot(_cse_626_, (face_center_vec - c_neigh_cell_vec));
        let _cse_624_ = ((((_cse_625_ * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(_cse_625_) + 0.00000001f))) * max(((s_own_T - _e151) * _cse_625_), 0f)) / max(abs(((s_own_T - _e151) * _cse_625_)), 0.00000001f));
        let _cse_623_ = (_e151 + _cse_624_);
        let _cse_621_ = (_cse_622_ * _cse_623_);
        let _cse_631_ = (_cse_1613_ - _cse_1610_);
        let _cse_630_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_631_) / vec2(_cse_586_));
        let _cse_629_ = dot(_cse_630_, (face_center_vec - c_owner_vec));
        let _cse_636_ = (_cse_1622_ - _cse_1619_);
        let _cse_635_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_636_) / vec2(_cse_586_));
        let _cse_634_ = dot(_cse_635_, (face_center_vec - c_owner_vec));
        let _cse_640_ = (_cse_1610_ - _cse_1613_);
        let _cse_639_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_640_) / vec2(_cse_610_));
        let _cse_638_ = dot(_cse_639_, (face_center_vec - c_neigh_cell_vec));
        let _cse_643_ = (_cse_1619_ - _cse_1622_);
        let _cse_642_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_643_) / vec2(_cse_610_));
        let _cse_641_ = dot(_cse_642_, (face_center_vec - c_neigh_cell_vec));
        let _e3396 = low_mach_params.model;
        let _e3409 = low_mach_params.pressure_coupling_alpha;
        let _e3414 = constants.eos_gamma;
        let _e3419 = constants.eos_dp_drho;
        u_l_0_ = (_cse_580_ + ((((1f - max(0f, (1f - abs((f32(_e3396) - 2f))))) * _e3409) * _cse_597_) / max((((_e3414 * _cse_597_) / _cse_580_) + _e3419), 0.000000000001f)));
        let _e3427 = low_mach_params.model;
        let _e3440 = low_mach_params.pressure_coupling_alpha;
        let _e3445 = constants.eos_gamma;
        let _e3450 = constants.eos_dp_drho;
        u_r_0_ = (_cse_604_ + ((((1f - max(0f, (1f - abs((f32(_e3427) - 2f))))) * _e3440) * _cse_621_) / max((((_e3445 * _cse_621_) / _cse_604_) + _e3450), 0.000000000001f)));
        let _e3493 = normal_vec;
        f_l_0_ = (_cse_580_ * dot(vec2<f32>((_cse_1610_ + ((((_cse_629_ * abs(_cse_631_)) / max(abs(_cse_631_), (abs(_cse_629_) + 0.00000001f))) * max((_cse_631_ * _cse_629_), 0f)) / max(abs((_cse_631_ * _cse_629_)), 0.00000001f))), (_cse_1619_ + ((((_cse_634_ * abs(_cse_636_)) / max(abs(_cse_636_), (abs(_cse_634_) + 0.00000001f))) * max((_cse_636_ * _cse_634_), 0f)) / max(abs((_cse_636_ * _cse_634_)), 0.00000001f)))), _e3493));
        let _e3533 = normal_vec;
        f_r_0_ = (_cse_604_ * dot(vec2<f32>((_cse_1613_ + ((((_cse_638_ * abs(_cse_640_)) / max(abs(_cse_640_), (abs(_cse_638_) + 0.00000001f))) * max((_cse_640_ * _cse_638_), 0f)) / max(abs((_cse_640_ * _cse_638_)), 0.00000001f))), (_cse_1622_ + ((((_cse_641_ * abs(_cse_643_)) / max(abs(_cse_643_), (abs(_cse_641_) + 0.00000001f))) * max((_cse_643_ * _cse_641_), 0f)) / max(abs((_cse_643_ * _cse_641_)), 0.00000001f)))), _e3533));
    }
    let _e3538 = constants.scheme;
    if ((_e3538 == 5u) && !(is_boundary_1)) {
        let _cse_649_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_655_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_654_ = max(_cse_655_, 0.000000000001f);
        let _cse_653_ = ((_e181 - s_own_rho) / _cse_654_);
        let _cse_652_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_653_);
        let _cse_651_ = dot(_cse_652_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_650_ = (_cse_651_ * 0.125f);
        let _cse_648_ = (_cse_649_ + _cse_650_);
        let _cse_647_ = (_cse_648_ - s_own_rho);
        let _cse_656_ = min((_e181 - s_own_rho), 0f);
        let _cse_646_ = max(_cse_647_, _cse_656_);
        let _cse_657_ = max((_e181 - s_own_rho), 0f);
        let _cse_645_ = min(_cse_646_, _cse_657_);
        let _cse_644_ = (s_own_rho + _cse_645_);
        let _e3574 = low_mach_params.model;
        let _cse_662_ = abs((f32(_e3574) - 2f));
        let _cse_661_ = (1f - _cse_662_);
        let _cse_660_ = max(0f, _cse_661_);
        let _cse_659_ = (1f - _cse_660_);
        let _e3587 = low_mach_params.pressure_coupling_alpha;
        let _cse_658_ = (_cse_659_ * _e3587);
        let _e3591 = constants.eos_r;
        let _cse_664_ = (_cse_644_ * _e3591);
        let _cse_670_ = ((s_own_T * 0.625f) + (_e151 * 0.375f));
        let _cse_674_ = ((_e151 - s_own_T) / _cse_654_);
        let _cse_673_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_674_);
        let _cse_672_ = dot(_cse_673_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_671_ = (_cse_672_ * 0.125f);
        let _cse_669_ = (_cse_670_ + _cse_671_);
        let _cse_668_ = (_cse_669_ - s_own_T);
        let _cse_667_ = max(_cse_668_, min((_e151 - s_own_T), 0f));
        let _cse_666_ = min(_cse_667_, max((_e151 - s_own_T), 0f));
        let _cse_665_ = (s_own_T + _cse_666_);
        let _cse_663_ = (_cse_664_ * _cse_665_);
        let _cse_680_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_686_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_685_ = max(_cse_686_, 0.000000000001f);
        let _cse_684_ = ((s_own_rho - _e181) / _cse_685_);
        let _cse_683_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_684_);
        let _cse_682_ = dot(_cse_683_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_681_ = (_cse_682_ * 0.125f);
        let _cse_679_ = (_cse_680_ + _cse_681_);
        let _cse_678_ = (_cse_679_ - _e181);
        let _cse_687_ = min((s_own_rho - _e181), 0f);
        let _cse_677_ = max(_cse_678_, _cse_687_);
        let _cse_688_ = max((s_own_rho - _e181), 0f);
        let _cse_676_ = min(_cse_677_, _cse_688_);
        let _cse_675_ = (_e181 + _cse_676_);
        let _e3649 = constants.eos_r;
        let _cse_690_ = (_cse_675_ * _e3649);
        let _cse_699_ = ((s_own_T - _e151) / _cse_685_);
        let _cse_698_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_699_);
        let _cse_697_ = dot(_cse_698_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_696_ = (_cse_697_ * 0.125f);
        let _cse_695_ = (((_e151 * 0.625f) + (s_own_T * 0.375f)) + _cse_696_);
        let _cse_694_ = (_cse_695_ - _e151);
        let _cse_693_ = max(_cse_694_, min((s_own_T - _e151), 0f));
        let _cse_692_ = min(_cse_693_, max((s_own_T - _e151), 0f));
        let _cse_691_ = (_e151 + _cse_692_);
        let _cse_689_ = (_cse_690_ * _cse_691_);
        let _cse_702_ = (_cse_1613_ - _cse_1610_);
        let _cse_705_ = (_cse_1622_ - _cse_1619_);
        let _cse_706_ = (_cse_1610_ - _cse_1613_);
        let _cse_707_ = (_cse_1619_ - _cse_1622_);
        let _e3683 = constants.eos_gamma;
        let _e3688 = constants.eos_dp_drho;
        u_l_0_ = (_cse_644_ + ((_cse_658_ * _cse_663_) / max((((_e3683 * _cse_663_) / _cse_644_) + _e3688), 0.000000000001f)));
        let _e3697 = constants.eos_gamma;
        let _e3702 = constants.eos_dp_drho;
        u_r_0_ = (_cse_675_ + ((_cse_658_ * _cse_689_) / max((((_e3697 * _cse_689_) / _cse_675_) + _e3702), 0.000000000001f)));
        let _e3753 = normal_vec;
        f_l_0_ = (_cse_644_ * dot(vec2<f32>((_cse_1610_ + min(max(((((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_702_) / vec2(_cse_654_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1610_), min(_cse_702_, 0f)), max(_cse_702_, 0f))), (_cse_1619_ + min(max(((((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_705_) / vec2(_cse_654_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1619_), min(_cse_705_, 0f)), max(_cse_705_, 0f)))), _e3753));
        let _e3801 = normal_vec;
        f_r_0_ = (_cse_675_ * dot(vec2<f32>((_cse_1613_ + min(max(((((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_706_) / vec2(_cse_685_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1613_), min(_cse_706_, 0f)), max(_cse_706_, 0f))), (_cse_1622_ + min(max(((((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_707_) / vec2(_cse_685_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1622_), min(_cse_707_, 0f)), max(_cse_707_, 0f)))), _e3801));
    }
    let _e3806 = constants.scheme;
    if ((_e3806 == 6u) && !(is_boundary_1)) {
        let _cse_718_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_717_ = max(_cse_718_, 0.000000000001f);
        let _cse_716_ = ((_e181 - s_own_rho) / _cse_717_);
        let _cse_715_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_716_);
        let _cse_714_ = dot(_cse_715_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_713_ = (_cse_714_ * 0.125f);
        let _cse_712_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + _cse_713_);
        let _cse_711_ = (_cse_712_ - s_own_rho);
        let _cse_720_ = max(abs((_e181 - s_own_rho)), (abs(_cse_711_) + 0.00000001f));
        let _cse_719_ = (abs((_e181 - s_own_rho)) / _cse_720_);
        let _cse_710_ = (_cse_711_ * _cse_719_);
        let _cse_723_ = ((_e181 - s_own_rho) * _cse_711_);
        let _cse_722_ = max(_cse_723_, 0f);
        let _cse_725_ = abs(_cse_723_);
        let _cse_724_ = max(_cse_725_, 0.00000001f);
        let _cse_721_ = (_cse_722_ / _cse_724_);
        let _cse_709_ = (_cse_710_ * _cse_721_);
        let _cse_708_ = (s_own_rho + _cse_709_);
        let _e3853 = constants.eos_r;
        let _cse_727_ = (_cse_708_ * _e3853);
        let _cse_733_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_717_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_732_ = (_cse_733_ * 0.125f);
        let _cse_731_ = (((s_own_T * 0.625f) + (_e151 * 0.375f)) + _cse_732_);
        let _cse_730_ = (_cse_731_ - s_own_T);
        let _cse_729_ = ((((_cse_730_ * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(_cse_730_) + 0.00000001f))) * max(((_e151 - s_own_T) * _cse_730_), 0f)) / max(abs(((_e151 - s_own_T) * _cse_730_)), 0.00000001f));
        let _cse_728_ = (s_own_T + _cse_729_);
        let _cse_726_ = (_cse_727_ * _cse_728_);
        let _cse_744_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_743_ = max(_cse_744_, 0.000000000001f);
        let _cse_742_ = ((s_own_rho - _e181) / _cse_743_);
        let _cse_741_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_742_);
        let _cse_740_ = dot(_cse_741_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_739_ = (_cse_740_ * 0.125f);
        let _cse_738_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + _cse_739_);
        let _cse_737_ = (_cse_738_ - _e181);
        let _cse_746_ = max(abs((s_own_rho - _e181)), (abs(_cse_737_) + 0.00000001f));
        let _cse_745_ = (abs((s_own_rho - _e181)) / _cse_746_);
        let _cse_736_ = (_cse_737_ * _cse_745_);
        let _cse_749_ = ((s_own_rho - _e181) * _cse_737_);
        let _cse_748_ = max(_cse_749_, 0f);
        let _cse_751_ = abs(_cse_749_);
        let _cse_750_ = max(_cse_751_, 0.00000001f);
        let _cse_747_ = (_cse_748_ / _cse_750_);
        let _cse_735_ = (_cse_736_ * _cse_747_);
        let _cse_734_ = (_e181 + _cse_735_);
        let _e3936 = constants.eos_r;
        let _cse_753_ = (_cse_734_ * _e3936);
        let _cse_759_ = dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_743_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_758_ = (_cse_759_ * 0.125f);
        let _cse_757_ = (((_e151 * 0.625f) + (s_own_T * 0.375f)) + _cse_758_);
        let _cse_756_ = (_cse_757_ - _e151);
        let _cse_755_ = ((((_cse_756_ * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(_cse_756_) + 0.00000001f))) * max(((s_own_T - _e151) * _cse_756_), 0f)) / max(abs(((s_own_T - _e151) * _cse_756_)), 0.00000001f));
        let _cse_754_ = (_e151 + _cse_755_);
        let _cse_752_ = (_cse_753_ * _cse_754_);
        let _cse_762_ = (((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_717_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_761_ = (_cse_762_ - _cse_1610_);
        let _cse_766_ = (((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_717_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_765_ = (_cse_766_ - _cse_1619_);
        let _cse_769_ = (((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_743_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_768_ = (_cse_769_ - _cse_1613_);
        let _cse_771_ = (((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_743_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_770_ = (_cse_771_ - _cse_1622_);
        let _e4043 = low_mach_params.model;
        let _e4056 = low_mach_params.pressure_coupling_alpha;
        let _e4061 = constants.eos_gamma;
        let _e4066 = constants.eos_dp_drho;
        u_l_0_ = (_cse_708_ + ((((1f - max(0f, (1f - abs((f32(_e4043) - 2f))))) * _e4056) * _cse_726_) / max((((_e4061 * _cse_726_) / _cse_708_) + _e4066), 0.000000000001f)));
        let _e4074 = low_mach_params.model;
        let _e4087 = low_mach_params.pressure_coupling_alpha;
        let _e4092 = constants.eos_gamma;
        let _e4097 = constants.eos_dp_drho;
        u_r_0_ = (_cse_734_ + ((((1f - max(0f, (1f - abs((f32(_e4074) - 2f))))) * _e4087) * _cse_752_) / max((((_e4092 * _cse_752_) / _cse_734_) + _e4097), 0.000000000001f)));
        let _e4148 = normal_vec;
        f_l_0_ = (_cse_708_ * dot(vec2<f32>((_cse_1610_ + ((((_cse_761_ * abs((_cse_1613_ - _cse_1610_))) / max(abs((_cse_1613_ - _cse_1610_)), (abs(_cse_761_) + 0.00000001f))) * max(((_cse_1613_ - _cse_1610_) * _cse_761_), 0f)) / max(abs(((_cse_1613_ - _cse_1610_) * _cse_761_)), 0.00000001f))), (_cse_1619_ + ((((_cse_765_ * abs((_cse_1622_ - _cse_1619_))) / max(abs((_cse_1622_ - _cse_1619_)), (abs(_cse_765_) + 0.00000001f))) * max(((_cse_1622_ - _cse_1619_) * _cse_765_), 0f)) / max(abs(((_cse_1622_ - _cse_1619_) * _cse_765_)), 0.00000001f)))), _e4148));
        let _e4196 = normal_vec;
        f_r_0_ = (_cse_734_ * dot(vec2<f32>((_cse_1613_ + ((((_cse_768_ * abs((_cse_1610_ - _cse_1613_))) / max(abs((_cse_1610_ - _cse_1613_)), (abs(_cse_768_) + 0.00000001f))) * max(((_cse_1610_ - _cse_1613_) * _cse_768_), 0f)) / max(abs(((_cse_1610_ - _cse_1613_) * _cse_768_)), 0.00000001f))), (_cse_1622_ + ((((_cse_770_ * abs((_cse_1619_ - _cse_1622_))) / max(abs((_cse_1619_ - _cse_1622_)), (abs(_cse_770_) + 0.00000001f))) * max(((_cse_1619_ - _cse_1622_) * _cse_770_), 0f)) / max(abs(((_cse_1619_ - _cse_1622_) * _cse_770_)), 0.00000001f)))), _e4196));
    }
    let _e4205 = a_plus;
    let _e4206 = f_l_0_;
    let _e4208 = a_minus;
    let _e4209 = f_r_0_;
    let _e4212 = a_plus;
    let _e4213 = a_minus;
    let _e4215 = u_r_0_;
    let _e4216 = u_l_0_;
    fluxes[((idx * 8u) + 0u)] = (((((_e4205 * _e4206) - (_e4208 * _e4209)) + ((_e4212 * _e4213) * (_e4215 - _e4216))) / denom) * area);
    let _cse_772_ = (s_own_rho * _cse_1610_);
    let _cse_774_ = (_e181 * _cse_1613_);
    let _cse_776_ = normal_vec.x;
    u_l_1_ = _cse_772_;
    u_r_1_ = _cse_774_;
    let _e4229 = normal_vec;
    let _e4234 = constants.eos_r;
    f_l_1_ = ((_cse_772_ * dot(vec2<f32>(_cse_1610_, _cse_1619_), _e4229)) + (((s_own_rho * _e4234) * s_own_T) * _cse_776_));
    let _e4241 = normal_vec;
    let _e4246 = constants.eos_r;
    f_r_1_ = ((_cse_774_ * dot(vec2<f32>(_cse_1613_, _cse_1622_), _e4241)) + (((_e181 * _e4246) * _e151) * _cse_776_));
    let _e4254 = constants.scheme;
    if ((_e4254 == 1u) && !(is_boundary_1)) {
        let _cse_783_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_782_ = max(_cse_783_, 0.000000000001f);
        let _cse_781_ = ((_e181 - s_own_rho) / _cse_782_);
        let _cse_780_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_781_);
        let _cse_779_ = dot(_cse_780_, (face_center_vec - c_owner_vec));
        let _cse_778_ = (s_own_rho + _cse_779_);
        let _cse_789_ = (_cse_1613_ - _cse_1610_);
        let _cse_788_ = (_cse_789_ / _cse_782_);
        let _cse_787_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_788_);
        let _cse_786_ = dot(_cse_787_, (face_center_vec - c_owner_vec));
        let _cse_784_ = (_cse_1610_ + _cse_786_);
        let _cse_777_ = (_cse_778_ * _cse_784_);
        let _cse_797_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_796_ = max(_cse_797_, 0.000000000001f);
        let _cse_795_ = ((s_own_rho - _e181) / _cse_796_);
        let _cse_794_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_795_);
        let _cse_793_ = dot(_cse_794_, (face_center_vec - c_neigh_cell_vec));
        let _cse_792_ = (_e181 + _cse_793_);
        let _cse_802_ = (_cse_1610_ - _cse_1613_);
        let _cse_801_ = (_cse_802_ / _cse_796_);
        let _cse_800_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_801_);
        let _cse_799_ = dot(_cse_800_, (face_center_vec - c_neigh_cell_vec));
        let _cse_798_ = (_cse_1613_ + _cse_799_);
        let _cse_791_ = (_cse_792_ * _cse_798_);
        let _cse_805_ = normal_vec.x;
        u_l_1_ = _cse_777_;
        u_r_1_ = _cse_791_;
        let _e4310 = normal_vec;
        let _e4315 = constants.eos_r;
        f_l_1_ = ((_cse_777_ * dot(vec2<f32>(_cse_784_, (_cse_1619_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_782_)), (face_center_vec - c_owner_vec)))), _e4310)) + (((_cse_778_ * _e4315) * (s_own_T + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_782_)), (face_center_vec - c_owner_vec)))) * _cse_805_));
        let _e4337 = normal_vec;
        let _e4342 = constants.eos_r;
        f_r_1_ = ((_cse_791_ * dot(vec2<f32>(_cse_798_, (_cse_1622_ + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_796_)), (face_center_vec - c_neigh_cell_vec)))), _e4337)) + (((_cse_792_ * _e4342) * (_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_796_)), (face_center_vec - c_neigh_cell_vec)))) * _cse_805_));
    }
    let _e4357 = constants.scheme;
    if ((_e4357 == 2u) && !(is_boundary_1)) {
        let _cse_810_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_816_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_815_ = max(_cse_816_, 0.000000000001f);
        let _cse_814_ = ((_e181 - s_own_rho) / _cse_815_);
        let _cse_813_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_814_);
        let _cse_812_ = dot(_cse_813_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_811_ = (_cse_812_ * 0.125f);
        let _cse_809_ = (_cse_810_ + _cse_811_);
        let _cse_808_ = (_cse_809_ - s_own_rho);
        let _cse_807_ = (s_own_rho + _cse_808_);
        let _cse_822_ = (_cse_1610_ * 0.625f);
        let _cse_823_ = (_cse_1613_ * 0.375f);
        let _cse_821_ = (_cse_822_ + _cse_823_);
        let _cse_829_ = (_cse_1613_ - _cse_1610_);
        let _cse_828_ = (_cse_829_ / _cse_815_);
        let _cse_827_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_828_);
        let _cse_826_ = dot(_cse_827_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_825_ = (_cse_826_ * 0.125f);
        let _cse_820_ = (_cse_821_ + _cse_825_);
        let _cse_819_ = (_cse_820_ - _cse_1610_);
        let _cse_817_ = (_cse_1610_ + _cse_819_);
        let _cse_806_ = (_cse_807_ * _cse_817_);
        let _cse_834_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_840_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_839_ = max(_cse_840_, 0.000000000001f);
        let _cse_838_ = ((s_own_rho - _e181) / _cse_839_);
        let _cse_837_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_838_);
        let _cse_836_ = dot(_cse_837_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_835_ = (_cse_836_ * 0.125f);
        let _cse_833_ = (_cse_834_ + _cse_835_);
        let _cse_832_ = (_cse_833_ - _e181);
        let _cse_831_ = (_e181 + _cse_832_);
        let _cse_845_ = (_cse_1613_ * 0.625f);
        let _cse_846_ = (_cse_1610_ * 0.375f);
        let _cse_844_ = (_cse_845_ + _cse_846_);
        let _cse_851_ = (_cse_1610_ - _cse_1613_);
        let _cse_850_ = (_cse_851_ / _cse_839_);
        let _cse_849_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_850_);
        let _cse_848_ = dot(_cse_849_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_847_ = (_cse_848_ * 0.125f);
        let _cse_843_ = (_cse_844_ + _cse_847_);
        let _cse_842_ = (_cse_843_ - _cse_1613_);
        let _cse_841_ = (_cse_1613_ + _cse_842_);
        let _cse_830_ = (_cse_831_ * _cse_841_);
        let _cse_854_ = normal_vec.x;
        u_l_1_ = _cse_806_;
        u_r_1_ = _cse_830_;
        let _e4458 = normal_vec;
        let _e4463 = constants.eos_r;
        f_l_1_ = ((_cse_806_ * dot(vec2<f32>(_cse_817_, ((((_cse_1619_ + (_cse_1619_ * 0.625f)) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_815_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1619_)), _e4458)) + (((_cse_807_ * _e4463) * ((((s_own_T + (s_own_T * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_815_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)) * _cse_854_));
        let _e4503 = normal_vec;
        let _e4508 = constants.eos_r;
        f_r_1_ = ((_cse_830_ * dot(vec2<f32>(_cse_841_, ((((_cse_1622_ + (_cse_1622_ * 0.625f)) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_839_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1622_)), _e4503)) + (((_cse_831_ * _e4508) * ((((_e151 + (_e151 * 0.625f)) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_839_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) * _cse_854_));
    }
    let _e4532 = constants.scheme;
    if ((_e4532 == 3u) && !(is_boundary_1)) {
        let _cse_863_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_862_ = max(_cse_863_, 0.000000000001f);
        let _cse_861_ = ((_e181 - s_own_rho) / _cse_862_);
        let _cse_860_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_861_);
        let _cse_859_ = dot(_cse_860_, (face_center_vec - c_owner_vec));
        let _cse_864_ = min((_e181 - s_own_rho), 0f);
        let _cse_858_ = max(_cse_859_, _cse_864_);
        let _cse_865_ = max((_e181 - s_own_rho), 0f);
        let _cse_857_ = min(_cse_858_, _cse_865_);
        let _cse_856_ = (s_own_rho + _cse_857_);
        let _cse_873_ = (_cse_1613_ - _cse_1610_);
        let _cse_872_ = (_cse_873_ / _cse_862_);
        let _cse_871_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_872_);
        let _cse_870_ = dot(_cse_871_, (face_center_vec - c_owner_vec));
        let _cse_875_ = min(_cse_873_, 0f);
        let _cse_869_ = max(_cse_870_, _cse_875_);
        let _cse_876_ = max(_cse_873_, 0f);
        let _cse_868_ = min(_cse_869_, _cse_876_);
        let _cse_866_ = (_cse_1610_ + _cse_868_);
        let _cse_855_ = (_cse_856_ * _cse_866_);
        let _cse_885_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_884_ = max(_cse_885_, 0.000000000001f);
        let _cse_883_ = ((s_own_rho - _e181) / _cse_884_);
        let _cse_882_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_883_);
        let _cse_881_ = dot(_cse_882_, (face_center_vec - c_neigh_cell_vec));
        let _cse_886_ = min((s_own_rho - _e181), 0f);
        let _cse_880_ = max(_cse_881_, _cse_886_);
        let _cse_887_ = max((s_own_rho - _e181), 0f);
        let _cse_879_ = min(_cse_880_, _cse_887_);
        let _cse_878_ = (_e181 + _cse_879_);
        let _cse_894_ = (_cse_1610_ - _cse_1613_);
        let _cse_893_ = (_cse_894_ / _cse_884_);
        let _cse_892_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_893_);
        let _cse_891_ = dot(_cse_892_, (face_center_vec - c_neigh_cell_vec));
        let _cse_895_ = min(_cse_894_, 0f);
        let _cse_890_ = max(_cse_891_, _cse_895_);
        let _cse_896_ = max(_cse_894_, 0f);
        let _cse_889_ = min(_cse_890_, _cse_896_);
        let _cse_888_ = (_cse_1613_ + _cse_889_);
        let _cse_877_ = (_cse_878_ * _cse_888_);
        let _cse_898_ = (_cse_1622_ - _cse_1619_);
        let _cse_900_ = normal_vec.x;
        let _cse_901_ = (_cse_1619_ - _cse_1622_);
        u_l_1_ = _cse_855_;
        u_r_1_ = _cse_877_;
        let _e4623 = normal_vec;
        let _e4628 = constants.eos_r;
        f_l_1_ = ((_cse_855_ * dot(vec2<f32>(_cse_866_, (_cse_1619_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_898_) / vec2(_cse_862_)), (face_center_vec - c_owner_vec)), min(_cse_898_, 0f)), max(_cse_898_, 0f)))), _e4623)) + (((_cse_856_ * _e4628) * (s_own_T + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_862_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f)))) * _cse_900_));
        let _e4663 = normal_vec;
        let _e4668 = constants.eos_r;
        f_r_1_ = ((_cse_877_ * dot(vec2<f32>(_cse_888_, (_cse_1622_ + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_901_) / vec2(_cse_884_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_901_, 0f)), max(_cse_901_, 0f)))), _e4663)) + (((_cse_878_ * _e4668) * (_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_884_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f)))) * _cse_900_));
    }
    let _e4691 = constants.scheme;
    if ((_e4691 == 4u) && !(is_boundary_1)) {
        let _cse_910_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_909_ = max(_cse_910_, 0.000000000001f);
        let _cse_908_ = ((_e181 - s_own_rho) / _cse_909_);
        let _cse_907_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_908_);
        let _cse_906_ = dot(_cse_907_, (face_center_vec - c_owner_vec));
        let _cse_905_ = ((_cse_906_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_906_) + 0.00000001f)));
        let _cse_912_ = ((_e181 - s_own_rho) * _cse_906_);
        let _cse_911_ = (max(_cse_912_, 0f) / max(abs(_cse_912_), 0.00000001f));
        let _cse_904_ = (_cse_905_ * _cse_911_);
        let _cse_903_ = (s_own_rho + _cse_904_);
        let _cse_920_ = (_cse_1613_ - _cse_1610_);
        let _cse_919_ = (_cse_920_ / _cse_909_);
        let _cse_918_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_919_);
        let _cse_917_ = dot(_cse_918_, (face_center_vec - c_owner_vec));
        let _cse_923_ = abs(_cse_920_);
        let _cse_924_ = max(_cse_923_, (abs(_cse_917_) + 0.00000001f));
        let _cse_922_ = (_cse_923_ / _cse_924_);
        let _cse_916_ = (_cse_917_ * _cse_922_);
        let _cse_927_ = (_cse_920_ * _cse_917_);
        let _cse_926_ = max(_cse_927_, 0f);
        let _cse_929_ = abs(_cse_927_);
        let _cse_928_ = max(_cse_929_, 0.00000001f);
        let _cse_925_ = (_cse_926_ / _cse_928_);
        let _cse_915_ = (_cse_916_ * _cse_925_);
        let _cse_913_ = (_cse_1610_ + _cse_915_);
        let _cse_902_ = (_cse_903_ * _cse_913_);
        let _cse_938_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_937_ = max(_cse_938_, 0.000000000001f);
        let _cse_936_ = ((s_own_rho - _e181) / _cse_937_);
        let _cse_935_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_936_);
        let _cse_934_ = dot(_cse_935_, (face_center_vec - c_neigh_cell_vec));
        let _cse_933_ = ((_cse_934_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_934_) + 0.00000001f)));
        let _cse_940_ = ((s_own_rho - _e181) * _cse_934_);
        let _cse_939_ = (max(_cse_940_, 0f) / max(abs(_cse_940_), 0.00000001f));
        let _cse_932_ = (_cse_933_ * _cse_939_);
        let _cse_931_ = (_e181 + _cse_932_);
        let _cse_947_ = (_cse_1610_ - _cse_1613_);
        let _cse_946_ = (_cse_947_ / _cse_937_);
        let _cse_945_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_946_);
        let _cse_944_ = dot(_cse_945_, (face_center_vec - c_neigh_cell_vec));
        let _cse_949_ = abs(_cse_947_);
        let _cse_950_ = max(_cse_949_, (abs(_cse_944_) + 0.00000001f));
        let _cse_948_ = (_cse_949_ / _cse_950_);
        let _cse_943_ = (_cse_944_ * _cse_948_);
        let _cse_953_ = (_cse_947_ * _cse_944_);
        let _cse_952_ = max(_cse_953_, 0f);
        let _cse_955_ = abs(_cse_953_);
        let _cse_954_ = max(_cse_955_, 0.00000001f);
        let _cse_951_ = (_cse_952_ / _cse_954_);
        let _cse_942_ = (_cse_943_ * _cse_951_);
        let _cse_941_ = (_cse_1613_ + _cse_942_);
        let _cse_930_ = (_cse_931_ * _cse_941_);
        let _cse_960_ = (_cse_1622_ - _cse_1619_);
        let _cse_959_ = (_cse_960_ / _cse_909_);
        let _cse_958_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_959_);
        let _cse_957_ = dot(_cse_958_, (face_center_vec - c_owner_vec));
        let _cse_965_ = (_cse_1619_ - _cse_1622_);
        let _cse_964_ = (_cse_965_ / _cse_937_);
        let _cse_963_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_964_);
        let _cse_962_ = dot(_cse_963_, (face_center_vec - c_neigh_cell_vec));
        u_l_1_ = _cse_902_;
        u_r_1_ = _cse_930_;
        let _e4835 = normal_vec;
        let _e4840 = constants.eos_r;
        let _e4894 = normal_vec.x;
        f_l_1_ = ((_cse_902_ * dot(vec2<f32>(_cse_913_, (_cse_1619_ + ((((_cse_957_ * abs(_cse_960_)) / max(abs(_cse_960_), (abs(_cse_957_) + 0.00000001f))) * max((_cse_960_ * _cse_957_), 0f)) / max(abs((_cse_960_ * _cse_957_)), 0.00000001f)))), _e4835)) + (((_cse_903_ * _e4840) * (s_own_T + ((((dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_909_)), (face_center_vec - c_owner_vec)) * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_909_)), (face_center_vec - c_owner_vec))) + 0.00000001f))) * max(((_e151 - s_own_T) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_909_)), (face_center_vec - c_owner_vec))), 0f)) / max(abs(((_e151 - s_own_T) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_909_)), (face_center_vec - c_owner_vec)))), 0.00000001f)))) * _e4894));
        let _e4916 = normal_vec;
        let _e4921 = constants.eos_r;
        let _e4975 = normal_vec.x;
        f_r_1_ = ((_cse_930_ * dot(vec2<f32>(_cse_941_, (_cse_1622_ + ((((_cse_962_ * abs(_cse_965_)) / max(abs(_cse_965_), (abs(_cse_962_) + 0.00000001f))) * max((_cse_965_ * _cse_962_), 0f)) / max(abs((_cse_965_ * _cse_962_)), 0.00000001f)))), _e4916)) + (((_cse_931_ * _e4921) * (_e151 + ((((dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_937_)), (face_center_vec - c_neigh_cell_vec)) * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_937_)), (face_center_vec - c_neigh_cell_vec))) + 0.00000001f))) * max(((s_own_T - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_937_)), (face_center_vec - c_neigh_cell_vec))), 0f)) / max(abs(((s_own_T - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_937_)), (face_center_vec - c_neigh_cell_vec)))), 0.00000001f)))) * _e4975));
    }
    let _e4980 = constants.scheme;
    if ((_e4980 == 5u) && !(is_boundary_1)) {
        let _cse_972_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_978_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_977_ = max(_cse_978_, 0.000000000001f);
        let _cse_976_ = ((_e181 - s_own_rho) / _cse_977_);
        let _cse_975_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_976_);
        let _cse_974_ = dot(_cse_975_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_973_ = (_cse_974_ * 0.125f);
        let _cse_971_ = (_cse_972_ + _cse_973_);
        let _cse_970_ = (_cse_971_ - s_own_rho);
        let _cse_979_ = min((_e181 - s_own_rho), 0f);
        let _cse_969_ = max(_cse_970_, _cse_979_);
        let _cse_980_ = max((_e181 - s_own_rho), 0f);
        let _cse_968_ = min(_cse_969_, _cse_980_);
        let _cse_967_ = (s_own_rho + _cse_968_);
        let _cse_988_ = (_cse_1610_ * 0.625f);
        let _cse_989_ = (_cse_1613_ * 0.375f);
        let _cse_987_ = (_cse_988_ + _cse_989_);
        let _cse_995_ = (_cse_1613_ - _cse_1610_);
        let _cse_994_ = (_cse_995_ / _cse_977_);
        let _cse_993_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_994_);
        let _cse_992_ = dot(_cse_993_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_991_ = (_cse_992_ * 0.125f);
        let _cse_986_ = (_cse_987_ + _cse_991_);
        let _cse_985_ = (_cse_986_ - _cse_1610_);
        let _cse_996_ = min(_cse_995_, 0f);
        let _cse_984_ = max(_cse_985_, _cse_996_);
        let _cse_997_ = max(_cse_995_, 0f);
        let _cse_983_ = min(_cse_984_, _cse_997_);
        let _cse_981_ = (_cse_1610_ + _cse_983_);
        let _cse_966_ = (_cse_967_ * _cse_981_);
        let _cse_1004_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_1010_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1009_ = max(_cse_1010_, 0.000000000001f);
        let _cse_1008_ = ((s_own_rho - _e181) / _cse_1009_);
        let _cse_1007_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1008_);
        let _cse_1006_ = dot(_cse_1007_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1005_ = (_cse_1006_ * 0.125f);
        let _cse_1003_ = (_cse_1004_ + _cse_1005_);
        let _cse_1002_ = (_cse_1003_ - _e181);
        let _cse_1001_ = max(_cse_1002_, min((s_own_rho - _e181), 0f));
        let _cse_1000_ = min(_cse_1001_, max((s_own_rho - _e181), 0f));
        let _cse_999_ = (_e181 + _cse_1000_);
        let _cse_1017_ = (_cse_1613_ * 0.625f);
        let _cse_1018_ = (_cse_1610_ * 0.375f);
        let _cse_1016_ = (_cse_1017_ + _cse_1018_);
        let _cse_1023_ = (_cse_1610_ - _cse_1613_);
        let _cse_1022_ = (_cse_1023_ / _cse_1009_);
        let _cse_1021_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1022_);
        let _cse_1020_ = dot(_cse_1021_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1019_ = (_cse_1020_ * 0.125f);
        let _cse_1015_ = (_cse_1016_ + _cse_1019_);
        let _cse_1014_ = (_cse_1015_ - _cse_1613_);
        let _cse_1024_ = min(_cse_1023_, 0f);
        let _cse_1013_ = max(_cse_1014_, _cse_1024_);
        let _cse_1025_ = max(_cse_1023_, 0f);
        let _cse_1012_ = min(_cse_1013_, _cse_1025_);
        let _cse_1011_ = (_cse_1613_ + _cse_1012_);
        let _cse_998_ = (_cse_999_ * _cse_1011_);
        let _cse_1028_ = (_cse_1622_ - _cse_1619_);
        let _cse_1029_ = (_cse_1619_ - _cse_1622_);
        u_l_1_ = _cse_966_;
        u_r_1_ = _cse_998_;
        let _e5114 = normal_vec;
        let _e5119 = constants.eos_r;
        let _e5148 = normal_vec.x;
        f_l_1_ = ((_cse_966_ * dot(vec2<f32>(_cse_981_, (_cse_1619_ + min(max(((((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1028_) / vec2(_cse_977_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1619_), min(_cse_1028_, 0f)), max(_cse_1028_, 0f)))), _e5114)) + (((_cse_967_ * _e5119) * (s_own_T + min(max(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_977_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f)))) * _e5148));
        let _e5174 = normal_vec;
        let _e5179 = constants.eos_r;
        let _e5208 = normal_vec.x;
        f_r_1_ = ((_cse_998_ * dot(vec2<f32>(_cse_1011_, (_cse_1622_ + min(max(((((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1029_) / vec2(_cse_1009_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1622_), min(_cse_1029_, 0f)), max(_cse_1029_, 0f)))), _e5174)) + (((_cse_999_ * _e5179) * (_e151 + min(max(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1009_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f)))) * _e5208));
    }
    let _e5213 = constants.scheme;
    if ((_e5213 == 6u) && !(is_boundary_1)) {
        let _cse_1039_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1038_ = max(_cse_1039_, 0.000000000001f);
        let _cse_1037_ = (((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1038_));
        let _cse_1036_ = dot(_cse_1037_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1035_ = (_cse_1036_ * 0.125f);
        let _cse_1034_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + _cse_1035_);
        let _cse_1033_ = (_cse_1034_ - s_own_rho);
        let _cse_1032_ = ((((_cse_1033_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1033_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1033_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1033_)), 0.00000001f));
        let _cse_1031_ = (s_own_rho + _cse_1032_);
        let _cse_1046_ = ((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f));
        let _cse_1052_ = (_cse_1613_ - _cse_1610_);
        let _cse_1051_ = (_cse_1052_ / _cse_1038_);
        let _cse_1050_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1051_);
        let _cse_1049_ = dot(_cse_1050_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1048_ = (_cse_1049_ * 0.125f);
        let _cse_1045_ = (_cse_1046_ + _cse_1048_);
        let _cse_1044_ = (_cse_1045_ - _cse_1610_);
        let _cse_1054_ = max(abs(_cse_1052_), (abs(_cse_1044_) + 0.00000001f));
        let _cse_1053_ = (abs(_cse_1052_) / _cse_1054_);
        let _cse_1043_ = (_cse_1044_ * _cse_1053_);
        let _cse_1057_ = (_cse_1052_ * _cse_1044_);
        let _cse_1056_ = max(_cse_1057_, 0f);
        let _cse_1059_ = abs(_cse_1057_);
        let _cse_1058_ = max(_cse_1059_, 0.00000001f);
        let _cse_1055_ = (_cse_1056_ / _cse_1058_);
        let _cse_1042_ = (_cse_1043_ * _cse_1055_);
        let _cse_1040_ = (_cse_1610_ + _cse_1042_);
        let _cse_1030_ = (_cse_1031_ * _cse_1040_);
        let _cse_1069_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1068_ = max(_cse_1069_, 0.000000000001f);
        let _cse_1067_ = (((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1068_));
        let _cse_1066_ = dot(_cse_1067_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1065_ = (_cse_1066_ * 0.125f);
        let _cse_1064_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + _cse_1065_);
        let _cse_1063_ = (_cse_1064_ - _e181);
        let _cse_1062_ = ((((_cse_1063_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1063_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1063_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1063_)), 0.00000001f));
        let _cse_1061_ = (_e181 + _cse_1062_);
        let _cse_1075_ = ((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f));
        let _cse_1080_ = (_cse_1610_ - _cse_1613_);
        let _cse_1079_ = (_cse_1080_ / _cse_1068_);
        let _cse_1078_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1079_);
        let _cse_1077_ = dot(_cse_1078_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1076_ = (_cse_1077_ * 0.125f);
        let _cse_1074_ = (_cse_1075_ + _cse_1076_);
        let _cse_1073_ = (_cse_1074_ - _cse_1613_);
        let _cse_1082_ = max(abs(_cse_1080_), (abs(_cse_1073_) + 0.00000001f));
        let _cse_1081_ = (abs(_cse_1080_) / _cse_1082_);
        let _cse_1072_ = (_cse_1073_ * _cse_1081_);
        let _cse_1085_ = (_cse_1080_ * _cse_1073_);
        let _cse_1084_ = max(_cse_1085_, 0f);
        let _cse_1087_ = abs(_cse_1085_);
        let _cse_1086_ = max(_cse_1087_, 0.00000001f);
        let _cse_1083_ = (_cse_1084_ / _cse_1086_);
        let _cse_1071_ = (_cse_1072_ * _cse_1083_);
        let _cse_1070_ = (_cse_1613_ + _cse_1071_);
        let _cse_1060_ = (_cse_1061_ * _cse_1070_);
        let _cse_1090_ = (((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_1038_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1089_ = (_cse_1090_ - _cse_1619_);
        let _cse_1093_ = (((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_1068_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1092_ = (_cse_1093_ - _cse_1622_);
        u_l_1_ = _cse_1030_;
        u_r_1_ = _cse_1060_;
        let _e5425 = normal_vec;
        let _e5430 = constants.eos_r;
        let _e5520 = normal_vec.x;
        f_l_1_ = ((_cse_1030_ * dot(vec2<f32>(_cse_1040_, (_cse_1619_ + ((((_cse_1089_ * abs((_cse_1622_ - _cse_1619_))) / max(abs((_cse_1622_ - _cse_1619_)), (abs(_cse_1089_) + 0.00000001f))) * max(((_cse_1622_ - _cse_1619_) * _cse_1089_), 0f)) / max(abs(((_cse_1622_ - _cse_1619_) * _cse_1089_)), 0.00000001f)))), _e5425)) + (((_cse_1031_ * _e5430) * (s_own_T + ((((((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1038_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T) * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1038_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)) + 0.00000001f))) * max(((_e151 - s_own_T) * ((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1038_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)), 0f)) / max(abs(((_e151 - s_own_T) * ((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1038_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T))), 0.00000001f)))) * _e5520));
        let _e5546 = normal_vec;
        let _e5551 = constants.eos_r;
        let _e5641 = normal_vec.x;
        f_r_1_ = ((_cse_1060_ * dot(vec2<f32>(_cse_1070_, (_cse_1622_ + ((((_cse_1092_ * abs((_cse_1619_ - _cse_1622_))) / max(abs((_cse_1619_ - _cse_1622_)), (abs(_cse_1092_) + 0.00000001f))) * max(((_cse_1619_ - _cse_1622_) * _cse_1092_), 0f)) / max(abs(((_cse_1619_ - _cse_1622_) * _cse_1092_)), 0.00000001f)))), _e5546)) + (((_cse_1061_ * _e5551) * (_e151 + ((((((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1068_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1068_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) + 0.00000001f))) * max(((s_own_T - _e151) * ((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1068_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)), 0f)) / max(abs(((s_own_T - _e151) * ((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1068_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))), 0.00000001f)))) * _e5641));
    }
    let _e5650 = a_plus;
    let _e5651 = f_l_1_;
    let _e5653 = a_minus;
    let _e5654 = f_r_1_;
    let _e5657 = a_plus;
    let _e5658 = a_minus;
    let _e5660 = u_r_1_;
    let _e5661 = u_l_1_;
    fluxes[((idx * 8u) + 1u)] = (((((_e5650 * _e5651) - (_e5653 * _e5654)) + ((_e5657 * _e5658) * (_e5660 - _e5661))) / denom) * area);
    let _cse_1094_ = (s_own_rho * _cse_1619_);
    let _cse_1096_ = (_e181 * _cse_1622_);
    let _cse_1098_ = normal_vec.y;
    u_l_2_ = _cse_1094_;
    u_r_2_ = _cse_1096_;
    let _e5674 = normal_vec;
    let _e5679 = constants.eos_r;
    f_l_2_ = ((_cse_1094_ * dot(vec2<f32>(_cse_1610_, _cse_1619_), _e5674)) + (((s_own_rho * _e5679) * s_own_T) * _cse_1098_));
    let _e5686 = normal_vec;
    let _e5691 = constants.eos_r;
    f_r_2_ = ((_cse_1096_ * dot(vec2<f32>(_cse_1613_, _cse_1622_), _e5686)) + (((_e181 * _e5691) * _e151) * _cse_1098_));
    let _e5699 = constants.scheme;
    if ((_e5699 == 1u) && !(is_boundary_1)) {
        let _cse_1105_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1104_ = max(_cse_1105_, 0.000000000001f);
        let _cse_1103_ = ((_e181 - s_own_rho) / _cse_1104_);
        let _cse_1102_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1103_);
        let _cse_1101_ = dot(_cse_1102_, (face_center_vec - c_owner_vec));
        let _cse_1100_ = (s_own_rho + _cse_1101_);
        let _cse_1111_ = (_cse_1622_ - _cse_1619_);
        let _cse_1110_ = (_cse_1111_ / _cse_1104_);
        let _cse_1109_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1110_);
        let _cse_1108_ = dot(_cse_1109_, (face_center_vec - c_owner_vec));
        let _cse_1106_ = (_cse_1619_ + _cse_1108_);
        let _cse_1099_ = (_cse_1100_ * _cse_1106_);
        let _cse_1119_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1118_ = max(_cse_1119_, 0.000000000001f);
        let _cse_1117_ = ((s_own_rho - _e181) / _cse_1118_);
        let _cse_1116_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1117_);
        let _cse_1115_ = dot(_cse_1116_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1114_ = (_e181 + _cse_1115_);
        let _cse_1124_ = (_cse_1619_ - _cse_1622_);
        let _cse_1123_ = (_cse_1124_ / _cse_1118_);
        let _cse_1122_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1123_);
        let _cse_1121_ = dot(_cse_1122_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1120_ = (_cse_1622_ + _cse_1121_);
        let _cse_1113_ = (_cse_1114_ * _cse_1120_);
        let _cse_1127_ = normal_vec.y;
        u_l_2_ = _cse_1099_;
        u_r_2_ = _cse_1113_;
        let _e5755 = normal_vec;
        let _e5760 = constants.eos_r;
        f_l_2_ = ((_cse_1099_ * dot(vec2<f32>((_cse_1610_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_1104_)), (face_center_vec - c_owner_vec))), _cse_1106_), _e5755)) + (((_cse_1100_ * _e5760) * (s_own_T + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1104_)), (face_center_vec - c_owner_vec)))) * _cse_1127_));
        let _e5782 = normal_vec;
        let _e5787 = constants.eos_r;
        f_r_2_ = ((_cse_1113_ * dot(vec2<f32>((_cse_1613_ + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_1118_)), (face_center_vec - c_neigh_cell_vec))), _cse_1120_), _e5782)) + (((_cse_1114_ * _e5787) * (_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1118_)), (face_center_vec - c_neigh_cell_vec)))) * _cse_1127_));
    }
    let _e5802 = constants.scheme;
    if ((_e5802 == 2u) && !(is_boundary_1)) {
        let _cse_1132_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_1138_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1137_ = max(_cse_1138_, 0.000000000001f);
        let _cse_1136_ = ((_e181 - s_own_rho) / _cse_1137_);
        let _cse_1135_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1136_);
        let _cse_1134_ = dot(_cse_1135_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1133_ = (_cse_1134_ * 0.125f);
        let _cse_1131_ = (_cse_1132_ + _cse_1133_);
        let _cse_1130_ = (_cse_1131_ - s_own_rho);
        let _cse_1129_ = (s_own_rho + _cse_1130_);
        let _cse_1144_ = (_cse_1619_ * 0.625f);
        let _cse_1145_ = (_cse_1622_ * 0.375f);
        let _cse_1143_ = (_cse_1144_ + _cse_1145_);
        let _cse_1151_ = (_cse_1622_ - _cse_1619_);
        let _cse_1150_ = (_cse_1151_ / _cse_1137_);
        let _cse_1149_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1150_);
        let _cse_1148_ = dot(_cse_1149_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1147_ = (_cse_1148_ * 0.125f);
        let _cse_1142_ = (_cse_1143_ + _cse_1147_);
        let _cse_1141_ = (_cse_1142_ - _cse_1619_);
        let _cse_1139_ = (_cse_1619_ + _cse_1141_);
        let _cse_1128_ = (_cse_1129_ * _cse_1139_);
        let _cse_1156_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_1162_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1161_ = max(_cse_1162_, 0.000000000001f);
        let _cse_1160_ = ((s_own_rho - _e181) / _cse_1161_);
        let _cse_1159_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1160_);
        let _cse_1158_ = dot(_cse_1159_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1157_ = (_cse_1158_ * 0.125f);
        let _cse_1155_ = (_cse_1156_ + _cse_1157_);
        let _cse_1154_ = (_cse_1155_ - _e181);
        let _cse_1153_ = (_e181 + _cse_1154_);
        let _cse_1167_ = (_cse_1622_ * 0.625f);
        let _cse_1168_ = (_cse_1619_ * 0.375f);
        let _cse_1166_ = (_cse_1167_ + _cse_1168_);
        let _cse_1173_ = (_cse_1619_ - _cse_1622_);
        let _cse_1172_ = (_cse_1173_ / _cse_1161_);
        let _cse_1171_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1172_);
        let _cse_1170_ = dot(_cse_1171_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1169_ = (_cse_1170_ * 0.125f);
        let _cse_1165_ = (_cse_1166_ + _cse_1169_);
        let _cse_1164_ = (_cse_1165_ - _cse_1622_);
        let _cse_1163_ = (_cse_1622_ + _cse_1164_);
        let _cse_1152_ = (_cse_1153_ * _cse_1163_);
        let _cse_1176_ = normal_vec.y;
        u_l_2_ = _cse_1128_;
        u_r_2_ = _cse_1152_;
        let _e5903 = normal_vec;
        let _e5908 = constants.eos_r;
        f_l_2_ = ((_cse_1128_ * dot(vec2<f32>(((((_cse_1610_ + (_cse_1610_ * 0.625f)) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_1137_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1610_), _cse_1139_), _e5903)) + (((_cse_1129_ * _e5908) * ((((s_own_T + (s_own_T * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1137_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)) * _cse_1176_));
        let _e5948 = normal_vec;
        let _e5953 = constants.eos_r;
        f_r_2_ = ((_cse_1152_ * dot(vec2<f32>(((((_cse_1613_ + (_cse_1613_ * 0.625f)) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_1161_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1613_), _cse_1163_), _e5948)) + (((_cse_1153_ * _e5953) * ((((_e151 + (_e151 * 0.625f)) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1161_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) * _cse_1176_));
    }
    let _e5977 = constants.scheme;
    if ((_e5977 == 3u) && !(is_boundary_1)) {
        let _cse_1185_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1184_ = max(_cse_1185_, 0.000000000001f);
        let _cse_1183_ = ((_e181 - s_own_rho) / _cse_1184_);
        let _cse_1182_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1183_);
        let _cse_1181_ = dot(_cse_1182_, (face_center_vec - c_owner_vec));
        let _cse_1186_ = min((_e181 - s_own_rho), 0f);
        let _cse_1180_ = max(_cse_1181_, _cse_1186_);
        let _cse_1187_ = max((_e181 - s_own_rho), 0f);
        let _cse_1179_ = min(_cse_1180_, _cse_1187_);
        let _cse_1178_ = (s_own_rho + _cse_1179_);
        let _cse_1195_ = (_cse_1622_ - _cse_1619_);
        let _cse_1194_ = (_cse_1195_ / _cse_1184_);
        let _cse_1193_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1194_);
        let _cse_1192_ = dot(_cse_1193_, (face_center_vec - c_owner_vec));
        let _cse_1197_ = min(_cse_1195_, 0f);
        let _cse_1191_ = max(_cse_1192_, _cse_1197_);
        let _cse_1198_ = max(_cse_1195_, 0f);
        let _cse_1190_ = min(_cse_1191_, _cse_1198_);
        let _cse_1188_ = (_cse_1619_ + _cse_1190_);
        let _cse_1177_ = (_cse_1178_ * _cse_1188_);
        let _cse_1207_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1206_ = max(_cse_1207_, 0.000000000001f);
        let _cse_1205_ = ((s_own_rho - _e181) / _cse_1206_);
        let _cse_1204_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1205_);
        let _cse_1203_ = dot(_cse_1204_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1208_ = min((s_own_rho - _e181), 0f);
        let _cse_1202_ = max(_cse_1203_, _cse_1208_);
        let _cse_1209_ = max((s_own_rho - _e181), 0f);
        let _cse_1201_ = min(_cse_1202_, _cse_1209_);
        let _cse_1200_ = (_e181 + _cse_1201_);
        let _cse_1216_ = (_cse_1619_ - _cse_1622_);
        let _cse_1215_ = (_cse_1216_ / _cse_1206_);
        let _cse_1214_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1215_);
        let _cse_1213_ = dot(_cse_1214_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1217_ = min(_cse_1216_, 0f);
        let _cse_1212_ = max(_cse_1213_, _cse_1217_);
        let _cse_1218_ = max(_cse_1216_, 0f);
        let _cse_1211_ = min(_cse_1212_, _cse_1218_);
        let _cse_1210_ = (_cse_1622_ + _cse_1211_);
        let _cse_1199_ = (_cse_1200_ * _cse_1210_);
        let _cse_1220_ = (_cse_1613_ - _cse_1610_);
        let _cse_1222_ = normal_vec.y;
        let _cse_1223_ = (_cse_1610_ - _cse_1613_);
        u_l_2_ = _cse_1177_;
        u_r_2_ = _cse_1199_;
        let _e6068 = normal_vec;
        let _e6073 = constants.eos_r;
        f_l_2_ = ((_cse_1177_ * dot(vec2<f32>((_cse_1610_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1220_) / vec2(_cse_1184_)), (face_center_vec - c_owner_vec)), min(_cse_1220_, 0f)), max(_cse_1220_, 0f))), _cse_1188_), _e6068)) + (((_cse_1178_ * _e6073) * (s_own_T + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1184_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f)))) * _cse_1222_));
        let _e6108 = normal_vec;
        let _e6113 = constants.eos_r;
        f_r_2_ = ((_cse_1199_ * dot(vec2<f32>((_cse_1613_ + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1223_) / vec2(_cse_1206_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_1223_, 0f)), max(_cse_1223_, 0f))), _cse_1210_), _e6108)) + (((_cse_1200_ * _e6113) * (_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1206_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f)))) * _cse_1222_));
    }
    let _e6136 = constants.scheme;
    if ((_e6136 == 4u) && !(is_boundary_1)) {
        let _cse_1232_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1231_ = max(_cse_1232_, 0.000000000001f);
        let _cse_1230_ = ((_e181 - s_own_rho) / _cse_1231_);
        let _cse_1229_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1230_);
        let _cse_1228_ = dot(_cse_1229_, (face_center_vec - c_owner_vec));
        let _cse_1227_ = ((_cse_1228_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1228_) + 0.00000001f)));
        let _cse_1234_ = ((_e181 - s_own_rho) * _cse_1228_);
        let _cse_1233_ = (max(_cse_1234_, 0f) / max(abs(_cse_1234_), 0.00000001f));
        let _cse_1226_ = (_cse_1227_ * _cse_1233_);
        let _cse_1225_ = (s_own_rho + _cse_1226_);
        let _cse_1242_ = (_cse_1622_ - _cse_1619_);
        let _cse_1241_ = (_cse_1242_ / _cse_1231_);
        let _cse_1240_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1241_);
        let _cse_1239_ = dot(_cse_1240_, (face_center_vec - c_owner_vec));
        let _cse_1245_ = abs(_cse_1242_);
        let _cse_1246_ = max(_cse_1245_, (abs(_cse_1239_) + 0.00000001f));
        let _cse_1244_ = (_cse_1245_ / _cse_1246_);
        let _cse_1238_ = (_cse_1239_ * _cse_1244_);
        let _cse_1249_ = (_cse_1242_ * _cse_1239_);
        let _cse_1248_ = max(_cse_1249_, 0f);
        let _cse_1251_ = abs(_cse_1249_);
        let _cse_1250_ = max(_cse_1251_, 0.00000001f);
        let _cse_1247_ = (_cse_1248_ / _cse_1250_);
        let _cse_1237_ = (_cse_1238_ * _cse_1247_);
        let _cse_1235_ = (_cse_1619_ + _cse_1237_);
        let _cse_1224_ = (_cse_1225_ * _cse_1235_);
        let _cse_1260_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1259_ = max(_cse_1260_, 0.000000000001f);
        let _cse_1258_ = ((s_own_rho - _e181) / _cse_1259_);
        let _cse_1257_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1258_);
        let _cse_1256_ = dot(_cse_1257_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1255_ = ((_cse_1256_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1256_) + 0.00000001f)));
        let _cse_1262_ = ((s_own_rho - _e181) * _cse_1256_);
        let _cse_1261_ = (max(_cse_1262_, 0f) / max(abs(_cse_1262_), 0.00000001f));
        let _cse_1254_ = (_cse_1255_ * _cse_1261_);
        let _cse_1253_ = (_e181 + _cse_1254_);
        let _cse_1269_ = (_cse_1619_ - _cse_1622_);
        let _cse_1268_ = (_cse_1269_ / _cse_1259_);
        let _cse_1267_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1268_);
        let _cse_1266_ = dot(_cse_1267_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1271_ = abs(_cse_1269_);
        let _cse_1272_ = max(_cse_1271_, (abs(_cse_1266_) + 0.00000001f));
        let _cse_1270_ = (_cse_1271_ / _cse_1272_);
        let _cse_1265_ = (_cse_1266_ * _cse_1270_);
        let _cse_1275_ = (_cse_1269_ * _cse_1266_);
        let _cse_1274_ = max(_cse_1275_, 0f);
        let _cse_1277_ = abs(_cse_1275_);
        let _cse_1276_ = max(_cse_1277_, 0.00000001f);
        let _cse_1273_ = (_cse_1274_ / _cse_1276_);
        let _cse_1264_ = (_cse_1265_ * _cse_1273_);
        let _cse_1263_ = (_cse_1622_ + _cse_1264_);
        let _cse_1252_ = (_cse_1253_ * _cse_1263_);
        let _cse_1282_ = (_cse_1613_ - _cse_1610_);
        let _cse_1281_ = (_cse_1282_ / _cse_1231_);
        let _cse_1280_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1281_);
        let _cse_1279_ = dot(_cse_1280_, (face_center_vec - c_owner_vec));
        let _cse_1287_ = (_cse_1610_ - _cse_1613_);
        let _cse_1286_ = (_cse_1287_ / _cse_1259_);
        let _cse_1285_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1286_);
        let _cse_1284_ = dot(_cse_1285_, (face_center_vec - c_neigh_cell_vec));
        u_l_2_ = _cse_1224_;
        u_r_2_ = _cse_1252_;
        let _e6280 = normal_vec;
        let _e6285 = constants.eos_r;
        let _e6339 = normal_vec.y;
        f_l_2_ = ((_cse_1224_ * dot(vec2<f32>((_cse_1610_ + ((((_cse_1279_ * abs(_cse_1282_)) / max(abs(_cse_1282_), (abs(_cse_1279_) + 0.00000001f))) * max((_cse_1282_ * _cse_1279_), 0f)) / max(abs((_cse_1282_ * _cse_1279_)), 0.00000001f))), _cse_1235_), _e6280)) + (((_cse_1225_ * _e6285) * (s_own_T + ((((dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1231_)), (face_center_vec - c_owner_vec)) * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1231_)), (face_center_vec - c_owner_vec))) + 0.00000001f))) * max(((_e151 - s_own_T) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1231_)), (face_center_vec - c_owner_vec))), 0f)) / max(abs(((_e151 - s_own_T) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1231_)), (face_center_vec - c_owner_vec)))), 0.00000001f)))) * _e6339));
        let _e6361 = normal_vec;
        let _e6366 = constants.eos_r;
        let _e6420 = normal_vec.y;
        f_r_2_ = ((_cse_1252_ * dot(vec2<f32>((_cse_1613_ + ((((_cse_1284_ * abs(_cse_1287_)) / max(abs(_cse_1287_), (abs(_cse_1284_) + 0.00000001f))) * max((_cse_1287_ * _cse_1284_), 0f)) / max(abs((_cse_1287_ * _cse_1284_)), 0.00000001f))), _cse_1263_), _e6361)) + (((_cse_1253_ * _e6366) * (_e151 + ((((dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1259_)), (face_center_vec - c_neigh_cell_vec)) * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1259_)), (face_center_vec - c_neigh_cell_vec))) + 0.00000001f))) * max(((s_own_T - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1259_)), (face_center_vec - c_neigh_cell_vec))), 0f)) / max(abs(((s_own_T - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1259_)), (face_center_vec - c_neigh_cell_vec)))), 0.00000001f)))) * _e6420));
    }
    let _e6425 = constants.scheme;
    if ((_e6425 == 5u) && !(is_boundary_1)) {
        let _cse_1294_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_1300_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1299_ = max(_cse_1300_, 0.000000000001f);
        let _cse_1298_ = ((_e181 - s_own_rho) / _cse_1299_);
        let _cse_1297_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1298_);
        let _cse_1296_ = dot(_cse_1297_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1295_ = (_cse_1296_ * 0.125f);
        let _cse_1293_ = (_cse_1294_ + _cse_1295_);
        let _cse_1292_ = (_cse_1293_ - s_own_rho);
        let _cse_1301_ = min((_e181 - s_own_rho), 0f);
        let _cse_1291_ = max(_cse_1292_, _cse_1301_);
        let _cse_1290_ = min(_cse_1291_, max((_e181 - s_own_rho), 0f));
        let _cse_1289_ = (s_own_rho + _cse_1290_);
        let _cse_1309_ = (_cse_1619_ * 0.625f);
        let _cse_1310_ = (_cse_1622_ * 0.375f);
        let _cse_1308_ = (_cse_1309_ + _cse_1310_);
        let _cse_1316_ = (_cse_1622_ - _cse_1619_);
        let _cse_1315_ = (_cse_1316_ / _cse_1299_);
        let _cse_1314_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1315_);
        let _cse_1313_ = dot(_cse_1314_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1312_ = (_cse_1313_ * 0.125f);
        let _cse_1307_ = (_cse_1308_ + _cse_1312_);
        let _cse_1306_ = (_cse_1307_ - _cse_1619_);
        let _cse_1317_ = min(_cse_1316_, 0f);
        let _cse_1305_ = max(_cse_1306_, _cse_1317_);
        let _cse_1318_ = max(_cse_1316_, 0f);
        let _cse_1304_ = min(_cse_1305_, _cse_1318_);
        let _cse_1302_ = (_cse_1619_ + _cse_1304_);
        let _cse_1288_ = (_cse_1289_ * _cse_1302_);
        let _cse_1325_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_1331_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1330_ = max(_cse_1331_, 0.000000000001f);
        let _cse_1329_ = ((s_own_rho - _e181) / _cse_1330_);
        let _cse_1328_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1329_);
        let _cse_1327_ = dot(_cse_1328_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1326_ = (_cse_1327_ * 0.125f);
        let _cse_1324_ = (_cse_1325_ + _cse_1326_);
        let _cse_1323_ = (_cse_1324_ - _e181);
        let _cse_1322_ = max(_cse_1323_, min((s_own_rho - _e181), 0f));
        let _cse_1332_ = max((s_own_rho - _e181), 0f);
        let _cse_1321_ = min(_cse_1322_, _cse_1332_);
        let _cse_1320_ = (_e181 + _cse_1321_);
        let _cse_1339_ = (_cse_1622_ * 0.625f);
        let _cse_1340_ = (_cse_1619_ * 0.375f);
        let _cse_1338_ = (_cse_1339_ + _cse_1340_);
        let _cse_1345_ = (_cse_1619_ - _cse_1622_);
        let _cse_1344_ = (_cse_1345_ / _cse_1330_);
        let _cse_1343_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1344_);
        let _cse_1342_ = dot(_cse_1343_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1341_ = (_cse_1342_ * 0.125f);
        let _cse_1337_ = (_cse_1338_ + _cse_1341_);
        let _cse_1336_ = (_cse_1337_ - _cse_1622_);
        let _cse_1346_ = min(_cse_1345_, 0f);
        let _cse_1335_ = max(_cse_1336_, _cse_1346_);
        let _cse_1347_ = max(_cse_1345_, 0f);
        let _cse_1334_ = min(_cse_1335_, _cse_1347_);
        let _cse_1333_ = (_cse_1622_ + _cse_1334_);
        let _cse_1319_ = (_cse_1320_ * _cse_1333_);
        let _cse_1350_ = (_cse_1613_ - _cse_1610_);
        let _cse_1351_ = (_cse_1610_ - _cse_1613_);
        u_l_2_ = _cse_1288_;
        u_r_2_ = _cse_1319_;
        let _e6559 = normal_vec;
        let _e6564 = constants.eos_r;
        let _e6593 = normal_vec.y;
        f_l_2_ = ((_cse_1288_ * dot(vec2<f32>((_cse_1610_ + min(max(((((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1350_) / vec2(_cse_1299_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1610_), min(_cse_1350_, 0f)), max(_cse_1350_, 0f))), _cse_1302_), _e6559)) + (((_cse_1289_ * _e6564) * (s_own_T + min(max(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1299_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f)))) * _e6593));
        let _e6619 = normal_vec;
        let _e6624 = constants.eos_r;
        let _e6653 = normal_vec.y;
        f_r_2_ = ((_cse_1319_ * dot(vec2<f32>((_cse_1613_ + min(max(((((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1351_) / vec2(_cse_1330_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1613_), min(_cse_1351_, 0f)), max(_cse_1351_, 0f))), _cse_1333_), _e6619)) + (((_cse_1320_ * _e6624) * (_e151 + min(max(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1330_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f)))) * _e6653));
    }
    let _e6658 = constants.scheme;
    if ((_e6658 == 6u) && !(is_boundary_1)) {
        let _cse_1361_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1360_ = max(_cse_1361_, 0.000000000001f);
        let _cse_1359_ = (((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1360_));
        let _cse_1358_ = dot(_cse_1359_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1357_ = (_cse_1358_ * 0.125f);
        let _cse_1356_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + _cse_1357_);
        let _cse_1355_ = (_cse_1356_ - s_own_rho);
        let _cse_1354_ = ((((_cse_1355_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1355_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1355_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1355_)), 0.00000001f));
        let _cse_1353_ = (s_own_rho + _cse_1354_);
        let _cse_1368_ = ((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f));
        let _cse_1374_ = (_cse_1622_ - _cse_1619_);
        let _cse_1373_ = (_cse_1374_ / _cse_1360_);
        let _cse_1372_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1373_);
        let _cse_1371_ = dot(_cse_1372_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1370_ = (_cse_1371_ * 0.125f);
        let _cse_1367_ = (_cse_1368_ + _cse_1370_);
        let _cse_1366_ = (_cse_1367_ - _cse_1619_);
        let _cse_1376_ = max(abs(_cse_1374_), (abs(_cse_1366_) + 0.00000001f));
        let _cse_1375_ = (abs(_cse_1374_) / _cse_1376_);
        let _cse_1365_ = (_cse_1366_ * _cse_1375_);
        let _cse_1379_ = (_cse_1374_ * _cse_1366_);
        let _cse_1378_ = max(_cse_1379_, 0f);
        let _cse_1381_ = abs(_cse_1379_);
        let _cse_1380_ = max(_cse_1381_, 0.00000001f);
        let _cse_1377_ = (_cse_1378_ / _cse_1380_);
        let _cse_1364_ = (_cse_1365_ * _cse_1377_);
        let _cse_1362_ = (_cse_1619_ + _cse_1364_);
        let _cse_1352_ = (_cse_1353_ * _cse_1362_);
        let _cse_1391_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1390_ = max(_cse_1391_, 0.000000000001f);
        let _cse_1389_ = (((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1390_));
        let _cse_1388_ = dot(_cse_1389_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1387_ = (_cse_1388_ * 0.125f);
        let _cse_1386_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + _cse_1387_);
        let _cse_1385_ = (_cse_1386_ - _e181);
        let _cse_1384_ = ((((_cse_1385_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1385_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1385_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1385_)), 0.00000001f));
        let _cse_1383_ = (_e181 + _cse_1384_);
        let _cse_1397_ = ((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f));
        let _cse_1402_ = (_cse_1619_ - _cse_1622_);
        let _cse_1401_ = (_cse_1402_ / _cse_1390_);
        let _cse_1400_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1401_);
        let _cse_1399_ = dot(_cse_1400_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1398_ = (_cse_1399_ * 0.125f);
        let _cse_1396_ = (_cse_1397_ + _cse_1398_);
        let _cse_1395_ = (_cse_1396_ - _cse_1622_);
        let _cse_1404_ = max(abs(_cse_1402_), (abs(_cse_1395_) + 0.00000001f));
        let _cse_1403_ = (abs(_cse_1402_) / _cse_1404_);
        let _cse_1394_ = (_cse_1395_ * _cse_1403_);
        let _cse_1407_ = (_cse_1402_ * _cse_1395_);
        let _cse_1406_ = max(_cse_1407_, 0f);
        let _cse_1409_ = abs(_cse_1407_);
        let _cse_1408_ = max(_cse_1409_, 0.00000001f);
        let _cse_1405_ = (_cse_1406_ / _cse_1408_);
        let _cse_1393_ = (_cse_1394_ * _cse_1405_);
        let _cse_1392_ = (_cse_1622_ + _cse_1393_);
        let _cse_1382_ = (_cse_1383_ * _cse_1392_);
        let _cse_1412_ = (((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_1360_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1411_ = (_cse_1412_ - _cse_1610_);
        let _cse_1415_ = (((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_1390_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1414_ = (_cse_1415_ - _cse_1613_);
        u_l_2_ = _cse_1352_;
        u_r_2_ = _cse_1382_;
        let _e6870 = normal_vec;
        let _e6875 = constants.eos_r;
        let _e6965 = normal_vec.y;
        f_l_2_ = ((_cse_1352_ * dot(vec2<f32>((_cse_1610_ + ((((_cse_1411_ * abs((_cse_1613_ - _cse_1610_))) / max(abs((_cse_1613_ - _cse_1610_)), (abs(_cse_1411_) + 0.00000001f))) * max(((_cse_1613_ - _cse_1610_) * _cse_1411_), 0f)) / max(abs(((_cse_1613_ - _cse_1610_) * _cse_1411_)), 0.00000001f))), _cse_1362_), _e6870)) + (((_cse_1353_ * _e6875) * (s_own_T + ((((((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1360_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T) * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1360_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)) + 0.00000001f))) * max(((_e151 - s_own_T) * ((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1360_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T)), 0f)) / max(abs(((_e151 - s_own_T) * ((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1360_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T))), 0.00000001f)))) * _e6965));
        let _e6991 = normal_vec;
        let _e6996 = constants.eos_r;
        let _e7086 = normal_vec.y;
        f_r_2_ = ((_cse_1382_ * dot(vec2<f32>((_cse_1613_ + ((((_cse_1414_ * abs((_cse_1610_ - _cse_1613_))) / max(abs((_cse_1610_ - _cse_1613_)), (abs(_cse_1414_) + 0.00000001f))) * max(((_cse_1610_ - _cse_1613_) * _cse_1414_), 0f)) / max(abs(((_cse_1610_ - _cse_1613_) * _cse_1414_)), 0.00000001f))), _cse_1392_), _e6991)) + (((_cse_1383_ * _e6996) * (_e151 + ((((((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1390_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1390_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) + 0.00000001f))) * max(((s_own_T - _e151) * ((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1390_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)), 0f)) / max(abs(((s_own_T - _e151) * ((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1390_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))), 0.00000001f)))) * _e7086));
    }
    let _e7095 = a_plus;
    let _e7096 = f_l_2_;
    let _e7098 = a_minus;
    let _e7099 = f_r_2_;
    let _e7102 = a_plus;
    let _e7103 = a_minus;
    let _e7105 = u_r_2_;
    let _e7106 = u_l_2_;
    fluxes[((idx * 8u) + 2u)] = (((((_e7095 * _e7096) - (_e7098 * _e7099)) + ((_e7102 * _e7103) * (_e7105 - _e7106))) / denom) * area);
    u_l_3_ = s_own_rho_e;
    u_r_3_ = _e211;
    let _e7116 = constants.eos_r;
    let _e7121 = normal_vec;
    f_l_3_ = ((s_own_rho_e + ((s_own_rho * _e7116) * s_own_T)) * dot(vec2<f32>(_cse_1610_, _cse_1619_), _e7121));
    let _e7127 = constants.eos_r;
    let _e7132 = normal_vec;
    f_r_3_ = ((_e211 + ((_e181 * _e7127) * _e151)) * dot(vec2<f32>(_cse_1613_, _cse_1622_), _e7132));
    let _e7138 = constants.scheme;
    if ((_e7138 == 1u) && !(is_boundary_1)) {
        let _cse_1421_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1420_ = max(_cse_1421_, 0.000000000001f);
        let _cse_1419_ = ((_e211 - s_own_rho_e) / _cse_1420_);
        let _cse_1418_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1419_);
        let _cse_1417_ = dot(_cse_1418_, (face_center_vec - c_owner_vec));
        let _cse_1416_ = (s_own_rho_e + _cse_1417_);
        let _cse_1427_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1426_ = max(_cse_1427_, 0.000000000001f);
        let _cse_1425_ = ((s_own_rho_e - _e211) / _cse_1426_);
        let _cse_1424_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1425_);
        let _cse_1423_ = dot(_cse_1424_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1422_ = (_e211 + _cse_1423_);
        u_l_3_ = _cse_1416_;
        u_r_3_ = _cse_1422_;
        let _e7177 = constants.eos_r;
        let _e7206 = normal_vec;
        f_l_3_ = ((_cse_1416_ + (((s_own_rho + dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1420_)), (face_center_vec - c_owner_vec))) * _e7177) * (s_own_T + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1420_)), (face_center_vec - c_owner_vec))))) * dot(vec2<f32>((_cse_1610_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_1420_)), (face_center_vec - c_owner_vec))), (_cse_1619_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_1420_)), (face_center_vec - c_owner_vec)))), _e7206));
        let _e7219 = constants.eos_r;
        let _e7248 = normal_vec;
        f_r_3_ = ((_cse_1422_ + (((_e181 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1426_)), (face_center_vec - c_neigh_cell_vec))) * _e7219) * (_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1426_)), (face_center_vec - c_neigh_cell_vec))))) * dot(vec2<f32>((_cse_1613_ + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_1426_)), (face_center_vec - c_neigh_cell_vec))), (_cse_1622_ + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_1426_)), (face_center_vec - c_neigh_cell_vec)))), _e7248));
    }
    let _e7253 = constants.scheme;
    if ((_e7253 == 2u) && !(is_boundary_1)) {
        let _cse_1435_ = ((s_own_rho_e * 0.625f) + (_e211 * 0.375f));
        let _cse_1441_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1440_ = max(_cse_1441_, 0.000000000001f);
        let _cse_1439_ = ((_e211 - s_own_rho_e) / _cse_1440_);
        let _cse_1438_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1439_);
        let _cse_1437_ = dot(_cse_1438_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1436_ = (_cse_1437_ * 0.125f);
        let _cse_1434_ = (_cse_1435_ + _cse_1436_);
        let _cse_1433_ = (_cse_1434_ - s_own_rho_e);
        let _cse_1432_ = (s_own_rho_e + _cse_1433_);
        let _cse_1445_ = ((_e211 * 0.625f) + (s_own_rho_e * 0.375f));
        let _cse_1451_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1450_ = max(_cse_1451_, 0.000000000001f);
        let _cse_1449_ = ((s_own_rho_e - _e211) / _cse_1450_);
        let _cse_1448_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1449_);
        let _cse_1447_ = dot(_cse_1448_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1446_ = (_cse_1447_ * 0.125f);
        let _cse_1444_ = (_cse_1445_ + _cse_1446_);
        let _cse_1443_ = (_cse_1444_ - _e211);
        let _cse_1442_ = (_e211 + _cse_1443_);
        u_l_3_ = _cse_1432_;
        u_r_3_ = _cse_1442_;
        let _e7319 = constants.eos_r;
        let _e7375 = normal_vec;
        f_l_3_ = ((_cse_1432_ + ((((((s_own_rho + (s_own_rho * 0.625f)) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1440_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho) * _e7319) * ((((s_own_T + (s_own_T * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1440_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T))) * dot(vec2<f32>(((((_cse_1610_ + (_cse_1610_ * 0.625f)) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1613_ - _cse_1610_)) / vec2(_cse_1440_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1610_), ((((_cse_1619_ + (_cse_1619_ * 0.625f)) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_cse_1622_ - _cse_1619_)) / vec2(_cse_1440_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1619_)), _e7375));
        let _e7397 = constants.eos_r;
        let _e7453 = normal_vec;
        f_r_3_ = ((_cse_1442_ + ((((((_e181 + (_e181 * 0.625f)) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1450_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181) * _e7397) * ((((_e151 + (_e151 * 0.625f)) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1450_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))) * dot(vec2<f32>(((((_cse_1613_ + (_cse_1613_ * 0.625f)) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1610_ - _cse_1613_)) / vec2(_cse_1450_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1613_), ((((_cse_1622_ + (_cse_1622_ * 0.625f)) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1619_ - _cse_1622_)) / vec2(_cse_1450_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1622_)), _e7453));
    }
    let _e7458 = constants.scheme;
    if ((_e7458 == 3u) && !(is_boundary_1)) {
        let _cse_1463_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1462_ = max(_cse_1463_, 0.000000000001f);
        let _cse_1461_ = ((_e211 - s_own_rho_e) / _cse_1462_);
        let _cse_1460_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1461_);
        let _cse_1459_ = dot(_cse_1460_, (face_center_vec - c_owner_vec));
        let _cse_1464_ = min((_e211 - s_own_rho_e), 0f);
        let _cse_1458_ = max(_cse_1459_, _cse_1464_);
        let _cse_1465_ = max((_e211 - s_own_rho_e), 0f);
        let _cse_1457_ = min(_cse_1458_, _cse_1465_);
        let _cse_1456_ = (s_own_rho_e + _cse_1457_);
        let _cse_1473_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1472_ = max(_cse_1473_, 0.000000000001f);
        let _cse_1471_ = ((s_own_rho_e - _e211) / _cse_1472_);
        let _cse_1470_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1471_);
        let _cse_1469_ = dot(_cse_1470_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1474_ = min((s_own_rho_e - _e211), 0f);
        let _cse_1468_ = max(_cse_1469_, _cse_1474_);
        let _cse_1475_ = max((s_own_rho_e - _e211), 0f);
        let _cse_1467_ = min(_cse_1468_, _cse_1475_);
        let _cse_1466_ = (_e211 + _cse_1467_);
        let _cse_1477_ = (_cse_1613_ - _cse_1610_);
        let _cse_1480_ = (_cse_1622_ - _cse_1619_);
        let _cse_1482_ = (_cse_1610_ - _cse_1613_);
        let _cse_1483_ = (_cse_1619_ - _cse_1622_);
        u_l_3_ = _cse_1456_;
        u_r_3_ = _cse_1466_;
        let _e7525 = constants.eos_r;
        let _e7572 = normal_vec;
        f_l_3_ = ((_cse_1456_ + (((s_own_rho + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1462_)), (face_center_vec - c_owner_vec)), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))) * _e7525) * (s_own_T + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1462_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f))))) * dot(vec2<f32>((_cse_1610_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1477_) / vec2(_cse_1462_)), (face_center_vec - c_owner_vec)), min(_cse_1477_, 0f)), max(_cse_1477_, 0f))), (_cse_1619_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1480_) / vec2(_cse_1462_)), (face_center_vec - c_owner_vec)), min(_cse_1480_, 0f)), max(_cse_1480_, 0f)))), _e7572));
        let _e7593 = constants.eos_r;
        let _e7640 = normal_vec;
        f_r_3_ = ((_cse_1466_ + (((_e181 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1472_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))) * _e7593) * (_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1472_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f))))) * dot(vec2<f32>((_cse_1613_ + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1482_) / vec2(_cse_1472_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_1482_, 0f)), max(_cse_1482_, 0f))), (_cse_1622_ + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1483_) / vec2(_cse_1472_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_1483_, 0f)), max(_cse_1483_, 0f)))), _e7640));
    }
    let _e7645 = constants.scheme;
    if ((_e7645 == 4u) && !(is_boundary_1)) {
        let _cse_1491_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1490_ = max(_cse_1491_, 0.000000000001f);
        let _cse_1489_ = ((_e211 - s_own_rho_e) / _cse_1490_);
        let _cse_1488_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1489_);
        let _cse_1487_ = dot(_cse_1488_, (face_center_vec - c_owner_vec));
        let _cse_1493_ = max(abs((_e211 - s_own_rho_e)), (abs(_cse_1487_) + 0.00000001f));
        let _cse_1492_ = (abs((_e211 - s_own_rho_e)) / _cse_1493_);
        let _cse_1486_ = (_cse_1487_ * _cse_1492_);
        let _cse_1496_ = ((_e211 - s_own_rho_e) * _cse_1487_);
        let _cse_1495_ = max(_cse_1496_, 0f);
        let _cse_1497_ = max(abs(_cse_1496_), 0.00000001f);
        let _cse_1494_ = (_cse_1495_ / _cse_1497_);
        let _cse_1485_ = (_cse_1486_ * _cse_1494_);
        let _cse_1484_ = (s_own_rho_e + _cse_1485_);
        let _cse_1505_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1504_ = max(_cse_1505_, 0.000000000001f);
        let _cse_1503_ = ((s_own_rho_e - _e211) / _cse_1504_);
        let _cse_1502_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1503_);
        let _cse_1501_ = dot(_cse_1502_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1507_ = max(abs((s_own_rho_e - _e211)), (abs(_cse_1501_) + 0.00000001f));
        let _cse_1506_ = (abs((s_own_rho_e - _e211)) / _cse_1507_);
        let _cse_1500_ = (_cse_1501_ * _cse_1506_);
        let _cse_1510_ = ((s_own_rho_e - _e211) * _cse_1501_);
        let _cse_1509_ = max(_cse_1510_, 0f);
        let _cse_1511_ = max(abs(_cse_1510_), 0.00000001f);
        let _cse_1508_ = (_cse_1509_ / _cse_1511_);
        let _cse_1499_ = (_cse_1500_ * _cse_1508_);
        let _cse_1498_ = (_e211 + _cse_1499_);
        let _cse_1514_ = ((_e181 - s_own_rho) / _cse_1490_);
        let _cse_1513_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1514_);
        let _cse_1512_ = dot(_cse_1513_, (face_center_vec - c_owner_vec));
        let _cse_1517_ = ((_e151 - s_own_T) / _cse_1490_);
        let _cse_1516_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1517_);
        let _cse_1515_ = dot(_cse_1516_, (face_center_vec - c_owner_vec));
        let _cse_1522_ = (_cse_1613_ - _cse_1610_);
        let _cse_1521_ = (_cse_1522_ / _cse_1490_);
        let _cse_1520_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1521_);
        let _cse_1519_ = dot(_cse_1520_, (face_center_vec - c_owner_vec));
        let _cse_1524_ = (_cse_1522_ * _cse_1519_);
        let _cse_1529_ = (_cse_1622_ - _cse_1619_);
        let _cse_1528_ = (_cse_1529_ / _cse_1490_);
        let _cse_1527_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1528_);
        let _cse_1526_ = dot(_cse_1527_, (face_center_vec - c_owner_vec));
        let _cse_1531_ = (_cse_1529_ * _cse_1526_);
        let _cse_1534_ = ((s_own_rho - _e181) / _cse_1504_);
        let _cse_1533_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1534_);
        let _cse_1532_ = dot(_cse_1533_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1537_ = ((s_own_T - _e151) / _cse_1504_);
        let _cse_1536_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1537_);
        let _cse_1535_ = dot(_cse_1536_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1541_ = (_cse_1610_ - _cse_1613_);
        let _cse_1540_ = (_cse_1541_ / _cse_1504_);
        let _cse_1539_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1540_);
        let _cse_1538_ = dot(_cse_1539_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1542_ = (_cse_1541_ * _cse_1538_);
        let _cse_1546_ = (_cse_1619_ - _cse_1622_);
        let _cse_1545_ = (_cse_1546_ / _cse_1504_);
        let _cse_1544_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1545_);
        let _cse_1543_ = dot(_cse_1544_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1547_ = (_cse_1546_ * _cse_1543_);
        u_l_3_ = _cse_1484_;
        u_r_3_ = _cse_1498_;
        let _e7788 = constants.eos_r;
        let _e7847 = normal_vec;
        f_l_3_ = ((_cse_1484_ + (((s_own_rho + ((((_cse_1512_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1512_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1512_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1512_)), 0.00000001f))) * _e7788) * (s_own_T + ((((_cse_1515_ * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(_cse_1515_) + 0.00000001f))) * max(((_e151 - s_own_T) * _cse_1515_), 0f)) / max(abs(((_e151 - s_own_T) * _cse_1515_)), 0.00000001f))))) * dot(vec2<f32>((_cse_1610_ + ((((_cse_1519_ * abs(_cse_1522_)) / max(abs(_cse_1522_), (abs(_cse_1519_) + 0.00000001f))) * max(_cse_1524_, 0f)) / max(abs(_cse_1524_), 0.00000001f))), (_cse_1619_ + ((((_cse_1526_ * abs(_cse_1529_)) / max(abs(_cse_1529_), (abs(_cse_1526_) + 0.00000001f))) * max(_cse_1531_, 0f)) / max(abs(_cse_1531_), 0.00000001f)))), _e7847));
        let _e7874 = constants.eos_r;
        let _e7933 = normal_vec;
        f_r_3_ = ((_cse_1498_ + (((_e181 + ((((_cse_1532_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1532_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1532_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1532_)), 0.00000001f))) * _e7874) * (_e151 + ((((_cse_1535_ * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(_cse_1535_) + 0.00000001f))) * max(((s_own_T - _e151) * _cse_1535_), 0f)) / max(abs(((s_own_T - _e151) * _cse_1535_)), 0.00000001f))))) * dot(vec2<f32>((_cse_1613_ + ((((_cse_1538_ * abs(_cse_1541_)) / max(abs(_cse_1541_), (abs(_cse_1538_) + 0.00000001f))) * max(_cse_1542_, 0f)) / max(abs(_cse_1542_), 0.00000001f))), (_cse_1622_ + ((((_cse_1543_ * abs(_cse_1546_)) / max(abs(_cse_1546_), (abs(_cse_1543_) + 0.00000001f))) * max(_cse_1547_, 0f)) / max(abs(_cse_1547_), 0.00000001f)))), _e7933));
    }
    let _e7938 = constants.scheme;
    if ((_e7938 == 5u) && !(is_boundary_1)) {
        let _cse_1553_ = ((s_own_rho_e * 0.625f) + (_e211 * 0.375f));
        let _cse_1559_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1558_ = max(_cse_1559_, 0.000000000001f);
        let _cse_1557_ = ((_e211 - s_own_rho_e) / _cse_1558_);
        let _cse_1556_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1557_);
        let _cse_1555_ = dot(_cse_1556_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1554_ = (_cse_1555_ * 0.125f);
        let _cse_1552_ = (_cse_1553_ + _cse_1554_);
        let _cse_1551_ = (_cse_1552_ - s_own_rho_e);
        let _cse_1560_ = min((_e211 - s_own_rho_e), 0f);
        let _cse_1550_ = max(_cse_1551_, _cse_1560_);
        let _cse_1561_ = max((_e211 - s_own_rho_e), 0f);
        let _cse_1549_ = min(_cse_1550_, _cse_1561_);
        let _cse_1548_ = (s_own_rho_e + _cse_1549_);
        let _cse_1567_ = ((_e211 * 0.625f) + (s_own_rho_e * 0.375f));
        let _cse_1573_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1572_ = max(_cse_1573_, 0.000000000001f);
        let _cse_1571_ = ((s_own_rho_e - _e211) / _cse_1572_);
        let _cse_1570_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1571_);
        let _cse_1569_ = dot(_cse_1570_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1568_ = (_cse_1569_ * 0.125f);
        let _cse_1566_ = (_cse_1567_ + _cse_1568_);
        let _cse_1565_ = (_cse_1566_ - _e211);
        let _cse_1574_ = min((s_own_rho_e - _e211), 0f);
        let _cse_1564_ = max(_cse_1565_, _cse_1574_);
        let _cse_1575_ = max((s_own_rho_e - _e211), 0f);
        let _cse_1563_ = min(_cse_1564_, _cse_1575_);
        let _cse_1562_ = (_e211 + _cse_1563_);
        let _cse_1578_ = (_cse_1613_ - _cse_1610_);
        let _cse_1581_ = (_cse_1622_ - _cse_1619_);
        let _cse_1582_ = (_cse_1610_ - _cse_1613_);
        let _cse_1583_ = (_cse_1619_ - _cse_1622_);
        u_l_3_ = _cse_1548_;
        u_r_3_ = _cse_1562_;
        let _e8032 = constants.eos_r;
        let _e8106 = normal_vec;
        f_l_3_ = ((_cse_1548_ + (((s_own_rho + min(max(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1558_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))) * _e8032) * (s_own_T + min(max(((((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1558_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_T), min((_e151 - s_own_T), 0f)), max((_e151 - s_own_T), 0f))))) * dot(vec2<f32>((_cse_1610_ + min(max(((((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1578_) / vec2(_cse_1558_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1610_), min(_cse_1578_, 0f)), max(_cse_1578_, 0f))), (_cse_1619_ + min(max(((((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1581_) / vec2(_cse_1558_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1619_), min(_cse_1581_, 0f)), max(_cse_1581_, 0f)))), _e8106));
        let _e8136 = constants.eos_r;
        let _e8210 = normal_vec;
        f_r_3_ = ((_cse_1562_ + (((_e181 + min(max(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1572_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))) * _e8136) * (_e151 + min(max(((((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1572_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_T - _e151), 0f)), max((s_own_T - _e151), 0f))))) * dot(vec2<f32>((_cse_1613_ + min(max(((((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1582_) / vec2(_cse_1572_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1613_), min(_cse_1582_, 0f)), max(_cse_1582_, 0f))), (_cse_1622_ + min(max(((((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1583_) / vec2(_cse_1572_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1622_), min(_cse_1583_, 0f)), max(_cse_1583_, 0f)))), _e8210));
    }
    let _e8215 = constants.scheme;
    if ((_e8215 == 6u) && !(is_boundary_1)) {
        let _cse_1593_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1592_ = max(_cse_1593_, 0.000000000001f);
        let _cse_1591_ = ((_e211 - s_own_rho_e) / _cse_1592_);
        let _cse_1590_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1591_);
        let _cse_1589_ = dot(_cse_1590_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1588_ = (_cse_1589_ * 0.125f);
        let _cse_1587_ = (((s_own_rho_e * 0.625f) + (_e211 * 0.375f)) + _cse_1588_);
        let _cse_1586_ = (_cse_1587_ - s_own_rho_e);
        let _cse_1594_ = ((_e211 - s_own_rho_e) * _cse_1586_);
        let _cse_1585_ = ((((_cse_1586_ * abs((_e211 - s_own_rho_e))) / max(abs((_e211 - s_own_rho_e)), (abs(_cse_1586_) + 0.00000001f))) * max(_cse_1594_, 0f)) / max(abs(_cse_1594_), 0.00000001f));
        let _cse_1584_ = (s_own_rho_e + _cse_1585_);
        let _cse_1604_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1603_ = max(_cse_1604_, 0.000000000001f);
        let _cse_1602_ = ((s_own_rho_e - _e211) / _cse_1603_);
        let _cse_1601_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1602_);
        let _cse_1600_ = dot(_cse_1601_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1599_ = (_cse_1600_ * 0.125f);
        let _cse_1598_ = (((_e211 * 0.625f) + (s_own_rho_e * 0.375f)) + _cse_1599_);
        let _cse_1597_ = (_cse_1598_ - _e211);
        let _cse_1605_ = ((s_own_rho_e - _e211) * _cse_1597_);
        let _cse_1596_ = ((((_cse_1597_ * abs((s_own_rho_e - _e211))) / max(abs((s_own_rho_e - _e211)), (abs(_cse_1597_) + 0.00000001f))) * max(_cse_1605_, 0f)) / max(abs(_cse_1605_), 0.00000001f));
        let _cse_1595_ = (_e211 + _cse_1596_);
        let _cse_1607_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1592_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1606_ = (_cse_1607_ - s_own_rho);
        let _cse_1609_ = (((s_own_T * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_T)) / vec2(_cse_1592_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1608_ = (_cse_1609_ - s_own_T);
        let _cse_1617_ = (_cse_1613_ - _cse_1610_);
        let _cse_1616_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_1617_) / vec2(_cse_1592_));
        let _cse_1615_ = dot(_cse_1616_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1614_ = (_cse_1615_ * 0.125f);
        let _cse_1612_ = (((_cse_1610_ * 0.625f) + (_cse_1613_ * 0.375f)) + _cse_1614_);
        let _cse_1611_ = (_cse_1612_ - _cse_1610_);
        let _cse_1618_ = (_cse_1617_ * _cse_1611_);
        let _cse_1627_ = (_cse_1622_ - _cse_1619_);
        let _cse_1626_ = (_cse_1627_ / _cse_1592_);
        let _cse_1625_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1626_);
        let _cse_1624_ = dot(_cse_1625_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1623_ = (_cse_1624_ * 0.125f);
        let _cse_1621_ = (((_cse_1619_ * 0.625f) + (_cse_1622_ * 0.375f)) + _cse_1623_);
        let _cse_1620_ = (_cse_1621_ - _cse_1619_);
        let _cse_1628_ = (_cse_1627_ * _cse_1620_);
        let _cse_1630_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1603_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1629_ = (_cse_1630_ - _e181);
        let _cse_1632_ = (((_e151 * 0.625f) + (s_own_T * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_T - _e151)) / vec2(_cse_1603_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1631_ = (_cse_1632_ - _e151);
        let _cse_1639_ = (_cse_1610_ - _cse_1613_);
        let _cse_1638_ = (_cse_1639_ / _cse_1603_);
        let _cse_1637_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1638_);
        let _cse_1636_ = dot(_cse_1637_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1635_ = (_cse_1636_ * 0.125f);
        let _cse_1634_ = (((_cse_1613_ * 0.625f) + (_cse_1610_ * 0.375f)) + _cse_1635_);
        let _cse_1633_ = (_cse_1634_ - _cse_1613_);
        let _cse_1640_ = (_cse_1639_ * _cse_1633_);
        let _cse_1646_ = (_cse_1619_ - _cse_1622_);
        let _cse_1645_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_1646_) / vec2(_cse_1603_));
        let _cse_1644_ = dot(_cse_1645_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1643_ = (_cse_1644_ * 0.125f);
        let _cse_1642_ = (((_cse_1622_ * 0.625f) + (_cse_1619_ * 0.375f)) + _cse_1643_);
        let _cse_1641_ = (_cse_1642_ - _cse_1622_);
        let _cse_1647_ = (_cse_1646_ * _cse_1641_);
        u_l_3_ = _cse_1584_;
        u_r_3_ = _cse_1595_;
        let _e8454 = constants.eos_r;
        let _e8513 = normal_vec;
        f_l_3_ = ((_cse_1584_ + (((s_own_rho + ((((_cse_1606_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1606_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1606_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1606_)), 0.00000001f))) * _e8454) * (s_own_T + ((((_cse_1608_ * abs((_e151 - s_own_T))) / max(abs((_e151 - s_own_T)), (abs(_cse_1608_) + 0.00000001f))) * max(((_e151 - s_own_T) * _cse_1608_), 0f)) / max(abs(((_e151 - s_own_T) * _cse_1608_)), 0.00000001f))))) * dot(vec2<f32>((_cse_1610_ + ((((_cse_1611_ * abs(_cse_1617_)) / max(abs(_cse_1617_), (abs(_cse_1611_) + 0.00000001f))) * max(_cse_1618_, 0f)) / max(abs(_cse_1618_), 0.00000001f))), (_cse_1619_ + ((((_cse_1620_ * abs(_cse_1627_)) / max(abs(_cse_1627_), (abs(_cse_1620_) + 0.00000001f))) * max(_cse_1628_, 0f)) / max(abs(_cse_1628_), 0.00000001f)))), _e8513));
        let _e8540 = constants.eos_r;
        let _e8599 = normal_vec;
        f_r_3_ = ((_cse_1595_ + (((_e181 + ((((_cse_1629_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1629_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1629_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1629_)), 0.00000001f))) * _e8540) * (_e151 + ((((_cse_1631_ * abs((s_own_T - _e151))) / max(abs((s_own_T - _e151)), (abs(_cse_1631_) + 0.00000001f))) * max(((s_own_T - _e151) * _cse_1631_), 0f)) / max(abs(((s_own_T - _e151) * _cse_1631_)), 0.00000001f))))) * dot(vec2<f32>((_cse_1613_ + ((((_cse_1633_ * abs(_cse_1639_)) / max(abs(_cse_1639_), (abs(_cse_1633_) + 0.00000001f))) * max(_cse_1640_, 0f)) / max(abs(_cse_1640_), 0.00000001f))), (_cse_1622_ + ((((_cse_1641_ * abs(_cse_1646_)) / max(abs(_cse_1646_), (abs(_cse_1641_) + 0.00000001f))) * max(_cse_1647_, 0f)) / max(abs(_cse_1647_), 0.00000001f)))), _e8599));
    }
    let _e8608 = a_plus;
    let _e8609 = f_l_3_;
    let _e8611 = a_minus;
    let _e8612 = f_r_3_;
    let _e8615 = a_plus;
    let _e8616 = a_minus;
    let _e8618 = u_r_3_;
    let _e8619 = u_l_3_;
    fluxes[((idx * 8u) + 3u)] = (((((_e8608 * _e8609) - (_e8611 * _e8612)) + ((_e8615 * _e8616) * (_e8618 - _e8619))) / denom) * area);
    let _e8627 = constants.scheme;
    if ((_e8627 == 1u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8642 = constants.scheme;
    if ((_e8642 == 2u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8653 = constants.scheme;
    if ((_e8653 == 3u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8664 = constants.scheme;
    if ((_e8664 == 4u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8675 = constants.scheme;
    if ((_e8675 == 5u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8686 = constants.scheme;
    if ((_e8686 == 6u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8701 = a_plus;
    let _e8702 = f_l_4_;
    let _e8704 = a_minus;
    let _e8705 = f_r_4_;
    let _e8708 = a_plus;
    let _e8709 = a_minus;
    let _e8711 = u_r_4_;
    let _e8712 = u_l_4_;
    fluxes[((idx * 8u) + 4u)] = (((((_e8701 * _e8702) - (_e8704 * _e8705)) + ((_e8708 * _e8709) * (_e8711 - _e8712))) / denom) * area);
    let _e8720 = constants.scheme;
    if ((_e8720 == 1u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8735 = constants.scheme;
    if ((_e8735 == 2u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8746 = constants.scheme;
    if ((_e8746 == 3u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8757 = constants.scheme;
    if ((_e8757 == 4u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8768 = constants.scheme;
    if ((_e8768 == 5u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8779 = constants.scheme;
    if ((_e8779 == 6u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8794 = a_plus;
    let _e8795 = f_l_5_;
    let _e8797 = a_minus;
    let _e8798 = f_r_5_;
    let _e8801 = a_plus;
    let _e8802 = a_minus;
    let _e8804 = u_r_5_;
    let _e8805 = u_l_5_;
    fluxes[((idx * 8u) + 5u)] = (((((_e8794 * _e8795) - (_e8797 * _e8798)) + ((_e8801 * _e8802) * (_e8804 - _e8805))) / denom) * area);
    let _e8813 = constants.scheme;
    if ((_e8813 == 1u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8828 = constants.scheme;
    if ((_e8828 == 2u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8839 = constants.scheme;
    if ((_e8839 == 3u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8850 = constants.scheme;
    if ((_e8850 == 4u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8861 = constants.scheme;
    if ((_e8861 == 5u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8872 = constants.scheme;
    if ((_e8872 == 6u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8887 = a_plus;
    let _e8888 = f_l_6_;
    let _e8890 = a_minus;
    let _e8891 = f_r_6_;
    let _e8894 = a_plus;
    let _e8895 = a_minus;
    let _e8897 = u_r_6_;
    let _e8898 = u_l_6_;
    fluxes[((idx * 8u) + 6u)] = (((((_e8887 * _e8888) - (_e8890 * _e8891)) + ((_e8894 * _e8895) * (_e8897 - _e8898))) / denom) * area);
    let _e8906 = constants.scheme;
    if ((_e8906 == 1u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8921 = constants.scheme;
    if ((_e8921 == 2u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8932 = constants.scheme;
    if ((_e8932 == 3u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8943 = constants.scheme;
    if ((_e8943 == 4u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8954 = constants.scheme;
    if ((_e8954 == 5u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8965 = constants.scheme;
    if ((_e8965 == 6u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8980 = a_plus;
    let _e8981 = f_l_7_;
    let _e8983 = a_minus;
    let _e8984 = f_r_7_;
    let _e8987 = a_plus;
    let _e8988 = a_minus;
    let _e8990 = u_r_7_;
    let _e8991 = u_l_7_;
    fluxes[((idx * 8u) + 7u)] = (((((_e8980 * _e8981) - (_e8983 * _e8984)) + ((_e8987 * _e8988) * (_e8990 - _e8991))) / denom) * area);
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e88 = other_center_vec;
            let d_neigh = distance(_e88, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e96 = lambda;
            let lambda_other = (1f - _e96);
            let _e99 = normal_vec;
            let _e106 = state[((idx * 8u) + 2u)];
            let _e107 = lambda;
            let _e109 = other_idx;
            let _e116 = state[((_e109 * 8u) + 2u)];
            let _e123 = state[((idx * 8u) + 2u)];
            let _e130 = bc_value[((face_idx * 3u) + 2u)];
            let _e137 = bc_kind[((face_idx * 3u) + 2u)];
            let _e147 = state[((idx * 8u) + 2u)];
            let _e154 = bc_value[((face_idx * 3u) + 2u)];
            let _e163 = bc_kind[((face_idx * 3u) + 2u)];
            let _e173 = grad_acc_p;
            grad_acc_p = (_e173 + ((_e99 * ((_e106 * _e107) + (select(_e116, select(select(_e123, _e130, (_e137 == 1u)), (_e147 + (_e154 * d_own)), (_e163 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e176 = k;
            k = (_e176 + 1u);
        }
    }
    let _e178 = grad_acc_p;
    let grad_out_p = ((_e178 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var phi: f32;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let d_own_1 = distance(c_owner_vec, face_center_vec);
    let _e69 = c_neigh_vec;
    let d_neigh = distance(_e69, face_center_vec);
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e76 = lambda;
    let lambda_other = (1f - _e76);
    let _e79 = c_neigh_vec;
    let d_vec = (_e79 - c_owner_vec);
    let _e81 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e81));
    let dist = max(dist_proj, 0.000001f);
    let s_own_U_x = state[((owner_1 * 8u) + 0u)];
    let s_own_U_y = state[((owner_1 * 8u) + 1u)];
    let s_own_d_p = state[((owner_1 * 8u) + 3u)];
    let s_own_p = state[((owner_1 * 8u) + 2u)];
    let _e114 = neigh_idx;
    let _e121 = state[((_e114 * 8u) + 0u)];
    let _e128 = state[((owner_1 * 8u) + 0u)];
    let _e135 = bc_kind[((idx * 3u) + 0u)];
    let _e142 = bc_value[((idx * 3u) + 0u)];
    let _e143 = bc_neighbor_scalar(_e121, _e128, _e135, _e142, d_own_1, is_boundary_1);
    let _e150 = state[((owner_1 * 8u) + 0u)];
    let _e157 = state[((owner_1 * 8u) + 0u)];
    let _e159 = normal_vec.x;
    let _e167 = state[((owner_1 * 8u) + 1u)];
    let _e169 = normal_vec.y;
    let _e175 = normal_vec.x;
    let s_neigh_U_x = select(_e143, (_e150 - ((2f * ((_e157 * _e159) + (_e167 * _e169))) * _e175)), (is_boundary_1 && (boundary_type == 4u)));
    let _e182 = neigh_idx;
    let _e189 = state[((_e182 * 8u) + 1u)];
    let _e196 = state[((owner_1 * 8u) + 1u)];
    let _e203 = bc_kind[((idx * 3u) + 1u)];
    let _e210 = bc_value[((idx * 3u) + 1u)];
    let _e211 = bc_neighbor_scalar(_e189, _e196, _e203, _e210, d_own_1, is_boundary_1);
    let _e218 = state[((owner_1 * 8u) + 1u)];
    let _e225 = state[((owner_1 * 8u) + 0u)];
    let _e227 = normal_vec.x;
    let _e235 = state[((owner_1 * 8u) + 1u)];
    let _e237 = normal_vec.y;
    let _e243 = normal_vec.y;
    let s_neigh_U_y = select(_e211, (_e218 - ((2f * ((_e225 * _e227) + (_e235 * _e237))) * _e243)), (is_boundary_1 && (boundary_type == 4u)));
    let _e250 = neigh_idx;
    let _e257 = state[((_e250 * 8u) + 3u)];
    let _e264 = state[((owner_1 * 8u) + 3u)];
    let s_neigh_d_p = select(_e257, _e264, is_boundary_1);
    let _e266 = neigh_idx;
    let _e273 = state[((_e266 * 8u) + 2u)];
    let _e280 = state[((owner_1 * 8u) + 2u)];
    let _e287 = bc_kind[((idx * 3u) + 2u)];
    let _e294 = bc_value[((idx * 3u) + 2u)];
    let _e295 = bc_neighbor_scalar(_e273, _e280, _e287, _e294, d_own_1, is_boundary_1);
    let _e298 = constants.density;
    let _e300 = lambda;
    let _e305 = normal_vec;
    let _e311 = constants.density;
    let _e312 = lambda;
    phi = (((_e298 * dot(((vec2<f32>(s_own_U_x, s_own_U_y) * _e300) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)), _e305)) * area) - ((((_e311 * ((s_own_d_p * _e312) + (s_neigh_d_p * lambda_other))) * (_e295 - s_own_p)) / dist) * area));
    let _e329 = phi;
    fluxes[((idx * 3u) + 0u)] = _e329;
    let _e336 = phi;
    fluxes[((idx * 3u) + 1u)] = _e336;
    let _e343 = phi;
    fluxes[((idx * 3u) + 2u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_apply {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub row_offsets: wgpu::BufferBinding<'a>,
            pub col_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub row_offsets: wgpu::BindGroupEntry<'a>,
            pub col_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.row_offsets),
                    },
                    col_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.col_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.row_offsets, self.col_indices, self.matrix_values]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"col_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub y: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub y: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    y: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.y),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.x, self.y, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::generic_coupled_apply::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> y: array<f32>;
@group(1) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e5 = constants.stride_x;
    let row = ((global_id.y * _e5) + global_id.x);
    let n = (arrayLength((&row_offsets)) - 1u);
    if (row >= n) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e23 = k;
        if (_e23 < end) {
        } else {
            break;
        }
        {
            let _e26 = k;
            let col = col_indices[_e26];
            let _e30 = k;
            let _e32 = matrix_values[_e30];
            let _e36 = x[col];
            let _e38 = sum;
            sum = (_e38 + (_e32 * _e36));
        }
        continuing {
            let _e41 = k;
            k = (_e41 + 1u);
        }
    }
    let _e45 = sum;
    y[row] = _e45;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup3::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 8u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 8u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 8u) + 0u)];
        let _e750 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 8u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 8u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 8u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 8u) + 1u)];
        let _e871 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 8u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 8u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 8u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 8u) + 2u)];
        let _e992 = state_old_old[((idx * 8u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 8u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 8u) + 3u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 8u) + 3u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 8u) + 3u)];
        let _e1113 = state_old_old[((idx * 8u) + 3u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 8u) + 3u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 8u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 8u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 8u) + 6u)];
    let _e1332 = state[((idx * 8u) + 6u)];
    let _e1340 = state[((idx * 8u) + 7u)];
    let _e1347 = state[((idx * 8u) + 7u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 8u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1560 = dist;
            let diff_coeff_rho_u = ((_e1558 * area) / _e1560);
            let _e1562 = is_boundary;
            if !(_e1562) {
                let _e1571 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1571 + diff_coeff_rho_u);
                let _e1580 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1580 - diff_coeff_rho_u);
            } else {
                let _e1588 = bc_kind[((face_idx * 8u) + 4u)];
                if (_e1588 == 1u) {
                    let _e1598 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1598 + diff_coeff_rho_u);
                    let _e1606 = bc_value[((face_idx * 8u) + 4u)];
                    let _e1608 = rhs_1_;
                    rhs_1_ = (_e1608 + (diff_coeff_rho_u * _e1606));
                } else {
                    let _e1616 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1616 == 2u) {
                        let _e1621 = constants.viscosity;
                        let _e1629 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1632 = rhs_1_;
                        rhs_1_ = (_e1632 + -(((_e1621 * area) * _e1629)));
                    }
                }
            }
            let _e1634 = is_boundary;
            if !(_e1634) {
                let _e1643 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1643 + diff_coeff_rho_u);
                let _e1652 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1652 - diff_coeff_rho_u);
            } else {
                let _e1660 = bc_kind[((face_idx * 8u) + 5u)];
                if (_e1660 == 1u) {
                    let _e1670 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1670 + diff_coeff_rho_u);
                    let _e1678 = bc_value[((face_idx * 8u) + 5u)];
                    let _e1680 = rhs_2_;
                    rhs_2_ = (_e1680 + (diff_coeff_rho_u * _e1678));
                } else {
                    let _e1688 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1688 == 2u) {
                        let _e1693 = constants.viscosity;
                        let _e1701 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1704 = rhs_2_;
                        rhs_2_ = (_e1704 + -(((_e1693 * area) * _e1701)));
                    }
                }
            }
            let _e1712 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1712;
            if (owner != idx) {
                let _e1715 = phi_1_;
                let _e1718 = phi_1_;
                phi_1_ = (_e1718 - (_e1715 * 2f));
            }
            let _e1720 = phi_1_;
            let _e1721 = rhs_1_;
            rhs_1_ = (_e1721 - _e1720);
            let _e1729 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1729;
            if (owner != idx) {
                let _e1732 = phi_2_;
                let _e1735 = phi_2_;
                phi_2_ = (_e1735 - (_e1732 * 2f));
            }
            let _e1737 = phi_2_;
            let _e1738 = rhs_2_;
            rhs_2_ = (_e1738 - _e1737);
            let _e1746 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1746;
            if (owner != idx) {
                let _e1749 = phi_3_;
                let _e1752 = phi_3_;
                phi_3_ = (_e1752 - (_e1749 * 2f));
            }
            let _e1754 = phi_3_;
            let _e1755 = rhs_3_;
            rhs_3_ = (_e1755 - _e1754);
        }
        continuing {
            let _e1758 = k;
            k = (_e1758 + 1u);
        }
    }
    let _e1767 = diag_0_;
    let _e1768 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1768 + _e1767);
    let _e1776 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1776;
    let _e1784 = diag_1_;
    let _e1785 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1785 + _e1784);
    let _e1793 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1793;
    let _e1801 = diag_2_;
    let _e1802 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1802 + _e1801);
    let _e1810 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1810;
    let _e1818 = diag_3_;
    let _e1819 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1819 + _e1818);
    let _e1827 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1827;
    let _e1835 = diag_4_;
    let _e1836 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1836 + _e1835);
    let _e1845 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1845;
    let _e1853 = diag_5_;
    let _e1854 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1854 + _e1853);
    let _e1863 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1863;
    let _e1871 = diag_6_;
    let _e1872 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e1872 + _e1871);
    let _e1880 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e1880;
    let _e1888 = diag_7_;
    let _e1889 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e1889 + _e1888);
    let _e1898 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e1898;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 8u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 8u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 8u) + 0u)];
        let _e750 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 8u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 8u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 8u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 8u) + 1u)];
        let _e871 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 8u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 8u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 8u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 8u) + 2u)];
        let _e992 = state_old_old[((idx * 8u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 8u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 8u) + 3u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 8u) + 3u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 8u) + 3u)];
        let _e1113 = state_old_old[((idx * 8u) + 3u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 8u) + 3u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 8u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 8u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 8u) + 6u)];
    let _e1332 = state[((idx * 8u) + 6u)];
    let _e1340 = state[((idx * 8u) + 7u)];
    let _e1347 = state[((idx * 8u) + 7u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 8u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1560 = dist;
            let diff_coeff_rho_u = ((_e1558 * area) / _e1560);
            let _e1562 = is_boundary;
            if !(_e1562) {
                let _e1571 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1571 + diff_coeff_rho_u);
                let _e1580 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1580 - diff_coeff_rho_u);
            } else {
                let _e1588 = bc_kind[((face_idx * 8u) + 4u)];
                if (_e1588 == 1u) {
                    let _e1598 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1598 + diff_coeff_rho_u);
                    let _e1606 = bc_value[((face_idx * 8u) + 4u)];
                    let _e1608 = rhs_1_;
                    rhs_1_ = (_e1608 + (diff_coeff_rho_u * _e1606));
                } else {
                    let _e1616 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1616 == 2u) {
                        let _e1621 = constants.viscosity;
                        let _e1629 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1632 = rhs_1_;
                        rhs_1_ = (_e1632 + -(((_e1621 * area) * _e1629)));
                    }
                }
            }
            let _e1634 = is_boundary;
            if !(_e1634) {
                let _e1643 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1643 + diff_coeff_rho_u);
                let _e1652 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1652 - diff_coeff_rho_u);
            } else {
                let _e1660 = bc_kind[((face_idx * 8u) + 5u)];
                if (_e1660 == 1u) {
                    let _e1670 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1670 + diff_coeff_rho_u);
                    let _e1678 = bc_value[((face_idx * 8u) + 5u)];
                    let _e1680 = rhs_2_;
                    rhs_2_ = (_e1680 + (diff_coeff_rho_u * _e1678));
                } else {
                    let _e1688 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1688 == 2u) {
                        let _e1693 = constants.viscosity;
                        let _e1701 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1704 = rhs_2_;
                        rhs_2_ = (_e1704 + -(((_e1693 * area) * _e1701)));
                    }
                }
            }
            let _e1712 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1712;
            if (owner != idx) {
                let _e1715 = phi_1_;
                let _e1718 = phi_1_;
                phi_1_ = (_e1718 - (_e1715 * 2f));
            }
            let _e1720 = phi_1_;
            let _e1721 = rhs_1_;
            rhs_1_ = (_e1721 - _e1720);
            let _e1729 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1729;
            if (owner != idx) {
                let _e1732 = phi_2_;
                let _e1735 = phi_2_;
                phi_2_ = (_e1735 - (_e1732 * 2f));
            }
            let _e1737 = phi_2_;
            let _e1738 = rhs_2_;
            rhs_2_ = (_e1738 - _e1737);
            let _e1746 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1746;
            if (owner != idx) {
                let _e1749 = phi_3_;
                let _e1752 = phi_3_;
                phi_3_ = (_e1752 - (_e1749 * 2f));
            }
            let _e1754 = phi_3_;
            let _e1755 = rhs_3_;
            rhs_3_ = (_e1755 - _e1754);
        }
        continuing {
            let _e1758 = k;
            k = (_e1758 + 1u);
        }
    }
    let _e1767 = diag_0_;
    let _e1768 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1768 + _e1767);
    let _e1776 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1776;
    let _e1784 = diag_1_;
    let _e1785 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1785 + _e1784);
    let _e1793 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1793;
    let _e1801 = diag_2_;
    let _e1802 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1802 + _e1801);
    let _e1810 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1810;
    let _e1818 = diag_3_;
    let _e1819 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1819 + _e1818);
    let _e1827 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1827;
    let _e1835 = diag_4_;
    let _e1836 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1836 + _e1835);
    let _e1845 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1845;
    let _e1853 = diag_5_;
    let _e1854 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1854 + _e1853);
    let _e1863 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1863;
    let _e1871 = diag_6_;
    let _e1872 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e1872 + _e1871);
    let _e1880 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e1880;
    let _e1888 = diag_7_;
    let _e1889 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e1889 + _e1888);
    let _e1898 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e1898;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some(
                    "generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann.wgsl",
                ),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e527 = dist;
            let diff_coeff_U = ((_e525 * area) / _e527);
            let _e529 = is_boundary;
            if !(_e529) {
                let _e531 = diag_0_;
                diag_0_ = (_e531 + diff_coeff_U);
                let _e540 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e540 - diff_coeff_U);
            } else {
                let _e548 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e548 == 1u) {
                    let _e551 = diag_0_;
                    diag_0_ = (_e551 + diff_coeff_U);
                    let _e559 = bc_value[((face_idx * 3u) + 0u)];
                    let _e561 = rhs_0_;
                    rhs_0_ = (_e561 + (diff_coeff_U * _e559));
                } else {
                    let _e569 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e569 == 2u) {
                        let _e574 = constants.viscosity;
                        let _e582 = bc_value[((face_idx * 3u) + 0u)];
                        let _e585 = rhs_0_;
                        rhs_0_ = (_e585 + -(((_e574 * area) * _e582)));
                    }
                }
            }
            let _e587 = is_boundary;
            if !(_e587) {
                let _e589 = diag_1_;
                diag_1_ = (_e589 + diff_coeff_U);
                let _e598 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e598 - diff_coeff_U);
            } else {
                let _e606 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e606 == 1u) {
                    let _e609 = diag_1_;
                    diag_1_ = (_e609 + diff_coeff_U);
                    let _e617 = bc_value[((face_idx * 3u) + 1u)];
                    let _e619 = rhs_1_;
                    rhs_1_ = (_e619 + (diff_coeff_U * _e617));
                } else {
                    let _e627 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e627 == 2u) {
                        let _e632 = constants.viscosity;
                        let _e640 = bc_value[((face_idx * 3u) + 1u)];
                        let _e643 = rhs_1_;
                        rhs_1_ = (_e643 + -(((_e632 * area) * _e640)));
                    }
                }
            }
            let _e651 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e651;
            if (owner != idx) {
                let _e654 = phi_0_;
                let _e657 = phi_0_;
                phi_0_ = (_e657 - (_e654 * 2f));
            }
            let _e659 = is_boundary;
            if !(_e659) {
                let _e661 = phi_0_;
                let _e664 = diag_0_;
                diag_0_ = (_e664 + max(_e661, 0f));
                let _e673 = phi_0_;
                let _e676 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e676 + min(_e673, 0f));
                let _e678 = phi_0_;
                let _e685 = state[((idx * 8u) + 0u)];
                let _e686 = other_idx;
                let _e693 = state[((_e686 * 8u) + 0u)];
                let _e694 = phi_0_;
                let _e698 = other_idx;
                let _e705 = state[((_e698 * 8u) + 0u)];
                let _e706 = other_idx;
                let _e714 = grad_state[((_e706 * 8u) + 0u)].x;
                let _e715 = other_idx;
                let _e723 = grad_state[((_e715 * 8u) + 0u)].y;
                let _e729 = other_center.x;
                let _e731 = other_center.y;
                let _e742 = state[((idx * 8u) + 0u)];
                let _e750 = grad_state[((idx * 8u) + 0u)].x;
                let _e758 = grad_state[((idx * 8u) + 0u)].y;
                let _e769 = phi_0_;
                let _e775 = constants.scheme;
                let _e779 = other_idx;
                let _e786 = state[((_e779 * 8u) + 0u)];
                let _e787 = other_idx;
                let _e794 = state[((_e787 * 8u) + 0u)];
                let _e804 = state[((idx * 8u) + 0u)];
                let _e808 = other_idx;
                let _e816 = grad_state[((_e808 * 8u) + 0u)].x;
                let _e817 = other_idx;
                let _e825 = grad_state[((_e817 * 8u) + 0u)].y;
                let _e831 = other_center.x;
                let _e833 = other_center.y;
                let _e840 = other_idx;
                let _e847 = state[((_e840 * 8u) + 0u)];
                let _e855 = state[((idx * 8u) + 0u)];
                let _e862 = state[((idx * 8u) + 0u)];
                let _e866 = other_idx;
                let _e873 = state[((_e866 * 8u) + 0u)];
                let _e884 = grad_state[((idx * 8u) + 0u)].x;
                let _e892 = grad_state[((idx * 8u) + 0u)].y;
                let _e895 = other_center.x;
                let _e897 = other_center.y;
                let _e913 = state[((idx * 8u) + 0u)];
                let _e915 = phi_0_;
                let _e921 = constants.scheme;
                let _e925 = other_idx;
                let _e932 = state[((_e925 * 8u) + 0u)];
                let _e933 = other_idx;
                let _e941 = grad_state[((_e933 * 8u) + 0u)].x;
                let _e942 = other_idx;
                let _e950 = grad_state[((_e942 * 8u) + 0u)].y;
                let _e956 = other_center.x;
                let _e958 = other_center.y;
                let _e968 = state[((idx * 8u) + 0u)];
                let _e969 = other_idx;
                let _e976 = state[((_e969 * 8u) + 0u)];
                let _e987 = state[((idx * 8u) + 0u)];
                let _e988 = other_idx;
                let _e995 = state[((_e988 * 8u) + 0u)];
                let _e1007 = state[((idx * 8u) + 0u)];
                let _e1015 = grad_state[((idx * 8u) + 0u)].x;
                let _e1023 = grad_state[((idx * 8u) + 0u)].y;
                let _e1033 = other_idx;
                let _e1040 = state[((_e1033 * 8u) + 0u)];
                let _e1047 = state[((idx * 8u) + 0u)];
                let _e1052 = other_idx;
                let _e1059 = state[((_e1052 * 8u) + 0u)];
                let _e1066 = state[((idx * 8u) + 0u)];
                let _e1072 = phi_0_;
                let _e1078 = constants.scheme;
                let _e1082 = other_idx;
                let _e1089 = state[((_e1082 * 8u) + 0u)];
                let _e1090 = other_idx;
                let _e1098 = grad_state[((_e1090 * 8u) + 0u)].x;
                let _e1099 = other_idx;
                let _e1107 = grad_state[((_e1099 * 8u) + 0u)].y;
                let _e1113 = other_center.x;
                let _e1115 = other_center.y;
                let _e1125 = state[((idx * 8u) + 0u)];
                let _e1126 = other_idx;
                let _e1133 = state[((_e1126 * 8u) + 0u)];
                let _e1143 = state[((idx * 8u) + 0u)];
                let _e1144 = other_idx;
                let _e1151 = state[((_e1144 * 8u) + 0u)];
                let _e1154 = other_idx;
                let _e1162 = grad_state[((_e1154 * 8u) + 0u)].x;
                let _e1163 = other_idx;
                let _e1171 = grad_state[((_e1163 * 8u) + 0u)].y;
                let _e1177 = other_center.x;
                let _e1179 = other_center.y;
                let _e1194 = state[((idx * 8u) + 0u)];
                let _e1195 = other_idx;
                let _e1202 = state[((_e1195 * 8u) + 0u)];
                let _e1204 = other_idx;
                let _e1212 = grad_state[((_e1204 * 8u) + 0u)].x;
                let _e1213 = other_idx;
                let _e1221 = grad_state[((_e1213 * 8u) + 0u)].y;
                let _e1227 = other_center.x;
                let _e1229 = other_center.y;
                let _e1243 = state[((idx * 8u) + 0u)];
                let _e1244 = other_idx;
                let _e1251 = state[((_e1244 * 8u) + 0u)];
                let _e1253 = other_idx;
                let _e1261 = grad_state[((_e1253 * 8u) + 0u)].x;
                let _e1262 = other_idx;
                let _e1270 = grad_state[((_e1262 * 8u) + 0u)].y;
                let _e1276 = other_center.x;
                let _e1278 = other_center.y;
                let _e1294 = state[((idx * 8u) + 0u)];
                let _e1302 = grad_state[((idx * 8u) + 0u)].x;
                let _e1310 = grad_state[((idx * 8u) + 0u)].y;
                let _e1320 = other_idx;
                let _e1327 = state[((_e1320 * 8u) + 0u)];
                let _e1334 = state[((idx * 8u) + 0u)];
                let _e1338 = other_idx;
                let _e1345 = state[((_e1338 * 8u) + 0u)];
                let _e1352 = state[((idx * 8u) + 0u)];
                let _e1362 = grad_state[((idx * 8u) + 0u)].x;
                let _e1370 = grad_state[((idx * 8u) + 0u)].y;
                let _e1385 = other_idx;
                let _e1392 = state[((_e1385 * 8u) + 0u)];
                let _e1399 = state[((idx * 8u) + 0u)];
                let _e1408 = grad_state[((idx * 8u) + 0u)].x;
                let _e1416 = grad_state[((idx * 8u) + 0u)].y;
                let _e1430 = other_idx;
                let _e1437 = state[((_e1430 * 8u) + 0u)];
                let _e1444 = state[((idx * 8u) + 0u)];
                let _e1453 = grad_state[((idx * 8u) + 0u)].x;
                let _e1461 = grad_state[((idx * 8u) + 0u)].y;
                let _e1477 = phi_0_;
                let _e1483 = constants.scheme;
                let _e1487 = other_idx;
                let _e1494 = state[((_e1487 * 8u) + 0u)];
                let _e1495 = other_idx;
                let _e1502 = state[((_e1495 * 8u) + 0u)];
                let _e1511 = state[((idx * 8u) + 0u)];
                let _e1515 = other_idx;
                let _e1523 = grad_state[((_e1515 * 8u) + 0u)].x;
                let _e1524 = other_idx;
                let _e1532 = grad_state[((_e1524 * 8u) + 0u)].y;
                let _e1538 = other_center.x;
                let _e1540 = other_center.y;
                let _e1547 = other_idx;
                let _e1554 = state[((_e1547 * 8u) + 0u)];
                let _e1562 = state[((idx * 8u) + 0u)];
                let _e1563 = other_idx;
                let _e1570 = state[((_e1563 * 8u) + 0u)];
                let _e1581 = state[((idx * 8u) + 0u)];
                let _e1582 = other_idx;
                let _e1589 = state[((_e1582 * 8u) + 0u)];
                let _e1601 = state[((idx * 8u) + 0u)];
                let _e1608 = state[((idx * 8u) + 0u)];
                let _e1611 = other_idx;
                let _e1618 = state[((_e1611 * 8u) + 0u)];
                let _e1629 = grad_state[((idx * 8u) + 0u)].x;
                let _e1637 = grad_state[((idx * 8u) + 0u)].y;
                let _e1640 = other_center.x;
                let _e1642 = other_center.y;
                let _e1658 = state[((idx * 8u) + 0u)];
                let _e1660 = other_idx;
                let _e1667 = state[((_e1660 * 8u) + 0u)];
                let _e1674 = state[((idx * 8u) + 0u)];
                let _e1679 = other_idx;
                let _e1686 = state[((_e1679 * 8u) + 0u)];
                let _e1693 = state[((idx * 8u) + 0u)];
                let _e1699 = phi_0_;
                let _e1705 = constants.scheme;
                let _e1709 = other_idx;
                let _e1716 = state[((_e1709 * 8u) + 0u)];
                let _e1717 = other_idx;
                let _e1724 = state[((_e1717 * 8u) + 0u)];
                let _e1733 = state[((idx * 8u) + 0u)];
                let _e1737 = other_idx;
                let _e1745 = grad_state[((_e1737 * 8u) + 0u)].x;
                let _e1746 = other_idx;
                let _e1754 = grad_state[((_e1746 * 8u) + 0u)].y;
                let _e1760 = other_center.x;
                let _e1762 = other_center.y;
                let _e1769 = other_idx;
                let _e1776 = state[((_e1769 * 8u) + 0u)];
                let _e1784 = state[((idx * 8u) + 0u)];
                let _e1785 = other_idx;
                let _e1792 = state[((_e1785 * 8u) + 0u)];
                let _e1802 = state[((idx * 8u) + 0u)];
                let _e1803 = other_idx;
                let _e1810 = state[((_e1803 * 8u) + 0u)];
                let _e1813 = other_idx;
                let _e1820 = state[((_e1813 * 8u) + 0u)];
                let _e1829 = state[((idx * 8u) + 0u)];
                let _e1833 = other_idx;
                let _e1841 = grad_state[((_e1833 * 8u) + 0u)].x;
                let _e1842 = other_idx;
                let _e1850 = grad_state[((_e1842 * 8u) + 0u)].y;
                let _e1856 = other_center.x;
                let _e1858 = other_center.y;
                let _e1865 = other_idx;
                let _e1872 = state[((_e1865 * 8u) + 0u)];
                let _e1885 = state[((idx * 8u) + 0u)];
                let _e1886 = other_idx;
                let _e1893 = state[((_e1886 * 8u) + 0u)];
                let _e1895 = other_idx;
                let _e1902 = state[((_e1895 * 8u) + 0u)];
                let _e1911 = state[((idx * 8u) + 0u)];
                let _e1915 = other_idx;
                let _e1923 = grad_state[((_e1915 * 8u) + 0u)].x;
                let _e1924 = other_idx;
                let _e1932 = grad_state[((_e1924 * 8u) + 0u)].y;
                let _e1938 = other_center.x;
                let _e1940 = other_center.y;
                let _e1947 = other_idx;
                let _e1954 = state[((_e1947 * 8u) + 0u)];
                let _e1966 = state[((idx * 8u) + 0u)];
                let _e1967 = other_idx;
                let _e1974 = state[((_e1967 * 8u) + 0u)];
                let _e1976 = other_idx;
                let _e1983 = state[((_e1976 * 8u) + 0u)];
                let _e1992 = state[((idx * 8u) + 0u)];
                let _e1996 = other_idx;
                let _e2004 = grad_state[((_e1996 * 8u) + 0u)].x;
                let _e2005 = other_idx;
                let _e2013 = grad_state[((_e2005 * 8u) + 0u)].y;
                let _e2019 = other_center.x;
                let _e2021 = other_center.y;
                let _e2028 = other_idx;
                let _e2035 = state[((_e2028 * 8u) + 0u)];
                let _e2049 = state[((idx * 8u) + 0u)];
                let _e2056 = state[((idx * 8u) + 0u)];
                let _e2059 = other_idx;
                let _e2066 = state[((_e2059 * 8u) + 0u)];
                let _e2077 = grad_state[((idx * 8u) + 0u)].x;
                let _e2085 = grad_state[((idx * 8u) + 0u)].y;
                let _e2088 = other_center.x;
                let _e2090 = other_center.y;
                let _e2106 = state[((idx * 8u) + 0u)];
                let _e2108 = other_idx;
                let _e2115 = state[((_e2108 * 8u) + 0u)];
                let _e2122 = state[((idx * 8u) + 0u)];
                let _e2126 = other_idx;
                let _e2133 = state[((_e2126 * 8u) + 0u)];
                let _e2140 = state[((idx * 8u) + 0u)];
                let _e2149 = state[((idx * 8u) + 0u)];
                let _e2152 = other_idx;
                let _e2159 = state[((_e2152 * 8u) + 0u)];
                let _e2170 = grad_state[((idx * 8u) + 0u)].x;
                let _e2178 = grad_state[((idx * 8u) + 0u)].y;
                let _e2181 = other_center.x;
                let _e2183 = other_center.y;
                let _e2199 = state[((idx * 8u) + 0u)];
                let _e2206 = other_idx;
                let _e2213 = state[((_e2206 * 8u) + 0u)];
                let _e2220 = state[((idx * 8u) + 0u)];
                let _e2228 = state[((idx * 8u) + 0u)];
                let _e2231 = other_idx;
                let _e2238 = state[((_e2231 * 8u) + 0u)];
                let _e2249 = grad_state[((idx * 8u) + 0u)].x;
                let _e2257 = grad_state[((idx * 8u) + 0u)].y;
                let _e2260 = other_center.x;
                let _e2262 = other_center.y;
                let _e2278 = state[((idx * 8u) + 0u)];
                let _e2284 = other_idx;
                let _e2291 = state[((_e2284 * 8u) + 0u)];
                let _e2298 = state[((idx * 8u) + 0u)];
                let _e2306 = state[((idx * 8u) + 0u)];
                let _e2309 = other_idx;
                let _e2316 = state[((_e2309 * 8u) + 0u)];
                let _e2327 = grad_state[((idx * 8u) + 0u)].x;
                let _e2335 = grad_state[((idx * 8u) + 0u)].y;
                let _e2338 = other_center.x;
                let _e2340 = other_center.y;
                let _e2356 = state[((idx * 8u) + 0u)];
                let _e2364 = phi_0_;
                let _e2370 = constants.scheme;
                let _e2380 = state[((idx * 8u) + 0u)];
                let _e2381 = other_idx;
                let _e2388 = state[((_e2381 * 8u) + 0u)];
                let _e2389 = phi_0_;
                let _e2395 = rhs_0_;
                rhs_0_ = (_e2395 - (_e678 * (select(select(select(select(select(select(select(_e685, _e693, (_e694 < 0f)), select((_e705 + dot(vec2<f32>(_e714, _e723), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e729, _e731)))), (_e742 + dot(vec2<f32>(_e750, _e758), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e769 > 0f)), (_e775 == 1u)), select(((((_e786 + (_e794 * 0.625f)) + (_e804 * 0.375f)) + (dot(vec2<f32>(_e816, _e825), (vec2<f32>(center.x, center.y) - vec2<f32>(_e831, _e833))) * 0.125f)) - _e847), ((((_e855 + (_e862 * 0.625f)) + (_e873 * 0.375f)) + (dot(vec2<f32>(_e884, _e892), (vec2<f32>(_e895, _e897) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e913), (_e915 > 0f)), (_e921 == 2u)), select((_e932 + min(max(dot(vec2<f32>(_e941, _e950), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e956, _e958))), min((_e968 - _e976), 0f)), max((_e987 - _e995), 0f))), (_e1007 + min(max(dot(vec2<f32>(_e1015, _e1023), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1040 - _e1047), 0f)), max((_e1059 - _e1066), 0f))), (_e1072 > 0f)), (_e1078 == 3u)), select((_e1089 + ((((dot(vec2<f32>(_e1098, _e1107), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1113, _e1115))) * abs((_e1125 - _e1133))) / max(abs((_e1143 - _e1151)), (abs(dot(vec2<f32>(_e1162, _e1171), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1177, _e1179)))) + 0.00000001f))) * max(((_e1194 - _e1202) * dot(vec2<f32>(_e1212, _e1221), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1227, _e1229)))), 0f)) / max(abs(((_e1243 - _e1251) * dot(vec2<f32>(_e1261, _e1270), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1276, _e1278))))), 0.00000001f))), (_e1294 + ((((dot(vec2<f32>(_e1302, _e1310), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1327 - _e1334))) / max(abs((_e1345 - _e1352)), (abs(dot(vec2<f32>(_e1362, _e1370), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1392 - _e1399) * dot(vec2<f32>(_e1408, _e1416), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1437 - _e1444) * dot(vec2<f32>(_e1453, _e1461), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1477 > 0f)), (_e1483 == 4u)), select((_e1494 + min(max(((((_e1502 * 0.625f) + (_e1511 * 0.375f)) + (dot(vec2<f32>(_e1523, _e1532), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1538, _e1540))) * 0.125f)) - _e1554), min((_e1562 - _e1570), 0f)), max((_e1581 - _e1589), 0f))), (_e1601 + min(max(((((_e1608 * 0.625f) + (_e1618 * 0.375f)) + (dot(vec2<f32>(_e1629, _e1637), (vec2<f32>(_e1640, _e1642) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1658), min((_e1667 - _e1674), 0f)), max((_e1686 - _e1693), 0f))), (_e1699 > 0f)), (_e1705 == 5u)), select((_e1716 + ((((((((_e1724 * 0.625f) + (_e1733 * 0.375f)) + (dot(vec2<f32>(_e1745, _e1754), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1760, _e1762))) * 0.125f)) - _e1776) * abs((_e1784 - _e1792))) / max(abs((_e1802 - _e1810)), (abs(((((_e1820 * 0.625f) + (_e1829 * 0.375f)) + (dot(vec2<f32>(_e1841, _e1850), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1856, _e1858))) * 0.125f)) - _e1872)) + 0.00000001f))) * max(((_e1885 - _e1893) * ((((_e1902 * 0.625f) + (_e1911 * 0.375f)) + (dot(vec2<f32>(_e1923, _e1932), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1938, _e1940))) * 0.125f)) - _e1954)), 0f)) / max(abs(((_e1966 - _e1974) * ((((_e1983 * 0.625f) + (_e1992 * 0.375f)) + (dot(vec2<f32>(_e2004, _e2013), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2019, _e2021))) * 0.125f)) - _e2035))), 0.00000001f))), (_e2049 + ((((((((_e2056 * 0.625f) + (_e2066 * 0.375f)) + (dot(vec2<f32>(_e2077, _e2085), (vec2<f32>(_e2088, _e2090) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2106) * abs((_e2115 - _e2122))) / max(abs((_e2133 - _e2140)), (abs(((((_e2149 * 0.625f) + (_e2159 * 0.375f)) + (dot(vec2<f32>(_e2170, _e2178), (vec2<f32>(_e2181, _e2183) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2199)) + 0.00000001f))) * max(((_e2213 - _e2220) * ((((_e2228 * 0.625f) + (_e2238 * 0.375f)) + (dot(vec2<f32>(_e2249, _e2257), (vec2<f32>(_e2260, _e2262) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2278)), 0f)) / max(abs(((_e2291 - _e2298) * ((((_e2306 * 0.625f) + (_e2316 * 0.375f)) + (dot(vec2<f32>(_e2327, _e2335), (vec2<f32>(_e2338, _e2340) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2356))), 0.00000001f))), (_e2364 > 0f)), (_e2370 == 6u)) - select(_e2380, _e2388, (_e2389 < 0f)))));
            } else {
                let _e2403 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e2403 == 1u) {
                    let _e2406 = phi_0_;
                    let _e2409 = diag_0_;
                    diag_0_ = (_e2409 + max(_e2406, 0f));
                    let _e2411 = phi_0_;
                    let _e2420 = bc_value[((face_idx * 3u) + 0u)];
                    let _e2422 = rhs_0_;
                    rhs_0_ = (_e2422 - (min(_e2411, 0f) * _e2420));
                } else {
                    let _e2424 = phi_0_;
                    let _e2425 = diag_0_;
                    diag_0_ = (_e2425 + _e2424);
                }
            }
            let _e2433 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e2433;
            if (owner != idx) {
                let _e2436 = phi_1_;
                let _e2439 = phi_1_;
                phi_1_ = (_e2439 - (_e2436 * 2f));
            }
            let _e2441 = is_boundary;
            if !(_e2441) {
                let _e2443 = phi_1_;
                let _e2446 = diag_1_;
                diag_1_ = (_e2446 + max(_e2443, 0f));
                let _e2455 = phi_1_;
                let _e2458 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e2458 + min(_e2455, 0f));
                let _e2460 = phi_1_;
                let _e2467 = state[((idx * 8u) + 1u)];
                let _e2468 = other_idx;
                let _e2475 = state[((_e2468 * 8u) + 1u)];
                let _e2476 = phi_1_;
                let _e2480 = other_idx;
                let _e2487 = state[((_e2480 * 8u) + 1u)];
                let _e2488 = other_idx;
                let _e2496 = grad_state[((_e2488 * 8u) + 1u)].x;
                let _e2497 = other_idx;
                let _e2505 = grad_state[((_e2497 * 8u) + 1u)].y;
                let _e2511 = other_center.x;
                let _e2513 = other_center.y;
                let _e2524 = state[((idx * 8u) + 1u)];
                let _e2532 = grad_state[((idx * 8u) + 1u)].x;
                let _e2540 = grad_state[((idx * 8u) + 1u)].y;
                let _e2551 = phi_1_;
                let _e2557 = constants.scheme;
                let _e2561 = other_idx;
                let _e2568 = state[((_e2561 * 8u) + 1u)];
                let _e2569 = other_idx;
                let _e2576 = state[((_e2569 * 8u) + 1u)];
                let _e2586 = state[((idx * 8u) + 1u)];
                let _e2590 = other_idx;
                let _e2598 = grad_state[((_e2590 * 8u) + 1u)].x;
                let _e2599 = other_idx;
                let _e2607 = grad_state[((_e2599 * 8u) + 1u)].y;
                let _e2613 = other_center.x;
                let _e2615 = other_center.y;
                let _e2622 = other_idx;
                let _e2629 = state[((_e2622 * 8u) + 1u)];
                let _e2637 = state[((idx * 8u) + 1u)];
                let _e2644 = state[((idx * 8u) + 1u)];
                let _e2648 = other_idx;
                let _e2655 = state[((_e2648 * 8u) + 1u)];
                let _e2666 = grad_state[((idx * 8u) + 1u)].x;
                let _e2674 = grad_state[((idx * 8u) + 1u)].y;
                let _e2677 = other_center.x;
                let _e2679 = other_center.y;
                let _e2695 = state[((idx * 8u) + 1u)];
                let _e2697 = phi_1_;
                let _e2703 = constants.scheme;
                let _e2707 = other_idx;
                let _e2714 = state[((_e2707 * 8u) + 1u)];
                let _e2715 = other_idx;
                let _e2723 = grad_state[((_e2715 * 8u) + 1u)].x;
                let _e2724 = other_idx;
                let _e2732 = grad_state[((_e2724 * 8u) + 1u)].y;
                let _e2738 = other_center.x;
                let _e2740 = other_center.y;
                let _e2750 = state[((idx * 8u) + 1u)];
                let _e2751 = other_idx;
                let _e2758 = state[((_e2751 * 8u) + 1u)];
                let _e2769 = state[((idx * 8u) + 1u)];
                let _e2770 = other_idx;
                let _e2777 = state[((_e2770 * 8u) + 1u)];
                let _e2789 = state[((idx * 8u) + 1u)];
                let _e2797 = grad_state[((idx * 8u) + 1u)].x;
                let _e2805 = grad_state[((idx * 8u) + 1u)].y;
                let _e2815 = other_idx;
                let _e2822 = state[((_e2815 * 8u) + 1u)];
                let _e2829 = state[((idx * 8u) + 1u)];
                let _e2834 = other_idx;
                let _e2841 = state[((_e2834 * 8u) + 1u)];
                let _e2848 = state[((idx * 8u) + 1u)];
                let _e2854 = phi_1_;
                let _e2860 = constants.scheme;
                let _e2864 = other_idx;
                let _e2871 = state[((_e2864 * 8u) + 1u)];
                let _e2872 = other_idx;
                let _e2880 = grad_state[((_e2872 * 8u) + 1u)].x;
                let _e2881 = other_idx;
                let _e2889 = grad_state[((_e2881 * 8u) + 1u)].y;
                let _e2895 = other_center.x;
                let _e2897 = other_center.y;
                let _e2907 = state[((idx * 8u) + 1u)];
                let _e2908 = other_idx;
                let _e2915 = state[((_e2908 * 8u) + 1u)];
                let _e2925 = state[((idx * 8u) + 1u)];
                let _e2926 = other_idx;
                let _e2933 = state[((_e2926 * 8u) + 1u)];
                let _e2936 = other_idx;
                let _e2944 = grad_state[((_e2936 * 8u) + 1u)].x;
                let _e2945 = other_idx;
                let _e2953 = grad_state[((_e2945 * 8u) + 1u)].y;
                let _e2959 = other_center.x;
                let _e2961 = other_center.y;
                let _e2976 = state[((idx * 8u) + 1u)];
                let _e2977 = other_idx;
                let _e2984 = state[((_e2977 * 8u) + 1u)];
                let _e2986 = other_idx;
                let _e2994 = grad_state[((_e2986 * 8u) + 1u)].x;
                let _e2995 = other_idx;
                let _e3003 = grad_state[((_e2995 * 8u) + 1u)].y;
                let _e3009 = other_center.x;
                let _e3011 = other_center.y;
                let _e3025 = state[((idx * 8u) + 1u)];
                let _e3026 = other_idx;
                let _e3033 = state[((_e3026 * 8u) + 1u)];
                let _e3035 = other_idx;
                let _e3043 = grad_state[((_e3035 * 8u) + 1u)].x;
                let _e3044 = other_idx;
                let _e3052 = grad_state[((_e3044 * 8u) + 1u)].y;
                let _e3058 = other_center.x;
                let _e3060 = other_center.y;
                let _e3076 = state[((idx * 8u) + 1u)];
                let _e3084 = grad_state[((idx * 8u) + 1u)].x;
                let _e3092 = grad_state[((idx * 8u) + 1u)].y;
                let _e3102 = other_idx;
                let _e3109 = state[((_e3102 * 8u) + 1u)];
                let _e3116 = state[((idx * 8u) + 1u)];
                let _e3120 = other_idx;
                let _e3127 = state[((_e3120 * 8u) + 1u)];
                let _e3134 = state[((idx * 8u) + 1u)];
                let _e3144 = grad_state[((idx * 8u) + 1u)].x;
                let _e3152 = grad_state[((idx * 8u) + 1u)].y;
                let _e3167 = other_idx;
                let _e3174 = state[((_e3167 * 8u) + 1u)];
                let _e3181 = state[((idx * 8u) + 1u)];
                let _e3190 = grad_state[((idx * 8u) + 1u)].x;
                let _e3198 = grad_state[((idx * 8u) + 1u)].y;
                let _e3212 = other_idx;
                let _e3219 = state[((_e3212 * 8u) + 1u)];
                let _e3226 = state[((idx * 8u) + 1u)];
                let _e3235 = grad_state[((idx * 8u) + 1u)].x;
                let _e3243 = grad_state[((idx * 8u) + 1u)].y;
                let _e3259 = phi_1_;
                let _e3265 = constants.scheme;
                let _e3269 = other_idx;
                let _e3276 = state[((_e3269 * 8u) + 1u)];
                let _e3277 = other_idx;
                let _e3284 = state[((_e3277 * 8u) + 1u)];
                let _e3293 = state[((idx * 8u) + 1u)];
                let _e3297 = other_idx;
                let _e3305 = grad_state[((_e3297 * 8u) + 1u)].x;
                let _e3306 = other_idx;
                let _e3314 = grad_state[((_e3306 * 8u) + 1u)].y;
                let _e3320 = other_center.x;
                let _e3322 = other_center.y;
                let _e3329 = other_idx;
                let _e3336 = state[((_e3329 * 8u) + 1u)];
                let _e3344 = state[((idx * 8u) + 1u)];
                let _e3345 = other_idx;
                let _e3352 = state[((_e3345 * 8u) + 1u)];
                let _e3363 = state[((idx * 8u) + 1u)];
                let _e3364 = other_idx;
                let _e3371 = state[((_e3364 * 8u) + 1u)];
                let _e3383 = state[((idx * 8u) + 1u)];
                let _e3390 = state[((idx * 8u) + 1u)];
                let _e3393 = other_idx;
                let _e3400 = state[((_e3393 * 8u) + 1u)];
                let _e3411 = grad_state[((idx * 8u) + 1u)].x;
                let _e3419 = grad_state[((idx * 8u) + 1u)].y;
                let _e3422 = other_center.x;
                let _e3424 = other_center.y;
                let _e3440 = state[((idx * 8u) + 1u)];
                let _e3442 = other_idx;
                let _e3449 = state[((_e3442 * 8u) + 1u)];
                let _e3456 = state[((idx * 8u) + 1u)];
                let _e3461 = other_idx;
                let _e3468 = state[((_e3461 * 8u) + 1u)];
                let _e3475 = state[((idx * 8u) + 1u)];
                let _e3481 = phi_1_;
                let _e3487 = constants.scheme;
                let _e3491 = other_idx;
                let _e3498 = state[((_e3491 * 8u) + 1u)];
                let _e3499 = other_idx;
                let _e3506 = state[((_e3499 * 8u) + 1u)];
                let _e3515 = state[((idx * 8u) + 1u)];
                let _e3519 = other_idx;
                let _e3527 = grad_state[((_e3519 * 8u) + 1u)].x;
                let _e3528 = other_idx;
                let _e3536 = grad_state[((_e3528 * 8u) + 1u)].y;
                let _e3542 = other_center.x;
                let _e3544 = other_center.y;
                let _e3551 = other_idx;
                let _e3558 = state[((_e3551 * 8u) + 1u)];
                let _e3566 = state[((idx * 8u) + 1u)];
                let _e3567 = other_idx;
                let _e3574 = state[((_e3567 * 8u) + 1u)];
                let _e3584 = state[((idx * 8u) + 1u)];
                let _e3585 = other_idx;
                let _e3592 = state[((_e3585 * 8u) + 1u)];
                let _e3595 = other_idx;
                let _e3602 = state[((_e3595 * 8u) + 1u)];
                let _e3611 = state[((idx * 8u) + 1u)];
                let _e3615 = other_idx;
                let _e3623 = grad_state[((_e3615 * 8u) + 1u)].x;
                let _e3624 = other_idx;
                let _e3632 = grad_state[((_e3624 * 8u) + 1u)].y;
                let _e3638 = other_center.x;
                let _e3640 = other_center.y;
                let _e3647 = other_idx;
                let _e3654 = state[((_e3647 * 8u) + 1u)];
                let _e3667 = state[((idx * 8u) + 1u)];
                let _e3668 = other_idx;
                let _e3675 = state[((_e3668 * 8u) + 1u)];
                let _e3677 = other_idx;
                let _e3684 = state[((_e3677 * 8u) + 1u)];
                let _e3693 = state[((idx * 8u) + 1u)];
                let _e3697 = other_idx;
                let _e3705 = grad_state[((_e3697 * 8u) + 1u)].x;
                let _e3706 = other_idx;
                let _e3714 = grad_state[((_e3706 * 8u) + 1u)].y;
                let _e3720 = other_center.x;
                let _e3722 = other_center.y;
                let _e3729 = other_idx;
                let _e3736 = state[((_e3729 * 8u) + 1u)];
                let _e3748 = state[((idx * 8u) + 1u)];
                let _e3749 = other_idx;
                let _e3756 = state[((_e3749 * 8u) + 1u)];
                let _e3758 = other_idx;
                let _e3765 = state[((_e3758 * 8u) + 1u)];
                let _e3774 = state[((idx * 8u) + 1u)];
                let _e3778 = other_idx;
                let _e3786 = grad_state[((_e3778 * 8u) + 1u)].x;
                let _e3787 = other_idx;
                let _e3795 = grad_state[((_e3787 * 8u) + 1u)].y;
                let _e3801 = other_center.x;
                let _e3803 = other_center.y;
                let _e3810 = other_idx;
                let _e3817 = state[((_e3810 * 8u) + 1u)];
                let _e3831 = state[((idx * 8u) + 1u)];
                let _e3838 = state[((idx * 8u) + 1u)];
                let _e3841 = other_idx;
                let _e3848 = state[((_e3841 * 8u) + 1u)];
                let _e3859 = grad_state[((idx * 8u) + 1u)].x;
                let _e3867 = grad_state[((idx * 8u) + 1u)].y;
                let _e3870 = other_center.x;
                let _e3872 = other_center.y;
                let _e3888 = state[((idx * 8u) + 1u)];
                let _e3890 = other_idx;
                let _e3897 = state[((_e3890 * 8u) + 1u)];
                let _e3904 = state[((idx * 8u) + 1u)];
                let _e3908 = other_idx;
                let _e3915 = state[((_e3908 * 8u) + 1u)];
                let _e3922 = state[((idx * 8u) + 1u)];
                let _e3931 = state[((idx * 8u) + 1u)];
                let _e3934 = other_idx;
                let _e3941 = state[((_e3934 * 8u) + 1u)];
                let _e3952 = grad_state[((idx * 8u) + 1u)].x;
                let _e3960 = grad_state[((idx * 8u) + 1u)].y;
                let _e3963 = other_center.x;
                let _e3965 = other_center.y;
                let _e3981 = state[((idx * 8u) + 1u)];
                let _e3988 = other_idx;
                let _e3995 = state[((_e3988 * 8u) + 1u)];
                let _e4002 = state[((idx * 8u) + 1u)];
                let _e4010 = state[((idx * 8u) + 1u)];
                let _e4013 = other_idx;
                let _e4020 = state[((_e4013 * 8u) + 1u)];
                let _e4031 = grad_state[((idx * 8u) + 1u)].x;
                let _e4039 = grad_state[((idx * 8u) + 1u)].y;
                let _e4042 = other_center.x;
                let _e4044 = other_center.y;
                let _e4060 = state[((idx * 8u) + 1u)];
                let _e4066 = other_idx;
                let _e4073 = state[((_e4066 * 8u) + 1u)];
                let _e4080 = state[((idx * 8u) + 1u)];
                let _e4088 = state[((idx * 8u) + 1u)];
                let _e4091 = other_idx;
                let _e4098 = state[((_e4091 * 8u) + 1u)];
                let _e4109 = grad_state[((idx * 8u) + 1u)].x;
                let _e4117 = grad_state[((idx * 8u) + 1u)].y;
                let _e4120 = other_center.x;
                let _e4122 = other_center.y;
                let _e4138 = state[((idx * 8u) + 1u)];
                let _e4146 = phi_1_;
                let _e4152 = constants.scheme;
                let _e4162 = state[((idx * 8u) + 1u)];
                let _e4163 = other_idx;
                let _e4170 = state[((_e4163 * 8u) + 1u)];
                let _e4171 = phi_1_;
                let _e4177 = rhs_1_;
                rhs_1_ = (_e4177 - (_e2460 * (select(select(select(select(select(select(select(_e2467, _e2475, (_e2476 < 0f)), select((_e2487 + dot(vec2<f32>(_e2496, _e2505), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2511, _e2513)))), (_e2524 + dot(vec2<f32>(_e2532, _e2540), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e2551 > 0f)), (_e2557 == 1u)), select(((((_e2568 + (_e2576 * 0.625f)) + (_e2586 * 0.375f)) + (dot(vec2<f32>(_e2598, _e2607), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2613, _e2615))) * 0.125f)) - _e2629), ((((_e2637 + (_e2644 * 0.625f)) + (_e2655 * 0.375f)) + (dot(vec2<f32>(_e2666, _e2674), (vec2<f32>(_e2677, _e2679) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2695), (_e2697 > 0f)), (_e2703 == 2u)), select((_e2714 + min(max(dot(vec2<f32>(_e2723, _e2732), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2738, _e2740))), min((_e2750 - _e2758), 0f)), max((_e2769 - _e2777), 0f))), (_e2789 + min(max(dot(vec2<f32>(_e2797, _e2805), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e2822 - _e2829), 0f)), max((_e2841 - _e2848), 0f))), (_e2854 > 0f)), (_e2860 == 3u)), select((_e2871 + ((((dot(vec2<f32>(_e2880, _e2889), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2895, _e2897))) * abs((_e2907 - _e2915))) / max(abs((_e2925 - _e2933)), (abs(dot(vec2<f32>(_e2944, _e2953), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2959, _e2961)))) + 0.00000001f))) * max(((_e2976 - _e2984) * dot(vec2<f32>(_e2994, _e3003), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3009, _e3011)))), 0f)) / max(abs(((_e3025 - _e3033) * dot(vec2<f32>(_e3043, _e3052), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3058, _e3060))))), 0.00000001f))), (_e3076 + ((((dot(vec2<f32>(_e3084, _e3092), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e3109 - _e3116))) / max(abs((_e3127 - _e3134)), (abs(dot(vec2<f32>(_e3144, _e3152), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e3174 - _e3181) * dot(vec2<f32>(_e3190, _e3198), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e3219 - _e3226) * dot(vec2<f32>(_e3235, _e3243), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e3259 > 0f)), (_e3265 == 4u)), select((_e3276 + min(max(((((_e3284 * 0.625f) + (_e3293 * 0.375f)) + (dot(vec2<f32>(_e3305, _e3314), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3320, _e3322))) * 0.125f)) - _e3336), min((_e3344 - _e3352), 0f)), max((_e3363 - _e3371), 0f))), (_e3383 + min(max(((((_e3390 * 0.625f) + (_e3400 * 0.375f)) + (dot(vec2<f32>(_e3411, _e3419), (vec2<f32>(_e3422, _e3424) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3440), min((_e3449 - _e3456), 0f)), max((_e3468 - _e3475), 0f))), (_e3481 > 0f)), (_e3487 == 5u)), select((_e3498 + ((((((((_e3506 * 0.625f) + (_e3515 * 0.375f)) + (dot(vec2<f32>(_e3527, _e3536), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3542, _e3544))) * 0.125f)) - _e3558) * abs((_e3566 - _e3574))) / max(abs((_e3584 - _e3592)), (abs(((((_e3602 * 0.625f) + (_e3611 * 0.375f)) + (dot(vec2<f32>(_e3623, _e3632), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3638, _e3640))) * 0.125f)) - _e3654)) + 0.00000001f))) * max(((_e3667 - _e3675) * ((((_e3684 * 0.625f) + (_e3693 * 0.375f)) + (dot(vec2<f32>(_e3705, _e3714), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3720, _e3722))) * 0.125f)) - _e3736)), 0f)) / max(abs(((_e3748 - _e3756) * ((((_e3765 * 0.625f) + (_e3774 * 0.375f)) + (dot(vec2<f32>(_e3786, _e3795), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3801, _e3803))) * 0.125f)) - _e3817))), 0.00000001f))), (_e3831 + ((((((((_e3838 * 0.625f) + (_e3848 * 0.375f)) + (dot(vec2<f32>(_e3859, _e3867), (vec2<f32>(_e3870, _e3872) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3888) * abs((_e3897 - _e3904))) / max(abs((_e3915 - _e3922)), (abs(((((_e3931 * 0.625f) + (_e3941 * 0.375f)) + (dot(vec2<f32>(_e3952, _e3960), (vec2<f32>(_e3963, _e3965) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3981)) + 0.00000001f))) * max(((_e3995 - _e4002) * ((((_e4010 * 0.625f) + (_e4020 * 0.375f)) + (dot(vec2<f32>(_e4031, _e4039), (vec2<f32>(_e4042, _e4044) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4060)), 0f)) / max(abs(((_e4073 - _e4080) * ((((_e4088 * 0.625f) + (_e4098 * 0.375f)) + (dot(vec2<f32>(_e4109, _e4117), (vec2<f32>(_e4120, _e4122) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4138))), 0.00000001f))), (_e4146 > 0f)), (_e4152 == 6u)) - select(_e4162, _e4170, (_e4171 < 0f)))));
            } else {
                let _e4185 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e4185 == 1u) {
                    let _e4188 = phi_1_;
                    let _e4191 = diag_1_;
                    diag_1_ = (_e4191 + max(_e4188, 0f));
                    let _e4193 = phi_1_;
                    let _e4202 = bc_value[((face_idx * 3u) + 1u)];
                    let _e4204 = rhs_1_;
                    rhs_1_ = (_e4204 - (min(_e4193, 0f) * _e4202));
                } else {
                    let _e4206 = phi_1_;
                    let _e4207 = diag_1_;
                    diag_1_ = (_e4207 + _e4206);
                }
            }
            let _e4219 = normal.x;
            let _e4221 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)] = (_e4221 + ((0.5f * area) * _e4219));
            let _e4233 = normal.x;
            let _e4235 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)] = (_e4235 + ((0.5f * area) * _e4233));
            let _e4247 = normal.y;
            let _e4249 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)] = (_e4249 + ((0.5f * area) * _e4247));
            let _e4261 = normal.y;
            let _e4263 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)] = (_e4263 + ((0.5f * area) * _e4261));
            let _e4267 = constants.density;
            let _e4274 = state[((idx * 8u) + 3u)];
            let _e4277 = dist;
            let diff_coeff_p = (((_e4267 * _e4274) * area) / _e4277);
            let _e4279 = is_boundary;
            if !(_e4279) {
                let _e4282 = diag_2_;
                diag_2_ = (_e4282 + diff_coeff_p);
                let _e4291 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e4291 - diff_coeff_p);
            } else {
                let _e4299 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e4299 == 1u) {
                    let _e4302 = diag_2_;
                    diag_2_ = (_e4302 + diff_coeff_p);
                    let _e4311 = bc_value[((face_idx * 3u) + 2u)];
                    let _e4313 = rhs_2_;
                    rhs_2_ = (_e4313 + (diff_coeff_p * _e4311));
                } else {
                    let _e4321 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e4321 == 2u) {
                        let _e4326 = constants.density;
                        let _e4333 = state[((idx * 8u) + 3u)];
                        let _e4342 = bc_value[((face_idx * 3u) + 2u)];
                        let _e4345 = rhs_2_;
                        rhs_2_ = (_e4345 + -((((_e4326 * _e4333) * area) * _e4342)));
                    }
                }
            }
            let _e4353 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e4353;
            if (owner != idx) {
                let _e4356 = phi_2_;
                let _e4359 = phi_2_;
                phi_2_ = (_e4359 - (_e4356 * 2f));
            }
            let _e4361 = phi_2_;
            let _e4362 = rhs_2_;
            rhs_2_ = (_e4362 - _e4361);
        }
        continuing {
            let _e4365 = k;
            k = (_e4365 + 1u);
        }
    }
    let _e4374 = diag_0_;
    let _e4375 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e4375 + _e4374);
    let _e4383 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e4383;
    let _e4391 = diag_1_;
    let _e4392 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e4392 + _e4391);
    let _e4400 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e4400;
    let _e4408 = diag_2_;
    let _e4409 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e4409 + _e4408);
    let _e4417 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e4417;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e527 = dist;
            let diff_coeff_U = ((_e525 * area) / _e527);
            let _e529 = is_boundary;
            if !(_e529) {
                let _e531 = diag_0_;
                diag_0_ = (_e531 + diff_coeff_U);
                let _e540 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e540 - diff_coeff_U);
            } else {
                let _e548 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e548 == 1u) {
                    let _e551 = diag_0_;
                    diag_0_ = (_e551 + diff_coeff_U);
                    let _e559 = bc_value[((face_idx * 3u) + 0u)];
                    let _e561 = rhs_0_;
                    rhs_0_ = (_e561 + (diff_coeff_U * _e559));
                } else {
                    let _e569 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e569 == 2u) {
                        let _e574 = constants.viscosity;
                        let _e582 = bc_value[((face_idx * 3u) + 0u)];
                        let _e585 = rhs_0_;
                        rhs_0_ = (_e585 + -(((_e574 * area) * _e582)));
                    }
                }
            }
            let _e587 = is_boundary;
            if !(_e587) {
                let _e589 = diag_1_;
                diag_1_ = (_e589 + diff_coeff_U);
                let _e598 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e598 - diff_coeff_U);
            } else {
                let _e606 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e606 == 1u) {
                    let _e609 = diag_1_;
                    diag_1_ = (_e609 + diff_coeff_U);
                    let _e617 = bc_value[((face_idx * 3u) + 1u)];
                    let _e619 = rhs_1_;
                    rhs_1_ = (_e619 + (diff_coeff_U * _e617));
                } else {
                    let _e627 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e627 == 2u) {
                        let _e632 = constants.viscosity;
                        let _e640 = bc_value[((face_idx * 3u) + 1u)];
                        let _e643 = rhs_1_;
                        rhs_1_ = (_e643 + -(((_e632 * area) * _e640)));
                    }
                }
            }
            let _e651 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e651;
            if (owner != idx) {
                let _e654 = phi_0_;
                let _e657 = phi_0_;
                phi_0_ = (_e657 - (_e654 * 2f));
            }
            let _e659 = is_boundary;
            if !(_e659) {
                let _e661 = phi_0_;
                let _e664 = diag_0_;
                diag_0_ = (_e664 + max(_e661, 0f));
                let _e673 = phi_0_;
                let _e676 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e676 + min(_e673, 0f));
                let _e678 = phi_0_;
                let _e685 = state[((idx * 8u) + 0u)];
                let _e686 = other_idx;
                let _e693 = state[((_e686 * 8u) + 0u)];
                let _e694 = phi_0_;
                let _e698 = other_idx;
                let _e705 = state[((_e698 * 8u) + 0u)];
                let _e706 = other_idx;
                let _e713 = state[((_e706 * 8u) + 0u)];
                let _e720 = state[((idx * 8u) + 0u)];
                let _e729 = other_idx;
                let _e736 = state[((_e729 * 8u) + 0u)];
                let _e743 = state[((idx * 8u) + 0u)];
                let _e757 = other_center.x;
                let _e759 = other_center.y;
                let _e770 = state[((idx * 8u) + 0u)];
                let _e771 = other_idx;
                let _e778 = state[((_e771 * 8u) + 0u)];
                let _e785 = state[((idx * 8u) + 0u)];
                let _e794 = other_idx;
                let _e801 = state[((_e794 * 8u) + 0u)];
                let _e808 = state[((idx * 8u) + 0u)];
                let _e827 = phi_0_;
                let _e833 = constants.scheme;
                let _e837 = other_idx;
                let _e844 = state[((_e837 * 8u) + 0u)];
                let _e845 = other_idx;
                let _e852 = state[((_e845 * 8u) + 0u)];
                let _e862 = state[((idx * 8u) + 0u)];
                let _e866 = other_idx;
                let _e873 = state[((_e866 * 8u) + 0u)];
                let _e880 = state[((idx * 8u) + 0u)];
                let _e889 = other_idx;
                let _e896 = state[((_e889 * 8u) + 0u)];
                let _e903 = state[((idx * 8u) + 0u)];
                let _e917 = other_center.x;
                let _e919 = other_center.y;
                let _e926 = other_idx;
                let _e933 = state[((_e926 * 8u) + 0u)];
                let _e941 = state[((idx * 8u) + 0u)];
                let _e948 = state[((idx * 8u) + 0u)];
                let _e952 = other_idx;
                let _e959 = state[((_e952 * 8u) + 0u)];
                let _e963 = other_idx;
                let _e970 = state[((_e963 * 8u) + 0u)];
                let _e977 = state[((idx * 8u) + 0u)];
                let _e986 = other_idx;
                let _e993 = state[((_e986 * 8u) + 0u)];
                let _e1000 = state[((idx * 8u) + 0u)];
                let _e1011 = other_center.x;
                let _e1013 = other_center.y;
                let _e1029 = state[((idx * 8u) + 0u)];
                let _e1031 = phi_0_;
                let _e1037 = constants.scheme;
                let _e1041 = other_idx;
                let _e1048 = state[((_e1041 * 8u) + 0u)];
                let _e1049 = other_idx;
                let _e1056 = state[((_e1049 * 8u) + 0u)];
                let _e1063 = state[((idx * 8u) + 0u)];
                let _e1072 = other_idx;
                let _e1079 = state[((_e1072 * 8u) + 0u)];
                let _e1086 = state[((idx * 8u) + 0u)];
                let _e1100 = other_center.x;
                let _e1102 = other_center.y;
                let _e1112 = state[((idx * 8u) + 0u)];
                let _e1113 = other_idx;
                let _e1120 = state[((_e1113 * 8u) + 0u)];
                let _e1131 = state[((idx * 8u) + 0u)];
                let _e1132 = other_idx;
                let _e1139 = state[((_e1132 * 8u) + 0u)];
                let _e1151 = state[((idx * 8u) + 0u)];
                let _e1152 = other_idx;
                let _e1159 = state[((_e1152 * 8u) + 0u)];
                let _e1166 = state[((idx * 8u) + 0u)];
                let _e1175 = other_idx;
                let _e1182 = state[((_e1175 * 8u) + 0u)];
                let _e1189 = state[((idx * 8u) + 0u)];
                let _e1207 = other_idx;
                let _e1214 = state[((_e1207 * 8u) + 0u)];
                let _e1221 = state[((idx * 8u) + 0u)];
                let _e1226 = other_idx;
                let _e1233 = state[((_e1226 * 8u) + 0u)];
                let _e1240 = state[((idx * 8u) + 0u)];
                let _e1246 = phi_0_;
                let _e1252 = constants.scheme;
                let _e1256 = other_idx;
                let _e1263 = state[((_e1256 * 8u) + 0u)];
                let _e1264 = other_idx;
                let _e1271 = state[((_e1264 * 8u) + 0u)];
                let _e1278 = state[((idx * 8u) + 0u)];
                let _e1287 = other_idx;
                let _e1294 = state[((_e1287 * 8u) + 0u)];
                let _e1301 = state[((idx * 8u) + 0u)];
                let _e1315 = other_center.x;
                let _e1317 = other_center.y;
                let _e1327 = state[((idx * 8u) + 0u)];
                let _e1328 = other_idx;
                let _e1335 = state[((_e1328 * 8u) + 0u)];
                let _e1345 = state[((idx * 8u) + 0u)];
                let _e1346 = other_idx;
                let _e1353 = state[((_e1346 * 8u) + 0u)];
                let _e1356 = other_idx;
                let _e1363 = state[((_e1356 * 8u) + 0u)];
                let _e1370 = state[((idx * 8u) + 0u)];
                let _e1379 = other_idx;
                let _e1386 = state[((_e1379 * 8u) + 0u)];
                let _e1393 = state[((idx * 8u) + 0u)];
                let _e1407 = other_center.x;
                let _e1409 = other_center.y;
                let _e1424 = state[((idx * 8u) + 0u)];
                let _e1425 = other_idx;
                let _e1432 = state[((_e1425 * 8u) + 0u)];
                let _e1434 = other_idx;
                let _e1441 = state[((_e1434 * 8u) + 0u)];
                let _e1448 = state[((idx * 8u) + 0u)];
                let _e1457 = other_idx;
                let _e1464 = state[((_e1457 * 8u) + 0u)];
                let _e1471 = state[((idx * 8u) + 0u)];
                let _e1485 = other_center.x;
                let _e1487 = other_center.y;
                let _e1501 = state[((idx * 8u) + 0u)];
                let _e1502 = other_idx;
                let _e1509 = state[((_e1502 * 8u) + 0u)];
                let _e1511 = other_idx;
                let _e1518 = state[((_e1511 * 8u) + 0u)];
                let _e1525 = state[((idx * 8u) + 0u)];
                let _e1534 = other_idx;
                let _e1541 = state[((_e1534 * 8u) + 0u)];
                let _e1548 = state[((idx * 8u) + 0u)];
                let _e1562 = other_center.x;
                let _e1564 = other_center.y;
                let _e1580 = state[((idx * 8u) + 0u)];
                let _e1581 = other_idx;
                let _e1588 = state[((_e1581 * 8u) + 0u)];
                let _e1595 = state[((idx * 8u) + 0u)];
                let _e1604 = other_idx;
                let _e1611 = state[((_e1604 * 8u) + 0u)];
                let _e1618 = state[((idx * 8u) + 0u)];
                let _e1636 = other_idx;
                let _e1643 = state[((_e1636 * 8u) + 0u)];
                let _e1650 = state[((idx * 8u) + 0u)];
                let _e1654 = other_idx;
                let _e1661 = state[((_e1654 * 8u) + 0u)];
                let _e1668 = state[((idx * 8u) + 0u)];
                let _e1671 = other_idx;
                let _e1678 = state[((_e1671 * 8u) + 0u)];
                let _e1685 = state[((idx * 8u) + 0u)];
                let _e1694 = other_idx;
                let _e1701 = state[((_e1694 * 8u) + 0u)];
                let _e1708 = state[((idx * 8u) + 0u)];
                let _e1731 = other_idx;
                let _e1738 = state[((_e1731 * 8u) + 0u)];
                let _e1745 = state[((idx * 8u) + 0u)];
                let _e1747 = other_idx;
                let _e1754 = state[((_e1747 * 8u) + 0u)];
                let _e1761 = state[((idx * 8u) + 0u)];
                let _e1770 = other_idx;
                let _e1777 = state[((_e1770 * 8u) + 0u)];
                let _e1784 = state[((idx * 8u) + 0u)];
                let _e1806 = other_idx;
                let _e1813 = state[((_e1806 * 8u) + 0u)];
                let _e1820 = state[((idx * 8u) + 0u)];
                let _e1822 = other_idx;
                let _e1829 = state[((_e1822 * 8u) + 0u)];
                let _e1836 = state[((idx * 8u) + 0u)];
                let _e1845 = other_idx;
                let _e1852 = state[((_e1845 * 8u) + 0u)];
                let _e1859 = state[((idx * 8u) + 0u)];
                let _e1883 = phi_0_;
                let _e1889 = constants.scheme;
                let _e1893 = other_idx;
                let _e1900 = state[((_e1893 * 8u) + 0u)];
                let _e1901 = other_idx;
                let _e1908 = state[((_e1901 * 8u) + 0u)];
                let _e1917 = state[((idx * 8u) + 0u)];
                let _e1921 = other_idx;
                let _e1928 = state[((_e1921 * 8u) + 0u)];
                let _e1935 = state[((idx * 8u) + 0u)];
                let _e1944 = other_idx;
                let _e1951 = state[((_e1944 * 8u) + 0u)];
                let _e1958 = state[((idx * 8u) + 0u)];
                let _e1972 = other_center.x;
                let _e1974 = other_center.y;
                let _e1981 = other_idx;
                let _e1988 = state[((_e1981 * 8u) + 0u)];
                let _e1996 = state[((idx * 8u) + 0u)];
                let _e1997 = other_idx;
                let _e2004 = state[((_e1997 * 8u) + 0u)];
                let _e2015 = state[((idx * 8u) + 0u)];
                let _e2016 = other_idx;
                let _e2023 = state[((_e2016 * 8u) + 0u)];
                let _e2035 = state[((idx * 8u) + 0u)];
                let _e2042 = state[((idx * 8u) + 0u)];
                let _e2045 = other_idx;
                let _e2052 = state[((_e2045 * 8u) + 0u)];
                let _e2056 = other_idx;
                let _e2063 = state[((_e2056 * 8u) + 0u)];
                let _e2070 = state[((idx * 8u) + 0u)];
                let _e2079 = other_idx;
                let _e2086 = state[((_e2079 * 8u) + 0u)];
                let _e2093 = state[((idx * 8u) + 0u)];
                let _e2104 = other_center.x;
                let _e2106 = other_center.y;
                let _e2122 = state[((idx * 8u) + 0u)];
                let _e2124 = other_idx;
                let _e2131 = state[((_e2124 * 8u) + 0u)];
                let _e2138 = state[((idx * 8u) + 0u)];
                let _e2143 = other_idx;
                let _e2150 = state[((_e2143 * 8u) + 0u)];
                let _e2157 = state[((idx * 8u) + 0u)];
                let _e2163 = phi_0_;
                let _e2169 = constants.scheme;
                let _e2173 = other_idx;
                let _e2180 = state[((_e2173 * 8u) + 0u)];
                let _e2181 = other_idx;
                let _e2188 = state[((_e2181 * 8u) + 0u)];
                let _e2197 = state[((idx * 8u) + 0u)];
                let _e2201 = other_idx;
                let _e2208 = state[((_e2201 * 8u) + 0u)];
                let _e2215 = state[((idx * 8u) + 0u)];
                let _e2224 = other_idx;
                let _e2231 = state[((_e2224 * 8u) + 0u)];
                let _e2238 = state[((idx * 8u) + 0u)];
                let _e2252 = other_center.x;
                let _e2254 = other_center.y;
                let _e2261 = other_idx;
                let _e2268 = state[((_e2261 * 8u) + 0u)];
                let _e2276 = state[((idx * 8u) + 0u)];
                let _e2277 = other_idx;
                let _e2284 = state[((_e2277 * 8u) + 0u)];
                let _e2294 = state[((idx * 8u) + 0u)];
                let _e2295 = other_idx;
                let _e2302 = state[((_e2295 * 8u) + 0u)];
                let _e2305 = other_idx;
                let _e2312 = state[((_e2305 * 8u) + 0u)];
                let _e2321 = state[((idx * 8u) + 0u)];
                let _e2325 = other_idx;
                let _e2332 = state[((_e2325 * 8u) + 0u)];
                let _e2339 = state[((idx * 8u) + 0u)];
                let _e2348 = other_idx;
                let _e2355 = state[((_e2348 * 8u) + 0u)];
                let _e2362 = state[((idx * 8u) + 0u)];
                let _e2376 = other_center.x;
                let _e2378 = other_center.y;
                let _e2385 = other_idx;
                let _e2392 = state[((_e2385 * 8u) + 0u)];
                let _e2405 = state[((idx * 8u) + 0u)];
                let _e2406 = other_idx;
                let _e2413 = state[((_e2406 * 8u) + 0u)];
                let _e2415 = other_idx;
                let _e2422 = state[((_e2415 * 8u) + 0u)];
                let _e2431 = state[((idx * 8u) + 0u)];
                let _e2435 = other_idx;
                let _e2442 = state[((_e2435 * 8u) + 0u)];
                let _e2449 = state[((idx * 8u) + 0u)];
                let _e2458 = other_idx;
                let _e2465 = state[((_e2458 * 8u) + 0u)];
                let _e2472 = state[((idx * 8u) + 0u)];
                let _e2486 = other_center.x;
                let _e2488 = other_center.y;
                let _e2495 = other_idx;
                let _e2502 = state[((_e2495 * 8u) + 0u)];
                let _e2514 = state[((idx * 8u) + 0u)];
                let _e2515 = other_idx;
                let _e2522 = state[((_e2515 * 8u) + 0u)];
                let _e2524 = other_idx;
                let _e2531 = state[((_e2524 * 8u) + 0u)];
                let _e2540 = state[((idx * 8u) + 0u)];
                let _e2544 = other_idx;
                let _e2551 = state[((_e2544 * 8u) + 0u)];
                let _e2558 = state[((idx * 8u) + 0u)];
                let _e2567 = other_idx;
                let _e2574 = state[((_e2567 * 8u) + 0u)];
                let _e2581 = state[((idx * 8u) + 0u)];
                let _e2595 = other_center.x;
                let _e2597 = other_center.y;
                let _e2604 = other_idx;
                let _e2611 = state[((_e2604 * 8u) + 0u)];
                let _e2625 = state[((idx * 8u) + 0u)];
                let _e2632 = state[((idx * 8u) + 0u)];
                let _e2635 = other_idx;
                let _e2642 = state[((_e2635 * 8u) + 0u)];
                let _e2646 = other_idx;
                let _e2653 = state[((_e2646 * 8u) + 0u)];
                let _e2660 = state[((idx * 8u) + 0u)];
                let _e2669 = other_idx;
                let _e2676 = state[((_e2669 * 8u) + 0u)];
                let _e2683 = state[((idx * 8u) + 0u)];
                let _e2694 = other_center.x;
                let _e2696 = other_center.y;
                let _e2712 = state[((idx * 8u) + 0u)];
                let _e2714 = other_idx;
                let _e2721 = state[((_e2714 * 8u) + 0u)];
                let _e2728 = state[((idx * 8u) + 0u)];
                let _e2732 = other_idx;
                let _e2739 = state[((_e2732 * 8u) + 0u)];
                let _e2746 = state[((idx * 8u) + 0u)];
                let _e2755 = state[((idx * 8u) + 0u)];
                let _e2758 = other_idx;
                let _e2765 = state[((_e2758 * 8u) + 0u)];
                let _e2769 = other_idx;
                let _e2776 = state[((_e2769 * 8u) + 0u)];
                let _e2783 = state[((idx * 8u) + 0u)];
                let _e2792 = other_idx;
                let _e2799 = state[((_e2792 * 8u) + 0u)];
                let _e2806 = state[((idx * 8u) + 0u)];
                let _e2817 = other_center.x;
                let _e2819 = other_center.y;
                let _e2835 = state[((idx * 8u) + 0u)];
                let _e2842 = other_idx;
                let _e2849 = state[((_e2842 * 8u) + 0u)];
                let _e2856 = state[((idx * 8u) + 0u)];
                let _e2864 = state[((idx * 8u) + 0u)];
                let _e2867 = other_idx;
                let _e2874 = state[((_e2867 * 8u) + 0u)];
                let _e2878 = other_idx;
                let _e2885 = state[((_e2878 * 8u) + 0u)];
                let _e2892 = state[((idx * 8u) + 0u)];
                let _e2901 = other_idx;
                let _e2908 = state[((_e2901 * 8u) + 0u)];
                let _e2915 = state[((idx * 8u) + 0u)];
                let _e2926 = other_center.x;
                let _e2928 = other_center.y;
                let _e2944 = state[((idx * 8u) + 0u)];
                let _e2950 = other_idx;
                let _e2957 = state[((_e2950 * 8u) + 0u)];
                let _e2964 = state[((idx * 8u) + 0u)];
                let _e2972 = state[((idx * 8u) + 0u)];
                let _e2975 = other_idx;
                let _e2982 = state[((_e2975 * 8u) + 0u)];
                let _e2986 = other_idx;
                let _e2993 = state[((_e2986 * 8u) + 0u)];
                let _e3000 = state[((idx * 8u) + 0u)];
                let _e3009 = other_idx;
                let _e3016 = state[((_e3009 * 8u) + 0u)];
                let _e3023 = state[((idx * 8u) + 0u)];
                let _e3034 = other_center.x;
                let _e3036 = other_center.y;
                let _e3052 = state[((idx * 8u) + 0u)];
                let _e3060 = phi_0_;
                let _e3066 = constants.scheme;
                let _e3076 = state[((idx * 8u) + 0u)];
                let _e3077 = other_idx;
                let _e3084 = state[((_e3077 * 8u) + 0u)];
                let _e3085 = phi_0_;
                let _e3091 = rhs_0_;
                rhs_0_ = (_e3091 - (_e678 * (select(select(select(select(select(select(select(_e685, _e693, (_e694 < 0f)), select((_e705 + dot(vec2<f32>((((_e713 - _e720) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e736 - _e743) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e757, _e759)))), (_e770 + dot(vec2<f32>((((_e778 - _e785) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e801 - _e808) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e827 > 0f)), (_e833 == 1u)), select(((((_e844 + (_e852 * 0.625f)) + (_e862 * 0.375f)) + (dot(vec2<f32>((((_e873 - _e880) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e896 - _e903) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e917, _e919))) * 0.125f)) - _e933), ((((_e941 + (_e948 * 0.625f)) + (_e959 * 0.375f)) + (dot(vec2<f32>((((_e970 - _e977) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e993 - _e1000) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e1011, _e1013) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1029), (_e1031 > 0f)), (_e1037 == 2u)), select((_e1048 + min(max(dot(vec2<f32>((((_e1056 - _e1063) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1079 - _e1086) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1100, _e1102))), min((_e1112 - _e1120), 0f)), max((_e1131 - _e1139), 0f))), (_e1151 + min(max(dot(vec2<f32>((((_e1159 - _e1166) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1182 - _e1189) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1214 - _e1221), 0f)), max((_e1233 - _e1240), 0f))), (_e1246 > 0f)), (_e1252 == 3u)), select((_e1263 + ((((dot(vec2<f32>((((_e1271 - _e1278) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1294 - _e1301) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1315, _e1317))) * abs((_e1327 - _e1335))) / max(abs((_e1345 - _e1353)), (abs(dot(vec2<f32>((((_e1363 - _e1370) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1386 - _e1393) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1407, _e1409)))) + 0.00000001f))) * max(((_e1424 - _e1432) * dot(vec2<f32>((((_e1441 - _e1448) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1464 - _e1471) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1485, _e1487)))), 0f)) / max(abs(((_e1501 - _e1509) * dot(vec2<f32>((((_e1518 - _e1525) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1541 - _e1548) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1562, _e1564))))), 0.00000001f))), (_e1580 + ((((dot(vec2<f32>((((_e1588 - _e1595) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1611 - _e1618) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1643 - _e1650))) / max(abs((_e1661 - _e1668)), (abs(dot(vec2<f32>((((_e1678 - _e1685) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1701 - _e1708) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1738 - _e1745) * dot(vec2<f32>((((_e1754 - _e1761) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1777 - _e1784) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1813 - _e1820) * dot(vec2<f32>((((_e1829 - _e1836) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1852 - _e1859) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1883 > 0f)), (_e1889 == 4u)), select((_e1900 + min(max(((((_e1908 * 0.625f) + (_e1917 * 0.375f)) + (dot(vec2<f32>((((_e1928 - _e1935) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1951 - _e1958) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1972, _e1974))) * 0.125f)) - _e1988), min((_e1996 - _e2004), 0f)), max((_e2015 - _e2023), 0f))), (_e2035 + min(max(((((_e2042 * 0.625f) + (_e2052 * 0.375f)) + (dot(vec2<f32>((((_e2063 - _e2070) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2086 - _e2093) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2104, _e2106) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2122), min((_e2131 - _e2138), 0f)), max((_e2150 - _e2157), 0f))), (_e2163 > 0f)), (_e2169 == 5u)), select((_e2180 + ((((((((_e2188 * 0.625f) + (_e2197 * 0.375f)) + (dot(vec2<f32>((((_e2208 - _e2215) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2231 - _e2238) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2252, _e2254))) * 0.125f)) - _e2268) * abs((_e2276 - _e2284))) / max(abs((_e2294 - _e2302)), (abs(((((_e2312 * 0.625f) + (_e2321 * 0.375f)) + (dot(vec2<f32>((((_e2332 - _e2339) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2355 - _e2362) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2376, _e2378))) * 0.125f)) - _e2392)) + 0.00000001f))) * max(((_e2405 - _e2413) * ((((_e2422 * 0.625f) + (_e2431 * 0.375f)) + (dot(vec2<f32>((((_e2442 - _e2449) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2465 - _e2472) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2486, _e2488))) * 0.125f)) - _e2502)), 0f)) / max(abs(((_e2514 - _e2522) * ((((_e2531 * 0.625f) + (_e2540 * 0.375f)) + (dot(vec2<f32>((((_e2551 - _e2558) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2574 - _e2581) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2595, _e2597))) * 0.125f)) - _e2611))), 0.00000001f))), (_e2625 + ((((((((_e2632 * 0.625f) + (_e2642 * 0.375f)) + (dot(vec2<f32>((((_e2653 - _e2660) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2676 - _e2683) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2694, _e2696) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2712) * abs((_e2721 - _e2728))) / max(abs((_e2739 - _e2746)), (abs(((((_e2755 * 0.625f) + (_e2765 * 0.375f)) + (dot(vec2<f32>((((_e2776 - _e2783) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2799 - _e2806) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2817, _e2819) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2835)) + 0.00000001f))) * max(((_e2849 - _e2856) * ((((_e2864 * 0.625f) + (_e2874 * 0.375f)) + (dot(vec2<f32>((((_e2885 - _e2892) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2908 - _e2915) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2926, _e2928) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2944)), 0f)) / max(abs(((_e2957 - _e2964) * ((((_e2972 * 0.625f) + (_e2982 * 0.375f)) + (dot(vec2<f32>((((_e2993 - _e3000) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3016 - _e3023) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3034, _e3036) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3052))), 0.00000001f))), (_e3060 > 0f)), (_e3066 == 6u)) - select(_e3076, _e3084, (_e3085 < 0f)))));
            } else {
                let _e3099 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3099 == 1u) {
                    let _e3102 = phi_0_;
                    let _e3105 = diag_0_;
                    diag_0_ = (_e3105 + max(_e3102, 0f));
                    let _e3107 = phi_0_;
                    let _e3116 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3118 = rhs_0_;
                    rhs_0_ = (_e3118 - (min(_e3107, 0f) * _e3116));
                } else {
                    let _e3120 = phi_0_;
                    let _e3121 = diag_0_;
                    diag_0_ = (_e3121 + _e3120);
                }
            }
            let _e3129 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3129;
            if (owner != idx) {
                let _e3132 = phi_1_;
                let _e3135 = phi_1_;
                phi_1_ = (_e3135 - (_e3132 * 2f));
            }
            let _e3137 = is_boundary;
            if !(_e3137) {
                let _e3139 = phi_1_;
                let _e3142 = diag_1_;
                diag_1_ = (_e3142 + max(_e3139, 0f));
                let _e3151 = phi_1_;
                let _e3154 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3154 + min(_e3151, 0f));
                let _e3156 = phi_1_;
                let _e3163 = state[((idx * 8u) + 1u)];
                let _e3164 = other_idx;
                let _e3171 = state[((_e3164 * 8u) + 1u)];
                let _e3172 = phi_1_;
                let _e3176 = other_idx;
                let _e3183 = state[((_e3176 * 8u) + 1u)];
                let _e3184 = other_idx;
                let _e3191 = state[((_e3184 * 8u) + 1u)];
                let _e3198 = state[((idx * 8u) + 1u)];
                let _e3207 = other_idx;
                let _e3214 = state[((_e3207 * 8u) + 1u)];
                let _e3221 = state[((idx * 8u) + 1u)];
                let _e3235 = other_center.x;
                let _e3237 = other_center.y;
                let _e3248 = state[((idx * 8u) + 1u)];
                let _e3249 = other_idx;
                let _e3256 = state[((_e3249 * 8u) + 1u)];
                let _e3263 = state[((idx * 8u) + 1u)];
                let _e3272 = other_idx;
                let _e3279 = state[((_e3272 * 8u) + 1u)];
                let _e3286 = state[((idx * 8u) + 1u)];
                let _e3305 = phi_1_;
                let _e3311 = constants.scheme;
                let _e3315 = other_idx;
                let _e3322 = state[((_e3315 * 8u) + 1u)];
                let _e3323 = other_idx;
                let _e3330 = state[((_e3323 * 8u) + 1u)];
                let _e3340 = state[((idx * 8u) + 1u)];
                let _e3344 = other_idx;
                let _e3351 = state[((_e3344 * 8u) + 1u)];
                let _e3358 = state[((idx * 8u) + 1u)];
                let _e3367 = other_idx;
                let _e3374 = state[((_e3367 * 8u) + 1u)];
                let _e3381 = state[((idx * 8u) + 1u)];
                let _e3395 = other_center.x;
                let _e3397 = other_center.y;
                let _e3404 = other_idx;
                let _e3411 = state[((_e3404 * 8u) + 1u)];
                let _e3419 = state[((idx * 8u) + 1u)];
                let _e3426 = state[((idx * 8u) + 1u)];
                let _e3430 = other_idx;
                let _e3437 = state[((_e3430 * 8u) + 1u)];
                let _e3441 = other_idx;
                let _e3448 = state[((_e3441 * 8u) + 1u)];
                let _e3455 = state[((idx * 8u) + 1u)];
                let _e3464 = other_idx;
                let _e3471 = state[((_e3464 * 8u) + 1u)];
                let _e3478 = state[((idx * 8u) + 1u)];
                let _e3489 = other_center.x;
                let _e3491 = other_center.y;
                let _e3507 = state[((idx * 8u) + 1u)];
                let _e3509 = phi_1_;
                let _e3515 = constants.scheme;
                let _e3519 = other_idx;
                let _e3526 = state[((_e3519 * 8u) + 1u)];
                let _e3527 = other_idx;
                let _e3534 = state[((_e3527 * 8u) + 1u)];
                let _e3541 = state[((idx * 8u) + 1u)];
                let _e3550 = other_idx;
                let _e3557 = state[((_e3550 * 8u) + 1u)];
                let _e3564 = state[((idx * 8u) + 1u)];
                let _e3578 = other_center.x;
                let _e3580 = other_center.y;
                let _e3590 = state[((idx * 8u) + 1u)];
                let _e3591 = other_idx;
                let _e3598 = state[((_e3591 * 8u) + 1u)];
                let _e3609 = state[((idx * 8u) + 1u)];
                let _e3610 = other_idx;
                let _e3617 = state[((_e3610 * 8u) + 1u)];
                let _e3629 = state[((idx * 8u) + 1u)];
                let _e3630 = other_idx;
                let _e3637 = state[((_e3630 * 8u) + 1u)];
                let _e3644 = state[((idx * 8u) + 1u)];
                let _e3653 = other_idx;
                let _e3660 = state[((_e3653 * 8u) + 1u)];
                let _e3667 = state[((idx * 8u) + 1u)];
                let _e3685 = other_idx;
                let _e3692 = state[((_e3685 * 8u) + 1u)];
                let _e3699 = state[((idx * 8u) + 1u)];
                let _e3704 = other_idx;
                let _e3711 = state[((_e3704 * 8u) + 1u)];
                let _e3718 = state[((idx * 8u) + 1u)];
                let _e3724 = phi_1_;
                let _e3730 = constants.scheme;
                let _e3734 = other_idx;
                let _e3741 = state[((_e3734 * 8u) + 1u)];
                let _e3742 = other_idx;
                let _e3749 = state[((_e3742 * 8u) + 1u)];
                let _e3756 = state[((idx * 8u) + 1u)];
                let _e3765 = other_idx;
                let _e3772 = state[((_e3765 * 8u) + 1u)];
                let _e3779 = state[((idx * 8u) + 1u)];
                let _e3793 = other_center.x;
                let _e3795 = other_center.y;
                let _e3805 = state[((idx * 8u) + 1u)];
                let _e3806 = other_idx;
                let _e3813 = state[((_e3806 * 8u) + 1u)];
                let _e3823 = state[((idx * 8u) + 1u)];
                let _e3824 = other_idx;
                let _e3831 = state[((_e3824 * 8u) + 1u)];
                let _e3834 = other_idx;
                let _e3841 = state[((_e3834 * 8u) + 1u)];
                let _e3848 = state[((idx * 8u) + 1u)];
                let _e3857 = other_idx;
                let _e3864 = state[((_e3857 * 8u) + 1u)];
                let _e3871 = state[((idx * 8u) + 1u)];
                let _e3885 = other_center.x;
                let _e3887 = other_center.y;
                let _e3902 = state[((idx * 8u) + 1u)];
                let _e3903 = other_idx;
                let _e3910 = state[((_e3903 * 8u) + 1u)];
                let _e3912 = other_idx;
                let _e3919 = state[((_e3912 * 8u) + 1u)];
                let _e3926 = state[((idx * 8u) + 1u)];
                let _e3935 = other_idx;
                let _e3942 = state[((_e3935 * 8u) + 1u)];
                let _e3949 = state[((idx * 8u) + 1u)];
                let _e3963 = other_center.x;
                let _e3965 = other_center.y;
                let _e3979 = state[((idx * 8u) + 1u)];
                let _e3980 = other_idx;
                let _e3987 = state[((_e3980 * 8u) + 1u)];
                let _e3989 = other_idx;
                let _e3996 = state[((_e3989 * 8u) + 1u)];
                let _e4003 = state[((idx * 8u) + 1u)];
                let _e4012 = other_idx;
                let _e4019 = state[((_e4012 * 8u) + 1u)];
                let _e4026 = state[((idx * 8u) + 1u)];
                let _e4040 = other_center.x;
                let _e4042 = other_center.y;
                let _e4058 = state[((idx * 8u) + 1u)];
                let _e4059 = other_idx;
                let _e4066 = state[((_e4059 * 8u) + 1u)];
                let _e4073 = state[((idx * 8u) + 1u)];
                let _e4082 = other_idx;
                let _e4089 = state[((_e4082 * 8u) + 1u)];
                let _e4096 = state[((idx * 8u) + 1u)];
                let _e4114 = other_idx;
                let _e4121 = state[((_e4114 * 8u) + 1u)];
                let _e4128 = state[((idx * 8u) + 1u)];
                let _e4132 = other_idx;
                let _e4139 = state[((_e4132 * 8u) + 1u)];
                let _e4146 = state[((idx * 8u) + 1u)];
                let _e4149 = other_idx;
                let _e4156 = state[((_e4149 * 8u) + 1u)];
                let _e4163 = state[((idx * 8u) + 1u)];
                let _e4172 = other_idx;
                let _e4179 = state[((_e4172 * 8u) + 1u)];
                let _e4186 = state[((idx * 8u) + 1u)];
                let _e4209 = other_idx;
                let _e4216 = state[((_e4209 * 8u) + 1u)];
                let _e4223 = state[((idx * 8u) + 1u)];
                let _e4225 = other_idx;
                let _e4232 = state[((_e4225 * 8u) + 1u)];
                let _e4239 = state[((idx * 8u) + 1u)];
                let _e4248 = other_idx;
                let _e4255 = state[((_e4248 * 8u) + 1u)];
                let _e4262 = state[((idx * 8u) + 1u)];
                let _e4284 = other_idx;
                let _e4291 = state[((_e4284 * 8u) + 1u)];
                let _e4298 = state[((idx * 8u) + 1u)];
                let _e4300 = other_idx;
                let _e4307 = state[((_e4300 * 8u) + 1u)];
                let _e4314 = state[((idx * 8u) + 1u)];
                let _e4323 = other_idx;
                let _e4330 = state[((_e4323 * 8u) + 1u)];
                let _e4337 = state[((idx * 8u) + 1u)];
                let _e4361 = phi_1_;
                let _e4367 = constants.scheme;
                let _e4371 = other_idx;
                let _e4378 = state[((_e4371 * 8u) + 1u)];
                let _e4379 = other_idx;
                let _e4386 = state[((_e4379 * 8u) + 1u)];
                let _e4395 = state[((idx * 8u) + 1u)];
                let _e4399 = other_idx;
                let _e4406 = state[((_e4399 * 8u) + 1u)];
                let _e4413 = state[((idx * 8u) + 1u)];
                let _e4422 = other_idx;
                let _e4429 = state[((_e4422 * 8u) + 1u)];
                let _e4436 = state[((idx * 8u) + 1u)];
                let _e4450 = other_center.x;
                let _e4452 = other_center.y;
                let _e4459 = other_idx;
                let _e4466 = state[((_e4459 * 8u) + 1u)];
                let _e4474 = state[((idx * 8u) + 1u)];
                let _e4475 = other_idx;
                let _e4482 = state[((_e4475 * 8u) + 1u)];
                let _e4493 = state[((idx * 8u) + 1u)];
                let _e4494 = other_idx;
                let _e4501 = state[((_e4494 * 8u) + 1u)];
                let _e4513 = state[((idx * 8u) + 1u)];
                let _e4520 = state[((idx * 8u) + 1u)];
                let _e4523 = other_idx;
                let _e4530 = state[((_e4523 * 8u) + 1u)];
                let _e4534 = other_idx;
                let _e4541 = state[((_e4534 * 8u) + 1u)];
                let _e4548 = state[((idx * 8u) + 1u)];
                let _e4557 = other_idx;
                let _e4564 = state[((_e4557 * 8u) + 1u)];
                let _e4571 = state[((idx * 8u) + 1u)];
                let _e4582 = other_center.x;
                let _e4584 = other_center.y;
                let _e4600 = state[((idx * 8u) + 1u)];
                let _e4602 = other_idx;
                let _e4609 = state[((_e4602 * 8u) + 1u)];
                let _e4616 = state[((idx * 8u) + 1u)];
                let _e4621 = other_idx;
                let _e4628 = state[((_e4621 * 8u) + 1u)];
                let _e4635 = state[((idx * 8u) + 1u)];
                let _e4641 = phi_1_;
                let _e4647 = constants.scheme;
                let _e4651 = other_idx;
                let _e4658 = state[((_e4651 * 8u) + 1u)];
                let _e4659 = other_idx;
                let _e4666 = state[((_e4659 * 8u) + 1u)];
                let _e4675 = state[((idx * 8u) + 1u)];
                let _e4679 = other_idx;
                let _e4686 = state[((_e4679 * 8u) + 1u)];
                let _e4693 = state[((idx * 8u) + 1u)];
                let _e4702 = other_idx;
                let _e4709 = state[((_e4702 * 8u) + 1u)];
                let _e4716 = state[((idx * 8u) + 1u)];
                let _e4730 = other_center.x;
                let _e4732 = other_center.y;
                let _e4739 = other_idx;
                let _e4746 = state[((_e4739 * 8u) + 1u)];
                let _e4754 = state[((idx * 8u) + 1u)];
                let _e4755 = other_idx;
                let _e4762 = state[((_e4755 * 8u) + 1u)];
                let _e4772 = state[((idx * 8u) + 1u)];
                let _e4773 = other_idx;
                let _e4780 = state[((_e4773 * 8u) + 1u)];
                let _e4783 = other_idx;
                let _e4790 = state[((_e4783 * 8u) + 1u)];
                let _e4799 = state[((idx * 8u) + 1u)];
                let _e4803 = other_idx;
                let _e4810 = state[((_e4803 * 8u) + 1u)];
                let _e4817 = state[((idx * 8u) + 1u)];
                let _e4826 = other_idx;
                let _e4833 = state[((_e4826 * 8u) + 1u)];
                let _e4840 = state[((idx * 8u) + 1u)];
                let _e4854 = other_center.x;
                let _e4856 = other_center.y;
                let _e4863 = other_idx;
                let _e4870 = state[((_e4863 * 8u) + 1u)];
                let _e4883 = state[((idx * 8u) + 1u)];
                let _e4884 = other_idx;
                let _e4891 = state[((_e4884 * 8u) + 1u)];
                let _e4893 = other_idx;
                let _e4900 = state[((_e4893 * 8u) + 1u)];
                let _e4909 = state[((idx * 8u) + 1u)];
                let _e4913 = other_idx;
                let _e4920 = state[((_e4913 * 8u) + 1u)];
                let _e4927 = state[((idx * 8u) + 1u)];
                let _e4936 = other_idx;
                let _e4943 = state[((_e4936 * 8u) + 1u)];
                let _e4950 = state[((idx * 8u) + 1u)];
                let _e4964 = other_center.x;
                let _e4966 = other_center.y;
                let _e4973 = other_idx;
                let _e4980 = state[((_e4973 * 8u) + 1u)];
                let _e4992 = state[((idx * 8u) + 1u)];
                let _e4993 = other_idx;
                let _e5000 = state[((_e4993 * 8u) + 1u)];
                let _e5002 = other_idx;
                let _e5009 = state[((_e5002 * 8u) + 1u)];
                let _e5018 = state[((idx * 8u) + 1u)];
                let _e5022 = other_idx;
                let _e5029 = state[((_e5022 * 8u) + 1u)];
                let _e5036 = state[((idx * 8u) + 1u)];
                let _e5045 = other_idx;
                let _e5052 = state[((_e5045 * 8u) + 1u)];
                let _e5059 = state[((idx * 8u) + 1u)];
                let _e5073 = other_center.x;
                let _e5075 = other_center.y;
                let _e5082 = other_idx;
                let _e5089 = state[((_e5082 * 8u) + 1u)];
                let _e5103 = state[((idx * 8u) + 1u)];
                let _e5110 = state[((idx * 8u) + 1u)];
                let _e5113 = other_idx;
                let _e5120 = state[((_e5113 * 8u) + 1u)];
                let _e5124 = other_idx;
                let _e5131 = state[((_e5124 * 8u) + 1u)];
                let _e5138 = state[((idx * 8u) + 1u)];
                let _e5147 = other_idx;
                let _e5154 = state[((_e5147 * 8u) + 1u)];
                let _e5161 = state[((idx * 8u) + 1u)];
                let _e5172 = other_center.x;
                let _e5174 = other_center.y;
                let _e5190 = state[((idx * 8u) + 1u)];
                let _e5192 = other_idx;
                let _e5199 = state[((_e5192 * 8u) + 1u)];
                let _e5206 = state[((idx * 8u) + 1u)];
                let _e5210 = other_idx;
                let _e5217 = state[((_e5210 * 8u) + 1u)];
                let _e5224 = state[((idx * 8u) + 1u)];
                let _e5233 = state[((idx * 8u) + 1u)];
                let _e5236 = other_idx;
                let _e5243 = state[((_e5236 * 8u) + 1u)];
                let _e5247 = other_idx;
                let _e5254 = state[((_e5247 * 8u) + 1u)];
                let _e5261 = state[((idx * 8u) + 1u)];
                let _e5270 = other_idx;
                let _e5277 = state[((_e5270 * 8u) + 1u)];
                let _e5284 = state[((idx * 8u) + 1u)];
                let _e5295 = other_center.x;
                let _e5297 = other_center.y;
                let _e5313 = state[((idx * 8u) + 1u)];
                let _e5320 = other_idx;
                let _e5327 = state[((_e5320 * 8u) + 1u)];
                let _e5334 = state[((idx * 8u) + 1u)];
                let _e5342 = state[((idx * 8u) + 1u)];
                let _e5345 = other_idx;
                let _e5352 = state[((_e5345 * 8u) + 1u)];
                let _e5356 = other_idx;
                let _e5363 = state[((_e5356 * 8u) + 1u)];
                let _e5370 = state[((idx * 8u) + 1u)];
                let _e5379 = other_idx;
                let _e5386 = state[((_e5379 * 8u) + 1u)];
                let _e5393 = state[((idx * 8u) + 1u)];
                let _e5404 = other_center.x;
                let _e5406 = other_center.y;
                let _e5422 = state[((idx * 8u) + 1u)];
                let _e5428 = other_idx;
                let _e5435 = state[((_e5428 * 8u) + 1u)];
                let _e5442 = state[((idx * 8u) + 1u)];
                let _e5450 = state[((idx * 8u) + 1u)];
                let _e5453 = other_idx;
                let _e5460 = state[((_e5453 * 8u) + 1u)];
                let _e5464 = other_idx;
                let _e5471 = state[((_e5464 * 8u) + 1u)];
                let _e5478 = state[((idx * 8u) + 1u)];
                let _e5487 = other_idx;
                let _e5494 = state[((_e5487 * 8u) + 1u)];
                let _e5501 = state[((idx * 8u) + 1u)];
                let _e5512 = other_center.x;
                let _e5514 = other_center.y;
                let _e5530 = state[((idx * 8u) + 1u)];
                let _e5538 = phi_1_;
                let _e5544 = constants.scheme;
                let _e5554 = state[((idx * 8u) + 1u)];
                let _e5555 = other_idx;
                let _e5562 = state[((_e5555 * 8u) + 1u)];
                let _e5563 = phi_1_;
                let _e5569 = rhs_1_;
                rhs_1_ = (_e5569 - (_e3156 * (select(select(select(select(select(select(select(_e3163, _e3171, (_e3172 < 0f)), select((_e3183 + dot(vec2<f32>((((_e3191 - _e3198) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3214 - _e3221) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3235, _e3237)))), (_e3248 + dot(vec2<f32>((((_e3256 - _e3263) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3279 - _e3286) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3305 > 0f)), (_e3311 == 1u)), select(((((_e3322 + (_e3330 * 0.625f)) + (_e3340 * 0.375f)) + (dot(vec2<f32>((((_e3351 - _e3358) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3374 - _e3381) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3395, _e3397))) * 0.125f)) - _e3411), ((((_e3419 + (_e3426 * 0.625f)) + (_e3437 * 0.375f)) + (dot(vec2<f32>((((_e3448 - _e3455) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3471 - _e3478) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3489, _e3491) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3507), (_e3509 > 0f)), (_e3515 == 2u)), select((_e3526 + min(max(dot(vec2<f32>((((_e3534 - _e3541) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3557 - _e3564) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3578, _e3580))), min((_e3590 - _e3598), 0f)), max((_e3609 - _e3617), 0f))), (_e3629 + min(max(dot(vec2<f32>((((_e3637 - _e3644) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3660 - _e3667) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e3692 - _e3699), 0f)), max((_e3711 - _e3718), 0f))), (_e3724 > 0f)), (_e3730 == 3u)), select((_e3741 + ((((dot(vec2<f32>((((_e3749 - _e3756) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3772 - _e3779) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3793, _e3795))) * abs((_e3805 - _e3813))) / max(abs((_e3823 - _e3831)), (abs(dot(vec2<f32>((((_e3841 - _e3848) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3864 - _e3871) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3885, _e3887)))) + 0.00000001f))) * max(((_e3902 - _e3910) * dot(vec2<f32>((((_e3919 - _e3926) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3942 - _e3949) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3963, _e3965)))), 0f)) / max(abs(((_e3979 - _e3987) * dot(vec2<f32>((((_e3996 - _e4003) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4019 - _e4026) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4040, _e4042))))), 0.00000001f))), (_e4058 + ((((dot(vec2<f32>((((_e4066 - _e4073) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4089 - _e4096) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e4121 - _e4128))) / max(abs((_e4139 - _e4146)), (abs(dot(vec2<f32>((((_e4156 - _e4163) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4179 - _e4186) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e4216 - _e4223) * dot(vec2<f32>((((_e4232 - _e4239) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4255 - _e4262) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e4291 - _e4298) * dot(vec2<f32>((((_e4307 - _e4314) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4330 - _e4337) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e4361 > 0f)), (_e4367 == 4u)), select((_e4378 + min(max(((((_e4386 * 0.625f) + (_e4395 * 0.375f)) + (dot(vec2<f32>((((_e4406 - _e4413) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4429 - _e4436) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4450, _e4452))) * 0.125f)) - _e4466), min((_e4474 - _e4482), 0f)), max((_e4493 - _e4501), 0f))), (_e4513 + min(max(((((_e4520 * 0.625f) + (_e4530 * 0.375f)) + (dot(vec2<f32>((((_e4541 - _e4548) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4564 - _e4571) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e4582, _e4584) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4600), min((_e4609 - _e4616), 0f)), max((_e4628 - _e4635), 0f))), (_e4641 > 0f)), (_e4647 == 5u)), select((_e4658 + ((((((((_e4666 * 0.625f) + (_e4675 * 0.375f)) + (dot(vec2<f32>((((_e4686 - _e4693) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4709 - _e4716) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4730, _e4732))) * 0.125f)) - _e4746) * abs((_e4754 - _e4762))) / max(abs((_e4772 - _e4780)), (abs(((((_e4790 * 0.625f) + (_e4799 * 0.375f)) + (dot(vec2<f32>((((_e4810 - _e4817) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4833 - _e4840) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4854, _e4856))) * 0.125f)) - _e4870)) + 0.00000001f))) * max(((_e4883 - _e4891) * ((((_e4900 * 0.625f) + (_e4909 * 0.375f)) + (dot(vec2<f32>((((_e4920 - _e4927) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4943 - _e4950) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4964, _e4966))) * 0.125f)) - _e4980)), 0f)) / max(abs(((_e4992 - _e5000) * ((((_e5009 * 0.625f) + (_e5018 * 0.375f)) + (dot(vec2<f32>((((_e5029 - _e5036) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5052 - _e5059) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5073, _e5075))) * 0.125f)) - _e5089))), 0.00000001f))), (_e5103 + ((((((((_e5110 * 0.625f) + (_e5120 * 0.375f)) + (dot(vec2<f32>((((_e5131 - _e5138) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5154 - _e5161) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5172, _e5174) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5190) * abs((_e5199 - _e5206))) / max(abs((_e5217 - _e5224)), (abs(((((_e5233 * 0.625f) + (_e5243 * 0.375f)) + (dot(vec2<f32>((((_e5254 - _e5261) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5277 - _e5284) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5295, _e5297) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5313)) + 0.00000001f))) * max(((_e5327 - _e5334) * ((((_e5342 * 0.625f) + (_e5352 * 0.375f)) + (dot(vec2<f32>((((_e5363 - _e5370) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5386 - _e5393) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5404, _e5406) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5422)), 0f)) / max(abs(((_e5435 - _e5442) * ((((_e5450 * 0.625f) + (_e5460 * 0.375f)) + (dot(vec2<f32>((((_e5471 - _e5478) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5494 - _e5501) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5512, _e5514) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5530))), 0.00000001f))), (_e5538 > 0f)), (_e5544 == 6u)) - select(_e5554, _e5562, (_e5563 < 0f)))));
            } else {
                let _e5577 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e5577 == 1u) {
                    let _e5580 = phi_1_;
                    let _e5583 = diag_1_;
                    diag_1_ = (_e5583 + max(_e5580, 0f));
                    let _e5585 = phi_1_;
                    let _e5594 = bc_value[((face_idx * 3u) + 1u)];
                    let _e5596 = rhs_1_;
                    rhs_1_ = (_e5596 - (min(_e5585, 0f) * _e5594));
                } else {
                    let _e5598 = phi_1_;
                    let _e5599 = diag_1_;
                    diag_1_ = (_e5599 + _e5598);
                }
            }
            let _e5611 = normal.x;
            let _e5613 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)] = (_e5613 + ((0.5f * area) * _e5611));
            let _e5625 = normal.x;
            let _e5627 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)] = (_e5627 + ((0.5f * area) * _e5625));
            let _e5639 = normal.y;
            let _e5641 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)] = (_e5641 + ((0.5f * area) * _e5639));
            let _e5653 = normal.y;
            let _e5655 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)] = (_e5655 + ((0.5f * area) * _e5653));
            let _e5659 = constants.density;
            let _e5666 = state[((idx * 8u) + 3u)];
            let _e5669 = dist;
            let diff_coeff_p = (((_e5659 * _e5666) * area) / _e5669);
            let _e5671 = is_boundary;
            if !(_e5671) {
                let _e5674 = diag_2_;
                diag_2_ = (_e5674 + diff_coeff_p);
                let _e5683 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e5683 - diff_coeff_p);
            } else {
                let _e5691 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e5691 == 1u) {
                    let _e5694 = diag_2_;
                    diag_2_ = (_e5694 + diff_coeff_p);
                    let _e5703 = bc_value[((face_idx * 3u) + 2u)];
                    let _e5705 = rhs_2_;
                    rhs_2_ = (_e5705 + (diff_coeff_p * _e5703));
                } else {
                    let _e5713 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e5713 == 2u) {
                        let _e5718 = constants.density;
                        let _e5725 = state[((idx * 8u) + 3u)];
                        let _e5734 = bc_value[((face_idx * 3u) + 2u)];
                        let _e5737 = rhs_2_;
                        rhs_2_ = (_e5737 + -((((_e5718 * _e5725) * area) * _e5734)));
                    }
                }
            }
            let _e5745 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e5745;
            if (owner != idx) {
                let _e5748 = phi_2_;
                let _e5751 = phi_2_;
                phi_2_ = (_e5751 - (_e5748 * 2f));
            }
            let _e5753 = phi_2_;
            let _e5754 = rhs_2_;
            rhs_2_ = (_e5754 - _e5753);
        }
        continuing {
            let _e5757 = k;
            k = (_e5757 + 1u);
        }
    }
    let _e5766 = diag_0_;
    let _e5767 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e5767 + _e5766);
    let _e5775 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e5775;
    let _e5783 = diag_1_;
    let _e5784 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e5784 + _e5783);
    let _e5792 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e5792;
    let _e5800 = diag_2_;
    let _e5801 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e5801 + _e5800);
    let _e5809 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e5809;
    return;
}
"#;
    }
    pub mod generic_coupled_update_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_compressible :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 8u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 8u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e52 = constants.dtau;
    let _e64 = state[((idx * 8u) + 0u)];
    let _e71 = state[((idx * 8u) + 0u)];
    let _e79 = state[((idx * 8u) + 0u)];
    let _e91 = x[((idx * 8u) + 0u)];
    let _e98 = x[((idx * 8u) + 0u)];
    let _e106 = x[((idx * 8u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, select(1f, _e49, (_e52 > 0f))), ((_e64 == _e71) && (abs(_e79) < 340000000000000000000000000000000000000f))), ((_e91 == _e98) && (abs(_e106) < 340000000000000000000000000000000000000f)));
    let _e124 = state[((idx * 8u) + 0u)];
    let _e131 = x[((idx * 8u) + 0u)];
    let _e138 = state[((idx * 8u) + 0u)];
    let _e145 = x[((idx * 8u) + 0u)];
    let _e148 = constants.alpha_u;
    let _e151 = constants.dtau;
    let _e163 = state[((idx * 8u) + 0u)];
    let _e170 = state[((idx * 8u) + 0u)];
    let _e178 = state[((idx * 8u) + 0u)];
    let _e190 = x[((idx * 8u) + 0u)];
    let _e197 = x[((idx * 8u) + 0u)];
    let _e205 = x[((idx * 8u) + 0u)];
    x[((idx * 8u) + 0u)] = select(_e124, select(_e131, mix(_e138, _e145, select(1f, _e148, (_e151 > 0f))), ((_e163 == _e170) && (abs(_e178) < 340000000000000000000000000000000000000f))), ((_e190 == _e197) && (abs(_e205) < 340000000000000000000000000000000000000f)));
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 8u) + 1u)];
    let _e237 = state[((idx * 8u) + 1u)];
    let _e244 = x[((idx * 8u) + 1u)];
    let _e247 = constants.alpha_u;
    let _e250 = constants.dtau;
    let _e262 = state[((idx * 8u) + 1u)];
    let _e269 = state[((idx * 8u) + 1u)];
    let _e277 = state[((idx * 8u) + 1u)];
    let _e289 = x[((idx * 8u) + 1u)];
    let _e296 = x[((idx * 8u) + 1u)];
    let _e304 = x[((idx * 8u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e223, select(_e230, mix(_e237, _e244, select(1f, _e247, (_e250 > 0f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f))), ((_e289 == _e296) && (abs(_e304) < 340000000000000000000000000000000000000f)));
    let _e322 = state[((idx * 8u) + 1u)];
    let _e329 = x[((idx * 8u) + 1u)];
    let _e336 = state[((idx * 8u) + 1u)];
    let _e343 = x[((idx * 8u) + 1u)];
    let _e346 = constants.alpha_u;
    let _e349 = constants.dtau;
    let _e361 = state[((idx * 8u) + 1u)];
    let _e368 = state[((idx * 8u) + 1u)];
    let _e376 = state[((idx * 8u) + 1u)];
    let _e388 = x[((idx * 8u) + 1u)];
    let _e395 = x[((idx * 8u) + 1u)];
    let _e403 = x[((idx * 8u) + 1u)];
    x[((idx * 8u) + 1u)] = select(_e322, select(_e329, mix(_e336, _e343, select(1f, _e346, (_e349 > 0f))), ((_e361 == _e368) && (abs(_e376) < 340000000000000000000000000000000000000f))), ((_e388 == _e395) && (abs(_e403) < 340000000000000000000000000000000000000f)));
    let _e421 = state[((idx * 8u) + 2u)];
    let _e428 = x[((idx * 8u) + 2u)];
    let _e435 = state[((idx * 8u) + 2u)];
    let _e442 = x[((idx * 8u) + 2u)];
    let _e445 = constants.alpha_u;
    let _e448 = constants.dtau;
    let _e460 = state[((idx * 8u) + 2u)];
    let _e467 = state[((idx * 8u) + 2u)];
    let _e475 = state[((idx * 8u) + 2u)];
    let _e487 = x[((idx * 8u) + 2u)];
    let _e494 = x[((idx * 8u) + 2u)];
    let _e502 = x[((idx * 8u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e421, select(_e428, mix(_e435, _e442, select(1f, _e445, (_e448 > 0f))), ((_e460 == _e467) && (abs(_e475) < 340000000000000000000000000000000000000f))), ((_e487 == _e494) && (abs(_e502) < 340000000000000000000000000000000000000f)));
    let _e520 = state[((idx * 8u) + 2u)];
    let _e527 = x[((idx * 8u) + 2u)];
    let _e534 = state[((idx * 8u) + 2u)];
    let _e541 = x[((idx * 8u) + 2u)];
    let _e544 = constants.alpha_u;
    let _e547 = constants.dtau;
    let _e559 = state[((idx * 8u) + 2u)];
    let _e566 = state[((idx * 8u) + 2u)];
    let _e574 = state[((idx * 8u) + 2u)];
    let _e586 = x[((idx * 8u) + 2u)];
    let _e593 = x[((idx * 8u) + 2u)];
    let _e601 = x[((idx * 8u) + 2u)];
    x[((idx * 8u) + 2u)] = select(_e520, select(_e527, mix(_e534, _e541, select(1f, _e544, (_e547 > 0f))), ((_e559 == _e566) && (abs(_e574) < 340000000000000000000000000000000000000f))), ((_e586 == _e593) && (abs(_e601) < 340000000000000000000000000000000000000f)));
    let _e619 = state[((idx * 8u) + 3u)];
    let _e626 = x[((idx * 8u) + 3u)];
    let _e633 = state[((idx * 8u) + 3u)];
    let _e640 = x[((idx * 8u) + 3u)];
    let _e643 = constants.alpha_u;
    let _e646 = constants.dtau;
    let _e658 = state[((idx * 8u) + 3u)];
    let _e665 = state[((idx * 8u) + 3u)];
    let _e673 = state[((idx * 8u) + 3u)];
    let _e685 = x[((idx * 8u) + 3u)];
    let _e692 = x[((idx * 8u) + 3u)];
    let _e700 = x[((idx * 8u) + 3u)];
    state[((idx * 8u) + 3u)] = select(_e619, select(_e626, mix(_e633, _e640, select(1f, _e643, (_e646 > 0f))), ((_e658 == _e665) && (abs(_e673) < 340000000000000000000000000000000000000f))), ((_e685 == _e692) && (abs(_e700) < 340000000000000000000000000000000000000f)));
    let _e718 = state[((idx * 8u) + 3u)];
    let _e725 = x[((idx * 8u) + 3u)];
    let _e732 = state[((idx * 8u) + 3u)];
    let _e739 = x[((idx * 8u) + 3u)];
    let _e742 = constants.alpha_u;
    let _e745 = constants.dtau;
    let _e757 = state[((idx * 8u) + 3u)];
    let _e764 = state[((idx * 8u) + 3u)];
    let _e772 = state[((idx * 8u) + 3u)];
    let _e784 = x[((idx * 8u) + 3u)];
    let _e791 = x[((idx * 8u) + 3u)];
    let _e799 = x[((idx * 8u) + 3u)];
    x[((idx * 8u) + 3u)] = select(_e718, select(_e725, mix(_e732, _e739, select(1f, _e742, (_e745 > 0f))), ((_e757 == _e764) && (abs(_e772) < 340000000000000000000000000000000000000f))), ((_e784 == _e791) && (abs(_e799) < 340000000000000000000000000000000000000f)));
    let _e817 = state[((idx * 8u) + 6u)];
    let _e824 = x[((idx * 8u) + 4u)];
    let _e831 = state[((idx * 8u) + 6u)];
    let _e838 = x[((idx * 8u) + 4u)];
    let _e841 = constants.alpha_u;
    let _e844 = constants.dtau;
    let _e856 = state[((idx * 8u) + 6u)];
    let _e863 = state[((idx * 8u) + 6u)];
    let _e871 = state[((idx * 8u) + 6u)];
    let _e883 = x[((idx * 8u) + 4u)];
    let _e890 = x[((idx * 8u) + 4u)];
    let _e898 = x[((idx * 8u) + 4u)];
    state[((idx * 8u) + 6u)] = select(_e817, select(_e824, mix(_e831, _e838, select(1f, _e841, (_e844 > 0f))), ((_e856 == _e863) && (abs(_e871) < 340000000000000000000000000000000000000f))), ((_e883 == _e890) && (abs(_e898) < 340000000000000000000000000000000000000f)));
    let _e916 = state[((idx * 8u) + 6u)];
    let _e923 = x[((idx * 8u) + 4u)];
    let _e930 = state[((idx * 8u) + 6u)];
    let _e937 = x[((idx * 8u) + 4u)];
    let _e940 = constants.alpha_u;
    let _e943 = constants.dtau;
    let _e955 = state[((idx * 8u) + 6u)];
    let _e962 = state[((idx * 8u) + 6u)];
    let _e970 = state[((idx * 8u) + 6u)];
    let _e982 = x[((idx * 8u) + 4u)];
    let _e989 = x[((idx * 8u) + 4u)];
    let _e997 = x[((idx * 8u) + 4u)];
    x[((idx * 8u) + 4u)] = select(_e916, select(_e923, mix(_e930, _e937, select(1f, _e940, (_e943 > 0f))), ((_e955 == _e962) && (abs(_e970) < 340000000000000000000000000000000000000f))), ((_e982 == _e989) && (abs(_e997) < 340000000000000000000000000000000000000f)));
    let _e1015 = state[((idx * 8u) + 7u)];
    let _e1022 = x[((idx * 8u) + 5u)];
    let _e1029 = state[((idx * 8u) + 7u)];
    let _e1036 = x[((idx * 8u) + 5u)];
    let _e1039 = constants.alpha_u;
    let _e1042 = constants.dtau;
    let _e1054 = state[((idx * 8u) + 7u)];
    let _e1061 = state[((idx * 8u) + 7u)];
    let _e1069 = state[((idx * 8u) + 7u)];
    let _e1081 = x[((idx * 8u) + 5u)];
    let _e1088 = x[((idx * 8u) + 5u)];
    let _e1096 = x[((idx * 8u) + 5u)];
    state[((idx * 8u) + 7u)] = select(_e1015, select(_e1022, mix(_e1029, _e1036, select(1f, _e1039, (_e1042 > 0f))), ((_e1054 == _e1061) && (abs(_e1069) < 340000000000000000000000000000000000000f))), ((_e1081 == _e1088) && (abs(_e1096) < 340000000000000000000000000000000000000f)));
    let _e1114 = state[((idx * 8u) + 7u)];
    let _e1121 = x[((idx * 8u) + 5u)];
    let _e1128 = state[((idx * 8u) + 7u)];
    let _e1135 = x[((idx * 8u) + 5u)];
    let _e1138 = constants.alpha_u;
    let _e1141 = constants.dtau;
    let _e1153 = state[((idx * 8u) + 7u)];
    let _e1160 = state[((idx * 8u) + 7u)];
    let _e1168 = state[((idx * 8u) + 7u)];
    let _e1180 = x[((idx * 8u) + 5u)];
    let _e1187 = x[((idx * 8u) + 5u)];
    let _e1195 = x[((idx * 8u) + 5u)];
    x[((idx * 8u) + 5u)] = select(_e1114, select(_e1121, mix(_e1128, _e1135, select(1f, _e1138, (_e1141 > 0f))), ((_e1153 == _e1160) && (abs(_e1168) < 340000000000000000000000000000000000000f))), ((_e1180 == _e1187) && (abs(_e1195) < 340000000000000000000000000000000000000f)));
    let _e1213 = state[((idx * 8u) + 4u)];
    let _e1220 = x[((idx * 8u) + 6u)];
    let _e1227 = state[((idx * 8u) + 4u)];
    let _e1234 = x[((idx * 8u) + 6u)];
    let _e1237 = constants.alpha_p;
    let _e1240 = constants.dtau;
    let _e1252 = state[((idx * 8u) + 4u)];
    let _e1259 = state[((idx * 8u) + 4u)];
    let _e1267 = state[((idx * 8u) + 4u)];
    let _e1279 = x[((idx * 8u) + 6u)];
    let _e1286 = x[((idx * 8u) + 6u)];
    let _e1294 = x[((idx * 8u) + 6u)];
    state[((idx * 8u) + 4u)] = select(_e1213, select(_e1220, mix(_e1227, _e1234, select(1f, _e1237, (_e1240 > 0f))), ((_e1252 == _e1259) && (abs(_e1267) < 340000000000000000000000000000000000000f))), ((_e1279 == _e1286) && (abs(_e1294) < 340000000000000000000000000000000000000f)));
    let _e1312 = state[((idx * 8u) + 4u)];
    let _e1319 = x[((idx * 8u) + 6u)];
    let _e1326 = state[((idx * 8u) + 4u)];
    let _e1333 = x[((idx * 8u) + 6u)];
    let _e1336 = constants.alpha_p;
    let _e1339 = constants.dtau;
    let _e1351 = state[((idx * 8u) + 4u)];
    let _e1358 = state[((idx * 8u) + 4u)];
    let _e1366 = state[((idx * 8u) + 4u)];
    let _e1378 = x[((idx * 8u) + 6u)];
    let _e1385 = x[((idx * 8u) + 6u)];
    let _e1393 = x[((idx * 8u) + 6u)];
    x[((idx * 8u) + 6u)] = select(_e1312, select(_e1319, mix(_e1326, _e1333, select(1f, _e1336, (_e1339 > 0f))), ((_e1351 == _e1358) && (abs(_e1366) < 340000000000000000000000000000000000000f))), ((_e1378 == _e1385) && (abs(_e1393) < 340000000000000000000000000000000000000f)));
    let _e1411 = state[((idx * 8u) + 5u)];
    let _e1418 = x[((idx * 8u) + 7u)];
    let _e1425 = state[((idx * 8u) + 5u)];
    let _e1432 = x[((idx * 8u) + 7u)];
    let _e1435 = constants.alpha_u;
    let _e1438 = constants.dtau;
    let _e1450 = state[((idx * 8u) + 5u)];
    let _e1457 = state[((idx * 8u) + 5u)];
    let _e1465 = state[((idx * 8u) + 5u)];
    let _e1477 = x[((idx * 8u) + 7u)];
    let _e1484 = x[((idx * 8u) + 7u)];
    let _e1492 = x[((idx * 8u) + 7u)];
    state[((idx * 8u) + 5u)] = select(_e1411, select(_e1418, mix(_e1425, _e1432, select(1f, _e1435, (_e1438 > 0f))), ((_e1450 == _e1457) && (abs(_e1465) < 340000000000000000000000000000000000000f))), ((_e1477 == _e1484) && (abs(_e1492) < 340000000000000000000000000000000000000f)));
    let _e1510 = state[((idx * 8u) + 5u)];
    let _e1517 = x[((idx * 8u) + 7u)];
    let _e1524 = state[((idx * 8u) + 5u)];
    let _e1531 = x[((idx * 8u) + 7u)];
    let _e1534 = constants.alpha_u;
    let _e1537 = constants.dtau;
    let _e1549 = state[((idx * 8u) + 5u)];
    let _e1556 = state[((idx * 8u) + 5u)];
    let _e1564 = state[((idx * 8u) + 5u)];
    let _e1576 = x[((idx * 8u) + 7u)];
    let _e1583 = x[((idx * 8u) + 7u)];
    let _e1591 = x[((idx * 8u) + 7u)];
    x[((idx * 8u) + 7u)] = select(_e1510, select(_e1517, mix(_e1524, _e1531, select(1f, _e1534, (_e1537 > 0f))), ((_e1549 == _e1556) && (abs(_e1564) < 340000000000000000000000000000000000000f))), ((_e1576 == _e1583) && (abs(_e1591) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 3u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 3u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e57 = state[((idx * 8u) + 0u)];
    let _e64 = state[((idx * 8u) + 0u)];
    let _e72 = state[((idx * 8u) + 0u)];
    let _e84 = x[((idx * 3u) + 0u)];
    let _e91 = x[((idx * 3u) + 0u)];
    let _e99 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, _e49), ((_e57 == _e64) && (abs(_e72) < 340000000000000000000000000000000000000f))), ((_e84 == _e91) && (abs(_e99) < 340000000000000000000000000000000000000f)));
    let _e117 = state[((idx * 8u) + 0u)];
    let _e124 = x[((idx * 3u) + 0u)];
    let _e131 = state[((idx * 8u) + 0u)];
    let _e138 = x[((idx * 3u) + 0u)];
    let _e141 = constants.alpha_u;
    let _e149 = state[((idx * 8u) + 0u)];
    let _e156 = state[((idx * 8u) + 0u)];
    let _e164 = state[((idx * 8u) + 0u)];
    let _e176 = x[((idx * 3u) + 0u)];
    let _e183 = x[((idx * 3u) + 0u)];
    let _e191 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e117, select(_e124, mix(_e131, _e138, _e141), ((_e149 == _e156) && (abs(_e164) < 340000000000000000000000000000000000000f))), ((_e176 == _e183) && (abs(_e191) < 340000000000000000000000000000000000000f)));
    let _e209 = state[((idx * 8u) + 1u)];
    let _e216 = x[((idx * 3u) + 1u)];
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 3u) + 1u)];
    let _e233 = constants.alpha_u;
    let _e241 = state[((idx * 8u) + 1u)];
    let _e248 = state[((idx * 8u) + 1u)];
    let _e256 = state[((idx * 8u) + 1u)];
    let _e268 = x[((idx * 3u) + 1u)];
    let _e275 = x[((idx * 3u) + 1u)];
    let _e283 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e209, select(_e216, mix(_e223, _e230, _e233), ((_e241 == _e248) && (abs(_e256) < 340000000000000000000000000000000000000f))), ((_e268 == _e275) && (abs(_e283) < 340000000000000000000000000000000000000f)));
    let _e301 = state[((idx * 8u) + 1u)];
    let _e308 = x[((idx * 3u) + 1u)];
    let _e315 = state[((idx * 8u) + 1u)];
    let _e322 = x[((idx * 3u) + 1u)];
    let _e325 = constants.alpha_u;
    let _e333 = state[((idx * 8u) + 1u)];
    let _e340 = state[((idx * 8u) + 1u)];
    let _e348 = state[((idx * 8u) + 1u)];
    let _e360 = x[((idx * 3u) + 1u)];
    let _e367 = x[((idx * 3u) + 1u)];
    let _e375 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e301, select(_e308, mix(_e315, _e322, _e325), ((_e333 == _e340) && (abs(_e348) < 340000000000000000000000000000000000000f))), ((_e360 == _e367) && (abs(_e375) < 340000000000000000000000000000000000000f)));
    let _e393 = state[((idx * 8u) + 2u)];
    let _e400 = x[((idx * 3u) + 2u)];
    let _e407 = state[((idx * 8u) + 2u)];
    let _e414 = x[((idx * 3u) + 2u)];
    let _e417 = constants.alpha_p;
    let _e425 = state[((idx * 8u) + 2u)];
    let _e432 = state[((idx * 8u) + 2u)];
    let _e440 = state[((idx * 8u) + 2u)];
    let _e452 = x[((idx * 3u) + 2u)];
    let _e459 = x[((idx * 3u) + 2u)];
    let _e467 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e393, select(_e400, mix(_e407, _e414, _e417), ((_e425 == _e432) && (abs(_e440) < 340000000000000000000000000000000000000f))), ((_e452 == _e459) && (abs(_e467) < 340000000000000000000000000000000000000f)));
    let _e485 = state[((idx * 8u) + 2u)];
    let _e492 = x[((idx * 3u) + 2u)];
    let _e499 = state[((idx * 8u) + 2u)];
    let _e506 = x[((idx * 3u) + 2u)];
    let _e509 = constants.alpha_p;
    let _e517 = state[((idx * 8u) + 2u)];
    let _e524 = state[((idx * 8u) + 2u)];
    let _e532 = state[((idx * 8u) + 2u)];
    let _e544 = x[((idx * 3u) + 2u)];
    let _e551 = x[((idx * 3u) + 2u)];
    let _e559 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e485, select(_e492, mix(_e499, _e506, _e509), ((_e517 == _e524) && (abs(_e532) < 340000000000000000000000000000000000000f))), ((_e544 == _e551) && (abs(_e559) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod packed_state_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_3_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_4_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_5_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_6_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_7_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 8u) + 0u)];
            let _e139 = bc_kind[((face_idx * 8u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 8u) + 0u)];
            let _e165 = bc_kind[((face_idx * 8u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 8u) + 1u)];
            let _e215 = bc_kind[((face_idx * 8u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 8u) + 1u)];
            let _e241 = bc_kind[((face_idx * 8u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 8u) + 2u)];
            let _e291 = bc_kind[((face_idx * 8u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 8u) + 2u)];
            let _e317 = bc_kind[((face_idx * 8u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 8u) + 3u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 8u) + 3u)];
            let _e353 = state[((idx * 8u) + 3u)];
            let _e360 = bc_value[((face_idx * 8u) + 3u)];
            let _e367 = bc_kind[((face_idx * 8u) + 3u)];
            let _e377 = state[((idx * 8u) + 3u)];
            let _e384 = bc_value[((face_idx * 8u) + 3u)];
            let _e393 = bc_kind[((face_idx * 8u) + 3u)];
            let _e403 = grad_acc_3_;
            grad_acc_3_ = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 8u) + 4u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 8u) + 4u)];
            let _e429 = state[((idx * 8u) + 4u)];
            let _e436 = bc_value[((face_idx * 8u) + 4u)];
            let _e443 = bc_kind[((face_idx * 8u) + 4u)];
            let _e453 = state[((idx * 8u) + 4u)];
            let _e460 = bc_value[((face_idx * 8u) + 4u)];
            let _e469 = bc_kind[((face_idx * 8u) + 4u)];
            let _e479 = grad_acc_4_;
            grad_acc_4_ = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 8u) + 5u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 8u) + 5u)];
            let _e505 = state[((idx * 8u) + 5u)];
            let _e512 = bc_value[((face_idx * 8u) + 5u)];
            let _e519 = bc_kind[((face_idx * 8u) + 5u)];
            let _e529 = state[((idx * 8u) + 5u)];
            let _e536 = bc_value[((face_idx * 8u) + 5u)];
            let _e545 = bc_kind[((face_idx * 8u) + 5u)];
            let _e555 = grad_acc_5_;
            grad_acc_5_ = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 8u) + 6u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 8u) + 6u)];
            let _e581 = state[((idx * 8u) + 6u)];
            let _e588 = bc_value[((face_idx * 8u) + 6u)];
            let _e595 = bc_kind[((face_idx * 8u) + 6u)];
            let _e605 = state[((idx * 8u) + 6u)];
            let _e612 = bc_value[((face_idx * 8u) + 6u)];
            let _e621 = bc_kind[((face_idx * 8u) + 6u)];
            let _e631 = grad_acc_6_;
            grad_acc_6_ = (_e631 + ((_e557 * ((_e564 * _e565) + (select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary) * lambda_other))) * area));
            let _e633 = normal_vec;
            let _e640 = state[((idx * 8u) + 7u)];
            let _e641 = lambda;
            let _e643 = other_idx;
            let _e650 = state[((_e643 * 8u) + 7u)];
            let _e657 = state[((idx * 8u) + 7u)];
            let _e664 = bc_value[((face_idx * 8u) + 7u)];
            let _e671 = bc_kind[((face_idx * 8u) + 7u)];
            let _e681 = state[((idx * 8u) + 7u)];
            let _e688 = bc_value[((face_idx * 8u) + 7u)];
            let _e697 = bc_kind[((face_idx * 8u) + 7u)];
            let _e707 = grad_acc_7_;
            grad_acc_7_ = (_e707 + ((_e633 * ((_e640 * _e641) + (select(_e650, select(select(_e657, _e664, (_e671 == 1u)), (_e681 + (_e688 * d_own)), (_e697 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e710 = k;
            k = (_e710 + 1u);
        }
    }
    let _e712 = grad_acc_0_;
    let grad_out_0_ = ((_e712 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e735 = grad_acc_1_;
    let grad_out_1_ = ((_e735 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e758 = grad_acc_2_;
    let grad_out_2_ = ((_e758 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    let _e781 = grad_acc_3_;
    let grad_out_3_ = ((_e781 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 3u)].x = grad_out_3_.x;
    grad_state[((idx * 8u) + 3u)].y = grad_out_3_.y;
    let _e804 = grad_acc_4_;
    let grad_out_4_ = ((_e804 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 4u)].x = grad_out_4_.x;
    grad_state[((idx * 8u) + 4u)].y = grad_out_4_.y;
    let _e827 = grad_acc_5_;
    let grad_out_5_ = ((_e827 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 5u)].x = grad_out_5_.x;
    grad_state[((idx * 8u) + 5u)].y = grad_out_5_.y;
    let _e850 = grad_acc_6_;
    let grad_out_6_ = ((_e850 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 6u)].x = grad_out_6_.x;
    grad_state[((idx * 8u) + 6u)].y = grad_out_6_.y;
    let _e873 = grad_acc_7_;
    let grad_out_7_ = ((_e873 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 7u)].x = grad_out_7_.x;
    grad_state[((idx * 8u) + 7u)].y = grad_out_7_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 3u) + 0u)];
            let _e139 = bc_kind[((face_idx * 3u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 3u) + 0u)];
            let _e165 = bc_kind[((face_idx * 3u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 3u) + 1u)];
            let _e215 = bc_kind[((face_idx * 3u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 3u) + 1u)];
            let _e241 = bc_kind[((face_idx * 3u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 3u) + 2u)];
            let _e291 = bc_kind[((face_idx * 3u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 3u) + 2u)];
            let _e317 = bc_kind[((face_idx * 3u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e330 = k;
            k = (_e330 + 1u);
        }
    }
    let _e332 = grad_acc_0_;
    let grad_out_0_ = ((_e332 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e355 = grad_acc_1_;
    let grad_out_1_ = ((_e355 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e378 = grad_acc_2_;
    let grad_out_2_ = ((_e378 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const U_X_OFFSET: u32 = 0u32;
        pub const U_Y_OFFSET: u32 = 1u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const GRAD_P_X_OFFSET: u32 = 4u32;
        pub const GRAD_P_Y_OFFSET: u32 = 5u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_correct_velocity_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const U_X_OFFSET: u32 = 0u;
const U_Y_OFFSET: u32 = 1u;
const D_P_OFFSET: u32 = 3u;
const GRAD_P_X_OFFSET: u32 = 4u;
const GRAD_P_Y_OFFSET: u32 = 5u;

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * STATE_STRIDE);
    let d_p = state[(base + D_P_OFFSET)];
    let grad_px = state[(base + GRAD_P_X_OFFSET)];
    let grad_py = state[(base + GRAD_P_Y_OFFSET)];
    let _e38 = state[(base + U_X_OFFSET)];
    state[(base + U_X_OFFSET)] = (_e38 - (d_p * grad_px));
    let _e49 = state[(base + U_Y_OFFSET)];
    state[(base + U_Y_OFFSET)] = (_e49 - (d_p * grad_py));
    return;
}
"#;
    }
}
pub mod generic_coupled_schur_setup {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 16, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl SetupParams {
        pub const fn new(
            num_cells: u32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                num_cells,
                unknowns_per_cell,
                p,
                u_len,
                u0123,
                u4567,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_DIAG_AND_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_diag_and_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_diag_and_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_diag_and_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_DIAG_AND_PRESSURE: &str = "build_diag_and_pressure";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        pub diagonal_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        pub diagonal_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalar_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                },
                diagonal_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
                params: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.scalar_row_offsets,
                self.diagonal_indices,
                self.matrix_values,
                self.diag_u_inv,
                self.diag_p_inv,
                self.p_matrix_values,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalar_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diagonal_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(6): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::generic_coupled_schur_setup::SetupParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GenericCoupledSchurSetup::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("generic_coupled_schur_setup.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SetupParams {
    num_cells: u32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> p_matrix_values: array<f32>;
@group(0) @binding(6) 
var<uniform> params: SetupParams;

fn u_index(i_1: u32) -> u32 {
    if (i_1 < 4u) {
        let _e6 = params.u0123_[i_1];
        return _e6;
    }
    let _e12 = params.u4567_[(i_1 - 4u)];
    return _e12;
}

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_diag_and_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var i: u32 = 0u;
    var rank: u32 = 0u;

    let cell = ((global_id.y * (num_workgroups.x * 64u)) + global_id.x);
    let _e12 = params.num_cells;
    if (cell >= _e12) {
        return;
    }
    let scalar_offset = scalar_row_offsets[cell];
    let scalar_end = scalar_row_offsets[(cell + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[cell];
    let diag_rank = (_e25 - scalar_offset);
    let _e29 = params.unknowns_per_cell;
    let _e32 = params.unknowns_per_cell;
    let block_stride = (_e29 * _e32);
    let start_row_0_ = (scalar_offset * block_stride);
    let _e37 = params.unknowns_per_cell;
    let row_stride = (num_neighbors * _e37);
    let _e41 = params.p;
    let start_row_p = (start_row_0_ + (_e41 * row_stride));
    let _e46 = params.unknowns_per_cell;
    let _e52 = params.p;
    let diag_p = matrix_values[((start_row_p + (diag_rank * _e46)) + _e52)];
    loop {
        let _e57 = i;
        let _e60 = params.u_len;
        if (_e57 < _e60) {
        } else {
            break;
        }
        {
            let _e62 = i;
            let _e63 = u_index(_e62);
            let start_row_u = (start_row_0_ + (_e63 * row_stride));
            let _e69 = params.unknowns_per_cell;
            let diag_u = matrix_values[((start_row_u + (diag_rank * _e69)) + _e63)];
            let _e75 = safe_inverse(diag_u);
            let _e79 = params.u_len;
            let _e81 = i;
            diag_u_inv[((cell * _e79) + _e81)] = _e75;
        }
        continuing {
            let _e85 = i;
            i = (_e85 + 1u);
        }
    }
    let _e89 = safe_inverse(diag_p);
    diag_p_inv[cell] = _e89;
    loop {
        let _e91 = rank;
        if (_e91 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e94 = rank;
            let _e97 = rank;
            let _e100 = params.unknowns_per_cell;
            let _e106 = params.p;
            let _e109 = matrix_values[((start_row_p + (_e97 * _e100)) + _e106)];
            p_matrix_values[(scalar_offset + _e94)] = _e109;
        }
        continuing {
            let _e111 = rank;
            rank = (_e111 + 1u);
        }
    }
    return;
}
"#;
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let j = params.num_iters;
    let n = params.n;
    let num_groups_n = ((n + 63u) / WORKGROUP_SIZE);
    let stride_x = (num_workgroups.x * WORKGROUP_SIZE);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
    if (group_flat >= num_groups_n) {
        return;
    }
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e39 = b_w[idx];
        w_val = _e39;
    }
    loop {
        let _e42 = i;
        if (_e42 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e48 = i;
                if (_e48 <= j) {
                    let _e52 = i;
                    let _e56 = b_basis[((_e52 * stride_words) + idx)];
                    v.x = _e56;
                }
                let _e57 = i;
                if ((_e57 + 1u) <= j) {
                    let _e62 = i;
                    let _e69 = b_basis[(((_e62 + 1u) * stride_words) + idx)];
                    v.y = _e69;
                }
                let _e70 = i;
                if ((_e70 + 2u) <= j) {
                    let _e75 = i;
                    let _e82 = b_basis[(((_e75 + 2u) * stride_words) + idx)];
                    v.z = _e82;
                }
                let _e83 = i;
                if ((_e83 + 3u) <= j) {
                    let _e88 = i;
                    let _e95 = b_basis[(((_e88 + 3u) * stride_words) + idx)];
                    v.w = _e95;
                }
            }
            let _e96 = v;
            let _e97 = w_val;
            let prod = (_e96 * _e97);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e114 = sdata_vec4_[(local_id.x + 32u)];
                let _e115 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e115 + _e114);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e128 = sdata_vec4_[(local_id.x + 16u)];
                let _e129 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e129 + _e128);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e142 = sdata_vec4_[(local_id.x + 8u)];
                let _e143 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e143 + _e142);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e156 = sdata_vec4_[(local_id.x + 4u)];
                let _e157 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e157 + _e156);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e170 = sdata_vec4_[(local_id.x + 2u)];
                let _e171 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e171 + _e170);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e184 = sdata_vec4_[(local_id.x + 1u)];
                let _e185 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e185 + _e184);
                let sum_1 = sdata_vec4_[0];
                let _e190 = i;
                if (_e190 <= j) {
                    let _e193 = i;
                    b_dot_partial[((_e193 * num_groups_n) + group_flat)] = sum_1.x;
                }
                let _e198 = i;
                if ((_e198 + 1u) <= j) {
                    let _e202 = i;
                    b_dot_partial[(((_e202 + 1u) * num_groups_n) + group_flat)] = sum_1.y;
                }
                let _e210 = i;
                if ((_e210 + 2u) <= j) {
                    let _e214 = i;
                    b_dot_partial[(((_e214 + 2u) * num_groups_n) + group_flat)] = sum_1.z;
                }
                let _e222 = i;
                if ((_e222 + 3u) <= j) {
                    let _e226 = i;
                    b_dot_partial[(((_e226 + 3u) * num_groups_n) + group_flat)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e235 = i;
            i = (_e235 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e8 = params.n;
    let num_groups_n_1 = ((_e8 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e16 = k;
        if (_e16 < num_groups_n_1) {
        } else {
            break;
        }
        {
            let _e21 = k;
            let _e24 = b_dot_partial[((i_2 * num_groups_n_1) + _e21)];
            let _e25 = sum;
            sum = (_e25 + _e24);
        }
        continuing {
            let _e28 = k;
            k = (_e28 + 64u);
        }
    }
    let _e33 = sum;
    sdata[local_id_1.x] = _e33;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e45 = sdata[(local_id_1.x + 32u)];
        let _e46 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e46 + _e45);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e59 = sdata[(local_id_1.x + 16u)];
        let _e60 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e60 + _e59);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e73 = sdata[(local_id_1.x + 8u)];
        let _e74 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e74 + _e73);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e87 = sdata[(local_id_1.x + 4u)];
        let _e88 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e88 + _e87);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e101 = sdata[(local_id_1.x + 2u)];
        let _e102 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e102 + _e101);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e115 = sdata[(local_id_1.x + 1u)];
        let _e116 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e116 + _e115);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e129 = sdata[0];
        b_hessenberg[h_idx] = _e129;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let stride_x_1 = (num_workgroups_1.x * WORKGROUP_SIZE);
    let idx_1 = ((global_id_2.y * stride_x_1) + global_id_2.x);
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e30 = i_1;
        if (_e30 <= j_2) {
        } else {
            break;
        }
        {
            let _e32 = i_1;
            if (_e32 <= j_2) {
                let _e38 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e38)];
                let _e43 = i_1;
                let v_val = b_basis[((_e43 * stride_words_1) + idx_1)];
                let _e50 = correction;
                correction = (_e50 + (h_val * v_val));
            }
            let _e52 = i_1;
            if ((_e52 + 1u) <= j_2) {
                let _e59 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e59 + 1u))];
                let _e66 = i_1;
                let v_val_1 = b_basis[(((_e66 + 1u) * stride_words_1) + idx_1)];
                let _e75 = correction;
                correction = (_e75 + (h_val_1 * v_val_1));
            }
            let _e77 = i_1;
            if ((_e77 + 2u) <= j_2) {
                let _e84 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e84 + 2u))];
                let _e91 = i_1;
                let v_val_2 = b_basis[(((_e91 + 2u) * stride_words_1) + idx_1)];
                let _e100 = correction;
                correction = (_e100 + (h_val_2 * v_val_2));
            }
            let _e102 = i_1;
            if ((_e102 + 3u) <= j_2) {
                let _e109 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e109 + 3u))];
                let _e116 = i_1;
                let v_val_3 = b_basis[(((_e116 + 3u) * stride_words_1) + idx_1)];
                let _e125 = correction;
                correction = (_e125 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e128 = i_1;
            i_1 = (_e128 + 4u);
        }
    }
    let _e134 = b_w[idx_1];
    let _e135 = correction;
    b_w[idx_1] = (_e134 - _e135);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.iter_params, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let j_1 = iter_params.current_idx;
    loop {
        let _e7 = i;
        if (_e7 < j_1) {
        } else {
            break;
        }
        {
            let _e9 = i;
            let _e10 = h_idx(_e9, j_1);
            let _e11 = i;
            let _e14 = h_idx((_e11 + 1u), j_1);
            let h_ij = hessenberg[_e10];
            let h_i1j = hessenberg[_e14];
            let _e22 = i;
            let cs = givens[_e22];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e10] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e14] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e39 = i;
            i = (_e39 + 1u);
        }
    }
    let _e41 = h_idx(j_1, j_1);
    let _e44 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e41];
    let h_j1j = hessenberg[_e44];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e56 = rho;
    if (abs(_e56) > 0.00000000000000000001f) {
        let _e60 = rho;
        c = (h_jj / _e60);
        let _e63 = rho;
        s = (h_j1j / _e63);
    }
    let _e68 = c;
    let _e69 = s;
    givens[j_1] = vec2<f32>(_e68, _e69);
    let _e73 = rho;
    hessenberg[_e41] = _e73;
    hessenberg[_e44] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e87 = c;
    let _e89 = s;
    g_rhs[j_1] = ((_e87 * g_j) + (_e89 * g_j1_));
    let _e96 = s;
    let _e99 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e96) * g_j) + (_e99 * g_j1_));
    let _e108 = g_rhs[(j_1 + 1u)];
    scalars[0] = abs(_e108);
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let k = iter_params.current_idx;
    loop {
        let _e5 = loop_i;
        if (_e5 < k) {
        } else {
            break;
        }
        {
            let _e9 = loop_i;
            let i_1 = ((k - 1u) - _e9);
            let _e13 = g_rhs[i_1];
            sum = _e13;
            j = (i_1 + 1u);
            loop {
                let _e18 = j;
                if (_e18 < k) {
                } else {
                    break;
                }
                {
                    let _e20 = j;
                    let _e21 = h_idx(i_1, _e20);
                    let _e24 = hessenberg[_e21];
                    let _e26 = j;
                    let _e28 = y_sol[_e26];
                    let _e30 = sum;
                    sum = (_e30 - (_e24 * _e28));
                }
                continuing {
                    let _e33 = j;
                    j = (_e33 + 1u);
                }
            }
            let _e35 = h_idx(i_1, i_1);
            let diag = hessenberg[_e35];
            if (abs(diag) > 0.000000000001f) {
                let _e44 = sum;
                y_sol[i_1] = (_e44 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e50 = loop_i;
            loop_i = (_e50 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const EXTRACT_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_extract_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline extract_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("extract_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    pub const ENTRY_EXTRACT_DIAG_INV: &str = "extract_diag_inv";
    pub const ENTRY_APPLY_DIAG_INV: &str = "apply_diag_inv";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn global_index(global_id_14: vec3<u32>, num_workgroups_12: vec3<u32>) -> u32 {
    return ((global_id_14.y * (num_workgroups_12.x * WORKGROUP_SIZE)) + global_id_14.x);
}

fn workgroup_index(group_id_2: vec3<u32>, num_workgroups_13: vec3<u32>) -> u32 {
    return ((group_id_2.y * num_workgroups_13.x) + group_id_2.x);
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val_1 = matrix_values[_e24];
            let _e30 = vec_x[col];
            let _e32 = sum;
            sum = (_e32 + (val_1 * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    vec_y[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let _e2 = global_index(global_id_1, num_workgroups_1);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha = scalars[0];
    let _e14 = vec_x[_e2];
    let _e18 = vec_y[_e2];
    vec_y[_e2] = ((alpha * _e14) + _e18);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    let _e2 = global_index(global_id_2, num_workgroups_2);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e10 = iter_params.current_idx;
    let alpha_1 = y_sol[_e10];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_y[_e2] = ((alpha_1 * _e17) + _e21);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let _e2 = global_index(global_id_3, num_workgroups_3);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_z[_e2] = ((alpha_2 * _e17) + (beta * _e21));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>, @builtin(num_workgroups) num_workgroups_4: vec3<u32>) {
    let _e2 = global_index(global_id_4, num_workgroups_4);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (alpha_3 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>, @builtin(num_workgroups) num_workgroups_5: vec3<u32>) {
    let _e2 = global_index(global_id_5, num_workgroups_5);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e14 = vec_y[_e2];
    vec_y[_e2] = (alpha_4 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>, @builtin(num_workgroups) num_workgroups_6: vec3<u32>) {
    let _e2 = global_index(global_id_6, num_workgroups_6);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = vec_x[_e2];
    vec_y[_e2] = _e11;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups_7: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e4 = global_index(global_id_7, num_workgroups_7);
    let lid = local_id.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let _e13 = vec_x[_e4];
        let _e16 = vec_y[_e4];
        local_sum = (_e13 * _e16);
    }
    let _e21 = local_sum;
    partial_sums[lid] = _e21;
    workgroupBarrier();
    loop {
        let _e23 = stride;
        if (_e23 > 0u) {
        } else {
            break;
        }
        {
            let _e26 = stride;
            if (lid < _e26) {
                let _e31 = stride;
                let _e34 = partial_sums[(lid + _e31)];
                let _e35 = partial_sums[lid];
                partial_sums[lid] = (_e35 + _e34);
            }
            workgroupBarrier();
        }
        continuing {
            let _e38 = stride;
            stride = (_e38 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e43 = workgroup_index(group_id, num_workgroups_7);
        let _e46 = params.n;
        let num_groups_n = ((_e46 + 63u) / WORKGROUP_SIZE);
        if (_e43 < num_groups_n) {
            let _e56 = partial_sums[0];
            vec_z[_e43] = _e56;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_8: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e4 = global_index(global_id_8, num_workgroups_8);
    let lid_1 = local_id_1.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let val_2 = vec_x[_e4];
        local_sum_1 = (val_2 * val_2);
    }
    let _e18 = local_sum_1;
    partial_sums[lid_1] = _e18;
    workgroupBarrier();
    loop {
        let _e20 = stride_1;
        if (_e20 > 0u) {
        } else {
            break;
        }
        {
            let _e23 = stride_1;
            if (lid_1 < _e23) {
                let _e28 = stride_1;
                let _e31 = partial_sums[(lid_1 + _e28)];
                let _e32 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e32 + _e31);
            }
            workgroupBarrier();
        }
        continuing {
            let _e35 = stride_1;
            stride_1 = (_e35 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e40 = workgroup_index(group_id_1, num_workgroups_8);
        let _e43 = params.n;
        let num_groups_n_1 = ((_e43 + 63u) / WORKGROUP_SIZE);
        if (_e40 < num_groups_n_1) {
            let _e53 = partial_sums[0];
            vec_z[_e40] = _e53;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>, @builtin(num_workgroups) num_workgroups_9: vec3<u32>) {
    let _e2 = global_index(global_id_9, num_workgroups_9);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let h = scalars[0];
    let _e14 = vec_y[_e2];
    let _e17 = vec_x[_e2];
    vec_y[_e2] = (_e14 - (h * _e17));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let num_partials_1 = params.n;
    loop {
        let _e6 = i_1;
        if (_e6 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e10 = i_1;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum_1;
            total_sum_1 = (_e13 + _e12);
        }
        continuing {
            let _e16 = i_1;
            i_1 = (_e16 + 1u);
        }
    }
    let _e18 = total_sum_1;
    let norm = sqrt(_e18);
    let _e23 = iter_params.current_idx;
    hessenberg[_e23] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn extract_diag_inv(@builtin(global_invocation_id) global_id_12: vec3<u32>, @builtin(num_workgroups) num_workgroups_10: vec3<u32>) {
    var diag: f32 = 1f;
    var k_1: u32;

    let _e3 = global_index(global_id_12, num_workgroups_10);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start_1 = row_offsets[_e3];
    let end_1 = row_offsets[(_e3 + 1u)];
    k_1 = start_1;
    loop {
        let _e17 = k_1;
        if (_e17 < end_1) {
        } else {
            break;
        }
        {
            let _e20 = k_1;
            let _e22 = col_indices[_e20];
            if (_e22 == _e3) {
                let _e25 = k_1;
                let _e27 = matrix_values[_e25];
                diag = _e27;
                break;
            }
        }
        continuing {
            let _e29 = k_1;
            k_1 = (_e29 + 1u);
        }
    }
    let _e32 = diag;
    let _e33 = safe_inverse(_e32);
    diag_u[_e3] = _e33;
    diag_v[_e3] = _e33;
    diag_p[_e3] = _e33;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_diag_inv(@builtin(global_invocation_id) global_id_13: vec3<u32>, @builtin(num_workgroups) num_workgroups_11: vec3<u32>) {
    let _e2 = global_index(global_id_13, num_workgroups_11);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = diag_u[_e2];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (_e11 * _e14);
    return;
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.x, self.r, self.p, self.v]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

fn global_index(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = matrix_values[_e24];
            let _e30 = p[col];
            let _e32 = sum;
            sum = (_e32 + (val * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    v[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var alpha: f32 = 0f;

    let _e3 = global_index(global_id_1, num_workgroups_1);
    let _e6 = scalars.r0_v;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_old;
        let _e15 = scalars.r0_v;
        alpha = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (_e3 >= _e25) {
        return;
    }
    let _e29 = alpha;
    let _e32 = p[_e3];
    let _e34 = x[_e3];
    x[_e3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha;
    let _e41 = v[_e3];
    let _e43 = r[_e3];
    r[_e3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var beta: f32 = 0f;

    let _e3 = global_index(global_id_2, num_workgroups_2);
    let _e6 = scalars.rho_old;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_new;
        let _e15 = scalars.rho_old;
        beta = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = beta;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (_e3 >= _e30) {
        return;
    }
    let _e36 = r[_e3];
    let _e37 = beta;
    let _e40 = p[_e3];
    p[_e3] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod outer_convergence {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub stride: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_targets: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl Params {
        pub const fn new(num_cells: u32, stride: u32, num_targets: u32, _pad0: u32) -> Self {
            Self {
                num_cells,
                stride,
                num_targets,
                _pad0,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct TargetDesc {
        #[doc = "offset: 0, size: 16, type: `array<u32, 4>`"]
        pub offsets: [u32; 4],
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub num_comps: u32,
        #[doc = "offset: 20, size: 12, type: `array<u32, 3>`"]
        pub _pad0: [u32; 3],
    }
    impl TargetDesc {
        pub const fn new(offsets: [u32; 4], num_comps: u32, _pad0: [u32; 3]) -> Self {
            Self {
                offsets,
                num_comps,
                _pad0,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input: wgpu::BufferBinding<'a>,
        pub targets: wgpu::BufferBinding<'a>,
        pub out_bits: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input: wgpu::BindGroupEntry<'a>,
        pub targets: wgpu::BindGroupEntry<'a>,
        pub out_bits: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input),
                },
                targets: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.targets),
                },
                out_bits: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.out_bits),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.input, self.targets, self.out_bits, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("OuterConvergence::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"targets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"out_bits\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::outer_convergence::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("OuterConvergence::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("OuterConvergence::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("outer_convergence.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    num_cells: u32,
    stride: u32,
    num_targets: u32,
    _pad0_: u32,
}

struct TargetDesc {
    offsets: array<u32, 4>,
    num_comps: u32,
    _pad0_: array<u32, 3>,
}

@group(0) @binding(0) 
var<storage> input: array<f32>;
@group(0) @binding(1) 
var<storage> targets: array<TargetDesc>;
@group(0) @binding(2) 
var<storage, read_write> out_bits: array<atomic<u32>>;
@group(0) @binding(3) 
var<uniform> params: Params;

@compute @workgroup_size(256, 1, 1) 
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    var t: u32 = 0u;
    var mag2_: f32;
    var c: u32;

    let cell = gid.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let _e9 = params.stride;
    let base = (cell * _e9);
    loop {
        let _e12 = t;
        let _e15 = params.num_targets;
        if (_e12 < _e15) {
        } else {
            break;
        }
        {
            let _e18 = t;
            let desc = targets[_e18];
            mag2_ = 0f;
            c = 0u;
            loop {
                let _e25 = c;
                if (_e25 < desc.num_comps) {
                } else {
                    break;
                }
                {
                    let _e29 = c;
                    let off = desc.offsets[_e29];
                    let v = input[(base + off)];
                    let _e35 = mag2_;
                    mag2_ = (_e35 + (v * v));
                }
                continuing {
                    let _e38 = c;
                    c = (_e38 + 1u);
                }
            }
            let _e41 = mag2_;
            let mag = sqrt(_e41);
            let bits = bitcast<u32>(mag);
            let _e45 = t;
            let _e47 = atomicMax((&out_bits[_e45]), bits);
        }
        continuing {
            let _e48 = t;
            t = (_e48 + 1u);
        }
    }
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_4;
            i_4 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_2] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_5;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_5;
            if (lid_2 < _e27) {
                let _e32 = i_5;
                let _e35 = scratch1_[(lid_2 + _e32)];
                let _e36 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_5;
            i_5 = (_e39 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u0: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            u0: u32,
            u1: u32,
            p: u32,
            _pad0: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                u0,
                u1,
                p,
                _pad0,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    u0_: u32,
    u1_: u32,
    p: u32,
    _pad0_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u = (base + _e14);
    let _e18 = params.u1_;
    let row_v = (base + _e18);
    let p_val = p_sol[_e3];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e32 = k_1;
        if (_e32 < end_u) {
        } else {
            break;
        }
        {
            let _e35 = k_1;
            let col = col_indices[_e35];
            let _e40 = params.unknowns_per_cell;
            let _e44 = params.p;
            if ((col % _e40) == _e44) {
                let _e48 = params.unknowns_per_cell;
                let p_cell = (col / _e48);
                let _e51 = k_1;
                let _e53 = matrix_values[_e51];
                let _e57 = p_sol[p_cell];
                let _e59 = correction_u;
                correction_u = (_e59 + (_e53 * _e57));
            }
        }
        continuing {
            let _e62 = k_1;
            k_1 = (_e62 + 1u);
        }
    }
    let _e68 = diag_u_inv[_e3];
    let _e69 = correction_u;
    let _e71 = z_out[row_u];
    z_out[row_u] = (_e71 - (_e68 * _e69));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e82 = k_2;
        if (_e82 < end_v) {
        } else {
            break;
        }
        {
            let _e85 = k_2;
            let col_1 = col_indices[_e85];
            let _e90 = params.unknowns_per_cell;
            let _e94 = params.p;
            if ((col_1 % _e90) == _e94) {
                let _e98 = params.unknowns_per_cell;
                let p_cell_1 = (col_1 / _e98);
                let _e101 = k_2;
                let _e103 = matrix_values[_e101];
                let _e107 = p_sol[p_cell_1];
                let _e109 = correction_v;
                correction_v = (_e109 + (_e103 * _e107));
            }
        }
        continuing {
            let _e112 = k_2;
            k_2 = (_e112 + 1u);
        }
    }
    let _e118 = diag_v_inv[_e3];
    let _e119 = correction_v;
    let _e121 = z_out[row_v];
    z_out[row_v] = (_e121 - (_e118 * _e119));
    let _e126 = params.p;
    z_out[(base + _e126)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u_1 = (base_1 + _e14);
    let _e18 = params.u1_;
    let row_v_1 = (base_1 + _e18);
    let _e22 = params.p;
    let row_p = (base_1 + _e22);
    loop {
        let _e25 = c;
        let _e28 = params.unknowns_per_cell;
        if (_e25 < _e28) {
        } else {
            break;
        }
        {
            let _e31 = c;
            let _e35 = c;
            let _e38 = r_in[(base_1 + _e35)];
            z_out[(base_1 + _e31)] = _e38;
        }
        continuing {
            let _e40 = c;
            c = (_e40 + 1u);
        }
    }
    let r_u = r_in[row_u_1];
    let r_v = r_in[row_v_1];
    let _e52 = diag_u_inv[_e3];
    z_out[row_u_1] = (_e52 * r_u);
    let _e58 = diag_v_inv[_e3];
    z_out[row_v_1] = (_e58 * r_v);
    z_out[row_p] = 0f;
    let _e65 = r_in[row_p];
    rhs_p = _e65;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e76 = k_3;
        if (_e76 < end_1) {
        } else {
            break;
        }
        {
            let _e79 = k_3;
            let col_2 = col_indices[_e79];
            let _e84 = params.unknowns_per_cell;
            let rem = (col_2 % _e84);
            z_val = 0f;
            let _e90 = params.u0_;
            if (rem == _e90) {
                let _e94 = params.unknowns_per_cell;
                let c_1 = (col_2 / _e94);
                let _e98 = r_in[col_2];
                let _e101 = diag_u_inv[c_1];
                z_val = (_e98 * _e101);
            } else {
                let _e105 = params.u1_;
                if (rem == _e105) {
                    let _e109 = params.unknowns_per_cell;
                    let c_2 = (col_2 / _e109);
                    let _e113 = r_in[col_2];
                    let _e116 = diag_v_inv[c_2];
                    z_val = (_e113 * _e116);
                }
            }
            let _e119 = k_3;
            let _e121 = matrix_values[_e119];
            let _e122 = z_val;
            let _e124 = rhs_p;
            rhs_p = (_e124 - (_e121 * _e122));
        }
        continuing {
            let _e127 = k_3;
            k_3 = (_e127 + 1u);
        }
    }
    let _e131 = rhs_p;
    temp_p[_e3] = _e131;
    let _e136 = diag_p_inv[_e3];
    let _e137 = rhs_p;
    p_sol[_e3] = (_e136 * _e137);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
pub mod schur_precond_generic {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            _pad0: u32,
            _pad1: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                p,
                u_len,
                _pad0,
                _pad1,
                u0123,
                u4567,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u_inv, self.diag_p_inv, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond_generic::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecondGeneric::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond_generic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    _pad0_: u32,
    _pad1_: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(2) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn u_index(i_3: u32) -> u32 {
    if (i_3 < 4u) {
        let _e6 = params.u0123_[i_3];
        return _e6;
    }
    let _e12 = params.u4567_[(i_3 - 4u)];
    return _e12;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var i: u32 = 0u;
    var correction_u: f32;
    var k_1: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let p_val = p_sol[_e3];
    loop {
        let _e16 = i;
        let _e19 = params.u_len;
        if (_e16 < _e19) {
        } else {
            break;
        }
        {
            let _e21 = i;
            let _e22 = u_index(_e21);
            let row_u = (base + _e22);
            let start_u = row_offsets[row_u];
            let end_u = row_offsets[(row_u + 1u)];
            correction_u = 0f;
            k_1 = start_u;
            loop {
                let _e35 = k_1;
                if (_e35 < end_u) {
                } else {
                    break;
                }
                {
                    let _e38 = k_1;
                    let col = col_indices[_e38];
                    let _e43 = params.unknowns_per_cell;
                    let _e47 = params.p;
                    if ((col % _e43) == _e47) {
                        let _e51 = params.unknowns_per_cell;
                        let p_cell = (col / _e51);
                        let _e54 = k_1;
                        let _e56 = matrix_values[_e54];
                        let _e59 = p_sol[p_cell];
                        let _e61 = correction_u;
                        correction_u = (_e61 + (_e56 * _e59));
                    }
                }
                continuing {
                    let _e64 = k_1;
                    k_1 = (_e64 + 1u);
                }
            }
            let _e71 = params.u_len;
            let _e73 = i;
            let _e76 = diag_u_inv[((_e3 * _e71) + _e73)];
            let _e77 = correction_u;
            let _e79 = z_out[row_u];
            z_out[row_u] = (_e79 - (_e76 * _e77));
        }
        continuing {
            let _e82 = i;
            i = (_e82 + 1u);
        }
    }
    let _e87 = params.p;
    z_out[(base + _e87)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var i_1: u32 = 0u;
    var rhs_p: f32;
    var k_2: u32;
    var z_val: f32;
    var i_2: u32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.p;
    let row_p = (base_1 + _e14);
    loop {
        let _e17 = c;
        let _e20 = params.unknowns_per_cell;
        if (_e17 < _e20) {
        } else {
            break;
        }
        {
            let _e23 = c;
            let _e27 = c;
            let _e30 = r_in[(base_1 + _e27)];
            z_out[(base_1 + _e23)] = _e30;
        }
        continuing {
            let _e32 = c;
            c = (_e32 + 1u);
        }
    }
    loop {
        let _e35 = i_1;
        let _e38 = params.u_len;
        if (_e35 < _e38) {
        } else {
            break;
        }
        {
            let _e40 = i_1;
            let _e41 = u_index(_e40);
            let row_u_1 = (base_1 + _e41);
            let _e48 = params.u_len;
            let _e50 = i_1;
            let _e53 = diag_u_inv[((_e3 * _e48) + _e50)];
            let _e56 = r_in[row_u_1];
            z_out[row_u_1] = (_e53 * _e56);
        }
        continuing {
            let _e59 = i_1;
            i_1 = (_e59 + 1u);
        }
    }
    z_out[row_p] = 0f;
    let _e66 = r_in[row_p];
    rhs_p = _e66;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_2 = start_1;
    loop {
        let _e77 = k_2;
        if (_e77 < end_1) {
        } else {
            break;
        }
        {
            let _e80 = k_2;
            let col_1 = col_indices[_e80];
            let _e85 = params.unknowns_per_cell;
            let rem = (col_1 % _e85);
            z_val = 0f;
            i_2 = 0u;
            loop {
                let _e91 = i_2;
                let _e94 = params.u_len;
                if (_e91 < _e94) {
                } else {
                    break;
                }
                {
                    let _e96 = i_2;
                    let _e97 = u_index(_e96);
                    if (rem == _e97) {
                        let _e101 = params.unknowns_per_cell;
                        let c_1 = (col_1 / _e101);
                        let _e105 = r_in[col_1];
                        let _e109 = params.u_len;
                        let _e111 = i_2;
                        let _e114 = diag_u_inv[((c_1 * _e109) + _e111)];
                        z_val = (_e105 * _e114);
                        break;
                    }
                }
                continuing {
                    let _e117 = i_2;
                    i_2 = (_e117 + 1u);
                }
            }
            let _e120 = k_2;
            let _e122 = matrix_values[_e120];
            let _e123 = z_val;
            let _e125 = rhs_p;
            rhs_p = (_e125 - (_e122 * _e123));
        }
        continuing {
            let _e128 = k_2;
            k_2 = (_e128 + 1u);
        }
    }
    let _e132 = rhs_p;
    temp_p[_e3] = _e132;
    let _e137 = diag_p_inv[_e3];
    let _e138 = rhs_p;
    p_sol[_e3] = (_e137 * _e138);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
