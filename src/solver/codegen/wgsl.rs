use super::super::scheme::Scheme;

use super::ast::{Coefficient, Discretization};
use super::ir::{DiscreteOp, DiscreteSystem};
use super::wgsl_ast::{Block, Function, Item, Module, Param, Stmt, Type};
use super::wgsl_dsl as dsl;

pub fn generate_wgsl(system: &DiscreteSystem) -> String {
    generate_wgsl_module(system).to_wgsl()
}

pub fn generate_wgsl_library(system: &DiscreteSystem) -> String {
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN (library)".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(generate_wgsl_library_items(system));
    module.to_wgsl()
}

pub fn generate_wgsl_library_items(system: &DiscreteSystem) -> Vec<Item> {
    let mut items = Vec::new();

    for equation in &system.equations {
        items.push(Item::Comment(format!(
            "equation: {} ({})",
            equation.target.name(),
            equation.target.kind().as_str()
        )));
        for op in &equation.ops {
            items.push(Item::Comment(term_comment(op)));
            items.push(Item::Function(term_stub(op)));
        }
        items.push(Item::Function(codegen_assemble_fn(equation)));
    }

    if has_convection(system) {
        items.push(Item::Function(codegen_conv_coeff_fn()));
    }
    if has_diffusion(system) {
        items.push(Item::Function(codegen_diff_coeff_fn()));
    }

    items
}

fn generate_wgsl_module(system: &DiscreteSystem) -> Module {
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));

    for equation in &system.equations {
        module.push(Item::Comment(format!(
            "equation: {} ({})",
            equation.target.name(),
            equation.target.kind().as_str()
        )));
        for op in &equation.ops {
            module.push(Item::Comment(term_comment(op)));
            module.push(Item::Function(term_stub(op)));
        }
        module.push(Item::Function(equation_assemble_fn(equation)));
    }

    module.push(Item::Function(main_fn(system)));
    module
}

fn term_comment(op: &DiscreteOp) -> String {
    let mut line = format!(
        "term: {} target={} field={} discretization={} scheme={}",
        op.kind.as_str(),
        op.target.name(),
        op.field.name(),
        op.discretization.as_str(),
        scheme_name(op.scheme),
    );

    if let Some(flux) = &op.flux {
        line.push_str(&format!(" flux={}", flux.name()));
    }

    if let Some(coeff) = &op.coeff {
        line.push(' ');
        line.push_str("coeff=");
        line.push_str(&format_coeff(coeff));
    }

    line
}

fn term_stub(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let scheme_id_value = format!("{}u", scheme_id(op.scheme));
    let discretization_value = format!("{}u", discretization_id(op.discretization));
    let body = Block::new(vec![
        Stmt::Comment("TODO: codegen term implementation".to_string()),
        dsl::let_typed("scheme_id", Type::U32, &scheme_id_value),
        dsl::let_typed("discretization_id", Type::U32, &discretization_value),
        dsl::assign("_", "scheme_id"),
        dsl::assign("_", "discretization_id"),
    ]);
    Function::new(name, Vec::new(), None, Vec::new(), body)
}

fn equation_assemble_fn(equation: &super::ir::DiscreteEquation) -> Function {
    let name = equation_function_name(&equation.target);
    let mut stmts = Vec::new();
    for op in &equation.ops {
        let term_name = term_function_name(op);
        stmts.push(dsl::call_stmt(&format!("{}()", term_name)));
    }
    Function::new(name, Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn codegen_assemble_fn(equation: &super::ir::DiscreteEquation) -> Function {
    let name = codegen_assemble_function_name(&equation.target);
    let mut stmts = Vec::new();
    for op in &equation.ops {
        let term_name = term_function_name(op);
        stmts.push(dsl::call_stmt(&format!("{}()", term_name)));
    }
    Function::new(name, Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn main_fn(system: &DiscreteSystem) -> Function {
    let mut stmts = Vec::new();
    for equation in &system.equations {
        let name = equation_function_name(&equation.target);
        stmts.push(dsl::call_stmt(&format!("{}()", name)));
    }
    Function::new("main", Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn codegen_conv_coeff_fn() -> Function {
    let params = vec![Param::new("flux", Type::F32, Vec::new())];
    let body = Block::new(vec![
        dsl::var_typed("conv_coeff_diag", Type::F32, Some("0.0")),
        dsl::var_typed("conv_coeff_off", Type::F32, Some("0.0")),
        dsl::if_block(
            "flux > 0.0",
            dsl::block(vec![dsl::assign("conv_coeff_diag", "flux")]),
            Some(dsl::block(vec![dsl::assign("conv_coeff_off", "flux")])),
        ),
        Stmt::Return(Some(dsl::expr("vec2<f32>(conv_coeff_diag, conv_coeff_off)"))),
    ]);
    Function::new(
        "codegen_conv_coeff",
        params,
        Some(Type::Vec2(Box::new(Type::F32))),
        Vec::new(),
        body,
    )
}

fn codegen_diff_coeff_fn() -> Function {
    let params = vec![
        Param::new("mu", Type::F32, Vec::new()),
        Param::new("area", Type::F32, Vec::new()),
        Param::new("dist", Type::F32, Vec::new()),
    ];
    let body = Block::new(vec![Stmt::Return(Some(dsl::expr(
        "mu * area / dist",
    )))]);
    Function::new(
        "codegen_diff_coeff",
        params,
        Some(Type::F32),
        Vec::new(),
        body,
    )
}

fn format_coeff(coeff: &Coefficient) -> String {
    match coeff {
        Coefficient::Constant(value) => format!("const({})", value),
        Coefficient::Field(field) => format!("field({})", field.name()),
    }
}

fn scheme_name(scheme: Scheme) -> &'static str {
    match scheme {
        Scheme::Upwind => "upwind",
        Scheme::SecondOrderUpwind => "sou",
        Scheme::QUICK => "quick",
    }
}

fn scheme_id(scheme: Scheme) -> u32 {
    match scheme {
        Scheme::Upwind => 0,
        Scheme::SecondOrderUpwind => 1,
        Scheme::QUICK => 2,
    }
}

fn discretization_id(discretization: Discretization) -> u32 {
    match discretization {
        Discretization::Implicit => 0,
        Discretization::Explicit => 1,
    }
}

fn sanitize_ident(value: &str) -> String {
    let mut output = String::with_capacity(value.len());
    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() || ch == '_' {
            output.push(ch);
        } else {
            output.push('_');
        }
    }
    if output.is_empty() {
        "_".to_string()
    } else {
        output
    }
}

fn term_function_name(op: &DiscreteOp) -> String {
    let mut name = String::new();
    name.push_str("term_");
    name.push_str(op.kind.as_str());
    name.push('_');
    if let Some(flux) = &op.flux {
        name.push_str(&sanitize_ident(flux.name()));
        name.push('_');
    }
    name.push_str(&sanitize_ident(op.field.name()));
    name.push('_');
    name.push_str(scheme_name(op.scheme));
    name
}

fn equation_function_name(field: &super::ast::FieldRef) -> String {
    format!("assemble_{}", sanitize_ident(field.name()))
}

fn codegen_assemble_function_name(field: &super::ast::FieldRef) -> String {
    format!("codegen_assemble_{}", sanitize_ident(field.name()))
}

fn has_convection(system: &DiscreteSystem) -> bool {
    system
        .equations
        .iter()
        .flat_map(|eq| eq.ops.iter())
        .any(|op| op.kind == super::ir::DiscreteOpKind::Convection)
}

fn has_diffusion(system: &DiscreteSystem) -> bool {
    system
        .equations
        .iter()
        .flat_map(|eq| eq.ops.iter())
        .any(|op| op.kind == super::ir::DiscreteOpKind::Diffusion)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::ast::{fvc, fvm, surface_scalar, vol_scalar, vol_vector};
    use crate::solver::codegen::ir::lower_system;
    use crate::solver::codegen::scheme::SchemeRegistry;

    #[test]
    fn generate_wgsl_emits_terms_and_metadata() {
        let u = vol_vector("U");
        let p = vol_scalar("p");
        let phi = surface_scalar("phi");
        let mu = vol_scalar("mu");

        let mut eqn = crate::solver::codegen::ast::Equation::new(u.clone());
        eqn.add_term(fvm::div(phi.clone(), u.clone()));
        eqn.add_term(fvc::grad(p.clone()));
        eqn.add_term(fvm::laplacian(
            Coefficient::field(mu).unwrap(),
            u.clone(),
        ));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::codegen::ast::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("// equation: U (vector2)"));
        assert!(wgsl.contains("term: div"));
        assert!(wgsl.contains("scheme=quick"));
        assert!(wgsl.contains("flux=phi"));
        assert!(wgsl.contains("term: grad"));
        assert!(wgsl.contains("term: laplacian"));
        assert!(wgsl.contains("coeff=field(mu)"));
        assert!(wgsl.contains("fn main()"));
    }

    #[test]
    fn format_helpers_cover_constant_coeff_and_schemes() {
        let coeff = Coefficient::constant(1.5);
        assert_eq!(format_coeff(&coeff), "const(1.5)");

        assert_eq!(scheme_name(Scheme::Upwind), "upwind");
        assert_eq!(scheme_name(Scheme::SecondOrderUpwind), "sou");
        assert_eq!(scheme_name(Scheme::QUICK), "quick");
        assert_eq!(scheme_id(Scheme::Upwind), 0);
        assert_eq!(scheme_id(Scheme::SecondOrderUpwind), 1);
        assert_eq!(scheme_id(Scheme::QUICK), 2);
        assert_eq!(discretization_id(Discretization::Implicit), 0);
        assert_eq!(discretization_id(Discretization::Explicit), 1);
    }

    #[test]
    fn generated_line_omits_optional_fields_when_absent() {
        let u = vol_vector("U");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvc::grad(u.clone()));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("term: grad"));
        assert!(!wgsl.contains("flux="));
        assert!(!wgsl.contains("coeff="));
    }

    #[test]
    fn generate_wgsl_includes_ddt_and_source_terms() {
        let u = vol_vector("U");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()))
            .with_term(fvc::source(u.clone()));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("term: ddt"));
        assert!(wgsl.contains("term: source"));
    }

    #[test]
    fn sanitize_ident_replaces_non_alnum() {
        assert_eq!(sanitize_ident("phi"), "phi");
        assert_eq!(sanitize_ident("phi.face"), "phi_face");
        assert_eq!(sanitize_ident("U[0]"), "U_0_");
        assert_eq!(sanitize_ident(""), "_");
    }

    #[test]
    fn term_function_name_includes_flux_and_scheme() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi.face");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi.clone(), u.clone()));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::codegen::ast::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry);
        let name = term_function_name(&discrete.equations[0].ops[0]);
        assert_eq!(name, "term_div_phi_face_U_quick");
    }

    #[test]
    fn generate_wgsl_emits_function_stubs() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi, u.clone()));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("fn term_div_phi_U_upwind()"));
        assert!(wgsl.contains("TODO: codegen term implementation"));
        assert!(wgsl.contains("scheme_id: u32 = 0u"));
        assert!(wgsl.contains("discretization_id: u32 = 0u"));
        assert!(wgsl.contains("fn assemble_U()"));
        assert!(wgsl.contains("assemble_U();"));
    }

    #[test]
    fn equation_function_name_is_sanitized() {
        let field = vol_vector("U-1");
        let name = equation_function_name(&field);
        assert_eq!(name, "assemble_U_1");
    }

    #[test]
    fn generate_wgsl_library_emits_codegen_assemble() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi");
        let nu = vol_scalar("nu");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi, u.clone()))
            .with_term(fvm::laplacian(
                Coefficient::field(nu).unwrap(),
                u.clone(),
            ));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl_library(&discrete);

        assert!(wgsl.contains("codegen_assemble_U"));
        assert!(!wgsl.contains("fn main()"));
        assert!(wgsl.contains("codegen_conv_coeff"));
        assert!(wgsl.contains("codegen_diff_coeff"));
    }

    #[test]
    fn generate_wgsl_library_omits_conv_coeff_when_no_convection() {
        let u = vol_vector("U");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl_library(&discrete);

        assert!(!wgsl.contains("codegen_conv_coeff"));
        assert!(!wgsl.contains("codegen_diff_coeff"));
    }

    #[test]
    fn generate_wgsl_library_emits_diff_coeff_for_laplacian() {
        let u = vol_vector("U");
        let nu = vol_scalar("nu");
        let eqn = crate::solver::codegen::ast::Equation::new(u.clone())
            .with_term(fvm::laplacian(
                Coefficient::field(nu).unwrap(),
                u.clone(),
            ));

        let mut system = crate::solver::codegen::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl_library(&discrete);

        assert!(wgsl.contains("codegen_diff_coeff"));
    }
}
