use super::super::dsl as typed;
use super::super::reconstruction::limited_linear_reconstruct_face;
use super::super::state_access::{state_scalar, state_vec2};
use super::super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt, StructDef,
    StructField, Type,
};
use super::super::wgsl_dsl as dsl;
use crate::solver::gpu::enums::{GpuBcKind, GpuLowMachPrecondModel};
use crate::solver::model::backend::StateLayout;
use crate::solver::model::FluxLayout;
use crate::solver::scheme::Scheme;

pub fn generate_ei_flux_kt_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (ei_flux_kt)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, flux_layout)));
    module.to_wgsl()
}

pub fn generate_compressible_flux_kt_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
) -> String {
    generate_ei_flux_kt_wgsl(layout, flux_layout)
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Struct(low_mach_params_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per boundary type × unknown)".to_string(),
    ));
    items.push(storage_var(
        "bc_kind",
        Type::array(Type::U32),
        2,
        0,
        AccessMode::Read,
    ));
    items.push(storage_var(
        "bc_value",
        Type::array(Type::F32),
        2,
        1,
        AccessMode::Read,
    ));
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var("state_iter", Type::array(Type::F32), 1, 9, AccessMode::Read),
        uniform_var("low_mach", Type::Custom("LowMachParams".to_string()), 1, 10),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, flux_layout: &FluxLayout) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout),
    )
}

fn main_body(layout: &StateLayout, flux_layout: &FluxLayout) -> Block {
    let mut stmts = Vec::new();
    let rho_field = "rho";
    let rho_u_field = "rho_u";
    let rho_e_field = "rho_e";
    let gamma = 1.4_f32;
    let gamma_minus_1 = gamma - 1.0;
    let flux_stride = flux_layout.stride;
    let off_rho = flux_layout
        .offset_for(rho_field)
        .unwrap_or_else(|| panic!("missing flux component {rho_field}"));
    let off_rho_u_x = flux_layout
        .offset_for(&format!("{rho_u_field}_x"))
        .unwrap_or_else(|| panic!("missing flux component {rho_u_field}_x"));
    let off_rho_u_y = flux_layout
        .offset_for(&format!("{rho_u_field}_y"))
        .unwrap_or_else(|| panic!("missing flux component {rho_u_field}_y"));
    let off_rho_e = flux_layout
        .offset_for(rho_e_field)
        .unwrap_or_else(|| panic!("missing flux component {rho_e_field}"));

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        Expr::ident("face_owner").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        Expr::ident("face_neighbor").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "area",
        Expr::ident("face_areas").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        Expr::ident("face_boundary").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        Expr::ident("face_centers").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "center_owner",
        Expr::ident("cell_centers").index(Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "center_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("center_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));
    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec")).sub(
        &typed::VecExpr::<2>::from_expr(Expr::ident("center_owner_vec")),
    );
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));
    stmts.push(dsl::var_typed_expr(
        "is_boundary",
        Type::Bool,
        Some(false.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "other_idx",
        Type::U32,
        Some(Expr::ident("owner")),
    ));

    let rho_l_expr = state_scalar(layout, "state_old", "owner", rho_field);
    let rho_u_l_expr = state_vec2(layout, "state_old", "owner", rho_u_field);
    let rho_e_l_expr = state_scalar(layout, "state_old", "owner", rho_e_field);
    stmts.push(dsl::let_expr("rho_l_cell", rho_l_expr));
    stmts.push(dsl::let_typed_expr(
        "rho_u_l_cell",
        Type::vec2_f32(),
        rho_u_l_expr,
    ));
    stmts.push(dsl::let_expr("rho_e_l_cell", rho_e_l_expr));
    stmts.push(dsl::var_typed_expr(
        "rho_l",
        Type::F32,
        Some(Expr::ident("rho_l_cell")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rho_u_l",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l_cell")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rho_e_l",
        Type::F32,
        Some(Expr::ident("rho_e_l_cell")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rho_r",
        Type::F32,
        Some(Expr::ident("rho_l")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rho_u_r",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rho_e_r",
        Type::F32,
        Some(Expr::ident("rho_e_l")),
    ));
    stmts.push(dsl::var_typed_expr(
        "center_r",
        Type::Custom("Vector2".to_string()),
        Some(Expr::ident("face_center")),
    ));

    let interior_block = {
        let rho_neigh_expr = state_scalar(layout, "state_old", "neigh_idx", rho_field);
        let rho_u_neigh_expr = state_vec2(layout, "state_old", "neigh_idx", rho_u_field);
        let rho_e_neigh_expr = state_scalar(layout, "state_old", "neigh_idx", rho_e_field);
        dsl::block(vec![
            dsl::let_typed_expr(
                "neigh_idx",
                Type::U32,
                Expr::call_named("u32", vec![Expr::ident("neighbor")]),
            ),
            dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neigh_idx")),
            dsl::let_expr("rho_neigh", rho_neigh_expr),
            dsl::let_typed_expr("rho_u_neigh", Type::vec2_f32(), rho_u_neigh_expr),
            dsl::let_expr("rho_e_neigh", rho_e_neigh_expr),
            dsl::assign_expr(Expr::ident("rho_r"), Expr::ident("rho_neigh")),
            dsl::assign_expr(Expr::ident("rho_u_r"), Expr::ident("rho_u_neigh")),
            dsl::assign_expr(Expr::ident("rho_e_r"), Expr::ident("rho_e_neigh")),
            dsl::assign_expr(
                Expr::ident("center_r"),
                Expr::ident("cell_centers").index(Expr::ident("neigh_idx")),
            ),
        ])
    };

    let boundary_block = dsl::block(vec![
        dsl::assign_expr(Expr::ident("is_boundary"), true),
        // Conservative (rho, rho_u_x, rho_u_y, rho_e) BCs via bc_kind/bc_value tables.
        // Unknown ordering matches EquationSystem target ordering for the compressible model.
        dsl::let_expr(
            "bc_idx_rho",
            Expr::ident("boundary_type") * 4u32 + 0u32,
        ),
        dsl::let_expr(
            "bc_idx_rho_u_x",
            Expr::ident("boundary_type") * 4u32 + 1u32,
        ),
        dsl::let_expr(
            "bc_idx_rho_u_y",
            Expr::ident("boundary_type") * 4u32 + 2u32,
        ),
        dsl::let_expr(
            "bc_idx_rho_e",
            Expr::ident("boundary_type") * 4u32 + 3u32,
        ),
        dsl::let_expr(
            "bc_rho",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho")),
        ),
        dsl::let_expr(
            "bc_rho_u_x",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho_u_x")),
        ),
        dsl::let_expr(
            "bc_rho_u_y",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho_u_y")),
        ),
        dsl::let_expr(
            "bc_rho_e",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho_e")),
        ),
        dsl::let_typed_expr(
            "bc_kind_rho",
            Type::U32,
            Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho")),
        ),
        dsl::let_typed_expr(
            "bc_kind_rho_u_x",
            Type::U32,
            Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho_u_x")),
        ),
        dsl::let_typed_expr(
            "bc_kind_rho_u_y",
            Type::U32,
            Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho_u_y")),
        ),
        dsl::let_typed_expr(
            "bc_kind_rho_e",
            Type::U32,
            Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho_e")),
        ),
        dsl::assign_expr(
            Expr::ident("rho_r"),
            dsl::select(
                Expr::ident("rho_l"),
                Expr::ident("bc_rho"),
                typed::EnumExpr::<GpuBcKind>::from_expr(Expr::ident("bc_kind_rho"))
                    .eq(GpuBcKind::Dirichlet),
            ),
        ),
        dsl::let_expr(
            "rho_u_r_x",
            dsl::select(
                Expr::ident("rho_u_l").field("x"),
                Expr::ident("bc_rho_u_x"),
                typed::EnumExpr::<GpuBcKind>::from_expr(Expr::ident("bc_kind_rho_u_x"))
                    .eq(GpuBcKind::Dirichlet),
            ),
        ),
        dsl::let_expr(
            "rho_u_r_y",
            dsl::select(
                Expr::ident("rho_u_l").field("y"),
                Expr::ident("bc_rho_u_y"),
                typed::EnumExpr::<GpuBcKind>::from_expr(Expr::ident("bc_kind_rho_u_y"))
                    .eq(GpuBcKind::Dirichlet),
            ),
        ),
        dsl::assign_expr(
            Expr::ident("rho_u_r"),
            typed::VecExpr::<2>::from_components([
                Expr::ident("rho_u_r_x"),
                Expr::ident("rho_u_r_y"),
            ])
            .expr(),
        ),
        dsl::assign_expr(
            Expr::ident("rho_e_r"),
            dsl::select(
                Expr::ident("rho_e_l"),
                Expr::ident("bc_rho_e"),
                typed::EnumExpr::<GpuBcKind>::from_expr(Expr::ident("bc_kind_rho_e"))
                    .eq(GpuBcKind::Dirichlet),
            ),
        ),
    ]);

    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        interior_block,
        Some(boundary_block),
    ));

    stmts.push(dsl::let_expr("rho_r_cell", Expr::ident("rho_r")));
    stmts.push(dsl::let_typed_expr(
        "rho_u_r_cell",
        Type::vec2_f32(),
        Expr::ident("rho_u_r"),
    ));
    stmts.push(dsl::let_expr("rho_e_r_cell", Expr::ident("rho_e_r")));

    let reconstruct_block = {
        let mut block = Vec::new();
        block.push(dsl::let_expr(
            "r_l_x",
            Expr::ident("face_center").field("x") - Expr::ident("center_owner").field("x"),
        ));
        block.push(dsl::let_expr(
            "r_l_y",
            Expr::ident("face_center").field("y") - Expr::ident("center_owner").field("y"),
        ));
        block.push(dsl::let_expr(
            "r_r_x",
            Expr::ident("face_center").field("x") - Expr::ident("center_r").field("x"),
        ));
        block.push(dsl::let_expr(
            "r_r_y",
            Expr::ident("face_center").field("y") - Expr::ident("center_r").field("y"),
        ));

        // Reconstruct conservative variables directly for robustness.
        block.push(dsl::let_expr(
            "grad_rho_l",
            Expr::ident("grad_rho").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_l",
            Expr::ident("grad_rho_u_x").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_l",
            Expr::ident("grad_rho_u_y").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_l",
            Expr::ident("grad_rho_e").index(Expr::ident("owner")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_r",
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_r",
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_r",
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_r",
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        ));

        let (rho_l_stmts, rho_l_face) = limited_linear_reconstruct_face(
            "rho",
            "l",
            Expr::ident("rho_l_cell"),
            Expr::ident("rho_r_cell"),
            Expr::ident("grad_rho_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_l_stmts);
        let (rho_u_x_l_stmts, rho_u_x_l_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "l",
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("grad_rho_u_x_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_x_l_stmts);
        let (rho_u_y_l_stmts, rho_u_y_l_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "l",
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("grad_rho_u_y_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_y_l_stmts);
        let (rho_e_l_stmts, rho_e_l_face) = limited_linear_reconstruct_face(
            "rho_e",
            "l",
            Expr::ident("rho_e_l_cell"),
            Expr::ident("rho_e_r_cell"),
            Expr::ident("grad_rho_e_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_e_l_stmts);

        let (rho_r_stmts, rho_r_face) = limited_linear_reconstruct_face(
            "rho",
            "r",
            Expr::ident("rho_r_cell"),
            Expr::ident("rho_l_cell"),
            Expr::ident("grad_rho_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_r_stmts);
        let (rho_u_x_r_stmts, rho_u_x_r_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "r",
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("grad_rho_u_x_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_x_r_stmts);
        let (rho_u_y_r_stmts, rho_u_y_r_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "r",
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("grad_rho_u_y_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_y_r_stmts);
        let (rho_e_r_stmts, rho_e_r_face) = limited_linear_reconstruct_face(
            "rho_e",
            "r",
            Expr::ident("rho_e_r_cell"),
            Expr::ident("rho_e_l_cell"),
            Expr::ident("grad_rho_e_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_e_r_stmts);

        block.push(dsl::assign_expr(Expr::ident("rho_l"), rho_l_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_l"),
            dsl::vec2_f32(rho_u_x_l_face, rho_u_y_l_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_l"), rho_e_l_face));
        block.push(dsl::assign_expr(Expr::ident("rho_r"), rho_r_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_r"),
            dsl::vec2_f32(rho_u_x_r_face, rho_u_y_r_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_r"), rho_e_r_face));

        dsl::block(block)
    };

    // For compressible KT fluxes, keep reconstruction conservative and stable:
    // - `scheme=0` and `scheme=2` default to piecewise-constant states.
    // - `scheme=1` enables limited linear reconstruction.
    stmts.push(dsl::if_block_expr(
        (!Expr::ident("is_boundary"))
            & typed::EnumExpr::<Scheme>::from_expr(Expr::ident("constants").field("scheme"))
                .eq(Scheme::SecondOrderUpwind),
        reconstruct_block,
        None,
    ));

    stmts.push(dsl::let_expr(
        "inv_rho_l",
        Expr::from(1.0) / dsl::max("rho_l", 1e-8),
    ));
    stmts.push(dsl::let_typed_expr(
        "u_l",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
            .mul_scalar(Expr::ident("inv_rho_l"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "ke_l",
        Expr::ident("rho_l")
            * typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l")))
            * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "p_l",
        dsl::max(
            0.0,
            (Expr::ident("rho_e_l") - Expr::ident("ke_l")) * gamma_minus_1,
        ),
    ));
    stmts.push(dsl::let_expr(
        "u_n_l",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_expr(
        "c_l",
        dsl::sqrt(Expr::ident("p_l") * Expr::ident("inv_rho_l") * gamma),
    ));

    stmts.push(dsl::let_expr(
        "inv_rho_r",
        Expr::from(1.0) / dsl::max("rho_r", 1e-8),
    ));
    stmts.push(dsl::let_typed_expr(
        "u_r",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r"))
            .mul_scalar(Expr::ident("inv_rho_r"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "ke_r",
        Expr::ident("rho_r")
            * typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r")))
            * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "p_r",
        dsl::max(
            0.0,
            (Expr::ident("rho_e_r") - Expr::ident("ke_r")) * gamma_minus_1,
        ),
    ));
    stmts.push(dsl::let_expr(
        "u_n_r",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_expr(
        "c_r",
        dsl::sqrt(Expr::ident("p_r") * Expr::ident("inv_rho_r") * gamma),
    ));
    stmts.push(dsl::let_typed_expr(
        "u_face",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("u_l"))
            .add(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r")))
            .mul_scalar(0.5.into())
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "u_face_n",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_expr(
        "c_bar",
        (Expr::ident("c_l") + Expr::ident("c_r")) * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "mach",
        dsl::abs("u_face_n") / dsl::max("c_bar", 1e-6),
    ));
    stmts.push(dsl::let_expr(
        "mach2",
        Expr::ident("mach") * Expr::ident("mach"),
    ));
    // Low-Mach preconditioning (optional). Default is `model=2` (off) for
    // rhoCentralFoam-like transient behavior (e.g., acoustics).
    stmts.push(dsl::var_typed_expr(
        "c_l_eff",
        Type::F32,
        Some(Expr::ident("c_l")),
    ));
    stmts.push(dsl::var_typed_expr(
        "c_r_eff",
        Type::F32,
        Some(Expr::ident("c_r")),
    ));
    let precond_legacy_block = dsl::block(vec![
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            Expr::ident("c_l") * Expr::ident("mach"),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            Expr::ident("c_r") * Expr::ident("mach"),
        ),
    ]);
    let precond_weiss_smith_block = dsl::block(vec![
        dsl::let_expr(
            "theta",
            dsl::min(
                1.0,
                dsl::max(
                    Expr::ident("mach2"),
                    Expr::ident("low_mach").field("theta_floor"),
                ),
            ),
        ),
        dsl::let_expr("one_minus_theta", Expr::from(1.0) - Expr::ident("theta")),
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            dsl::sqrt(
                Expr::ident("theta") * Expr::ident("c_l") * Expr::ident("c_l")
                    + Expr::ident("one_minus_theta") * Expr::ident("u_n_l") * Expr::ident("u_n_l"),
            ),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            dsl::sqrt(
                Expr::ident("theta") * Expr::ident("c_r") * Expr::ident("c_r")
                    + Expr::ident("one_minus_theta") * Expr::ident("u_n_r") * Expr::ident("u_n_r"),
            ),
        ),
    ]);
    let precond_model = typed::EnumExpr::<GpuLowMachPrecondModel>::from_expr(
        Expr::ident("low_mach").field("model"),
    );
    let precond_else_block = dsl::block(vec![dsl::if_block_expr(
        precond_model.eq(GpuLowMachPrecondModel::WeissSmith),
        precond_weiss_smith_block,
        None,
    )]);
    stmts.push(dsl::if_block_expr(
        precond_model.eq(GpuLowMachPrecondModel::Legacy),
        precond_legacy_block,
        Some(precond_else_block),
    ));
    stmts.push(dsl::let_typed_expr(
        "center_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("center_r")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "d_center",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("center_r_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                "center_owner_vec",
            )))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "dist",
        dsl::max(dsl::length("d_center"), 1e-6),
    ));
    stmts.push(dsl::let_expr(
        "mu",
        Expr::ident("constants").field("viscosity"),
    ));

    stmts.push(dsl::let_expr(
        "a_plus",
        dsl::max(
            0.0,
            dsl::max(
                Expr::ident("u_n_l") + Expr::ident("c_l_eff"),
                Expr::ident("u_n_r") + Expr::ident("c_r_eff"),
            ),
        ),
    ));
    stmts.push(dsl::let_expr(
        "a_minus",
        dsl::min(
            0.0,
            dsl::min(
                Expr::ident("u_n_l") - Expr::ident("c_l_eff"),
                Expr::ident("u_n_r") - Expr::ident("c_r_eff"),
            ),
        ),
    ));
    stmts.push(dsl::let_expr(
        "denom",
        dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
    ));
    stmts.push(dsl::let_expr(
        "a_prod",
        Expr::ident("a_plus") * Expr::ident("a_minus"),
    ));
    stmts.push(dsl::let_expr(
        "a_pos",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    stmts.push(dsl::let_expr(
        "a_neg",
        Expr::from(1.0) - Expr::ident("a_pos"),
    ));
    stmts.push(dsl::let_expr(
        "a_prod_scaled",
        Expr::ident("a_prod") / Expr::ident("denom"),
    ));

    stmts.push(dsl::let_expr(
        "flux_rho_l",
        Expr::ident("rho_l") * Expr::ident("u_n_l"),
    ));
    stmts.push(dsl::let_expr(
        "flux_rho_r",
        Expr::ident("rho_r") * Expr::ident("u_n_r"),
    ));
    stmts.push(dsl::var_typed_expr(
        "flux_rho",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_r") - Expr::ident("rho_l")),
        ),
    ));
    stmts.push(dsl::let_typed_expr(
        "flux_rho_u_l",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
            .mul_scalar(Expr::ident("u_n_l"))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .mul_scalar(Expr::ident("p_l")),
            )
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "flux_rho_u_r",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r"))
            .mul_scalar(Expr::ident("u_n_r"))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .mul_scalar(Expr::ident("p_r")),
            )
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "rho_u_jump",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l")))
            .expr(),
    ));
    stmts.push(dsl::var_typed_expr(
        "flux_rho_u",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u_l"))
                .mul_scalar(Expr::ident("a_pos"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u_r"))
                        .mul_scalar(Expr::ident("a_neg")),
                )
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_jump"))
                        .mul_scalar(Expr::ident("a_prod_scaled")),
                )
                .expr(),
        ),
    ));
    stmts.push(dsl::let_expr(
        "visc_scale",
        (-Expr::ident("mu")) / Expr::ident("dist"),
    ));
    stmts.push(dsl::let_typed_expr(
        "diff_u",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("u_r"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l")))
            .mul_scalar(Expr::ident("visc_scale"))
            .expr(),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("flux_rho_u"),
        typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u"))
            .add(&typed::VecExpr::<2>::from_expr(Expr::ident("diff_u")))
            .expr(),
    ));

    stmts.push(dsl::let_expr(
        "flux_rho_e_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("u_n_l"),
    ));
    stmts.push(dsl::let_expr(
        "flux_rho_e_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("u_n_r"),
    ));
    stmts.push(dsl::var_typed_expr(
        "flux_rho_e",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_e_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_e_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_e_r") - Expr::ident("rho_e_l")),
        ),
    ));
    stmts.push(dsl::let_expr(
        "inv_rho_l_cell",
        Expr::from(1.0) / dsl::max("rho_l_cell", 1e-8),
    ));
    stmts.push(dsl::let_expr(
        "inv_rho_r_cell",
        Expr::from(1.0) / dsl::max("rho_r_cell", 1e-8),
    ));
    stmts.push(dsl::let_typed_expr(
        "u_l_cell",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l_cell"))
            .mul_scalar(Expr::ident("inv_rho_l_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "u_r_cell",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r_cell"))
            .mul_scalar(Expr::ident("inv_rho_r_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "u2_l_cell",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))),
    ));
    stmts.push(dsl::let_expr(
        "u2_r_cell",
        typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_rho_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho").index(Expr::ident("owner")))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_x_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_x").index(Expr::ident("owner")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_y_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_y").index(Expr::ident("owner")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_e_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho_e").index(Expr::ident("owner")))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_x_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u_y_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_e_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        )
        .expr(),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_u_x_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_l_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                    .mul_scalar(Expr::ident("u_l_cell").field("x")),
            )
            .mul_scalar(Expr::ident("inv_rho_l_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u_y_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_l_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                    .mul_scalar(Expr::ident("u_l_cell").field("y")),
            )
            .mul_scalar(Expr::ident("inv_rho_l_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u_x_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_r_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                    .mul_scalar(Expr::ident("u_r_cell").field("x")),
            )
            .mul_scalar(Expr::ident("inv_rho_r_cell"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u_y_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_r_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                    .mul_scalar(Expr::ident("u_r_cell").field("y")),
            )
            .mul_scalar(Expr::ident("inv_rho_r_cell"))
            .expr(),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_u2_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_l_vec"))
            .mul_scalar(Expr::ident("u_l_cell").field("x") * 2.0)
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_l_vec"))
                    .mul_scalar(Expr::ident("u_l_cell").field("y") * 2.0),
            )
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_u2_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_r_vec"))
            .mul_scalar(Expr::ident("u_r_cell").field("x") * 2.0)
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_r_vec"))
                    .mul_scalar(Expr::ident("u_r_cell").field("y") * 2.0),
            )
            .expr(),
    ));

    stmts.push(dsl::let_typed_expr(
        "grad_rho_u2_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
            .mul_scalar(Expr::ident("u2_l_cell"))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_l_vec"))
                    .mul_scalar(Expr::ident("rho_l_cell")),
            )
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_rho_u2_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
            .mul_scalar(Expr::ident("u2_r_cell"))
            .add(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_r_vec"))
                    .mul_scalar(Expr::ident("rho_r_cell")),
            )
            .expr(),
    ));

    stmts.push(dsl::let_expr("gamma_minus_1", gamma_minus_1));
    stmts.push(dsl::let_typed_expr(
        "grad_p_l_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_l_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_l_vec"))
                    .mul_scalar(0.5.into()),
            )
            .mul_scalar(Expr::ident("gamma_minus_1"))
            .expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "grad_p_r_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_r_vec"))
            .sub(
                &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_r_vec"))
                    .mul_scalar(0.5.into()),
            )
            .mul_scalar(Expr::ident("gamma_minus_1"))
            .expr(),
    ));

    stmts.push(dsl::let_expr(
        "grad_p_l_n",
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_l_vec"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_expr(
        "grad_p_r_n",
        typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_r_vec"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
    ));
    stmts.push(dsl::let_expr(
        "grad_p_face_n",
        (Expr::ident("grad_p_l_n") + Expr::ident("grad_p_r_n")) * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "grad_p_jump_n",
        (Expr::ident("p_r") - Expr::ident("p_l")) / Expr::ident("dist"),
    ));
    stmts.push(dsl::let_expr(
        "rho_face",
        (Expr::ident("rho_l") + Expr::ident("rho_r")) * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "p_bar",
        (Expr::ident("p_l") + Expr::ident("p_r")) * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "dp_rel",
        dsl::abs(Expr::ident("p_r") - Expr::ident("p_l")) / dsl::max("p_bar", 1e-6),
    ));
    // Rhie–Chow-style pressure flux coupling is only used with low-Mach preconditioning.
    // (In the pure KT mode it can introduce dispersive/odd-even pressure ringing.)
    let pressure_coupling_block = dsl::block(vec![
        dsl::let_expr(
            "pc_theta",
            dsl::min(
                1.0,
                dsl::max(
                    Expr::ident("mach2"),
                    Expr::ident("low_mach").field("theta_floor"),
                ),
            ),
        ),
        dsl::let_expr("pc_low_mach", Expr::from(1.0) - Expr::ident("pc_theta")),
        dsl::let_expr(
            "pc_smooth",
            Expr::from(1.0) / ((Expr::ident("dp_rel") / 0.2) * (Expr::ident("dp_rel") / 0.2) + 1.0),
        ),
        dsl::let_expr(
            "pc_alpha",
            Expr::ident("low_mach").field("pressure_coupling_alpha")
                * Expr::ident("pc_low_mach")
                * Expr::ident("pc_smooth"),
        ),
        dsl::let_expr(
            "m_corr",
            Expr::ident("pc_alpha") * Expr::ident("constants").field("dt")
                / dsl::max("rho_face", 1e-8)
                * (Expr::ident("grad_p_face_n") - Expr::ident("grad_p_jump_n")),
        ),
        dsl::let_expr(
            "h_l",
            (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
        ),
        dsl::let_expr(
            "h_r",
            (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
        ),
        dsl::let_expr("h_face", (Expr::ident("h_l") + Expr::ident("h_r")) * 0.5),
        dsl::assign_expr(
            Expr::ident("flux_rho"),
            Expr::ident("flux_rho") + Expr::ident("m_corr"),
        ),
        dsl::assign_expr(
            Expr::ident("flux_rho_u"),
            typed::VecExpr::<2>::from_expr(Expr::ident("flux_rho_u"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
                        .mul_scalar(Expr::ident("m_corr")),
                )
                .expr(),
        ),
        dsl::assign_expr(
            Expr::ident("flux_rho_e"),
            Expr::ident("flux_rho_e") + Expr::ident("m_corr") * Expr::ident("h_face"),
        ),
    ]);
    stmts.push(dsl::if_block_expr(
        (!Expr::ident("is_boundary"))
            & precond_model.ne(GpuLowMachPrecondModel::Off)
            & Expr::ident("low_mach")
                .field("pressure_coupling_alpha")
                .gt(0.0),
        pressure_coupling_block,
        None,
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("flux_rho_e"),
        Expr::ident("flux_rho_e")
            + typed::VecExpr::<2>::from_expr(Expr::ident("diff_u"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))),
    ));

    stmts.push(dsl::let_expr("base", Expr::ident("idx") * flux_stride));
    stmts.push(dsl::assign_expr(
        Expr::ident("fluxes").index(Expr::ident("base") + off_rho),
        Expr::ident("flux_rho") * Expr::ident("area"),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("fluxes").index(Expr::ident("base") + off_rho_u_x),
        Expr::ident("flux_rho_u").field("x") * Expr::ident("area"),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("fluxes").index(Expr::ident("base") + off_rho_u_y),
        Expr::ident("flux_rho_u").field("y") * Expr::ident("area"),
    ));
    stmts.push(dsl::assign_expr(
        Expr::ident("fluxes").index(Expr::ident("base") + off_rho_e),
        Expr::ident("flux_rho_e") * Expr::ident("area"),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;
    use crate::solver::model::FluxLayout;

    #[test]
    fn compressible_flux_kt_codegen_emits_state_arrays() {
        let model = compressible_model();
        let flux_layout = FluxLayout::from_system(&model.system);
        let wgsl = generate_ei_flux_kt_wgsl(&model.state_layout, &flux_layout);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("face_owner"));
        assert!(wgsl.contains("fluxes"));
        assert!(wgsl.contains("a_plus"));
        assert!(wgsl.contains("flux_rho_e"));
        assert!(wgsl.contains("constants.viscosity"));
        assert!(wgsl.contains("diff_u"));
    }
}
