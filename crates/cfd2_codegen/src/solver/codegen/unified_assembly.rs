use std::collections::HashMap;

use super::coeff_expr::coeff_cell_expr;
use super::dsl as typed;
use super::state_access::state_component;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use super::KernelWgsl;
use crate::solver::codegen::ir::{DiscreteOpKind, DiscreteSystem};
use crate::solver::codegen::reconstruction::scalar_reconstruction;
use crate::solver::gpu::enums::GpuBcKind;
use crate::solver::gpu::enums::TimeScheme;
use crate::solver::ir::{Coefficient, Discretization, StateLayout, TermOp};
use crate::solver::scheme::Scheme;

pub fn generate_unified_assembly_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    flux_stride: u32,
    needs_gradients: bool,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (unified_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));

    let needs_fluxes = system.equations.iter().any(|eq| {
        eq.ops
            .iter()
            .any(|op| op.kind == DiscreteOpKind::Convection)
    });

    if needs_fluxes && flux_stride == 0 {
        panic!("unified_assembly requires flux_stride > 0 when convection ops are present");
    }

    module.extend(base_assembly_items(needs_gradients, needs_fluxes));
    module.push(Item::Function(main_assembly_fn(
        system,
        layout,
        flux_stride,
        needs_gradients,
    )));
    KernelWgsl::from(module)
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("eos_gamma", Type::F32),
            StructField::new("eos_gm1", Type::F32),
            StructField::new("eos_r", Type::F32),
            StructField::new("eos_dp_drho", Type::F32),
            StructField::new("eos_p_offset", Type::F32),
            StructField::new("eos_theta_ref", Type::F32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn base_mesh_items() -> Vec<Item> {
    vec![
        Item::Struct(vector2_struct()),
        Item::Struct(constants_struct()),
        Item::Comment("Group 0: Mesh".to_string()),
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
    ]
}

fn base_state_items(needs_gradients: bool, needs_fluxes: bool) -> Vec<Item> {
    let mut items = vec![
        Item::Comment("Group 1: Fields".to_string()),
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 3),
        storage_var("state_iter", Type::array(Type::F32), 1, 4, AccessMode::Read),
    ];
    if needs_gradients {
        items.push(storage_var(
            "grad_state",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::Read,
        ));
    }
    if needs_fluxes {
        items.push(storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            6,
            AccessMode::ReadWrite,
        ));
    }
    items
}

fn base_assembly_items(needs_gradients: bool, needs_fluxes: bool) -> Vec<Item> {
    let mut items = Vec::new();
    items.extend(base_mesh_items());
    items.extend(base_state_items(needs_gradients, needs_fluxes));
    items.push(Item::Comment(
        "Group 2: Solver (block CSR values + RHS)".to_string(),
    ));
    items.push(storage_var(
        "matrix_values",
        Type::array(Type::F32),
        2,
        0,
        AccessMode::ReadWrite,
    ));
    items.push(storage_var(
        "rhs",
        Type::array(Type::F32),
        2,
        1,
        AccessMode::ReadWrite,
    ));
    items.push(storage_var(
        "scalar_row_offsets",
        Type::array(Type::U32),
        2,
        2,
        AccessMode::Read,
    ));
    items.push(Item::Comment(
        "Group 3: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.push(storage_var(
        "bc_kind",
        Type::array(Type::U32),
        3,
        0,
        AccessMode::Read,
    ));
    items.push(storage_var(
        "bc_value",
        Type::array(Type::F32),
        3,
        1,
        AccessMode::Read,
    ));
    items
}

fn coupled_unknown_components(system: &DiscreteSystem) -> Vec<(crate::solver::ir::FieldRef, u32)> {
    let mut out = Vec::new();
    for equation in &system.equations {
        let count = equation.target.kind().component_count() as u32;
        for component in 0..count {
            out.push((equation.target, component));
        }
    }
    out
}

fn coupled_offsets(system: &DiscreteSystem) -> HashMap<String, u32> {
    let mut offsets = HashMap::new();
    let mut current = 0u32;
    for equation in &system.equations {
        offsets.insert(equation.target.name().to_string(), current);
        current += equation.target.kind().component_count() as u32;
    }
    offsets
}

fn coefficient_value_expr(
    layout: &StateLayout,
    coeff: Option<&Coefficient>,
    idx_ident: &str,
    default: Expr,
) -> Expr {
    coeff_cell_expr(layout, coeff, idx_ident, default)
}

fn main_assembly_fn(
    system: &DiscreteSystem,
    layout: &StateLayout,
    flux_stride: u32,
    needs_gradients: bool,
) -> Function {
    let _stride = layout.stride();
    let unknowns = coupled_unknown_components(system);
    let coupled_stride = unknowns.len() as u32;
    let block_stride = coupled_stride * coupled_stride;
    let offsets = coupled_offsets(system);

    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let block_shape = typed::BlockShape::new(coupled_stride as u8, coupled_stride as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "diag_rank",
        dsl::array_access("diagonal_indices", Expr::ident("idx")) - Expr::ident("scalar_offset"),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx") + 1u32)
            - Expr::ident("scalar_offset"),
    ));

    // start_row_i = scalar_offset * block_stride + num_neighbors * coupled_stride * i
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::ident("scalar_offset") * block_stride,
    ));
    for row in 1..coupled_stride {
        let name = format!("start_row_{row}");
        stmts.push(dsl::let_expr(
            &name,
            Expr::ident("start_row_0") + Expr::ident("num_neighbors") * coupled_stride * row,
        ));
    }

    // Clear all block entries for this cell's rows.
    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("rank", 0u32),
        Expr::ident("rank").lt(Expr::ident("num_neighbors")),
        dsl::for_step_increment_expr(Expr::ident("rank")),
        dsl::block(dsl::for_each_mat_entry_block(
            coupled_stride as usize,
            |r, c| {
                vec![dsl::assign_expr(
                    block_matrix
                        .entry(&Expr::ident("rank"), r as u8, c as u8)
                        .expr,
                    0.0,
                )]
            },
        )),
    ));

    // diag_i / rhs_i accumulators
    for i in 0..coupled_stride {
        let diag_name = format!("diag_{i}");
        stmts.push(dsl::var_typed_expr(&diag_name, Type::F32, Some(0.0.into())));
        let rhs_name = format!("rhs_{i}");
        stmts.push(dsl::var_typed_expr(&rhs_name, Type::F32, Some(0.0.into())));
    }

    // Time derivative contributions (implicit only).
    for equation in &system.equations {
        let Some(ddt_op) = equation.ops.iter().find(|op| {
            op.kind == DiscreteOpKind::TimeDerivative
                && op.discretization == Discretization::Implicit
        }) else {
            continue;
        };

        let base_offset = *offsets
            .get(equation.target.name())
            .expect("missing target offset");
        let rho_expr = coefficient_value_expr(layout, ddt_op.coeff.as_ref(), "idx", 1.0.into());
        let base_coeff =
            Expr::ident("vol") * rho_expr.clone() / Expr::ident("constants").field("dt");
        let dtau = Expr::ident("constants").field("dtau");
        let dual_time_coeff = Expr::ident("vol") * rho_expr / dtau.clone();

        let dt = Expr::ident("constants").field("dt");
        let dt_old = Expr::ident("constants").field("dt_old");
        let time_scheme =
            typed::EnumExpr::<TimeScheme>::from_expr(Expr::ident("constants").field("time_scheme"));

        for component in 0..equation.target.kind().component_count() as u32 {
            let u_idx = base_offset + component;
            let phi_n = state_component(
                layout,
                "state_old",
                "idx",
                equation.target.name(),
                component,
            );
            let phi_nm1 = state_component(
                layout,
                "state_old_old",
                "idx",
                equation.target.name(),
                component,
            );
            let phi_iter = state_component(
                layout,
                "state_iter",
                "idx",
                equation.target.name(),
                component,
            );

            // Default BDF1
            stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(format!("diag_{u_idx}")),
                base_coeff.clone(),
            ));
            stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(format!("rhs_{u_idx}")),
                base_coeff.clone() * phi_n.clone(),
            ));

            // Optional BDF2.
            stmts.push(dsl::if_block_expr(
                time_scheme.eq(TimeScheme::BDF2),
                dsl::block(vec![
                    dsl::let_expr("r", dt.clone() / dt_old.clone()),
                    dsl::let_expr(
                        "diag_bdf2",
                        base_coeff.clone() * (Expr::ident("r") * 2.0 + 1.0)
                            / (Expr::ident("r") + 1.0),
                    ),
                    dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
                    dsl::let_expr(
                        "factor_nm1",
                        (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
                    ),
                    dsl::assign_expr(
                        Expr::ident(format!("diag_{u_idx}")),
                        Expr::ident(format!("diag_{u_idx}")) - base_coeff.clone()
                            + Expr::ident("diag_bdf2"),
                    ),
                    dsl::assign_expr(
                        Expr::ident(format!("rhs_{u_idx}")),
                        Expr::ident(format!("rhs_{u_idx}")) - base_coeff.clone() * phi_n.clone()
                            + base_coeff.clone()
                                * (Expr::ident("factor_n") * phi_n
                                    - Expr::ident("factor_nm1") * phi_nm1),
                    ),
                ]),
                None,
            ));

            // Optional pseudo-time continuation (dual-time stepping):
            // Add a diagonal `rho/dtau` term along with the matching RHS term so the
            // converged physical-time solution remains unchanged.
            stmts.push(dsl::if_block_expr(
                dtau.clone().gt(0.0),
                dsl::block(vec![
                    dsl::assign_op_expr(
                        AssignOp::Add,
                        Expr::ident(format!("diag_{u_idx}")),
                        dual_time_coeff.clone(),
                    ),
                    dsl::assign_op_expr(
                        AssignOp::Add,
                        Expr::ident(format!("rhs_{u_idx}")),
                        dual_time_coeff.clone() * phi_iter,
                    ),
                ]),
                None,
            ));
        }
    }

    // Source terms.
    for equation in &system.equations {
        for source_op in equation
            .ops
            .iter()
            .filter(|op| op.kind == DiscreteOpKind::Source)
        {
            let base_offset = *offsets
                .get(equation.target.name())
                .expect("missing target offset");

            let val = coefficient_value_expr(layout, source_op.coeff.as_ref(), "idx", 0.0.into());
            let term = val * Expr::ident("vol");

            let field_name = source_op.field.name();
            let field_offset_opt = offsets.get(field_name).copied();
            if source_op.discretization == Discretization::Implicit {
                if source_op.field.kind() != equation.target.kind() {
                    panic!(
                        "implicit source currently requires field.kind == target.kind (target={}, field={})",
                        equation.target.name(),
                        field_name
                    );
                }
                let field_offset = field_offset_opt.unwrap_or_else(|| {
                    panic!(
                        "implicit source requires '{}' to be a coupled unknown field",
                        field_name
                    )
                });
                let diag_block = block_matrix.row_entry(&Expr::ident("diag_rank"));

                for component in 0..equation.target.kind().component_count() as u32 {
                    let row_u_idx = base_offset + component;
                    let col_u_idx = field_offset + component;
                    if row_u_idx == col_u_idx {
                        // LHS -= term * phi.
                        // Assuming term is the coefficient S_p where S = S_p * phi.
                        // Contribution to diagonal is -S_p * V.
                        stmts.push(dsl::assign_op_expr(
                            AssignOp::Sub,
                            Expr::ident(format!("diag_{row_u_idx}")),
                            term.clone(),
                        ));
                    } else {
                        // Cross-coupled source term: contribute to the (row, col) block entry.
                        stmts.push(dsl::assign_op_expr(
                            AssignOp::Sub,
                            diag_block.entry(row_u_idx as u8, col_u_idx as u8).expr,
                            term.clone(),
                        ));
                    }
                }
            } else {
                // RHS += term.
                for component in 0..equation.target.kind().component_count() as u32 {
                    let u_idx = base_offset + component;
                    stmts.push(dsl::assign_op_expr(
                        AssignOp::Add,
                        Expr::ident(format!("rhs_{u_idx}")),
                        term.clone(),
                    ));
                }
            }
        }
    }

    // Face loop for diffusion contributions (implicit only).
    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neighbor_raw",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "boundary_type",
            dsl::array_access("face_boundary", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "f_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::var_typed_expr(
            "normal",
            Type::Custom("Vector2".to_string()),
            Some(dsl::array_access("face_normals", Expr::ident("face_idx"))),
        ));
        body.push(dsl::var_typed_expr(
            "is_boundary",
            Type::Bool,
            Some(false.into()),
        ));
        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center",
            Type::Custom("Vector2".to_string()),
            None,
        ));

        // Make normal outward from `idx`.
        body.push(dsl::if_block_expr(
            Expr::ident("owner").ne(Expr::ident("idx")),
            dsl::block(vec![
                dsl::assign_expr(
                    Expr::ident("normal").field("x"),
                    -Expr::ident("normal").field("x"),
                ),
                dsl::assign_expr(
                    Expr::ident("normal").field("y"),
                    -Expr::ident("normal").field("y"),
                ),
            ]),
            None,
        ));

        let interior_block = dsl::block(vec![
            dsl::let_expr(
                "neighbor",
                Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
            ),
            dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
            dsl::if_block_expr(
                Expr::ident("owner").ne(Expr::ident("idx")),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("other_idx"),
                    Expr::ident("owner"),
                )]),
                None,
            ),
            dsl::assign_expr(
                Expr::ident("other_center"),
                dsl::array_access("cell_centers", Expr::ident("other_idx")),
            ),
        ]);

        let boundary_block = dsl::block(vec![
            dsl::assign_expr(Expr::ident("is_boundary"), true),
            dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("idx")),
            dsl::assign_expr(Expr::ident("other_center"), Expr::ident("f_center")),
        ]);

        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            interior_block,
            Some(boundary_block),
        ));

        body.push(dsl::let_expr(
            "dx",
            Expr::ident("other_center").field("x") - Expr::ident("center").field("x"),
        ));
        body.push(dsl::let_expr(
            "dy",
            Expr::ident("other_center").field("y") - Expr::ident("center").field("y"),
        ));
        body.push(dsl::let_expr(
            "dist_proj",
            dsl::abs(
                Expr::ident("dx") * Expr::ident("normal").field("x")
                    + Expr::ident("dy") * Expr::ident("normal").field("y"),
            ),
        ));
        body.push(dsl::let_expr(
            "dist_euc",
            dsl::sqrt(
                Expr::ident("dx") * Expr::ident("dx") + Expr::ident("dy") * Expr::ident("dy"),
            ),
        ));
        body.push(dsl::var_typed_expr(
            "dist",
            Type::F32,
            Some(dsl::max("dist_euc", 1e-6)),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("dist_proj").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("dist"),
                Expr::ident("dist_proj"),
            )]),
            None,
        ));

        body.push(dsl::let_expr(
            "scalar_mat_idx",
            dsl::array_access("cell_face_matrix_indices", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ));

        // Diffusion contributions per equation.
        for equation in &system.equations {
            let base_offset = *offsets
                .get(equation.target.name())
                .expect("missing target offset");

            if let Some(diff_op) = equation.ops.iter().find(|op| {
                op.kind == DiscreteOpKind::Diffusion
                    && op.discretization == Discretization::Implicit
            }) {
                if diff_op.field.kind() != equation.target.kind() {
                    panic!(
                        "implicit diffusion currently requires field.kind == target.kind (target={}, field={})",
                        equation.target.name(),
                        diff_op.field.name()
                    );
                }

                let field_name = diff_op.field.name();
                let field_base_offset = offsets.get(field_name).copied().unwrap_or_else(|| {
                    panic!(
                        "implicit diffusion currently requires '{}' to be a coupled unknown field",
                        field_name
                    )
                });

                // Face-interpolated coefficient for implicit diffusion.
                // This is critical for consistency with the Rhie-Chow flux formula:
                // the pressure Laplacian coefficient (rho * d_p) must match the
                // face-interpolated d_p used in the momentum flux computation.
                let kappa_own =
                    coefficient_value_expr(layout, diff_op.coeff.as_ref(), "idx", 1.0.into());
                let kappa_other =
                    coefficient_value_expr(layout, diff_op.coeff.as_ref(), "other_idx", 1.0.into());
                // Use arithmetic mean for interior faces; for boundaries use owner value.
                let kappa = dsl::select(
                    kappa_own.clone(),
                    (kappa_own.clone() + kappa_other) * 0.5,
                    !Expr::ident("is_boundary"),
                );

                let diff_coeff_name = format!("diff_coeff_{}", equation.target.name());
                body.push(dsl::let_expr(
                    &diff_coeff_name,
                    kappa.clone() * Expr::ident("area") / Expr::ident("dist"),
                ));

                for component in 0..equation.target.kind().component_count() as u32 {
                    let row_u_idx = base_offset + component;
                    let col_u_idx = field_base_offset + component;

                    // Boundary values are taken from the field being diffused (the "column"
                    // variable), not from the equation target.
                    let bc_table_idx = Expr::ident("face_idx") * coupled_stride + col_u_idx;
                    let bc_kind_expr = typed::EnumExpr::<GpuBcKind>::from_expr(dsl::array_access(
                        "bc_kind",
                        bc_table_idx,
                    ));
                    let bc_value_expr = dsl::array_access("bc_value", bc_table_idx);

                    let diag_block = block_matrix.row_entry(&Expr::ident("diag_rank"));

                    let interior_contrib = dsl::block(vec![
                        // Diagonal contribution.
                        if row_u_idx == col_u_idx {
                            dsl::assign_op_expr(
                                AssignOp::Add,
                                Expr::ident(format!("diag_{row_u_idx}")),
                                Expr::ident(&diff_coeff_name),
                            )
                        } else {
                            dsl::assign_op_expr(
                                AssignOp::Add,
                                diag_block.entry(row_u_idx as u8, col_u_idx as u8).expr,
                                Expr::ident(&diff_coeff_name),
                            )
                        },
                        // Neighbor contribution.
                        dsl::assign_op_expr(
                            AssignOp::Sub,
                            block_matrix
                                .entry(
                                    &Expr::ident("neighbor_rank"),
                                    row_u_idx as u8,
                                    col_u_idx as u8,
                                )
                                .expr,
                            Expr::ident(&diff_coeff_name),
                        ),
                    ]);

                    let neumann_rhs =
                        -(kappa.clone() * Expr::ident("area") * bc_value_expr.clone());
                    let boundary_contrib = {
                        let is_velocity_field = matches!(field_name, "u" | "U" | "rho_u" | "rhoU");
                        let is_slipwall = Expr::ident("boundary_type").eq(Expr::from(4u32));

                        // SlipWall: emulate OpenFOAM `type slip` by projecting out the normal
                        // component at the boundary. This cannot be represented by the scalar
                        // per-component BC table, so handle it here (diffusion terms only).
                        let slip_bc_value = if is_velocity_field
                            && equation.target.kind().component_count() >= 2
                            && component <= 1
                        {
                            let vx = state_component(layout, "state", "idx", field_name, 0);
                            let vy = state_component(layout, "state", "idx", field_name, 1);
                            let nx = Expr::ident("normal").field("x");
                            let ny = Expr::ident("normal").field("y");
                            let un = vx.clone() * nx.clone() + vy.clone() * ny.clone();

                            Some(if component == 0 {
                                vx - un.clone() * nx
                            } else {
                                vy - un * ny
                            })
                        } else {
                            None
                        };

                        let diag_add = if row_u_idx == col_u_idx {
                            dsl::assign_op_expr(
                                AssignOp::Add,
                                Expr::ident(format!("diag_{row_u_idx}")),
                                Expr::ident(&diff_coeff_name),
                            )
                        } else {
                            dsl::assign_op_expr(
                                AssignOp::Add,
                                diag_block.entry(row_u_idx as u8, col_u_idx as u8).expr,
                                Expr::ident(&diff_coeff_name),
                            )
                        };

                        let slip_block = slip_bc_value.map(|value| {
                            dsl::block(vec![
                                diag_add.clone(),
                                dsl::assign_op_expr(
                                    AssignOp::Add,
                                    Expr::ident(format!("rhs_{row_u_idx}")),
                                    Expr::ident(&diff_coeff_name) * value,
                                ),
                            ])
                        });

                        let default_block = dsl::block(vec![dsl::if_block_expr(
                            bc_kind_expr.eq(GpuBcKind::Dirichlet),
                            dsl::block(vec![
                                diag_add,
                                dsl::assign_op_expr(
                                    AssignOp::Add,
                                    Expr::ident(format!("rhs_{row_u_idx}")),
                                    Expr::ident(&diff_coeff_name) * bc_value_expr.clone(),
                                ),
                            ]),
                            Some(dsl::block(vec![dsl::if_block_expr(
                                bc_kind_expr.eq(GpuBcKind::Neumann),
                                dsl::block(vec![dsl::assign_op_expr(
                                    AssignOp::Add,
                                    Expr::ident(format!("rhs_{row_u_idx}")),
                                    neumann_rhs,
                                )]),
                                None,
                            )])),
                        )]);

                        if let Some(slip_block) = slip_block {
                            dsl::block(vec![dsl::if_block_expr(
                                is_slipwall,
                                slip_block,
                                Some(default_block),
                            )])
                        } else {
                            default_block
                        }
                    };

                    body.push(dsl::if_block_expr(
                        !Expr::ident("is_boundary"),
                        interior_contrib,
                        Some(boundary_contrib),
                    ));
                }
            }

            // Explicit diffusion (RHS-only), supporting `laplacian(k, field)` where `field` may
            // differ from the equation target (e.g., viscous term for conserved momentum using
            // the derived velocity `u`).
            if let Some(diff_op) = equation.ops.iter().find(|op| {
                op.kind == DiscreteOpKind::Diffusion
                    && op.discretization == Discretization::Explicit
            }) {
                if diff_op.field.kind() != equation.target.kind() {
                    panic!(
                        "explicit diffusion currently requires field.kind == target.kind (target={}, field={})",
                        equation.target.name(),
                        diff_op.field.name()
                    );
                }

                let field_name = diff_op.field.name();

                let kappa_own =
                    coefficient_value_expr(layout, diff_op.coeff.as_ref(), "idx", 1.0.into());
                let kappa_other =
                    coefficient_value_expr(layout, diff_op.coeff.as_ref(), "other_idx", 1.0.into());
                let kappa_face = dsl::select(
                    kappa_own.clone(),
                    (kappa_own.clone() + kappa_other) * 0.5,
                    !Expr::ident("is_boundary"),
                );

                let diff_coeff_name =
                    format!("diff_coeff_exp_{}_{}", equation.target.name(), field_name);
                body.push(dsl::let_expr(
                    &diff_coeff_name,
                    kappa_face * Expr::ident("area") / Expr::ident("dist"),
                ));

                let field_offset_opt = offsets.get(field_name).copied();
                let is_derived_u = matches!(field_name, "u" | "U")
                    && offsets.get("rho").is_some()
                    && offsets.get("rho_u").is_some();

                for component in 0..equation.target.kind().component_count() as u32 {
                    let u_idx = base_offset + component;
                    let phi_own = state_component(layout, "state", "idx", field_name, component);
                    let phi_neigh =
                        state_component(layout, "state", "other_idx", field_name, component);

                    let interior_contrib = dsl::block(vec![dsl::assign_op_expr(
                        AssignOp::Add,
                        Expr::ident(format!("rhs_{u_idx}")),
                        Expr::ident(&diff_coeff_name) * (phi_neigh - phi_own.clone()),
                    )]);

                    let boundary_contrib = if let Some(field_base_offset) = field_offset_opt {
                        let field_u_idx = field_base_offset + component;
                        let bc_table_idx = Expr::ident("face_idx") * coupled_stride + field_u_idx;
                        let bc_kind_expr = typed::EnumExpr::<GpuBcKind>::from_expr(
                            dsl::array_access("bc_kind", bc_table_idx),
                        );
                        let bc_value_expr = dsl::array_access("bc_value", bc_table_idx);

                        let neumann_rhs =
                            -(kappa_own.clone() * Expr::ident("area") * bc_value_expr.clone());

                        dsl::block(vec![dsl::if_block_expr(
                            bc_kind_expr.eq(GpuBcKind::Dirichlet),
                            dsl::block(vec![dsl::assign_op_expr(
                                AssignOp::Add,
                                Expr::ident(format!("rhs_{u_idx}")),
                                Expr::ident(&diff_coeff_name)
                                    * (bc_value_expr.clone() - phi_own.clone()),
                            )]),
                            Some(dsl::block(vec![dsl::if_block_expr(
                                bc_kind_expr.eq(GpuBcKind::Neumann),
                                dsl::block(vec![dsl::assign_op_expr(
                                    AssignOp::Add,
                                    Expr::ident(format!("rhs_{u_idx}")),
                                    neumann_rhs,
                                )]),
                                None,
                            )])),
                        )])
                    } else if is_derived_u {
                        // Derive a velocity boundary value from conserved BCs: u = rho_u / rho.
                        let rho_idx = *offsets.get("rho").expect("missing rho offset");
                        let rho_u_base = *offsets.get("rho_u").expect("missing rho_u offset");
                        let rho_u_idx = rho_u_base + component;

                        let bc_rho_idx = Expr::ident("face_idx") * coupled_stride + rho_idx;
                        let bc_rho_u_idx = Expr::ident("face_idx") * coupled_stride + rho_u_idx;

                        let bc_rho_kind = typed::EnumExpr::<GpuBcKind>::from_expr(
                            dsl::array_access("bc_kind", bc_rho_idx),
                        );
                        let bc_rho_u_kind = typed::EnumExpr::<GpuBcKind>::from_expr(
                            dsl::array_access("bc_kind", bc_rho_u_idx),
                        );
                        let bc_rho_val = dsl::array_access("bc_value", bc_rho_idx);
                        let bc_rho_u_val = dsl::array_access("bc_value", bc_rho_u_idx);

                        let rho_own = state_component(layout, "state", "idx", "rho", 0);
                        let rho_bc =
                            dsl::select(rho_own, bc_rho_val, bc_rho_kind.eq(GpuBcKind::Dirichlet));
                        let rho_bc_safe = dsl::max(rho_bc, 1e-12);
                        let u_bc = bc_rho_u_val / rho_bc_safe;
                        let u_other = dsl::select(
                            phi_own.clone(),
                            u_bc,
                            bc_rho_u_kind.eq(GpuBcKind::Dirichlet),
                        );

                        dsl::block(vec![dsl::assign_op_expr(
                            AssignOp::Add,
                            Expr::ident(format!("rhs_{u_idx}")),
                            Expr::ident(&diff_coeff_name) * (u_other - phi_own.clone()),
                        )])
                    } else {
                        // No BC information for this derived field; default to zero-gradient.
                        dsl::block(vec![])
                    };

                    body.push(dsl::if_block_expr(
                        !Expr::ident("is_boundary"),
                        interior_contrib,
                        Some(boundary_contrib),
                    ));
                }
            }

            // 2. Convection
            if let Some(conv_op) = equation.ops.iter().find(|op| {
                op.kind == DiscreteOpKind::Convection
                    && op.discretization == Discretization::Implicit
            }) {
                // Flux buffer is interpreted as a packed per-unknown-component face flux table.
                // Indexing is `fluxes[face * flux_stride + u_idx]`, where `u_idx` is the packed
                // unknown component index in the coupled system.
                //
                // Flux population is handled by an optional flux module kernel; assembly only
                // assumes the packed `(face_idx, u_idx)` layout.
                let flux_stride = flux_stride;

                // `DivFlux` terms represent conservative flux divergence:
                // the face flux is precomputed (e.g., KT) and should contribute RHS-only:
                //   RHS -= sum_face(sign * flux_face_component)
                // This must not be treated like a scalar convection operator.
                if conv_op.term_op == TermOp::DivFlux {
                    for component in 0..equation.target.kind().component_count() as u32 {
                        let u_idx = base_offset + component;
                        let flux_var = format!("phi_{u_idx}");
                        let flux_val_expr = dsl::array_access_linear(
                            "fluxes",
                            Expr::ident("face_idx"),
                            flux_stride,
                            u_idx,
                        );

                        body.push(dsl::var_typed_expr(
                            &flux_var,
                            Type::F32,
                            Some(flux_val_expr.clone()),
                        ));
                        body.push(dsl::if_block_expr(
                            Expr::ident("owner").ne(Expr::ident("idx")),
                            dsl::block(vec![dsl::assign_op_expr(
                                AssignOp::Sub,
                                Expr::ident(&flux_var),
                                Expr::ident(&flux_var) * 2.0,
                            )]),
                            None,
                        ));
                        body.push(dsl::assign_op_expr(
                            AssignOp::Sub,
                            Expr::ident(format!("rhs_{u_idx}")),
                            Expr::ident(&flux_var),
                        ));
                    }
                } else {
                    // Reconstruct field at face (scalar convection operator)
                    for component in 0..equation.target.kind().component_count() as u32 {
                        let u_idx = base_offset + component;
                        let field_name = equation.target.name();

                        let flux_var = format!("phi_{u_idx}");
                        let flux_val_expr = dsl::array_access_linear(
                            "fluxes",
                            Expr::ident("face_idx"),
                            flux_stride,
                            u_idx,
                        );
                        body.push(dsl::var_typed_expr(
                            &flux_var,
                            Type::F32,
                            Some(flux_val_expr.clone()),
                        ));
                        body.push(dsl::if_block_expr(
                            Expr::ident("owner").ne(Expr::ident("idx")),
                            dsl::block(vec![dsl::assign_op_expr(
                                AssignOp::Sub,
                                Expr::ident(&flux_var),
                                Expr::ident(&flux_var) * 2.0,
                            )]),
                            None,
                        ));

                        let phi_own =
                            state_component(layout, "state", "idx", field_name, component);
                        let phi_neigh =
                            state_component(layout, "state", "other_idx", field_name, component);

                        // Runtime-configurable advection scheme.
                        //
                        // Note: we intentionally do not bake the scheme selection into the WGSL
                        // at codegen time; the solver drives it through `constants.scheme`.
                        let scheme_lit = typed::EnumExpr::<Scheme>::from_expr(
                            Expr::ident("constants").field("scheme"),
                        );

                        // Reconstruction gradients.
                        //
                        // If a packed `grad_state` buffer exists, use it. Otherwise, fall back to
                        // a simple two-point gradient estimate based on neighbor differences.
                        // This keeps the scheme knob meaningful without requiring a dedicated
                        // gradients kernel for every model.
                        let (grad_own, grad_neigh) = if needs_gradients {
                            let grad_own = dsl::array_access_linear(
                                "grad_state",
                                Expr::ident("idx"),
                                layout.stride(),
                                layout.offset_for(field_name).unwrap() as u32 + component,
                            );
                            let grad_neigh = dsl::array_access_linear(
                                "grad_state",
                                Expr::ident("other_idx"),
                                layout.stride(),
                                layout.offset_for(field_name).unwrap() as u32 + component,
                            );
                            (grad_own, grad_neigh)
                        } else {
                            let diff = phi_neigh.clone() - phi_own.clone();
                            let denom = dsl::max(
                                Expr::ident("dx") * Expr::ident("dx")
                                    + Expr::ident("dy") * Expr::ident("dy"),
                                1e-12,
                            );
                            let g_x = diff.clone() * Expr::ident("dx") / denom.clone();
                            let g_y = diff * Expr::ident("dy") / denom;
                            let grad = dsl::vec2_f32(g_x, g_y);
                            (grad.clone(), grad)
                        };

                        let rec = scalar_reconstruction(
                            scheme_lit,
                            Expr::ident(&flux_var),
                            phi_own,
                            phi_neigh,
                            grad_own,
                            grad_neigh,
                            Expr::ident("center"),
                            Expr::ident("other_center"),
                            Expr::ident("f_center"),
                        );

                        let flux_pos = dsl::max(Expr::ident(&flux_var), 0.0);
                        let flux_neg = dsl::min(Expr::ident(&flux_var), 0.0);

                        let dc_term = Expr::ident(&flux_var) * (rec.phi_ho - rec.phi_upwind);

                        let interior_contrib = dsl::block(vec![
                            dsl::assign_op_expr(
                                AssignOp::Add,
                                Expr::ident(format!("diag_{u_idx}")),
                                flux_pos.clone(),
                            ),
                            dsl::assign_op_expr(
                                AssignOp::Add,
                                block_matrix
                                    .entry(&Expr::ident("neighbor_rank"), u_idx as u8, u_idx as u8)
                                    .expr,
                                flux_neg.clone(),
                            ),
                            dsl::assign_op_expr(
                                AssignOp::Sub,
                                Expr::ident(format!("rhs_{u_idx}")),
                                dc_term.clone(),
                            ),
                        ]);

                        let bc_table_idx = Expr::ident("face_idx") * coupled_stride + u_idx;
                        let bc_kind_expr = typed::EnumExpr::<GpuBcKind>::from_expr(
                            dsl::array_access("bc_kind", bc_table_idx),
                        );
                        let bc_value_expr = dsl::array_access("bc_value", bc_table_idx);

                        let boundary_contrib = dsl::block(vec![dsl::if_block_expr(
                            bc_kind_expr.eq(GpuBcKind::Dirichlet),
                            dsl::block(vec![
                                dsl::assign_op_expr(
                                    AssignOp::Add,
                                    Expr::ident(format!("diag_{u_idx}")),
                                    flux_pos.clone(),
                                ),
                                dsl::assign_op_expr(
                                    AssignOp::Sub,
                                    Expr::ident(format!("rhs_{u_idx}")),
                                    flux_neg.clone() * bc_value_expr.clone(),
                                ),
                            ]),
                            Some(dsl::block(vec![dsl::assign_op_expr(
                                AssignOp::Add,
                                Expr::ident(format!("diag_{u_idx}")),
                                Expr::ident(&flux_var),
                            )])),
                        )]);

                        body.push(dsl::if_block_expr(
                            !Expr::ident("is_boundary"),
                            interior_contrib,
                            Some(boundary_contrib),
                        ));
                    }
                }
            }

            // 3. Gradient
            if let Some(grad_op) = equation
                .ops
                .iter()
                .find(|op| op.kind == DiscreteOpKind::Gradient)
            {
                let field_name = grad_op.field.name();
                let p_offset_opt = offsets.get(field_name);
                let phi_own = state_component(layout, "state", "idx", field_name, 0);
                let phi_neigh = state_component(layout, "state", "other_idx", field_name, 0);

                let coeff =
                    coefficient_value_expr(layout, grad_op.coeff.as_ref(), "idx", 1.0.into());
                let factor = coeff * 0.5 * Expr::ident("area");

                for component in 0..equation.target.kind().component_count() as u32 {
                    let u_idx = base_offset + component;
                    let n_comp = if component == 0 {
                        Expr::ident("normal").field("x")
                    } else {
                        Expr::ident("normal").field("y")
                    };

                    let term_common = factor.clone() * n_comp;

                    if grad_op.discretization == Discretization::Implicit && p_offset_opt.is_some()
                    {
                        let p_idx = *p_offset_opt.unwrap();
                        let diag_block = block_matrix.row_entry(&Expr::ident("diag_rank"));

                        // Owner p contribution -> Diag block (u, p)
                        body.push(dsl::assign_op_expr(
                            AssignOp::Add,
                            diag_block.entry(u_idx as u8, p_idx as u8).expr,
                            term_common.clone(),
                        ));
                        // Neighbor p contribution -> Neighbor block (u, p)
                        body.push(dsl::assign_op_expr(
                            AssignOp::Add,
                            block_matrix
                                .entry(&Expr::ident("neighbor_rank"), u_idx as u8, p_idx as u8)
                                .expr,
                            term_common.clone(),
                        ));
                    } else {
                        let val = term_common.clone() * (phi_own + phi_neigh);
                        body.push(dsl::assign_op_expr(
                            AssignOp::Sub,
                            Expr::ident(format!("rhs_{u_idx}")),
                            val,
                        ));
                    }
                }
            }
        }

        body
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(face_loop_body),
    ));

    // Write diagonal block and RHS.
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    for i in 0..coupled_stride {
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            diag_entry.entry(i as u8, i as u8).expr,
            Expr::ident(format!("diag_{i}")),
        ));
        stmts.push(dsl::assign_expr(
            dsl::array_access_linear("rhs", Expr::ident("idx"), coupled_stride, i),
            Expr::ident(format!("rhs_{i}")),
        ));
    }

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}
