use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use super::KernelWgsl;

pub fn generate_rhie_chow_correct_velocity_wgsl(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_correct_velocity)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn_correct_velocity(
        state_stride,
        u_x_offset,
        u_y_offset,
        d_p_offset,
        grad_p_x_offset,
        grad_p_y_offset,
    )));
    KernelWgsl::from(module)
}

pub fn generate_rhie_chow_store_grad_p_wgsl(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_store_grad_p)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn_store_grad_p(
        state_stride,
        grad_p_x_offset,
        grad_p_y_offset,
        grad_old_x_offset,
        grad_old_y_offset,
    )));
    KernelWgsl::from(module)
}

pub fn generate_rhie_chow_correct_velocity_delta_wgsl(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_correct_velocity_delta)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn_correct_velocity_delta(
        state_stride,
        u_x_offset,
        u_y_offset,
        d_p_offset,
        grad_p_x_offset,
        grad_p_y_offset,
        grad_old_x_offset,
        grad_old_y_offset,
    )));
    KernelWgsl::from(module)
}

fn base_items() -> Vec<Item> {
    vec![
        Item::Struct(constants_struct()),
        storage_var(
            "state",
            Type::array(Type::F32),
            0,
            0,
            AccessMode::ReadWrite,
        ),
        uniform_var(
            "constants",
            Type::Custom("Constants".to_string()),
            0,
            1,
        ),
    ]
}

fn constants_struct() -> StructDef {
    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn_correct_velocity(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body_correct_velocity(
            state_stride,
            u_x_offset,
            u_y_offset,
            d_p_offset,
            grad_p_x_offset,
            grad_p_y_offset,
        ),
    )
}

fn main_body_correct_velocity(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
) -> Block {
    let mut stmts = main_preamble(state_stride);

    stmts.push(dsl::let_expr(
        "d_p",
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(d_p_offset)),
    ));
    stmts.push(dsl::let_expr(
        "grad_px",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_py",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_x_offset)),
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_x_offset))
            - Expr::ident("d_p") * Expr::ident("grad_px"),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_y_offset)),
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_y_offset))
            - Expr::ident("d_p") * Expr::ident("grad_py"),
    ));

    Block::new(stmts)
}

fn main_fn_store_grad_p(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body_store_grad_p(
            state_stride,
            grad_p_x_offset,
            grad_p_y_offset,
            grad_old_x_offset,
            grad_old_y_offset,
        ),
    )
}

fn main_body_store_grad_p(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Block {
    let mut stmts = main_preamble(state_stride);

    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_x_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_y_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));

    Block::new(stmts)
}

fn main_fn_correct_velocity_delta(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body_correct_velocity_delta(
            state_stride,
            u_x_offset,
            u_y_offset,
            d_p_offset,
            grad_p_x_offset,
            grad_p_y_offset,
            grad_old_x_offset,
            grad_old_y_offset,
        ),
    )
}

fn main_body_correct_velocity_delta(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Block {
    let mut stmts = main_preamble(state_stride);

    stmts.push(dsl::let_expr(
        "d_p",
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(d_p_offset)),
    ));
    stmts.push(dsl::let_expr(
        "grad_px",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_py",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_old_x",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_old_y",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_y_offset),
        ),
    ));

    stmts.push(dsl::comment(
        "Apply SIMPLE-style velocity correction using the change in pressure gradient:",
    ));
    stmts.push(dsl::comment("  U_new = HbyA - d_p * grad(p_new)"));
    stmts.push(dsl::comment("  U_old = HbyA - d_p * grad(p_old)"));
    stmts.push(dsl::comment("=> U_new = U_old - d_p * (grad(p_new) - grad(p_old))"));

    stmts.push(dsl::let_expr(
        "corr_x",
        Expr::ident("d_p") * (Expr::ident("grad_px") - Expr::ident("grad_old_x")),
    ));
    stmts.push(dsl::let_expr(
        "corr_y",
        Expr::ident("d_p") * (Expr::ident("grad_py") - Expr::ident("grad_old_y")),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_x_offset)),
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_x_offset))
            - Expr::ident("corr_x"),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_y_offset)),
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_y_offset))
            - Expr::ident("corr_y"),
    ));

    Block::new(stmts)
}

fn main_params() -> Vec<Param> {
    vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )]
}

fn main_preamble(state_stride: u32) -> Vec<Stmt> {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()])
            / dsl::max(Expr::lit_u32(state_stride), Expr::lit_u32(1)),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "base",
        Expr::ident("idx") * Expr::lit_u32(state_stride),
    ));

    stmts
}
