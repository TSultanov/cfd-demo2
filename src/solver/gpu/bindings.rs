// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: 9d5a6ec7878c146f4e9e77d73fc4dd29a1fc76bf54b7c268fbb368dec06e4678

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    AmgPack,
    BlockPrecond,
    DotProduct,
    DotProductPair,
    GeneratedDpInitIncompressibleMomentum,
    GeneratedDpUpdateFromDiagIncompressibleMomentum,
    GeneratedFluxModuleCompressible,
    GeneratedFluxModuleGradientsCompressible,
    GeneratedFluxModuleGradientsIncompressibleMomentum,
    GeneratedFluxModuleIncompressibleMomentum,
    GeneratedGenericCoupledApply,
    GeneratedGenericCoupledAssemblyCompressible,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateCompressible,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum,
    GeneratedGenericCoupledAssemblyIncompressibleMomentum,
    GeneratedGenericCoupledUpdateCompressible,
    GeneratedGenericCoupledUpdateGenericDiffusionDemo,
    GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledUpdateIncompressibleMomentum,
    GeneratedPackedStateGradientsCompressible,
    GeneratedPackedStateGradientsGenericDiffusionDemo,
    GeneratedPackedStateGradientsGenericDiffusionDemoNeumann,
    GeneratedPackedStateGradientsIncompressibleMomentum,
    GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum,
    GeneratedRhieChowGradPUpdateIncompressibleMomentum,
    GeneratedRhieChowStoreGradPIncompressibleMomentum,
    GenericCoupledSchurSetup,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    OuterConvergence,
    Scalars,
    SchurPrecond,
    SchurPrecondGeneric,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self { Self :: Amg => amg :: create_pipeline_layout (device) , Self :: AmgPack => amg_pack :: create_pipeline_layout (device) , Self :: BlockPrecond => block_precond :: create_pipeline_layout (device) , Self :: DotProduct => dot_product :: create_pipeline_layout (device) , Self :: DotProductPair => dot_product_pair :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentum => generated :: dp_init_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => generated :: dp_update_from_diag_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleCompressible => generated :: flux_module_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsCompressible => generated :: flux_module_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => generated :: flux_module_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentum => generated :: flux_module_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledApply => generated :: generic_coupled_apply :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyCompressible => generated :: generic_coupled_assembly_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => generated :: generic_coupled_assembly_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => generated :: generic_coupled_assembly_grad_state_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => generated :: generic_coupled_assembly_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateCompressible => generated :: generic_coupled_update_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => generated :: generic_coupled_update_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => generated :: generic_coupled_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsCompressible => generated :: packed_state_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => generated :: packed_state_gradients_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => generated :: packed_state_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum => generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowGradPUpdateIncompressibleMomentum => generated :: rhie_chow_grad_p_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowStoreGradPIncompressibleMomentum => generated :: rhie_chow_store_grad_p_incompressible_momentum :: create_pipeline_layout (device) , Self :: GenericCoupledSchurSetup => generic_coupled_schur_setup :: create_pipeline_layout (device) , Self :: GmresCgs => gmres_cgs :: create_pipeline_layout (device) , Self :: GmresLogic => gmres_logic :: create_pipeline_layout (device) , Self :: GmresOps => gmres_ops :: create_pipeline_layout (device) , Self :: LinearSolver => linear_solver :: create_pipeline_layout (device) , Self :: OuterConvergence => outer_convergence :: create_pipeline_layout (device) , Self :: Scalars => scalars :: create_pipeline_layout (device) , Self :: SchurPrecond => schur_precond :: create_pipeline_layout (device) , Self :: SchurPrecondGeneric => schur_precond_generic :: create_pipeline_layout (device) , }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self { Self :: Amg => { amg :: create_shader_module_embed_source (device) } , Self :: AmgPack => { amg_pack :: create_shader_module_embed_source (device) } , Self :: BlockPrecond => { block_precond :: create_shader_module_embed_source (device) } , Self :: DotProduct => { dot_product :: create_shader_module_embed_source (device) } , Self :: DotProductPair => { dot_product_pair :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentum => { generated :: dp_init_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => { generated :: dp_update_from_diag_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleCompressible => { generated :: flux_module_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsCompressible => { generated :: flux_module_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => { generated :: flux_module_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentum => { generated :: flux_module_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledApply => { generated :: generic_coupled_apply :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyCompressible => { generated :: generic_coupled_assembly_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => { generated :: generic_coupled_assembly_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => { generated :: generic_coupled_assembly_grad_state_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => { generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => { generated :: generic_coupled_assembly_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateCompressible => { generated :: generic_coupled_update_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => { generated :: generic_coupled_update_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => { generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => { generated :: generic_coupled_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsCompressible => { generated :: packed_state_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => { generated :: packed_state_gradients_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => { generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => { generated :: packed_state_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum => { generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowGradPUpdateIncompressibleMomentum => { generated :: rhie_chow_grad_p_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowStoreGradPIncompressibleMomentum => { generated :: rhie_chow_store_grad_p_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GenericCoupledSchurSetup => { generic_coupled_schur_setup :: create_shader_module_embed_source (device) } , Self :: GmresCgs => { gmres_cgs :: create_shader_module_embed_source (device) } , Self :: GmresLogic => { gmres_logic :: create_shader_module_embed_source (device) } , Self :: GmresOps => { gmres_ops :: create_shader_module_embed_source (device) } , Self :: LinearSolver => { linear_solver :: create_shader_module_embed_source (device) } , Self :: OuterConvergence => { outer_convergence :: create_shader_module_embed_source (device) } , Self :: Scalars => { scalars :: create_shader_module_embed_source (device) } , Self :: SchurPrecond => { schur_precond :: create_shader_module_embed_source (device) } , Self :: SchurPrecondGeneric => { schur_precond_generic :: create_shader_module_embed_source (device) } , }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const AMG_PACK_PACK_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg_pack::PackParams, num_cells) == 0);
        assert!(std::mem::offset_of!(amg_pack::PackParams, component) == 4);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad1) == 8);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad2) == 12);
        assert!(std::mem::size_of::<amg_pack::PackParams>() == 16);
    };
    const BLOCK_PRECOND_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(block_precond::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(block_precond::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<block_precond::GmresParams>() == 32);
    };
    const BLOCK_PRECOND_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(block_precond::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<block_precond::IterParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 16);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 16);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dtau) == 8
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, time) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(std::mem::size_of::<generated::dp_init_incompressible_momentum::Constants>() == 48);
    };
    const GENERATED_DP_UPDATE_FROM_DIAG_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::dp_update_from_diag_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_module_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_p) == 28
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gamma) == 48
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gm1) == 52
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_p_offset)
                == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::Constants>() == 72);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_LOW_MACH_PARAMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, model) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                theta_floor
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                pressure_coupling_alpha
            ) == 8
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, _pad0) == 12
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::LowMachParams>() == 16);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Vector2, y) == 4
        );
        assert!(std::mem::size_of::<generated::flux_module_gradients_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_gradients_compressible::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_compressible::Constants>() == 48
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Vector2>() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_APPLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, time_scheme) == 44
        );
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gamma) == 48);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gm1) == 52);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_p_offset) == 64
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_theta_ref) == 68
        );
        assert!(std::mem::size_of::<generated::generic_coupled_apply::Constants>() == 72);
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Vector2>() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Constants>()
                == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_grad_state_compressible::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , x) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , y) == 4) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 > () == 8) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_compressible::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Vector2>() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Constants>() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_RHIE_CHOW_CORRECT_VELOCITY_DELTA_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERATED_RHIE_CHOW_GRAD_P_UPDATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_RHIE_CHOW_GRAD_P_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_grad_p_update_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERATED_RHIE_CHOW_STORE_GRAD_P_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_store_grad_p_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::rhie_chow_store_grad_p_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERIC_COUPLED_SCHUR_SETUP_SETUP_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, num_cells) == 0);
        assert!(
            std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, unknowns_per_cell) == 4
        );
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, p) == 8);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u_len) == 12);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u0123) == 16);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u4567) == 32);
        assert!(std::mem::size_of::<generic_coupled_schur_setup::SetupParams>() == 48);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 24);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const OUTER_CONVERGENCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::Params, num_cells) == 0);
        assert!(std::mem::offset_of!(outer_convergence::Params, stride) == 4);
        assert!(std::mem::offset_of!(outer_convergence::Params, num_targets) == 8);
        assert!(std::mem::offset_of!(outer_convergence::Params, _pad0) == 12);
        assert!(std::mem::size_of::<outer_convergence::Params>() == 16);
    };
    const OUTER_CONVERGENCE_TARGET_DESC_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, offsets) == 0);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, num_comps) == 16);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, _pad0) == 20);
        assert!(std::mem::size_of::<outer_convergence::TargetDesc>() == 32);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 24);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, unknowns_per_cell) == 12);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u0) == 16);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u1) == 20);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, p) == 24);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, _pad0) == 28);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 32);
    };
    const SCHUR_PRECOND_GENERIC_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, omega) == 8);
        assert!(
            std::mem::offset_of!(schur_precond_generic::PrecondParams, unknowns_per_cell) == 12
        );
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, p) == 16);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u_len) == 20);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad0) == 24);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad1) == 28);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u0123) == 32);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u4567) == 48);
        assert!(std::mem::size_of::<schur_precond_generic::PrecondParams>() == 64);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.coarse_vec]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let stride_x = (num_workgroups.x * 64u);
    let i = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.n;
    if (i >= _e13) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e24 = k;
        if (_e24 < end) {
        } else {
            break;
        }
        {
            let _e27 = k;
            let col = col_indices[_e27];
            let _e31 = k;
            let val = values[_e31];
            if (col == i) {
                diag = val;
            } else {
                let _e39 = x[col];
                let _e41 = sigma;
                sigma = (_e41 + (val * _e39));
            }
        }
        continuing {
            let _e44 = k;
            k = (_e44 + 1u);
        }
    }
    let _e46 = diag;
    if (abs(_e46) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e53 = b[i];
    let _e54 = sigma;
    let _e56 = diag;
    let x_new = ((_e53 - _e54) / _e56);
    let _e62 = x[i];
    let _e65 = params.omega;
    x[i] = mix(_e62, x_new, _e65);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let i_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.n;
    if (i_1 >= _e12) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e23 = k_1;
        if (_e23 < end_1) {
        } else {
            break;
        }
        {
            let _e26 = k_1;
            let coarse_idx = op_col_indices[_e26];
            let _e30 = k_1;
            let val_1 = op_values[_e30];
            let _e36 = coarse_vec[coarse_idx];
            let _e38 = correction;
            correction = (_e38 + (val_1 * _e36));
        }
        continuing {
            let _e41 = k_1;
            k_1 = (_e41 + 1u);
        }
    }
    let _e45 = correction;
    let _e46 = x[i_1];
    x[i_1] = (_e46 + _e45);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let stride_x_2 = (num_workgroups_2.x * 64u);
    let i_2 = ((global_id_2.y * stride_x_2) + global_id_2.x);
    let _e12 = params.n;
    if (i_2 >= _e12) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e23 = k_2;
        if (_e23 < end_2) {
        } else {
            break;
        }
        {
            let _e26 = k_2;
            let fine_idx = op_col_indices[_e26];
            let _e30 = k_2;
            let r_val = op_values[_e30];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e44 = j;
                if (_e44 < a_end) {
                } else {
                    break;
                }
                {
                    let _e47 = j;
                    let _e49 = values[_e47];
                    let _e52 = j;
                    let _e54 = col_indices[_e52];
                    let _e56 = x[_e54];
                    let _e58 = ax;
                    ax = (_e58 + (_e49 * _e56));
                }
                continuing {
                    let _e61 = j;
                    j = (_e61 + 1u);
                }
            }
            let _e65 = b[fine_idx];
            let _e66 = ax;
            let fine_r = (_e65 - _e66);
            let _e70 = sum;
            sum = (_e70 + (r_val * fine_r));
        }
        continuing {
            let _e73 = k_2;
            k_2 = (_e73 + 1u);
        }
    }
    let _e77 = sum;
    coarse_vec[i_2] = _e77;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let stride_x_3 = (num_workgroups_3.x * 64u);
    let i_3 = ((global_id_3.y * stride_x_3) + global_id_3.x);
    let _e11 = params.n;
    if (i_3 >= _e11) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for amg_pack::PackParams {}
    unsafe impl bytemuck::Pod for amg_pack::PackParams {}
    unsafe impl bytemuck::Zeroable for block_precond::GmresParams {}
    unsafe impl bytemuck::Pod for block_precond::GmresParams {}
    unsafe impl bytemuck::Zeroable for block_precond::IterParams {}
    unsafe impl bytemuck::Pod for block_precond::IterParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::dp_update_from_diag_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::dp_update_from_diag_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_grad_state_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_correct_velocity_delta_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::rhie_chow_grad_p_update_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_grad_p_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_store_grad_p_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::rhie_chow_store_grad_p_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Pod for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for outer_convergence::Params {}
    unsafe impl bytemuck::Pod for outer_convergence::Params {}
    unsafe impl bytemuck::Zeroable for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Pod for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Zeroable for schur_precond_generic::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond_generic::PrecondParams {}
}
pub mod amg_pack {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PackParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub component: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PackParams {
        pub const fn new(num_cells: u32, component: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                num_cells,
                component,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const PACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_pack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline pack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("pack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UNPACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_unpack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline unpack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("unpack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_PACK_COMPONENT: &str = "pack_component";
    pub const ENTRY_UNPACK_COMPONENT: &str = "unpack_component";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input_buf: wgpu::BufferBinding<'a>,
        pub output_buf: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input_buf: wgpu::BindGroupEntry<'a>,
        pub output_buf: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input_buf: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input_buf),
                },
                output_buf: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.output_buf),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.input_buf, self.output_buf]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"output_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg_pack::PackParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AmgPack::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg_pack.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PackParams {
    num_cells: u32,
    component: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> input_buf: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> output_buf: array<f32>;
@group(1) @binding(0) 
var<uniform> params: PackParams;

@compute @workgroup_size(64, 1, 1) 
fn pack_component(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let _e11 = params.num_cells;
    if (idx >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base = ((idx * 4u) + _e17);
    let _e23 = input_buf[base];
    output_buf[idx] = _e23;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn unpack_component(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let stride_x_1 = (num_workgroups_1.x * 64u);
    let idx_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e11 = params.num_cells;
    if (idx_1 >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base_1 = ((idx_1 * 4u) + _e17);
    let _e23 = input_buf[idx_1];
    output_buf[base_1] = _e23;
    return;
}
"#;
}
pub mod block_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const MAX_BLOCK: u32 = 16u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_BLOCK_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_block_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_block_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_block_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_BLOCK_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_block_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_block_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_block_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_BLOCK_INV: &str = "build_block_inv";
    pub const ENTRY_APPLY_BLOCK_PRECOND: &str = "apply_block_precond";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.block_inv]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("BlockPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("block_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const MAX_BLOCK: u32 = 16u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

fn swap_rows(a_1: ptr<function, array<array<f32, 16>, 16>>, b: ptr<function, array<array<f32, 16>, 16>>, r0_: u32, r1_: u32, n: u32) {
    var c_6: u32 = 0u;

    if (r0_ == r1_) {
        return;
    }
    loop {
        let _e6 = c_6;
        if (_e6 < n) {
        } else {
            break;
        }
        {
            let _e10 = c_6;
            let tmp = (*a_1)[r0_][_e10];
            let _e14 = c_6;
            let _e17 = c_6;
            let _e19 = (*a_1)[r1_][_e17];
            (*a_1)[r0_][_e14] = _e19;
            let _e21 = c_6;
            (*a_1)[r1_][_e21] = tmp;
            let _e25 = c_6;
            let tmp_b = (*b)[r0_][_e25];
            let _e29 = c_6;
            let _e32 = c_6;
            let _e34 = (*b)[r1_][_e32];
            (*b)[r0_][_e29] = _e34;
            let _e36 = c_6;
            (*b)[r1_][_e36] = tmp_b;
        }
        continuing {
            let _e38 = c_6;
            c_6 = (_e38 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn build_block_inv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var a: array<array<f32, 16>, 16>;
    var inv: array<array<f32, 16>, 16>;
    var diag_orig: array<f32, 16>;
    var r: u32 = 0u;
    var c: u32;
    var k: u32;
    var singular: bool = false;
    var i: u32 = 0u;
    var pivot: u32;
    var pivot_val: f32;
    var r_1: u32;
    var piv: f32;
    var c_1: u32;
    var r_2: u32;
    var c_2: u32;
    var r_3: u32 = 0u;
    var c_3: u32;
    var r_4: u32 = 0u;
    var c_4: u32;

    let stride_x = (num_workgroups.x * 64u);
    let cell = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.num_cells;
    if (cell >= _e13) {
        return;
    }
    let _e17 = params.num_cells;
    if (_e17 == 0u) {
        return;
    }
    let _e22 = params.n;
    let _e25 = params.num_cells;
    let b_1 = (_e22 / _e25);
    if ((b_1 == 0u) || (b_1 > MAX_BLOCK)) {
        return;
    }
    let base = (cell * b_1);
    loop {
        let _e34 = r;
        if (_e34 < b_1) {
        } else {
            break;
        }
        {
            c = 0u;
            loop {
                let _e38 = c;
                if (_e38 < b_1) {
                } else {
                    break;
                }
                {
                    let _e41 = r;
                    let _e43 = c;
                    a[_e41][_e43] = 0f;
                    let _e47 = r;
                    let _e49 = c;
                    inv[_e47][_e49] = 0f;
                }
                continuing {
                    let _e52 = c;
                    c = (_e52 + 1u);
                }
            }
            let _e55 = r;
            let row = (base + _e55);
            let start = row_offsets[row];
            let end = row_offsets[(row + 1u)];
            k = start;
            loop {
                let _e66 = k;
                if (_e66 < end) {
                } else {
                    break;
                }
                {
                    let _e69 = k;
                    let col = col_indices[_e69];
                    if ((col >= base) && (col < (base + b_1))) {
                        let local = (col - base);
                        let _e77 = r;
                        let _e81 = k;
                        let _e83 = matrix_values[_e81];
                        a[_e77][local] = _e83;
                    }
                }
                continuing {
                    let _e84 = k;
                    k = (_e84 + 1u);
                }
            }
            let _e87 = r;
            let _e89 = r;
            inv[_e87][_e89] = 1f;
            let _e93 = r;
            let _e95 = r;
            let _e97 = r;
            let _e99 = a[_e95][_e97];
            diag_orig[_e93] = _e99;
        }
        continuing {
            let _e100 = r;
            r = (_e100 + 1u);
        }
    }
    loop {
        let _e104 = i;
        if (_e104 < b_1) {
        } else {
            break;
        }
        {
            let _e106 = i;
            pivot = _e106;
            let _e108 = i;
            let _e110 = i;
            let _e112 = a[_e108][_e110];
            pivot_val = abs(_e112);
            let _e115 = i;
            r_1 = (_e115 + 1u);
            loop {
                let _e119 = r_1;
                if (_e119 < b_1) {
                } else {
                    break;
                }
                {
                    let _e121 = r_1;
                    let _e123 = i;
                    let _e125 = a[_e121][_e123];
                    let val_1 = abs(_e125);
                    let _e127 = pivot_val;
                    if (val_1 > _e127) {
                        pivot_val = val_1;
                        let _e129 = r_1;
                        pivot = _e129;
                    }
                }
                continuing {
                    let _e130 = r_1;
                    r_1 = (_e130 + 1u);
                }
            }
            let _e133 = pivot_val;
            if (_e133 < 0.000000000001f) {
                singular = true;
            }
            let _e138 = i;
            let _e139 = pivot;
            swap_rows((&a), (&inv), _e138, _e139, b_1);
            let _e140 = i;
            let _e142 = i;
            let _e144 = a[_e140][_e142];
            piv = _e144;
            let _e146 = piv;
            if (abs(_e146) < 0.000000000001f) {
                let _e150 = piv;
                piv = select(0.000000000001f, -0.000000000001f, (_e150 < 0f));
            }
            let _e156 = piv;
            let inv_piv = (1f / _e156);
            c_1 = 0u;
            loop {
                let _e161 = c_1;
                if (_e161 < b_1) {
                } else {
                    break;
                }
                {
                    let _e163 = i;
                    let _e165 = c_1;
                    let _e167 = i;
                    let _e169 = c_1;
                    let _e171 = a[_e167][_e169];
                    a[_e163][_e165] = (_e171 * inv_piv);
                    let _e173 = i;
                    let _e175 = c_1;
                    let _e177 = i;
                    let _e179 = c_1;
                    let _e181 = inv[_e177][_e179];
                    inv[_e173][_e175] = (_e181 * inv_piv);
                }
                continuing {
                    let _e183 = c_1;
                    c_1 = (_e183 + 1u);
                }
            }
            r_2 = 0u;
            loop {
                let _e188 = r_2;
                if (_e188 < b_1) {
                } else {
                    break;
                }
                {
                    let _e190 = r_2;
                    let _e191 = i;
                    if (_e190 == _e191) {
                        continue;
                    }
                    let _e193 = r_2;
                    let _e195 = i;
                    let factor = a[_e193][_e195];
                    c_2 = 0u;
                    loop {
                        let _e200 = c_2;
                        if (_e200 < b_1) {
                        } else {
                            break;
                        }
                        {
                            let _e202 = r_2;
                            let _e204 = c_2;
                            let _e206 = r_2;
                            let _e208 = c_2;
                            let _e210 = a[_e206][_e208];
                            let _e211 = i;
                            let _e213 = c_2;
                            let _e215 = a[_e211][_e213];
                            a[_e202][_e204] = (_e210 - (factor * _e215));
                            let _e218 = r_2;
                            let _e220 = c_2;
                            let _e222 = r_2;
                            let _e224 = c_2;
                            let _e226 = inv[_e222][_e224];
                            let _e227 = i;
                            let _e229 = c_2;
                            let _e231 = inv[_e227][_e229];
                            inv[_e218][_e220] = (_e226 - (factor * _e231));
                        }
                        continuing {
                            let _e234 = c_2;
                            c_2 = (_e234 + 1u);
                        }
                    }
                }
                continuing {
                    let _e237 = r_2;
                    r_2 = (_e237 + 1u);
                }
            }
        }
        continuing {
            let _e240 = i;
            i = (_e240 + 1u);
        }
    }
    let _e243 = singular;
    if _e243 {
        loop {
            let _e245 = r_3;
            if (_e245 < b_1) {
            } else {
                break;
            }
            {
                c_3 = 0u;
                loop {
                    let _e249 = c_3;
                    if (_e249 < b_1) {
                    } else {
                        break;
                    }
                    {
                        let _e251 = r_3;
                        let _e253 = c_3;
                        inv[_e251][_e253] = 0f;
                    }
                    continuing {
                        let _e256 = c_3;
                        c_3 = (_e256 + 1u);
                    }
                }
                let _e259 = r_3;
                let _e261 = r_3;
                let _e263 = r_3;
                let _e265 = diag_orig[_e263];
                let _e266 = safe_inverse(_e265);
                inv[_e259][_e261] = _e266;
            }
            continuing {
                let _e267 = r_3;
                r_3 = (_e267 + 1u);
            }
        }
    }
    let offset = (cell * (b_1 * b_1));
    loop {
        let _e273 = r_4;
        if (_e273 < b_1) {
        } else {
            break;
        }
        {
            c_4 = 0u;
            loop {
                let _e277 = c_4;
                if (_e277 < b_1) {
                } else {
                    break;
                }
                {
                    let _e280 = r_4;
                    let _e283 = c_4;
                    let _e286 = r_4;
                    let _e288 = c_4;
                    let _e290 = inv[_e286][_e288];
                    block_inv[((offset + (_e280 * b_1)) + _e283)] = _e290;
                }
                continuing {
                    let _e291 = c_4;
                    c_4 = (_e291 + 1u);
                }
            }
        }
        continuing {
            let _e294 = r_4;
            r_4 = (_e294 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_block_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var r_5: u32 = 0u;
    var sum: f32;
    var c_5: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let cell_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.num_cells;
    if (cell_1 >= _e12) {
        return;
    }
    let _e16 = params.num_cells;
    if (_e16 == 0u) {
        return;
    }
    let _e21 = params.n;
    let _e24 = params.num_cells;
    let b_2 = (_e21 / _e24);
    if ((b_2 == 0u) || (b_2 > MAX_BLOCK)) {
        return;
    }
    let base_1 = (cell_1 * b_2);
    let offset_1 = (cell_1 * (b_2 * b_2));
    loop {
        let _e35 = r_5;
        if (_e35 < b_2) {
        } else {
            break;
        }
        {
            sum = 0f;
            c_5 = 0u;
            loop {
                let _e41 = c_5;
                if (_e41 < b_2) {
                } else {
                    break;
                }
                {
                    let _e44 = r_5;
                    let _e47 = c_5;
                    let _e50 = block_inv[((offset_1 + (_e44 * b_2)) + _e47)];
                    let _e52 = c_5;
                    let _e55 = vec_x[(base_1 + _e52)];
                    let _e57 = sum;
                    sum = (_e57 + (_e50 * _e55));
                }
                continuing {
                    let _e59 = c_5;
                    c_5 = (_e59 + 1u);
                }
            }
            let _e63 = r_5;
            let _e66 = sum;
            vec_y[(base_1 + _e63)] = _e66;
        }
        continuing {
            let _e67 = r_5;
            r_5 = (_e67 + 1u);
        }
    }
    return;
}
"#;
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a[idx];
        let _e22 = dot_b[idx];
        val = (_e19 * _e22);
    }
    let _e27 = val;
    scratch[lid] = _e27;
    workgroupBarrier();
    loop {
        let _e29 = i;
        if (_e29 > 0u) {
        } else {
            break;
        }
        {
            let _e32 = i;
            if (lid < _e32) {
                let _e37 = i;
                let _e40 = scratch[(lid + _e37)];
                let _e41 = scratch[lid];
                scratch[lid] = (_e41 + _e40);
            }
            workgroupBarrier();
        }
        continuing {
            let _e44 = i;
            i = (_e44 >> 1u);
        }
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e56 = params.num_groups;
        if (group_flat < _e56) {
            let _e62 = scratch[0];
            dot_result[group_flat] = _e62;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a0_[idx];
        let _e22 = dot_b0_[idx];
        val0_ = (_e19 * _e22);
        let _e27 = dot_a1_[idx];
        let _e30 = dot_b1_[idx];
        val1_ = (_e27 * _e30);
    }
    let _e35 = val0_;
    scratch_a[lid] = _e35;
    let _e38 = val1_;
    scratch_b[lid] = _e38;
    workgroupBarrier();
    loop {
        let _e40 = offset;
        if (lid < _e40) {
            let _e45 = offset;
            let _e48 = scratch_a[(lid + _e45)];
            let _e49 = scratch_a[lid];
            scratch_a[lid] = (_e49 + _e48);
            let _e54 = offset;
            let _e57 = scratch_b[(lid + _e54)];
            let _e58 = scratch_b[lid];
            scratch_b[lid] = (_e58 + _e57);
        }
        workgroupBarrier();
        let _e60 = offset;
        if (_e60 == 1u) {
            break;
        }
        let _e63 = offset;
        offset = (_e63 >> 1u);
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e76 = params.num_groups;
        if (group_flat < _e76) {
            let _e82 = scratch_a[0];
            dot_result_a[group_flat] = _e82;
            let _e87 = scratch_b[0];
            dot_result_b[group_flat] = _e87;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod dp_init_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedDpInitIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::dp_init_incompressible_momentum::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = cell_vols[idx];
    let vol = max(_e25, 0.000000000001f);
    let _e30 = constants.alpha_u;
    let d_p = ((_e30 * dt) / rho);
    state[((idx * 8u) + 3u)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: dp_update_from_diag_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = constants.alpha_u;
    let d_p = ((_e25 * dt) / rho);
    state[((idx * 8u) + 3u)] = d_p;
    return;
}
"#;
    }
    pub mod flux_module_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct LowMachParams {
            #[doc = "offset: 0, size: 4, type: `u32`"]
            pub model: u32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub theta_floor: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub pressure_coupling_alpha: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub _pad0: f32,
        }
        impl LowMachParams {
            pub const fn new(
                model: u32,
                theta_floor: f32,
                pressure_coupling_alpha: f32,
                _pad0: f32,
            ) -> Self {
                Self {
                    model,
                    theta_floor,
                    pressure_coupling_alpha,
                    _pad0,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub low_mach_params: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub low_mach_params: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    low_mach_params: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.low_mach_params),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.low_mach_params,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"low_mach_params\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::LowMachParams,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0_: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var a_plus: f32;
    var a_minus: f32;
    var u_l_0_: f32;
    var u_r_0_: f32;
    var f_l_0_: f32;
    var f_r_0_: f32;
    var u_l_1_: f32;
    var u_r_1_: f32;
    var f_l_1_: f32;
    var f_r_1_: f32;
    var u_l_2_: f32;
    var u_r_2_: f32;
    var f_l_2_: f32;
    var f_r_2_: f32;
    var u_l_3_: f32;
    var u_r_3_: f32;
    var f_l_3_: f32;
    var f_r_3_: f32;
    var u_l_4_: f32 = 0f;
    var u_r_4_: f32 = 0f;
    var f_l_4_: f32 = 0f;
    var f_r_4_: f32 = 0f;
    var u_l_5_: f32 = 0f;
    var u_r_5_: f32 = 0f;
    var f_l_5_: f32 = 0f;
    var f_r_5_: f32 = 0f;
    var u_l_6_: f32 = 0f;
    var u_r_6_: f32 = 0f;
    var f_l_6_: f32 = 0f;
    var f_r_6_: f32 = 0f;
    var u_l_7_: f32 = 0f;
    var u_r_7_: f32 = 0f;
    var f_l_7_: f32 = 0f;
    var f_r_7_: f32 = 0f;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e37 = face_normals[idx].x;
    let _e41 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e37, _e41);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e54 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e54) < 0f) {
        let _e58 = normal_vec;
        normal_vec = -(_e58);
    }
    let _e61 = neigh_idx;
    let c_neigh = cell_centers[_e61];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let _e70 = normal_vec;
    let d_own_1 = abs(dot((face_center_vec - c_owner_vec), _e70));
    let _e73 = c_neigh_vec;
    let _e75 = normal_vec;
    let d_neigh = abs(dot((_e73 - face_center_vec), _e75));
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e83 = lambda;
    let lambda_other = (1f - _e83);
    let _e86 = c_neigh_vec;
    let d_vec = (_e86 - c_owner_vec);
    let _e88 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e88));
    let dist = max(dist_proj, 0.000001f);
    let _e99 = state[((owner_1 * 22u) + 9u)];
    let _e106 = state[((owner_1 * 22u) + 9u)];
    let _e113 = bc_kind[((idx * 8u) + 7u)];
    let _e120 = bc_value[((idx * 8u) + 7u)];
    let _e121 = bc_neighbor_scalar(_e99, _e106, _e113, _e120, d_own_1, is_boundary_1);
    let s_own_grad_T_x = state[((owner_1 * 22u) + 16u)];
    let s_own_grad_T_y = state[((owner_1 * 22u) + 17u)];
    let s_own_grad_rho_x = state[((owner_1 * 22u) + 12u)];
    let s_own_grad_rho_y = state[((owner_1 * 22u) + 13u)];
    let s_own_grad_rho_u_x_x = state[((owner_1 * 22u) + 3u)];
    let s_own_grad_rho_u_x_y = state[((owner_1 * 22u) + 4u)];
    let s_own_grad_rho_u_y_x = state[((owner_1 * 22u) + 5u)];
    let s_own_grad_rho_u_y_y = state[((owner_1 * 22u) + 6u)];
    let s_own_grad_u_x_x = state[((owner_1 * 22u) + 18u)];
    let s_own_grad_u_x_y = state[((owner_1 * 22u) + 19u)];
    let s_own_grad_u_y_x = state[((owner_1 * 22u) + 20u)];
    let s_own_grad_u_y_y = state[((owner_1 * 22u) + 21u)];
    let _e212 = state[((owner_1 * 22u) + 0u)];
    let _e219 = state[((owner_1 * 22u) + 0u)];
    let _e226 = bc_kind[((idx * 8u) + 0u)];
    let _e233 = bc_value[((idx * 8u) + 0u)];
    let _e234 = bc_neighbor_scalar(_e212, _e219, _e226, _e233, d_own_1, is_boundary_1);
    let _e241 = state[((owner_1 * 22u) + 1u)];
    let _e248 = state[((owner_1 * 22u) + 1u)];
    let _e255 = bc_kind[((idx * 8u) + 1u)];
    let _e262 = bc_value[((idx * 8u) + 1u)];
    let _e263 = bc_neighbor_scalar(_e241, _e248, _e255, _e262, d_own_1, is_boundary_1);
    let _e270 = state[((owner_1 * 22u) + 1u)];
    let _e277 = state[((owner_1 * 22u) + 1u)];
    let _e279 = normal_vec.x;
    let _e287 = state[((owner_1 * 22u) + 2u)];
    let _e289 = normal_vec.y;
    let _e293 = normal_vec.x;
    let _cse_1850_ = select(_e263, (_e270 - (((_e277 * _e279) + (_e287 * _e289)) * _e293)), (is_boundary_1 && (boundary_type == 4u)));
    let _e306 = state[((owner_1 * 22u) + 2u)];
    let _e313 = state[((owner_1 * 22u) + 2u)];
    let _e320 = bc_kind[((idx * 8u) + 2u)];
    let _e327 = bc_value[((idx * 8u) + 2u)];
    let _e328 = bc_neighbor_scalar(_e306, _e313, _e320, _e327, d_own_1, is_boundary_1);
    let _e335 = state[((owner_1 * 22u) + 2u)];
    let _e342 = state[((owner_1 * 22u) + 1u)];
    let _e344 = normal_vec.x;
    let _e352 = state[((owner_1 * 22u) + 2u)];
    let _e354 = normal_vec.y;
    let _e358 = normal_vec.y;
    let _cse_1860_ = select(_e328, (_e335 - (((_e342 * _e344) + (_e352 * _e354)) * _e358)), (is_boundary_1 && (boundary_type == 4u)));
    let _e365 = neigh_idx;
    let _e372 = state[((_e365 * 22u) + 9u)];
    let _e379 = state[((owner_1 * 22u) + 9u)];
    let _e386 = bc_kind[((idx * 8u) + 7u)];
    let _e393 = bc_value[((idx * 8u) + 7u)];
    let _e394 = bc_neighbor_scalar(_e372, _e379, _e386, _e393, d_own_1, is_boundary_1);
    let _e395 = neigh_idx;
    let _e402 = state[((_e395 * 22u) + 16u)];
    let _e409 = state[((owner_1 * 22u) + 16u)];
    let s_neigh_grad_T_x = select(_e402, _e409, is_boundary_1);
    let _e411 = neigh_idx;
    let _e418 = state[((_e411 * 22u) + 17u)];
    let _e425 = state[((owner_1 * 22u) + 17u)];
    let s_neigh_grad_T_y = select(_e418, _e425, is_boundary_1);
    let _e427 = neigh_idx;
    let _e434 = state[((_e427 * 22u) + 12u)];
    let _e441 = state[((owner_1 * 22u) + 12u)];
    let s_neigh_grad_rho_x = select(_e434, _e441, is_boundary_1);
    let _e443 = neigh_idx;
    let _e450 = state[((_e443 * 22u) + 13u)];
    let _e457 = state[((owner_1 * 22u) + 13u)];
    let s_neigh_grad_rho_y = select(_e450, _e457, is_boundary_1);
    let _e459 = neigh_idx;
    let _e466 = state[((_e459 * 22u) + 3u)];
    let _e473 = state[((owner_1 * 22u) + 3u)];
    let s_neigh_grad_rho_u_x_x = select(_e466, _e473, is_boundary_1);
    let _e475 = neigh_idx;
    let _e482 = state[((_e475 * 22u) + 4u)];
    let _e489 = state[((owner_1 * 22u) + 4u)];
    let s_neigh_grad_rho_u_x_y = select(_e482, _e489, is_boundary_1);
    let _e491 = neigh_idx;
    let _e498 = state[((_e491 * 22u) + 5u)];
    let _e505 = state[((owner_1 * 22u) + 5u)];
    let s_neigh_grad_rho_u_y_x = select(_e498, _e505, is_boundary_1);
    let _e507 = neigh_idx;
    let _e514 = state[((_e507 * 22u) + 6u)];
    let _e521 = state[((owner_1 * 22u) + 6u)];
    let s_neigh_grad_rho_u_y_y = select(_e514, _e521, is_boundary_1);
    let _e523 = neigh_idx;
    let _e530 = state[((_e523 * 22u) + 18u)];
    let _e537 = state[((owner_1 * 22u) + 18u)];
    let s_neigh_grad_u_x_x = select(_e530, _e537, is_boundary_1);
    let _e539 = neigh_idx;
    let _e546 = state[((_e539 * 22u) + 19u)];
    let _e553 = state[((owner_1 * 22u) + 19u)];
    let s_neigh_grad_u_x_y = select(_e546, _e553, is_boundary_1);
    let _e555 = neigh_idx;
    let _e562 = state[((_e555 * 22u) + 20u)];
    let _e569 = state[((owner_1 * 22u) + 20u)];
    let s_neigh_grad_u_y_x = select(_e562, _e569, is_boundary_1);
    let _e571 = neigh_idx;
    let _e578 = state[((_e571 * 22u) + 21u)];
    let _e585 = state[((owner_1 * 22u) + 21u)];
    let s_neigh_grad_u_y_y = select(_e578, _e585, is_boundary_1);
    let _e587 = neigh_idx;
    let _e594 = state[((_e587 * 22u) + 0u)];
    let _e601 = state[((owner_1 * 22u) + 0u)];
    let _e608 = bc_kind[((idx * 8u) + 0u)];
    let _e615 = bc_value[((idx * 8u) + 0u)];
    let _e616 = bc_neighbor_scalar(_e594, _e601, _e608, _e615, d_own_1, is_boundary_1);
    let _e617 = neigh_idx;
    let _e624 = state[((_e617 * 22u) + 1u)];
    let _e631 = state[((owner_1 * 22u) + 1u)];
    let _e638 = bc_kind[((idx * 8u) + 1u)];
    let _e645 = bc_value[((idx * 8u) + 1u)];
    let _e646 = bc_neighbor_scalar(_e624, _e631, _e638, _e645, d_own_1, is_boundary_1);
    let _e653 = state[((owner_1 * 22u) + 1u)];
    let _e660 = state[((owner_1 * 22u) + 1u)];
    let _e662 = normal_vec.x;
    let _e670 = state[((owner_1 * 22u) + 2u)];
    let _e672 = normal_vec.y;
    let _e676 = normal_vec.x;
    let _cse_1856_ = select(_e646, (_e653 - (((_e660 * _e662) + (_e670 * _e672)) * _e676)), (is_boundary_1 && (boundary_type == 4u)));
    let _e683 = neigh_idx;
    let _e690 = state[((_e683 * 22u) + 2u)];
    let _e697 = state[((owner_1 * 22u) + 2u)];
    let _e704 = bc_kind[((idx * 8u) + 2u)];
    let _e711 = bc_value[((idx * 8u) + 2u)];
    let _e712 = bc_neighbor_scalar(_e690, _e697, _e704, _e711, d_own_1, is_boundary_1);
    let _e719 = state[((owner_1 * 22u) + 2u)];
    let _e726 = state[((owner_1 * 22u) + 1u)];
    let _e728 = normal_vec.x;
    let _e736 = state[((owner_1 * 22u) + 2u)];
    let _e738 = normal_vec.y;
    let _e742 = normal_vec.y;
    let _cse_1866_ = select(_e712, (_e719 - (((_e726 * _e728) + (_e736 * _e738)) * _e742)), (is_boundary_1 && (boundary_type == 4u)));
    let _cse_2_ = vec2<f32>(_cse_1850_, _cse_1860_);
    let _cse_1_ = ((_cse_2_ * 1f) / vec2(_e234));
    let _e754 = normal_vec;
    let _cse_0_ = dot(_cse_1_, _e754);
    let _e758 = low_mach_params.model;
    let _cse_12_ = (f32(_e758) - 2f);
    let _cse_11_ = abs(_cse_12_);
    let _cse_10_ = (1f - _cse_11_);
    let _cse_9_ = max(0f, _cse_10_);
    let _e769 = constants.eos_r;
    let _cse_16_ = ((_e234 * _e769) * _e121);
    let _e774 = constants.eos_gamma;
    let _cse_15_ = (_e774 * _cse_16_);
    let _cse_14_ = (_cse_15_ / _e234);
    let _e779 = constants.eos_dp_drho;
    let _cse_13_ = (_cse_14_ + _e779);
    let _cse_8_ = (_cse_9_ * _cse_13_);
    let _e784 = low_mach_params.model;
    let _cse_21_ = f32(_e784);
    let _cse_20_ = abs(_cse_21_);
    let _cse_19_ = (1f - _cse_20_);
    let _cse_18_ = max(0f, _cse_19_);
    let _cse_23_ = (_cse_0_ * _cse_0_);
    let _cse_22_ = min(_cse_23_, _cse_13_);
    let _cse_17_ = (_cse_18_ * _cse_22_);
    let _cse_7_ = (_cse_8_ + _cse_17_);
    let _e797 = low_mach_params.model;
    let _cse_28_ = (f32(_e797) - 1f);
    let _cse_27_ = abs(_cse_28_);
    let _cse_26_ = (1f - _cse_27_);
    let _cse_25_ = max(0f, _cse_26_);
    let _e808 = low_mach_params.theta_floor;
    let _cse_31_ = (_e808 * _cse_13_);
    let _cse_30_ = max(_cse_23_, _cse_31_);
    let _cse_29_ = min(_cse_30_, _cse_13_);
    let _cse_24_ = (_cse_25_ * _cse_29_);
    let _cse_6_ = (_cse_7_ + _cse_24_);
    let _cse_5_ = sqrt(_cse_6_);
    let _cse_34_ = vec2<f32>(_cse_1856_, _cse_1866_);
    let _cse_33_ = ((_cse_34_ * 1f) / vec2(_e616));
    let _e820 = normal_vec;
    let _cse_32_ = dot(_cse_33_, _e820);
    let _e824 = constants.eos_r;
    let _cse_44_ = ((_e616 * _e824) * _e394);
    let _e829 = constants.eos_gamma;
    let _cse_43_ = (_e829 * _cse_44_);
    let _cse_42_ = (_cse_43_ / _e616);
    let _e834 = constants.eos_dp_drho;
    let _cse_41_ = (_cse_42_ + _e834);
    let _cse_40_ = (_cse_9_ * _cse_41_);
    let _cse_47_ = (_cse_32_ * _cse_32_);
    let _cse_46_ = min(_cse_47_, _cse_41_);
    let _cse_45_ = (_cse_18_ * _cse_46_);
    let _cse_39_ = (_cse_40_ + _cse_45_);
    let _e843 = low_mach_params.theta_floor;
    let _cse_51_ = (_e843 * _cse_41_);
    let _cse_50_ = max(_cse_47_, _cse_51_);
    let _cse_49_ = min(_cse_50_, _cse_41_);
    let _cse_48_ = (_cse_25_ * _cse_49_);
    let _cse_38_ = (_cse_39_ + _cse_48_);
    let _cse_37_ = sqrt(_cse_38_);
    a_plus = max(0f, max((_cse_0_ + _cse_5_), (_cse_32_ + _cse_37_)));
    a_minus = min(0f, min((_cse_0_ - _cse_5_), (_cse_32_ - _cse_37_)));
    let _e864 = constants.scheme;
    if ((_e864 == 1u) && !(is_boundary_1)) {
        let _cse_57_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_55_ = (_cse_1850_ + _cse_57_);
        let _cse_60_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_58_ = (_cse_1860_ + _cse_60_);
        let _cse_54_ = vec2<f32>(_cse_55_, _cse_58_);
        let _cse_63_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_62_ = (_e234 + _cse_63_);
        let _cse_61_ = (1f / _cse_62_);
        let _cse_53_ = (_cse_54_ * _cse_61_);
        let _e885 = normal_vec;
        let _cse_52_ = dot(_cse_53_, _e885);
        let _e889 = constants.eos_r;
        let _cse_72_ = (_cse_62_ * _e889);
        let _cse_74_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_73_ = (_e121 + _cse_74_);
        let _cse_71_ = (_cse_72_ * _cse_73_);
        let _e898 = constants.eos_gamma;
        let _cse_70_ = (_e898 * _cse_71_);
        let _cse_69_ = (_cse_70_ / _cse_62_);
        let _e903 = constants.eos_dp_drho;
        let _cse_68_ = (_cse_69_ + _e903);
        let _e907 = low_mach_params.model;
        let _cse_67_ = (max(0f, (1f - abs((f32(_e907) - 2f)))) * _cse_68_);
        let _cse_77_ = (_cse_52_ * _cse_52_);
        let _cse_76_ = min(_cse_77_, _cse_68_);
        let _e921 = low_mach_params.model;
        let _cse_75_ = (max(0f, (1f - abs(f32(_e921)))) * _cse_76_);
        let _cse_66_ = (_cse_67_ + _cse_75_);
        let _e932 = low_mach_params.theta_floor;
        let _cse_81_ = (_e932 * _cse_68_);
        let _cse_80_ = max(_cse_77_, _cse_81_);
        let _cse_79_ = min(_cse_80_, _cse_68_);
        let _e938 = low_mach_params.model;
        let _cse_78_ = (max(0f, (1f - abs((f32(_e938) - 1f)))) * _cse_79_);
        let _cse_65_ = (_cse_66_ + _cse_78_);
        let _cse_64_ = sqrt(_cse_65_);
        let _cse_88_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_87_ = dot(_cse_88_, (face_center_vec - c_neigh_cell_vec));
        let _cse_85_ = (_cse_1856_ + _cse_87_);
        let _cse_92_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_91_ = dot(_cse_92_, (face_center_vec - c_neigh_cell_vec));
        let _cse_89_ = (_cse_1866_ + _cse_91_);
        let _cse_84_ = vec2<f32>(_cse_85_, _cse_89_);
        let _cse_96_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_95_ = dot(_cse_96_, (face_center_vec - c_neigh_cell_vec));
        let _cse_94_ = (_e616 + _cse_95_);
        let _cse_93_ = (1f / _cse_94_);
        let _cse_83_ = (_cse_84_ * _cse_93_);
        let _e978 = normal_vec;
        let _cse_82_ = dot(_cse_83_, _e978);
        let _e982 = constants.eos_r;
        let _cse_105_ = (_cse_94_ * _e982);
        let _cse_108_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_107_ = dot(_cse_108_, (face_center_vec - c_neigh_cell_vec));
        let _cse_106_ = (_e394 + _cse_107_);
        let _cse_104_ = (_cse_105_ * _cse_106_);
        let _e995 = constants.eos_gamma;
        let _cse_103_ = (_e995 * _cse_104_);
        let _cse_102_ = (_cse_103_ / _cse_94_);
        let _e1000 = constants.eos_dp_drho;
        let _cse_101_ = (_cse_102_ + _e1000);
        let _e1004 = low_mach_params.model;
        let _cse_100_ = (max(0f, (1f - abs((f32(_e1004) - 2f)))) * _cse_101_);
        let _cse_111_ = (_cse_82_ * _cse_82_);
        let _cse_110_ = min(_cse_111_, _cse_101_);
        let _e1018 = low_mach_params.model;
        let _cse_109_ = (max(0f, (1f - abs(f32(_e1018)))) * _cse_110_);
        let _cse_99_ = (_cse_100_ + _cse_109_);
        let _e1029 = low_mach_params.theta_floor;
        let _cse_115_ = (_e1029 * _cse_101_);
        let _cse_114_ = max(_cse_111_, _cse_115_);
        let _cse_113_ = min(_cse_114_, _cse_101_);
        let _e1035 = low_mach_params.model;
        let _cse_112_ = (max(0f, (1f - abs((f32(_e1035) - 1f)))) * _cse_113_);
        let _cse_98_ = (_cse_99_ + _cse_112_);
        let _cse_97_ = sqrt(_cse_98_);
        a_plus = max(0f, max((_cse_52_ + _cse_64_), (_cse_82_ + _cse_97_)));
        a_minus = min(0f, min((_cse_52_ - _cse_64_), (_cse_82_ - _cse_97_)));
    }
    let _e1059 = constants.scheme;
    if ((_e1059 == 2u) && !(is_boundary_1)) {
        let _cse_123_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_122_ = (_cse_123_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_121_ = (_cse_122_ - _cse_1850_);
        let _cse_119_ = (_cse_1850_ + _cse_121_);
        let _cse_129_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_128_ = (_cse_129_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_127_ = (_cse_128_ - _cse_1860_);
        let _cse_125_ = (_cse_1860_ + _cse_127_);
        let _cse_118_ = vec2<f32>(_cse_119_, _cse_125_);
        let _cse_136_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_135_ = (_cse_136_ * 0.125f);
        let _cse_134_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + _cse_135_);
        let _cse_133_ = (_cse_134_ - _e234);
        let _cse_132_ = (_e234 + _cse_133_);
        let _cse_131_ = (1f / _cse_132_);
        let _cse_117_ = (_cse_118_ * _cse_131_);
        let _e1107 = normal_vec;
        let _cse_116_ = dot(_cse_117_, _e1107);
        let _e1111 = constants.eos_r;
        let _cse_143_ = ((_cse_132_ * _e1111) * ((((_e121 + (_e121 * 0.625f)) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121));
        let _e1129 = constants.eos_gamma;
        let _cse_142_ = (_e1129 * _cse_143_);
        let _cse_141_ = (_cse_142_ / _cse_132_);
        let _e1134 = constants.eos_dp_drho;
        let _cse_140_ = (_cse_141_ + _e1134);
        let _cse_146_ = (_cse_116_ * _cse_116_);
        let _cse_145_ = min(_cse_146_, _cse_140_);
        let _e1140 = low_mach_params.model;
        let _cse_144_ = (max(0f, (1f - abs(f32(_e1140)))) * _cse_145_);
        let _e1150 = low_mach_params.model;
        let _cse_139_ = ((max(0f, (1f - abs((f32(_e1150) - 2f)))) * _cse_140_) + _cse_144_);
        let _e1163 = low_mach_params.theta_floor;
        let _cse_149_ = max(_cse_146_, (_e1163 * _cse_140_));
        let _cse_148_ = min(_cse_149_, _cse_140_);
        let _e1169 = low_mach_params.model;
        let _cse_147_ = (max(0f, (1f - abs((f32(_e1169) - 1f)))) * _cse_148_);
        let _cse_138_ = (_cse_139_ + _cse_147_);
        let _cse_137_ = sqrt(_cse_138_);
        let _cse_155_ = (((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_154_ = (_cse_155_ - _cse_1856_);
        let _cse_153_ = (_cse_1856_ + _cse_154_);
        let _cse_158_ = (((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_157_ = (_cse_158_ - _cse_1866_);
        let _cse_156_ = (_cse_1866_ + _cse_157_);
        let _cse_152_ = vec2<f32>(_cse_153_, _cse_156_);
        let _cse_165_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_164_ = dot(_cse_165_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_163_ = (_cse_164_ * 0.125f);
        let _cse_162_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_163_);
        let _cse_161_ = (_cse_162_ - _e616);
        let _cse_160_ = (_e616 + _cse_161_);
        let _cse_159_ = (1f / _cse_160_);
        let _cse_151_ = (_cse_152_ * _cse_159_);
        let _e1236 = normal_vec;
        let _cse_150_ = dot(_cse_151_, _e1236);
        let _e1240 = constants.eos_r;
        let _cse_173_ = (_cse_160_ * _e1240);
        let _cse_172_ = (_cse_173_ * ((((_e394 + (_e394 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394));
        let _e1262 = constants.eos_gamma;
        let _cse_171_ = (_e1262 * _cse_172_);
        let _cse_170_ = (_cse_171_ / _cse_160_);
        let _e1267 = constants.eos_dp_drho;
        let _cse_169_ = (_cse_170_ + _e1267);
        let _cse_176_ = (_cse_150_ * _cse_150_);
        let _cse_175_ = min(_cse_176_, _cse_169_);
        let _e1273 = low_mach_params.model;
        let _cse_174_ = (max(0f, (1f - abs(f32(_e1273)))) * _cse_175_);
        let _e1283 = low_mach_params.model;
        let _cse_168_ = ((max(0f, (1f - abs((f32(_e1283) - 2f)))) * _cse_169_) + _cse_174_);
        let _e1296 = low_mach_params.theta_floor;
        let _cse_179_ = max(_cse_176_, (_e1296 * _cse_169_));
        let _cse_178_ = min(_cse_179_, _cse_169_);
        let _e1302 = low_mach_params.model;
        let _cse_177_ = (max(0f, (1f - abs((f32(_e1302) - 1f)))) * _cse_178_);
        let _cse_167_ = (_cse_168_ + _cse_177_);
        let _cse_166_ = sqrt(_cse_167_);
        a_plus = max(0f, max((_cse_116_ + _cse_137_), (_cse_150_ + _cse_166_)));
        a_minus = min(0f, min((_cse_116_ - _cse_137_), (_cse_150_ - _cse_166_)));
    }
    let _e1326 = constants.scheme;
    if ((_e1326 == 3u) && !(is_boundary_1)) {
        let _cse_187_ = (_cse_1856_ - _cse_1850_);
        let _cse_186_ = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), min(_cse_187_, 0f));
        let _cse_185_ = min(_cse_186_, max(_cse_187_, 0f));
        let _cse_183_ = (_cse_1850_ + _cse_185_);
        let _cse_193_ = (_cse_1866_ - _cse_1860_);
        let _cse_192_ = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), min(_cse_193_, 0f));
        let _cse_191_ = min(_cse_192_, max(_cse_193_, 0f));
        let _cse_189_ = (_cse_1860_ + _cse_191_);
        let _cse_182_ = vec2<f32>(_cse_183_, _cse_189_);
        let _cse_198_ = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e616 - _e234), 0f));
        let _cse_197_ = min(_cse_198_, max((_e616 - _e234), 0f));
        let _cse_196_ = (_e234 + _cse_197_);
        let _cse_195_ = (1f / _cse_196_);
        let _cse_181_ = (_cse_182_ * _cse_195_);
        let _e1369 = normal_vec;
        let _cse_180_ = dot(_cse_181_, _e1369);
        let _e1373 = constants.eos_r;
        let _cse_205_ = ((_cse_196_ * _e1373) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f))));
        let _e1390 = constants.eos_gamma;
        let _cse_204_ = (_e1390 * _cse_205_);
        let _cse_203_ = (_cse_204_ / _cse_196_);
        let _e1395 = constants.eos_dp_drho;
        let _cse_202_ = (_cse_203_ + _e1395);
        let _cse_208_ = (_cse_180_ * _cse_180_);
        let _cse_207_ = min(_cse_208_, _cse_202_);
        let _e1401 = low_mach_params.model;
        let _cse_206_ = (max(0f, (1f - abs(f32(_e1401)))) * _cse_207_);
        let _e1411 = low_mach_params.model;
        let _cse_201_ = ((max(0f, (1f - abs((f32(_e1411) - 2f)))) * _cse_202_) + _cse_206_);
        let _e1424 = low_mach_params.theta_floor;
        let _cse_211_ = max(_cse_208_, (_e1424 * _cse_202_));
        let _cse_210_ = min(_cse_211_, _cse_202_);
        let _e1430 = low_mach_params.model;
        let _cse_209_ = (max(0f, (1f - abs((f32(_e1430) - 1f)))) * _cse_210_);
        let _cse_200_ = (_cse_201_ + _cse_209_);
        let _cse_199_ = sqrt(_cse_200_);
        let _cse_218_ = (_cse_1850_ - _cse_1856_);
        let _cse_217_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_218_, 0f));
        let _cse_216_ = min(_cse_217_, max(_cse_218_, 0f));
        let _cse_215_ = (_cse_1856_ + _cse_216_);
        let _cse_222_ = (_cse_1860_ - _cse_1866_);
        let _cse_221_ = max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_222_, 0f));
        let _cse_220_ = min(_cse_221_, max(_cse_222_, 0f));
        let _cse_219_ = (_cse_1866_ + _cse_220_);
        let _cse_214_ = vec2<f32>(_cse_215_, _cse_219_);
        let _cse_228_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_227_ = dot(_cse_228_, (face_center_vec - c_neigh_cell_vec));
        let _cse_226_ = max(_cse_227_, min((_e234 - _e616), 0f));
        let _cse_225_ = min(_cse_226_, max((_e234 - _e616), 0f));
        let _cse_224_ = (_e616 + _cse_225_);
        let _cse_223_ = (1f / _cse_224_);
        let _cse_213_ = (_cse_214_ * _cse_223_);
        let _e1492 = normal_vec;
        let _cse_212_ = dot(_cse_213_, _e1492);
        let _e1496 = constants.eos_r;
        let _cse_236_ = (_cse_224_ * _e1496);
        let _cse_237_ = (_e394 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f)));
        let _cse_235_ = (_cse_236_ * _cse_237_);
        let _e1517 = constants.eos_gamma;
        let _cse_234_ = (_e1517 * _cse_235_);
        let _cse_233_ = (_cse_234_ / _cse_224_);
        let _e1522 = constants.eos_dp_drho;
        let _cse_232_ = (_cse_233_ + _e1522);
        let _cse_240_ = (_cse_212_ * _cse_212_);
        let _cse_239_ = min(_cse_240_, _cse_232_);
        let _e1528 = low_mach_params.model;
        let _cse_238_ = (max(0f, (1f - abs(f32(_e1528)))) * _cse_239_);
        let _e1538 = low_mach_params.model;
        let _cse_231_ = ((max(0f, (1f - abs((f32(_e1538) - 2f)))) * _cse_232_) + _cse_238_);
        let _e1551 = low_mach_params.theta_floor;
        let _cse_243_ = max(_cse_240_, (_e1551 * _cse_232_));
        let _cse_242_ = min(_cse_243_, _cse_232_);
        let _e1557 = low_mach_params.model;
        let _cse_241_ = (max(0f, (1f - abs((f32(_e1557) - 1f)))) * _cse_242_);
        let _cse_230_ = (_cse_231_ + _cse_241_);
        let _cse_229_ = sqrt(_cse_230_);
        a_plus = max(0f, max((_cse_180_ + _cse_199_), (_cse_212_ + _cse_229_)));
        a_minus = min(0f, min((_cse_180_ - _cse_199_), (_cse_212_ - _cse_229_)));
    }
    let _e1581 = constants.scheme;
    if ((_e1581 == 4u) && !(is_boundary_1)) {
        let _cse_248_ = (vec2<f32>(_cse_1856_, _cse_1866_) - vec2<f32>(_cse_1850_, _cse_1860_));
        let _cse_257_ = dot(_cse_248_, _cse_248_);
        let _cse_259_ = (_cse_257_ * _cse_257_);
        let _cse_258_ = (_cse_259_ + 0.000000000000000000000000000001f);
        let _cse_256_ = ((dot(_cse_248_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_257_) / _cse_258_);
        let _cse_255_ = (2f * _cse_256_);
        let _cse_254_ = (_cse_255_ - 1f);
        let _cse_253_ = min(_cse_254_, 1999f);
        let _cse_252_ = max(-2001f, _cse_253_);
        let _cse_260_ = abs(_cse_252_);
        let _cse_251_ = (_cse_252_ + _cse_260_);
        let _cse_250_ = (_cse_251_ / (1f + _cse_260_));
        let _cse_249_ = (_cse_250_ * lambda_other);
        let _cse_247_ = (_cse_248_ * _cse_249_);
        let _cse_246_ = (vec2<f32>(_cse_1850_, _cse_1860_) + _cse_247_);
        let _cse_267_ = ((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y))) * (_e616 - _e234)) / (((_e616 - _e234) * (_e616 - _e234)) + 0.000000000000000000000000000001f)) - 1f);
        let _cse_266_ = min(_cse_267_, 1999f);
        let _cse_265_ = max(-2001f, _cse_266_);
        let _cse_264_ = ((_cse_265_ + abs(_cse_265_)) / (1f + abs(_cse_265_)));
        let _cse_263_ = (_cse_264_ * lambda_other);
        let _cse_262_ = (_cse_263_ * (_e616 - _e234));
        let _cse_261_ = (_e234 + _cse_262_);
        let _cse_245_ = ((_cse_246_ * 1f) / vec2(_cse_261_));
        let _e1653 = normal_vec;
        let _cse_244_ = dot(_cse_245_, _e1653);
        let _e1657 = constants.eos_gamma;
        let _e1661 = constants.eos_r;
        let _cse_271_ = ((((_e1657 * _cse_261_) * _e1661) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e394 - _e121)))) / _cse_261_);
        let _e1734 = constants.eos_dp_drho;
        let _cse_270_ = (_cse_271_ + _e1734);
        let _cse_272_ = (_cse_244_ * _cse_244_);
        let _e1739 = low_mach_params.model;
        let _e1751 = low_mach_params.model;
        let _e1763 = low_mach_params.model;
        let _e1774 = low_mach_params.theta_floor;
        let _cse_269_ = (((max(0f, (1f - abs((f32(_e1739) - 2f)))) * _cse_270_) + (max(0f, (1f - abs(f32(_e1751)))) * min(_cse_272_, _cse_270_))) + (max(0f, (1f - abs((f32(_e1763) - 1f)))) * min(max(_cse_272_, (_e1774 * _cse_270_)), _cse_270_)));
        let _cse_268_ = sqrt(_cse_269_);
        let _cse_285_ = (dot(_cse_248_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))))) * _cse_257_);
        let _cse_284_ = (_cse_285_ / _cse_258_);
        let _cse_283_ = (2f * _cse_284_);
        let _cse_282_ = (_cse_283_ - 1f);
        let _cse_281_ = min(_cse_282_, 1999f);
        let _cse_280_ = max(-2001f, _cse_281_);
        let _cse_286_ = abs(_cse_280_);
        let _cse_279_ = (_cse_280_ + _cse_286_);
        let _cse_278_ = (_cse_279_ / (1f + _cse_286_));
        let _e1812 = lambda;
        let _cse_277_ = (_cse_278_ * _e1812);
        let _cse_276_ = (_cse_248_ * _cse_277_);
        let _cse_275_ = (vec2<f32>(_cse_1856_, _cse_1866_) - _cse_276_);
        let _cse_296_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e616 - _e234)) / (((_e616 - _e234) * (_e616 - _e234)) + 0.000000000000000000000000000001f));
        let _cse_295_ = (2f * _cse_296_);
        let _cse_294_ = (_cse_295_ - 1f);
        let _cse_293_ = min(_cse_294_, 1999f);
        let _cse_292_ = max(-2001f, _cse_293_);
        let _cse_297_ = abs(_cse_292_);
        let _cse_291_ = (_cse_292_ + _cse_297_);
        let _cse_290_ = (_cse_291_ / (1f + _cse_297_));
        let _e1845 = lambda;
        let _cse_289_ = (_cse_290_ * _e1845);
        let _cse_288_ = (_cse_289_ * (_e616 - _e234));
        let _cse_287_ = (_e616 - _cse_288_);
        let _cse_274_ = ((_cse_275_ * 1f) / vec2(_cse_287_));
        let _e1854 = normal_vec;
        let _cse_273_ = dot(_cse_274_, _e1854);
        let _e1858 = constants.eos_r;
        let _e1935 = lambda;
        let _cse_304_ = ((_cse_287_ * _e1858) * (_e394 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e1935) * (_e394 - _e121))));
        let _e1943 = constants.eos_gamma;
        let _cse_303_ = (_e1943 * _cse_304_);
        let _cse_302_ = (_cse_303_ / _cse_287_);
        let _e1948 = constants.eos_dp_drho;
        let _cse_301_ = (_cse_302_ + _e1948);
        let _cse_305_ = (_cse_273_ * _cse_273_);
        let _e1953 = low_mach_params.model;
        let _e1965 = low_mach_params.model;
        let _cse_300_ = ((max(0f, (1f - abs((f32(_e1953) - 2f)))) * _cse_301_) + (max(0f, (1f - abs(f32(_e1965)))) * min(_cse_305_, _cse_301_)));
        let _e1977 = low_mach_params.theta_floor;
        let _cse_307_ = min(max(_cse_305_, (_e1977 * _cse_301_)), _cse_301_);
        let _e1983 = low_mach_params.model;
        let _cse_306_ = (max(0f, (1f - abs((f32(_e1983) - 1f)))) * _cse_307_);
        let _cse_299_ = (_cse_300_ + _cse_306_);
        let _cse_298_ = sqrt(_cse_299_);
        a_plus = max(0f, max((_cse_244_ + _cse_268_), (_cse_273_ + _cse_298_)));
        a_minus = min(0f, min((_cse_244_ - _cse_268_), (_cse_273_ - _cse_298_)));
    }
    let _e2007 = constants.scheme;
    if ((_e2007 == 5u) && !(is_boundary_1)) {
        let _cse_315_ = ((((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1850_);
        let _cse_314_ = max(_cse_315_, min((_cse_1856_ - _cse_1850_), 0f));
        let _cse_313_ = min(_cse_314_, max((_cse_1856_ - _cse_1850_), 0f));
        let _cse_311_ = (_cse_1850_ + _cse_313_);
        let _cse_321_ = ((((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1860_);
        let _cse_320_ = max(_cse_321_, min((_cse_1866_ - _cse_1860_), 0f));
        let _cse_319_ = min(_cse_320_, max((_cse_1866_ - _cse_1860_), 0f));
        let _cse_317_ = (_cse_1860_ + _cse_319_);
        let _cse_310_ = vec2<f32>(_cse_311_, _cse_317_);
        let _cse_327_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_326_ = (_cse_327_ - _e234);
        let _cse_325_ = max(_cse_326_, min((_e616 - _e234), 0f));
        let _cse_324_ = min(_cse_325_, max((_e616 - _e234), 0f));
        let _cse_323_ = (_e234 + _cse_324_);
        let _cse_309_ = ((_cse_310_ * 1f) / vec2(_cse_323_));
        let _e2080 = normal_vec;
        let _cse_308_ = dot(_cse_309_, _e2080);
        let _e2084 = constants.eos_r;
        let _cse_334_ = ((_cse_323_ * _e2084) * (_e121 + min(max(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f))));
        let _e2110 = constants.eos_gamma;
        let _cse_333_ = (_e2110 * _cse_334_);
        let _cse_332_ = (_cse_333_ / _cse_323_);
        let _e2115 = constants.eos_dp_drho;
        let _cse_331_ = (_cse_332_ + _e2115);
        let _cse_337_ = (_cse_308_ * _cse_308_);
        let _cse_336_ = min(_cse_337_, _cse_331_);
        let _e2121 = low_mach_params.model;
        let _cse_335_ = (max(0f, (1f - abs(f32(_e2121)))) * _cse_336_);
        let _e2131 = low_mach_params.model;
        let _cse_330_ = ((max(0f, (1f - abs((f32(_e2131) - 2f)))) * _cse_331_) + _cse_335_);
        let _e2144 = low_mach_params.theta_floor;
        let _cse_340_ = max(_cse_337_, (_e2144 * _cse_331_));
        let _cse_339_ = min(_cse_340_, _cse_331_);
        let _e2150 = low_mach_params.model;
        let _cse_338_ = (max(0f, (1f - abs((f32(_e2150) - 1f)))) * _cse_339_);
        let _cse_329_ = (_cse_330_ + _cse_338_);
        let _cse_328_ = sqrt(_cse_329_);
        let _cse_347_ = ((((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1856_);
        let _cse_346_ = max(_cse_347_, min((_cse_1850_ - _cse_1856_), 0f));
        let _cse_345_ = min(_cse_346_, max((_cse_1850_ - _cse_1856_), 0f));
        let _cse_344_ = (_cse_1856_ + _cse_345_);
        let _cse_351_ = ((((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1866_);
        let _cse_350_ = max(_cse_351_, min((_cse_1860_ - _cse_1866_), 0f));
        let _cse_349_ = min(_cse_350_, max((_cse_1860_ - _cse_1866_), 0f));
        let _cse_348_ = (_cse_1866_ + _cse_349_);
        let _cse_343_ = vec2<f32>(_cse_344_, _cse_348_);
        let _cse_358_ = (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_357_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_358_);
        let _cse_356_ = (_cse_357_ - _e616);
        let _cse_355_ = max(_cse_356_, min((_e234 - _e616), 0f));
        let _cse_354_ = min(_cse_355_, max((_e234 - _e616), 0f));
        let _cse_353_ = (_e616 + _cse_354_);
        let _cse_352_ = (1f / _cse_353_);
        let _cse_342_ = (_cse_343_ * _cse_352_);
        let _e2241 = normal_vec;
        let _cse_341_ = dot(_cse_342_, _e2241);
        let _e2245 = constants.eos_r;
        let _cse_365_ = ((_cse_353_ * _e2245) * (_e394 + min(max(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f))));
        let _e2275 = constants.eos_gamma;
        let _cse_364_ = (_e2275 * _cse_365_);
        let _cse_363_ = (_cse_364_ / _cse_353_);
        let _e2280 = constants.eos_dp_drho;
        let _cse_362_ = (_cse_363_ + _e2280);
        let _cse_368_ = (_cse_341_ * _cse_341_);
        let _cse_367_ = min(_cse_368_, _cse_362_);
        let _e2286 = low_mach_params.model;
        let _cse_366_ = (max(0f, (1f - abs(f32(_e2286)))) * _cse_367_);
        let _e2296 = low_mach_params.model;
        let _cse_361_ = ((max(0f, (1f - abs((f32(_e2296) - 2f)))) * _cse_362_) + _cse_366_);
        let _e2309 = low_mach_params.theta_floor;
        let _cse_371_ = max(_cse_368_, (_e2309 * _cse_362_));
        let _cse_370_ = min(_cse_371_, _cse_362_);
        let _e2315 = low_mach_params.model;
        let _cse_369_ = (max(0f, (1f - abs((f32(_e2315) - 1f)))) * _cse_370_);
        let _cse_360_ = (_cse_361_ + _cse_369_);
        let _cse_359_ = sqrt(_cse_360_);
        a_plus = max(0f, max((_cse_308_ + _cse_328_), (_cse_341_ + _cse_359_)));
        a_minus = min(0f, min((_cse_308_ - _cse_328_), (_cse_341_ - _cse_359_)));
    }
    let _e2339 = constants.scheme;
    if ((_e2339 == 6u) && !(is_boundary_1)) {
        let _cse_378_ = ((((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1850_);
        let _cse_377_ = ((((_cse_378_ * abs((_cse_1856_ - _cse_1850_))) / max(abs((_cse_1856_ - _cse_1850_)), (abs(_cse_378_) + 0.00000001f))) * max(((_cse_1856_ - _cse_1850_) * _cse_378_), 0f)) / max(abs(((_cse_1856_ - _cse_1850_) * _cse_378_)), 0.00000001f));
        let _cse_375_ = (_cse_1850_ + _cse_377_);
        let _cse_383_ = ((((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1860_);
        let _cse_382_ = ((((_cse_383_ * abs((_cse_1866_ - _cse_1860_))) / max(abs((_cse_1866_ - _cse_1860_)), (abs(_cse_383_) + 0.00000001f))) * max(((_cse_1866_ - _cse_1860_) * _cse_383_), 0f)) / max(abs(((_cse_1866_ - _cse_1860_) * _cse_383_)), 0.00000001f));
        let _cse_380_ = (_cse_1860_ + _cse_382_);
        let _cse_374_ = vec2<f32>(_cse_375_, _cse_380_);
        let _cse_389_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_388_ = (_cse_389_ - _e234);
        let _cse_387_ = ((_cse_388_ * abs((_e616 - _e234))) / max(abs((_e616 - _e234)), (abs(_cse_388_) + 0.00000001f)));
        let _cse_386_ = ((_cse_387_ * max(((_e616 - _e234) * _cse_388_), 0f)) / max(abs(((_e616 - _e234) * _cse_388_)), 0.00000001f));
        let _cse_385_ = (_e234 + _cse_386_);
        let _cse_373_ = ((_cse_374_ * 1f) / vec2(_cse_385_));
        let _e2451 = normal_vec;
        let _cse_372_ = dot(_cse_373_, _e2451);
        let _e2455 = constants.eos_r;
        let _cse_396_ = ((_cse_385_ * _e2455) * (_e121 + ((((((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e394 - _e121))) / max(abs((_e394 - _e121)), (abs(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f))));
        let _e2530 = constants.eos_gamma;
        let _cse_395_ = (_e2530 * _cse_396_);
        let _cse_394_ = (_cse_395_ / _cse_385_);
        let _e2535 = constants.eos_dp_drho;
        let _cse_393_ = (_cse_394_ + _e2535);
        let _cse_399_ = (_cse_372_ * _cse_372_);
        let _cse_398_ = min(_cse_399_, _cse_393_);
        let _e2541 = low_mach_params.model;
        let _cse_397_ = (max(0f, (1f - abs(f32(_e2541)))) * _cse_398_);
        let _e2551 = low_mach_params.model;
        let _cse_392_ = ((max(0f, (1f - abs((f32(_e2551) - 2f)))) * _cse_393_) + _cse_397_);
        let _e2564 = low_mach_params.theta_floor;
        let _cse_402_ = max(_cse_399_, (_e2564 * _cse_393_));
        let _cse_401_ = min(_cse_402_, _cse_393_);
        let _e2570 = low_mach_params.model;
        let _cse_400_ = (max(0f, (1f - abs((f32(_e2570) - 1f)))) * _cse_401_);
        let _cse_391_ = (_cse_392_ + _cse_400_);
        let _cse_390_ = sqrt(_cse_391_);
        let _cse_409_ = (((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_408_ = (_cse_409_ - _cse_1856_);
        let _cse_407_ = ((((_cse_408_ * abs((_cse_1850_ - _cse_1856_))) / max(abs((_cse_1850_ - _cse_1856_)), (abs(_cse_408_) + 0.00000001f))) * max(((_cse_1850_ - _cse_1856_) * _cse_408_), 0f)) / max(abs(((_cse_1850_ - _cse_1856_) * _cse_408_)), 0.00000001f));
        let _cse_406_ = (_cse_1856_ + _cse_407_);
        let _cse_413_ = (((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_412_ = (_cse_413_ - _cse_1866_);
        let _cse_411_ = ((((_cse_412_ * abs((_cse_1860_ - _cse_1866_))) / max(abs((_cse_1860_ - _cse_1866_)), (abs(_cse_412_) + 0.00000001f))) * max(((_cse_1860_ - _cse_1866_) * _cse_412_), 0f)) / max(abs(((_cse_1860_ - _cse_1866_) * _cse_412_)), 0.00000001f));
        let _cse_410_ = (_cse_1866_ + _cse_411_);
        let _cse_405_ = vec2<f32>(_cse_406_, _cse_410_);
        let _cse_420_ = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_419_ = (_cse_420_ * 0.125f);
        let _cse_418_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_419_);
        let _cse_417_ = (_cse_418_ - _e616);
        let _cse_416_ = ((_cse_417_ * abs((_e234 - _e616))) / max(abs((_e234 - _e616)), (abs(_cse_417_) + 0.00000001f)));
        let _cse_422_ = ((_e234 - _e616) * _cse_417_);
        let _cse_421_ = (max(_cse_422_, 0f) / max(abs(_cse_422_), 0.00000001f));
        let _cse_415_ = (_cse_416_ * _cse_421_);
        let _cse_414_ = (_e616 + _cse_415_);
        let _cse_404_ = ((_cse_405_ * 1f) / vec2(_cse_414_));
        let _e2699 = normal_vec;
        let _cse_403_ = dot(_cse_404_, _e2699);
        let _e2703 = constants.eos_r;
        let _cse_429_ = ((_cse_414_ * _e2703) * (_e394 + ((((((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394) * abs((_e121 - _e394))) / max(abs((_e121 - _e394)), (abs(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)) + 0.00000001f))) * max(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)), 0f)) / max(abs(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394))), 0.00000001f))));
        let _e2794 = constants.eos_gamma;
        let _cse_428_ = (_e2794 * _cse_429_);
        let _cse_427_ = (_cse_428_ / _cse_414_);
        let _e2799 = constants.eos_dp_drho;
        let _cse_426_ = (_cse_427_ + _e2799);
        let _cse_432_ = (_cse_403_ * _cse_403_);
        let _cse_431_ = min(_cse_432_, _cse_426_);
        let _e2805 = low_mach_params.model;
        let _cse_430_ = (max(0f, (1f - abs(f32(_e2805)))) * _cse_431_);
        let _e2815 = low_mach_params.model;
        let _cse_425_ = ((max(0f, (1f - abs((f32(_e2815) - 2f)))) * _cse_426_) + _cse_430_);
        let _e2828 = low_mach_params.theta_floor;
        let _cse_435_ = max(_cse_432_, (_e2828 * _cse_426_));
        let _cse_434_ = min(_cse_435_, _cse_426_);
        let _e2834 = low_mach_params.model;
        let _cse_433_ = (max(0f, (1f - abs((f32(_e2834) - 1f)))) * _cse_434_);
        let _cse_424_ = (_cse_425_ + _cse_433_);
        let _cse_423_ = sqrt(_cse_424_);
        a_plus = max(0f, max((_cse_372_ + _cse_390_), (_cse_403_ + _cse_423_)));
        a_minus = min(0f, min((_cse_372_ - _cse_390_), (_cse_403_ - _cse_423_)));
    }
    let _e2856 = a_plus;
    let _e2857 = a_minus;
    let denom = max((_e2856 - _e2857), 0.000001f);
    let _e2863 = low_mach_params.model;
    let _cse_441_ = (f32(_e2863) - 2f);
    let _cse_440_ = abs(_cse_441_);
    let _cse_439_ = (1f - _cse_440_);
    let _cse_438_ = max(0f, _cse_439_);
    let _cse_437_ = (1f - _cse_438_);
    let _e2876 = low_mach_params.pressure_coupling_alpha;
    let _cse_436_ = (_cse_437_ * _e2876);
    let _e2880 = constants.eos_r;
    let _cse_442_ = ((_e234 * _e2880) * _e121);
    let _e2885 = constants.eos_r;
    let _cse_443_ = ((_e616 * _e2885) * _e394);
    let _e2891 = constants.eos_gamma;
    let _e2896 = constants.eos_dp_drho;
    u_l_0_ = (_e234 + ((_cse_436_ * _cse_442_) / max((((_e2891 * _cse_442_) / _e234) + _e2896), 0.000000000001f)));
    let _e2906 = constants.eos_gamma;
    let _e2911 = constants.eos_dp_drho;
    u_r_0_ = (_e616 + ((_cse_436_ * _cse_443_) / max((((_e2906 * _cse_443_) / _e616) + _e2911), 0.000000000001f)));
    let _e2923 = normal_vec;
    f_l_0_ = (_e234 * dot(((vec2<f32>(_cse_1850_, _cse_1860_) * 1f) / vec2(_e234)), _e2923));
    let _e2932 = normal_vec;
    f_r_0_ = (_e616 * dot(((vec2<f32>(_cse_1856_, _cse_1866_) * 1f) / vec2(_e616)), _e2932));
    let _e2938 = constants.scheme;
    if ((_e2938 == 1u) && !(is_boundary_1)) {
        let _cse_445_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_444_ = (_e234 + _cse_445_);
        let _e2949 = low_mach_params.model;
        let _cse_451_ = (f32(_e2949) - 2f);
        let _cse_450_ = abs(_cse_451_);
        let _cse_449_ = (1f - _cse_450_);
        let _cse_448_ = max(0f, _cse_449_);
        let _cse_447_ = (1f - _cse_448_);
        let _e2962 = low_mach_params.pressure_coupling_alpha;
        let _cse_446_ = (_cse_447_ * _e2962);
        let _e2966 = constants.eos_r;
        let _cse_453_ = (_cse_444_ * _e2966);
        let _cse_455_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_454_ = (_e121 + _cse_455_);
        let _cse_452_ = (_cse_453_ * _cse_454_);
        let _cse_458_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_457_ = dot(_cse_458_, (face_center_vec - c_neigh_cell_vec));
        let _cse_456_ = (_e616 + _cse_457_);
        let _e2983 = constants.eos_r;
        let _cse_460_ = (_cse_456_ * _e2983);
        let _cse_463_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_462_ = dot(_cse_463_, (face_center_vec - c_neigh_cell_vec));
        let _cse_461_ = (_e394 + _cse_462_);
        let _cse_459_ = (_cse_460_ * _cse_461_);
        let _e2997 = constants.eos_gamma;
        let _e3002 = constants.eos_dp_drho;
        u_l_0_ = (_cse_444_ + ((_cse_446_ * _cse_452_) / max((((_e2997 * _cse_452_) / _cse_444_) + _e3002), 0.000000000001f)));
        let _e3011 = constants.eos_gamma;
        let _e3016 = constants.eos_dp_drho;
        u_r_0_ = (_cse_456_ + ((_cse_446_ * _cse_459_) / max((((_e3011 * _cse_459_) / _cse_456_) + _e3016), 0.000000000001f)));
        let _e3035 = normal_vec;
        f_l_0_ = (_cse_444_ * dot(((vec2<f32>((_cse_1850_ + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec))), (_cse_1860_ + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)))) * 1f) / vec2(_cse_444_)), _e3035));
        let _e3059 = normal_vec;
        f_r_0_ = (_cse_456_ * dot(((vec2<f32>((_cse_1856_ + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec))), (_cse_1866_ + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)))) * 1f) / vec2(_cse_456_)), _e3059));
    }
    let _e3064 = constants.scheme;
    if ((_e3064 == 2u) && !(is_boundary_1)) {
        let _cse_467_ = ((_e234 * 0.625f) + (_e616 * 0.375f));
        let _cse_469_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_468_ = (_cse_469_ * 0.125f);
        let _cse_466_ = (_cse_467_ + _cse_468_);
        let _cse_465_ = (_cse_466_ - _e234);
        let _cse_464_ = (_e234 + _cse_465_);
        let _e3084 = low_mach_params.model;
        let _cse_475_ = (f32(_e3084) - 2f);
        let _cse_474_ = abs(_cse_475_);
        let _cse_473_ = (1f - _cse_474_);
        let _cse_472_ = max(0f, _cse_473_);
        let _cse_471_ = (1f - _cse_472_);
        let _e3097 = low_mach_params.pressure_coupling_alpha;
        let _cse_470_ = (_cse_471_ * _e3097);
        let _e3101 = constants.eos_r;
        let _cse_477_ = (_cse_464_ * _e3101);
        let _cse_481_ = ((_e121 * 0.625f) + (_e394 * 0.375f));
        let _cse_483_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_482_ = (_cse_483_ * 0.125f);
        let _cse_480_ = (_cse_481_ + _cse_482_);
        let _cse_479_ = (_cse_480_ - _e121);
        let _cse_478_ = (_e121 + _cse_479_);
        let _cse_476_ = (_cse_477_ * _cse_478_);
        let _cse_487_ = ((_e616 * 0.625f) + (_e234 * 0.375f));
        let _cse_490_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_489_ = dot(_cse_490_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_488_ = (_cse_489_ * 0.125f);
        let _cse_486_ = (_cse_487_ + _cse_488_);
        let _cse_485_ = (_cse_486_ - _e616);
        let _cse_484_ = (_e616 + _cse_485_);
        let _e3136 = constants.eos_r;
        let _cse_492_ = (_cse_484_ * _e3136);
        let _cse_496_ = ((_e394 * 0.625f) + (_e121 * 0.375f));
        let _cse_499_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_498_ = dot(_cse_499_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_497_ = (_cse_498_ * 0.125f);
        let _cse_495_ = (_cse_496_ + _cse_497_);
        let _cse_494_ = (_cse_495_ - _e394);
        let _cse_493_ = (_e394 + _cse_494_);
        let _cse_491_ = (_cse_492_ * _cse_493_);
        let _e3159 = constants.eos_gamma;
        let _e3164 = constants.eos_dp_drho;
        u_l_0_ = (_cse_464_ + ((_cse_470_ * _cse_476_) / max((((_e3159 * _cse_476_) / _cse_464_) + _e3164), 0.000000000001f)));
        let _e3173 = constants.eos_gamma;
        let _e3178 = constants.eos_dp_drho;
        u_r_0_ = (_cse_484_ + ((_cse_470_ * _cse_491_) / max((((_e3173 * _cse_491_) / _cse_484_) + _e3178), 0.000000000001f)));
        let _e3215 = normal_vec;
        f_l_0_ = (_cse_464_ * dot(((vec2<f32>(((((_cse_1850_ + (_cse_1850_ * 0.625f)) + (_cse_1856_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1850_), ((((_cse_1860_ + (_cse_1860_ * 0.625f)) + (_cse_1866_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1860_)) * 1f) / vec2(_cse_464_)), _e3215));
        let _e3257 = normal_vec;
        f_r_0_ = (_cse_484_ * dot(((vec2<f32>(((((_cse_1856_ + (_cse_1856_ * 0.625f)) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1856_), ((((_cse_1866_ + (_cse_1866_ * 0.625f)) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1866_)) * 1f) / vec2(_cse_484_)), _e3257));
    }
    let _e3262 = constants.scheme;
    if ((_e3262 == 3u) && !(is_boundary_1)) {
        let _cse_507_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_508_ = min((_e616 - _e234), 0f);
        let _cse_506_ = max(_cse_507_, _cse_508_);
        let _cse_509_ = max((_e616 - _e234), 0f);
        let _cse_505_ = min(_cse_506_, _cse_509_);
        let _cse_504_ = (_e234 + _cse_505_);
        let _e3281 = low_mach_params.model;
        let _cse_515_ = (f32(_e3281) - 2f);
        let _cse_514_ = abs(_cse_515_);
        let _cse_513_ = (1f - _cse_514_);
        let _cse_512_ = max(0f, _cse_513_);
        let _cse_511_ = (1f - _cse_512_);
        let _e3294 = low_mach_params.pressure_coupling_alpha;
        let _cse_510_ = (_cse_511_ * _e3294);
        let _e3298 = constants.eos_r;
        let _cse_517_ = (_cse_504_ * _e3298);
        let _cse_521_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_522_ = min((_e394 - _e121), 0f);
        let _cse_520_ = max(_cse_521_, _cse_522_);
        let _cse_523_ = max((_e394 - _e121), 0f);
        let _cse_519_ = min(_cse_520_, _cse_523_);
        let _cse_518_ = (_e121 + _cse_519_);
        let _cse_516_ = (_cse_517_ * _cse_518_);
        let _cse_528_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_527_ = dot(_cse_528_, (face_center_vec - c_neigh_cell_vec));
        let _cse_529_ = min((_e234 - _e616), 0f);
        let _cse_526_ = max(_cse_527_, _cse_529_);
        let _cse_530_ = max((_e234 - _e616), 0f);
        let _cse_525_ = min(_cse_526_, _cse_530_);
        let _cse_524_ = (_e616 + _cse_525_);
        let _e3331 = constants.eos_r;
        let _cse_532_ = (_cse_524_ * _e3331);
        let _cse_537_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_536_ = dot(_cse_537_, (face_center_vec - c_neigh_cell_vec));
        let _cse_538_ = min((_e121 - _e394), 0f);
        let _cse_535_ = max(_cse_536_, _cse_538_);
        let _cse_539_ = max((_e121 - _e394), 0f);
        let _cse_534_ = min(_cse_535_, _cse_539_);
        let _cse_533_ = (_e394 + _cse_534_);
        let _cse_531_ = (_cse_532_ * _cse_533_);
        let _cse_541_ = (_cse_1856_ - _cse_1850_);
        let _cse_544_ = (_cse_1866_ - _cse_1860_);
        let _cse_546_ = (_cse_1850_ - _cse_1856_);
        let _cse_547_ = (_cse_1860_ - _cse_1866_);
        let _e3357 = constants.eos_gamma;
        let _e3362 = constants.eos_dp_drho;
        u_l_0_ = (_cse_504_ + ((_cse_510_ * _cse_516_) / max((((_e3357 * _cse_516_) / _cse_504_) + _e3362), 0.000000000001f)));
        let _e3371 = constants.eos_gamma;
        let _e3376 = constants.eos_dp_drho;
        u_r_0_ = (_cse_524_ + ((_cse_510_ * _cse_531_) / max((((_e3371 * _cse_531_) / _cse_524_) + _e3376), 0.000000000001f)));
        let _e3407 = normal_vec;
        f_l_0_ = (_cse_504_ * dot(((vec2<f32>((_cse_1850_ + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), min(_cse_541_, 0f)), max(_cse_541_, 0f))), (_cse_1860_ + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), min(_cse_544_, 0f)), max(_cse_544_, 0f)))) * 1f) / vec2(_cse_504_)), _e3407));
        let _e3443 = normal_vec;
        f_r_0_ = (_cse_524_ * dot(((vec2<f32>((_cse_1856_ + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_546_, 0f)), max(_cse_546_, 0f))), (_cse_1866_ + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min(_cse_547_, 0f)), max(_cse_547_, 0f)))) * 1f) / vec2(_cse_524_)), _e3443));
    }
    let _e3448 = constants.scheme;
    if ((_e3448 == 4u) && !(is_boundary_1)) {
        let _cse_559_ = dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y));
        let _cse_558_ = (_cse_559_ * (_e616 - _e234));
        let _cse_561_ = ((_e616 - _e234) * (_e616 - _e234));
        let _cse_560_ = (_cse_561_ + 0.000000000000000000000000000001f);
        let _cse_557_ = (_cse_558_ / _cse_560_);
        let _cse_556_ = (2f * _cse_557_);
        let _cse_555_ = (_cse_556_ - 1f);
        let _cse_554_ = min(_cse_555_, 1999f);
        let _cse_553_ = max(-2001f, _cse_554_);
        let _cse_562_ = abs(_cse_553_);
        let _cse_552_ = (_cse_553_ + _cse_562_);
        let _cse_563_ = (1f + _cse_562_);
        let _cse_551_ = (_cse_552_ / _cse_563_);
        let _cse_550_ = (_cse_551_ * lambda_other);
        let _cse_549_ = (_cse_550_ * (_e616 - _e234));
        let _cse_548_ = (_e234 + _cse_549_);
        let _cse_568_ = (((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f));
        let _cse_567_ = (_cse_568_ - 1f);
        let _cse_566_ = min(_cse_567_, 1999f);
        let _cse_565_ = max(-2001f, _cse_566_);
        let _e3502 = constants.eos_r;
        let _cse_564_ = ((_cse_548_ * _e3502) * (_e121 + ((((_cse_565_ + abs(_cse_565_)) / (1f + abs(_cse_565_))) * lambda_other) * (_e394 - _e121))));
        let _cse_581_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_580_ = dot((c_neigh_cell_vec - c_owner_vec), _cse_581_);
        let _cse_579_ = (_cse_580_ * (_e616 - _e234));
        let _cse_578_ = (_cse_579_ / _cse_560_);
        let _cse_577_ = (2f * _cse_578_);
        let _cse_576_ = (_cse_577_ - 1f);
        let _cse_575_ = min(_cse_576_, 1999f);
        let _cse_574_ = max(-2001f, _cse_575_);
        let _cse_582_ = abs(_cse_574_);
        let _cse_573_ = (_cse_574_ + _cse_582_);
        let _cse_583_ = (1f + _cse_582_);
        let _cse_572_ = (_cse_573_ / _cse_583_);
        let _e3538 = lambda;
        let _cse_571_ = (_cse_572_ * _e3538);
        let _cse_570_ = (_cse_571_ * (_e616 - _e234));
        let _cse_569_ = (_e616 - _cse_570_);
        let _e3545 = constants.eos_r;
        let _cse_585_ = (_cse_569_ * _e3545);
        let _cse_594_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f));
        let _cse_593_ = (2f * _cse_594_);
        let _cse_592_ = (_cse_593_ - 1f);
        let _cse_591_ = min(_cse_592_, 1999f);
        let _cse_590_ = max(-2001f, _cse_591_);
        let _cse_595_ = abs(_cse_590_);
        let _cse_589_ = ((_cse_590_ + _cse_595_) / (1f + _cse_595_));
        let _e3575 = lambda;
        let _cse_588_ = (_cse_589_ * _e3575);
        let _cse_587_ = (_cse_588_ * (_e394 - _e121));
        let _cse_586_ = (_e394 - _cse_587_);
        let _cse_584_ = (_cse_585_ * _cse_586_);
        let _cse_596_ = (vec2<f32>(_cse_1856_, _cse_1866_) - vec2<f32>(_cse_1850_, _cse_1860_));
        let _cse_602_ = dot(_cse_596_, _cse_596_);
        let _cse_604_ = (_cse_602_ * _cse_602_);
        let _cse_603_ = (_cse_604_ + 0.000000000000000000000000000001f);
        let _cse_601_ = ((dot(_cse_596_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_602_) / _cse_603_);
        let _cse_600_ = (2f * _cse_601_);
        let _cse_599_ = (_cse_600_ - 1f);
        let _cse_598_ = min(_cse_599_, 1999f);
        let _cse_597_ = max(-2001f, _cse_598_);
        let _cse_610_ = (dot(_cse_596_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))))) * _cse_602_);
        let _cse_609_ = (_cse_610_ / _cse_603_);
        let _cse_608_ = (2f * _cse_609_);
        let _cse_607_ = (_cse_608_ - 1f);
        let _cse_606_ = min(_cse_607_, 1999f);
        let _cse_605_ = max(-2001f, _cse_606_);
        let _cse_611_ = abs(_cse_605_);
        let _e3635 = low_mach_params.model;
        let _e3648 = low_mach_params.pressure_coupling_alpha;
        let _e3653 = constants.eos_gamma;
        let _e3658 = constants.eos_dp_drho;
        u_l_0_ = (_cse_548_ + ((((1f - max(0f, (1f - abs((f32(_e3635) - 2f))))) * _e3648) * _cse_564_) / max((((_e3653 * _cse_564_) / _cse_548_) + _e3658), 0.000000000001f)));
        let _e3666 = low_mach_params.model;
        let _e3679 = low_mach_params.pressure_coupling_alpha;
        let _e3684 = constants.eos_gamma;
        let _e3689 = constants.eos_dp_drho;
        u_r_0_ = (_cse_569_ + ((((1f - max(0f, (1f - abs((f32(_e3666) - 2f))))) * _e3679) * _cse_584_) / max((((_e3684 * _cse_584_) / _cse_569_) + _e3689), 0.000000000001f)));
        let _e3710 = normal_vec;
        f_l_0_ = (_cse_548_ * dot((((vec2<f32>(_cse_1850_, _cse_1860_) + (((_cse_596_ * (_cse_597_ + abs(_cse_597_))) / vec2((1f + abs(_cse_597_)))) * lambda_other)) * 1f) / vec2(_cse_548_)), _e3710));
        let _e3720 = lambda;
        let _e3727 = normal_vec;
        f_r_0_ = (_cse_569_ * dot((((vec2<f32>(_cse_1856_, _cse_1866_) - (((_cse_596_ * (_cse_605_ + _cse_611_)) / vec2((1f + _cse_611_))) * _e3720)) * 1f) / vec2(_cse_569_)), _e3727));
    }
    let _e3732 = constants.scheme;
    if ((_e3732 == 5u) && !(is_boundary_1)) {
        let _cse_617_ = ((_e234 * 0.625f) + (_e616 * 0.375f));
        let _cse_619_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_618_ = (_cse_619_ * 0.125f);
        let _cse_616_ = (_cse_617_ + _cse_618_);
        let _cse_615_ = (_cse_616_ - _e234);
        let _cse_620_ = min((_e616 - _e234), 0f);
        let _cse_614_ = max(_cse_615_, _cse_620_);
        let _cse_621_ = max((_e616 - _e234), 0f);
        let _cse_613_ = min(_cse_614_, _cse_621_);
        let _cse_612_ = (_e234 + _cse_613_);
        let _e3760 = low_mach_params.model;
        let _cse_627_ = (f32(_e3760) - 2f);
        let _cse_626_ = abs(_cse_627_);
        let _cse_625_ = (1f - _cse_626_);
        let _cse_624_ = max(0f, _cse_625_);
        let _cse_623_ = (1f - _cse_624_);
        let _e3773 = low_mach_params.pressure_coupling_alpha;
        let _cse_622_ = (_cse_623_ * _e3773);
        let _e3777 = constants.eos_r;
        let _cse_629_ = (_cse_612_ * _e3777);
        let _cse_635_ = ((_e121 * 0.625f) + (_e394 * 0.375f));
        let _cse_637_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_636_ = (_cse_637_ * 0.125f);
        let _cse_634_ = (_cse_635_ + _cse_636_);
        let _cse_633_ = (_cse_634_ - _e121);
        let _cse_638_ = min((_e394 - _e121), 0f);
        let _cse_632_ = max(_cse_633_, _cse_638_);
        let _cse_639_ = max((_e394 - _e121), 0f);
        let _cse_631_ = min(_cse_632_, _cse_639_);
        let _cse_630_ = (_e121 + _cse_631_);
        let _cse_628_ = (_cse_629_ * _cse_630_);
        let _cse_645_ = ((_e616 * 0.625f) + (_e234 * 0.375f));
        let _cse_648_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_647_ = dot(_cse_648_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_646_ = (_cse_647_ * 0.125f);
        let _cse_644_ = (_cse_645_ + _cse_646_);
        let _cse_643_ = (_cse_644_ - _e616);
        let _cse_649_ = min((_e234 - _e616), 0f);
        let _cse_642_ = max(_cse_643_, _cse_649_);
        let _cse_650_ = max((_e234 - _e616), 0f);
        let _cse_641_ = min(_cse_642_, _cse_650_);
        let _cse_640_ = (_e616 + _cse_641_);
        let _e3828 = constants.eos_r;
        let _cse_652_ = (_cse_640_ * _e3828);
        let _cse_658_ = ((_e394 * 0.625f) + (_e121 * 0.375f));
        let _cse_661_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_660_ = dot(_cse_661_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_659_ = (_cse_660_ * 0.125f);
        let _cse_657_ = (_cse_658_ + _cse_659_);
        let _cse_656_ = (_cse_657_ - _e394);
        let _cse_662_ = min((_e121 - _e394), 0f);
        let _cse_655_ = max(_cse_656_, _cse_662_);
        let _cse_663_ = max((_e121 - _e394), 0f);
        let _cse_654_ = min(_cse_655_, _cse_663_);
        let _cse_653_ = (_e394 + _cse_654_);
        let _cse_651_ = (_cse_652_ * _cse_653_);
        let _cse_666_ = (_cse_1856_ - _cse_1850_);
        let _cse_669_ = (_cse_1866_ - _cse_1860_);
        let _cse_670_ = (_cse_1850_ - _cse_1856_);
        let _cse_671_ = (_cse_1860_ - _cse_1866_);
        let _e3863 = constants.eos_gamma;
        let _e3868 = constants.eos_dp_drho;
        u_l_0_ = (_cse_612_ + ((_cse_622_ * _cse_628_) / max((((_e3863 * _cse_628_) / _cse_612_) + _e3868), 0.000000000001f)));
        let _e3877 = constants.eos_gamma;
        let _e3882 = constants.eos_dp_drho;
        u_r_0_ = (_cse_640_ + ((_cse_622_ * _cse_651_) / max((((_e3877 * _cse_651_) / _cse_640_) + _e3882), 0.000000000001f)));
        let _e3931 = normal_vec;
        f_l_0_ = (_cse_612_ * dot(((vec2<f32>((_cse_1850_ + min(max(((((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1850_), min(_cse_666_, 0f)), max(_cse_666_, 0f))), (_cse_1860_ + min(max(((((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1860_), min(_cse_669_, 0f)), max(_cse_669_, 0f)))) * 1f) / vec2(_cse_612_)), _e3931));
        let _e3985 = normal_vec;
        f_r_0_ = (_cse_640_ * dot(((vec2<f32>((_cse_1856_ + min(max(((((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1856_), min(_cse_670_, 0f)), max(_cse_670_, 0f))), (_cse_1866_ + min(max(((((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _cse_1866_), min(_cse_671_, 0f)), max(_cse_671_, 0f)))) * 1f) / vec2(_cse_640_)), _e3985));
    }
    let _e3990 = constants.scheme;
    if ((_e3990 == 6u) && !(is_boundary_1)) {
        let _cse_677_ = ((_e234 * 0.625f) + (_e616 * 0.375f));
        let _cse_679_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_678_ = (_cse_679_ * 0.125f);
        let _cse_676_ = (_cse_677_ + _cse_678_);
        let _cse_675_ = (_cse_676_ - _e234);
        let _cse_683_ = abs(_cse_675_);
        let _cse_682_ = (_cse_683_ + 0.00000001f);
        let _cse_681_ = max(abs((_e616 - _e234)), _cse_682_);
        let _cse_680_ = (abs((_e616 - _e234)) / _cse_681_);
        let _cse_674_ = (_cse_675_ * _cse_680_);
        let _cse_686_ = ((_e616 - _e234) * _cse_675_);
        let _cse_685_ = max(_cse_686_, 0f);
        let _cse_688_ = abs(_cse_686_);
        let _cse_687_ = max(_cse_688_, 0.00000001f);
        let _cse_684_ = (_cse_685_ / _cse_687_);
        let _cse_673_ = (_cse_674_ * _cse_684_);
        let _cse_672_ = (_e234 + _cse_673_);
        let _e4029 = constants.eos_r;
        let _cse_690_ = (_cse_672_ * _e4029);
        let _cse_694_ = (((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_693_ = (_cse_694_ - _e121);
        let _cse_692_ = ((((_cse_693_ * abs((_e394 - _e121))) / max(abs((_e394 - _e121)), (abs(_cse_693_) + 0.00000001f))) * max(((_e394 - _e121) * _cse_693_), 0f)) / max(abs(((_e394 - _e121) * _cse_693_)), 0.00000001f));
        let _cse_691_ = (_e121 + _cse_692_);
        let _cse_689_ = (_cse_690_ * _cse_691_);
        let _cse_700_ = ((_e616 * 0.625f) + (_e234 * 0.375f));
        let _cse_703_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_702_ = dot(_cse_703_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_701_ = (_cse_702_ * 0.125f);
        let _cse_699_ = (_cse_700_ + _cse_701_);
        let _cse_698_ = (_cse_699_ - _e616);
        let _cse_707_ = abs(_cse_698_);
        let _cse_706_ = (_cse_707_ + 0.00000001f);
        let _cse_705_ = max(abs((_e234 - _e616)), _cse_706_);
        let _cse_704_ = (abs((_e234 - _e616)) / _cse_705_);
        let _cse_697_ = (_cse_698_ * _cse_704_);
        let _cse_710_ = ((_e234 - _e616) * _cse_698_);
        let _cse_709_ = max(_cse_710_, 0f);
        let _cse_712_ = abs(_cse_710_);
        let _cse_711_ = max(_cse_712_, 0.00000001f);
        let _cse_708_ = (_cse_709_ / _cse_711_);
        let _cse_696_ = (_cse_697_ * _cse_708_);
        let _cse_695_ = (_e616 + _cse_696_);
        let _e4104 = constants.eos_r;
        let _cse_714_ = (_cse_695_ * _e4104);
        let _cse_721_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_720_ = dot(_cse_721_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_719_ = (_cse_720_ * 0.125f);
        let _cse_718_ = (((_e394 * 0.625f) + (_e121 * 0.375f)) + _cse_719_);
        let _cse_717_ = (_cse_718_ - _e394);
        let _cse_722_ = ((_e121 - _e394) * _cse_717_);
        let _cse_716_ = ((((_cse_717_ * abs((_e121 - _e394))) / max(abs((_e121 - _e394)), (abs(_cse_717_) + 0.00000001f))) * max(_cse_722_, 0f)) / max(abs(_cse_722_), 0.00000001f));
        let _cse_715_ = (_e394 + _cse_716_);
        let _cse_713_ = (_cse_714_ * _cse_715_);
        let _cse_725_ = (((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_724_ = (_cse_725_ - _cse_1850_);
        let _cse_729_ = (((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_728_ = (_cse_729_ - _cse_1860_);
        let _cse_732_ = (((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_731_ = (_cse_732_ - _cse_1856_);
        let _cse_733_ = ((_cse_1850_ - _cse_1856_) * _cse_731_);
        let _cse_735_ = (((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_734_ = (_cse_735_ - _cse_1866_);
        let _e4203 = low_mach_params.model;
        let _e4216 = low_mach_params.pressure_coupling_alpha;
        let _e4221 = constants.eos_gamma;
        let _e4226 = constants.eos_dp_drho;
        u_l_0_ = (_cse_672_ + ((((1f - max(0f, (1f - abs((f32(_e4203) - 2f))))) * _e4216) * _cse_689_) / max((((_e4221 * _cse_689_) / _cse_672_) + _e4226), 0.000000000001f)));
        let _e4234 = low_mach_params.model;
        let _e4247 = low_mach_params.pressure_coupling_alpha;
        let _e4252 = constants.eos_gamma;
        let _e4257 = constants.eos_dp_drho;
        u_r_0_ = (_cse_695_ + ((((1f - max(0f, (1f - abs((f32(_e4234) - 2f))))) * _e4247) * _cse_713_) / max((((_e4252 * _cse_713_) / _cse_695_) + _e4257), 0.000000000001f)));
        let _e4312 = normal_vec;
        f_l_0_ = (_cse_672_ * dot(((vec2<f32>((_cse_1850_ + ((((_cse_724_ * abs((_cse_1856_ - _cse_1850_))) / max(abs((_cse_1856_ - _cse_1850_)), (abs(_cse_724_) + 0.00000001f))) * max(((_cse_1856_ - _cse_1850_) * _cse_724_), 0f)) / max(abs(((_cse_1856_ - _cse_1850_) * _cse_724_)), 0.00000001f))), (_cse_1860_ + ((((_cse_728_ * abs((_cse_1866_ - _cse_1860_))) / max(abs((_cse_1866_ - _cse_1860_)), (abs(_cse_728_) + 0.00000001f))) * max(((_cse_1866_ - _cse_1860_) * _cse_728_), 0f)) / max(abs(((_cse_1866_ - _cse_1860_) * _cse_728_)), 0.00000001f)))) * 1f) / vec2(_cse_672_)), _e4312));
        let _e4360 = normal_vec;
        f_r_0_ = (_cse_695_ * dot(((vec2<f32>((_cse_1856_ + ((((_cse_731_ * abs((_cse_1850_ - _cse_1856_))) / max(abs((_cse_1850_ - _cse_1856_)), (abs(_cse_731_) + 0.00000001f))) * max(_cse_733_, 0f)) / max(abs(_cse_733_), 0.00000001f))), (_cse_1866_ + ((((_cse_734_ * abs((_cse_1860_ - _cse_1866_))) / max(abs((_cse_1860_ - _cse_1866_)), (abs(_cse_734_) + 0.00000001f))) * max(((_cse_1860_ - _cse_1866_) * _cse_734_), 0f)) / max(abs(((_cse_1860_ - _cse_1866_) * _cse_734_)), 0.00000001f)))) * 1f) / vec2(_cse_695_)), _e4360));
    }
    let _e4369 = a_plus;
    let _e4370 = f_l_0_;
    let _e4372 = a_minus;
    let _e4373 = f_r_0_;
    let _e4376 = a_plus;
    let _e4377 = a_minus;
    let _e4379 = u_r_0_;
    let _e4380 = u_l_0_;
    fluxes[((idx * 8u) + 0u)] = (((((_e4369 * _e4370) - (_e4372 * _e4373)) + ((_e4376 * _e4377) * (_e4379 - _e4380))) / denom) * area);
    let _cse_737_ = vec2<f32>(_cse_1850_, _cse_1860_);
    let _cse_736_ = _cse_737_.x;
    let _cse_741_ = vec2<f32>(_cse_1856_, _cse_1866_);
    let _cse_740_ = _cse_741_.x;
    let _cse_744_ = normal_vec.x;
    let _cse_752_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
    let _e4397 = lambda;
    let _cse_751_ = (_cse_752_ * _e4397);
    let _cse_753_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
    let _cse_750_ = (_cse_751_ + _cse_753_);
    let _cse_749_ = _cse_750_.x;
    let _cse_759_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
    let _e4408 = lambda;
    let _cse_758_ = (_cse_759_ * _e4408);
    let _cse_760_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
    let _cse_757_ = (_cse_758_ + _cse_760_);
    let _cse_756_ = _cse_757_.y;
    let _cse_755_ = (_cse_749_ + _cse_756_);
    let _cse_754_ = (0.6666667f * _cse_755_);
    let _cse_748_ = (_cse_749_ - _cse_754_);
    let _cse_747_ = (_cse_748_ * _cse_744_);
    let _cse_762_ = _cse_757_.x;
    let _cse_763_ = normal_vec.y;
    let _cse_761_ = (_cse_762_ * _cse_763_);
    let _cse_746_ = (_cse_747_ + _cse_761_);
    let _e4426 = constants.viscosity;
    let _cse_745_ = (_e4426 * _cse_746_);
    u_l_1_ = _cse_736_;
    u_r_1_ = _cse_740_;
    let _e4434 = normal_vec;
    let _e4439 = constants.eos_r;
    f_l_1_ = (((_cse_736_ * dot(((_cse_737_ * 1f) / vec2(_e234)), _e4434)) + (((_e234 * _e4439) * _e121) * _cse_744_)) - _cse_745_);
    let _e4450 = normal_vec;
    let _e4455 = constants.eos_r;
    f_r_1_ = (((_cse_740_ * dot(((_cse_741_ * 1f) / vec2(_e616)), _e4450)) + (((_e616 * _e4455) * _e394) * _cse_744_)) - _cse_745_);
    let _e4464 = constants.scheme;
    if ((_e4464 == 1u) && !(is_boundary_1)) {
        let _cse_768_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_766_ = (_cse_1850_ + _cse_768_);
        let _cse_771_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_769_ = (_cse_1860_ + _cse_771_);
        let _cse_765_ = vec2<f32>(_cse_766_, _cse_769_);
        let _cse_764_ = _cse_765_.x;
        let _cse_777_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_776_ = dot(_cse_777_, (face_center_vec - c_neigh_cell_vec));
        let _cse_774_ = (_cse_1856_ + _cse_776_);
        let _cse_781_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_780_ = dot(_cse_781_, (face_center_vec - c_neigh_cell_vec));
        let _cse_778_ = (_cse_1866_ + _cse_780_);
        let _cse_773_ = vec2<f32>(_cse_774_, _cse_778_);
        let _cse_772_ = _cse_773_.x;
        let _cse_783_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_782_ = (_e234 + _cse_783_);
        let _cse_784_ = normal_vec.x;
        let _cse_792_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e4508 = lambda;
        let _cse_791_ = (_cse_792_ * _e4508);
        let _cse_793_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_790_ = (_cse_791_ + _cse_793_);
        let _cse_789_ = _cse_790_.x;
        let _cse_799_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e4519 = lambda;
        let _cse_798_ = (_cse_799_ * _e4519);
        let _cse_800_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_797_ = (_cse_798_ + _cse_800_);
        let _cse_796_ = _cse_797_.y;
        let _cse_795_ = (_cse_789_ + _cse_796_);
        let _cse_794_ = (0.6666667f * _cse_795_);
        let _cse_788_ = (_cse_789_ - _cse_794_);
        let _cse_787_ = (_cse_788_ * _cse_784_);
        let _cse_802_ = _cse_797_.x;
        let _cse_803_ = normal_vec.y;
        let _cse_801_ = (_cse_802_ * _cse_803_);
        let _cse_786_ = (_cse_787_ + _cse_801_);
        let _e4537 = constants.viscosity;
        let _cse_785_ = (_e4537 * _cse_786_);
        let _cse_806_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_805_ = dot(_cse_806_, (face_center_vec - c_neigh_cell_vec));
        let _cse_804_ = (_e616 + _cse_805_);
        u_l_1_ = _cse_764_;
        u_r_1_ = _cse_772_;
        let _e4551 = normal_vec;
        let _e4556 = constants.eos_r;
        f_l_1_ = (((_cse_764_ * dot(((_cse_765_ * 1f) / vec2(_cse_782_)), _e4551)) + (((_cse_782_ * _e4556) * (_e121 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)))) * _cse_784_)) - _cse_785_);
        let _e4570 = normal_vec;
        let _e4575 = constants.eos_r;
        f_r_1_ = (((_cse_772_ * dot(((_cse_773_ * 1f) / vec2(_cse_804_)), _e4570)) + (((_cse_804_ * _e4575) * (_e394 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)))) * _cse_784_)) - _cse_785_);
    }
    let _e4591 = constants.scheme;
    if ((_e4591 == 2u) && !(is_boundary_1)) {
        let _cse_814_ = (_cse_1850_ * 0.625f);
        let _cse_815_ = (_cse_1856_ * 0.375f);
        let _cse_813_ = (_cse_814_ + _cse_815_);
        let _cse_817_ = (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f);
        let _cse_812_ = (_cse_813_ + _cse_817_);
        let _cse_811_ = (_cse_812_ - _cse_1850_);
        let _cse_809_ = (_cse_1850_ + _cse_811_);
        let _cse_823_ = (_cse_1860_ * 0.625f);
        let _cse_824_ = (_cse_1866_ * 0.375f);
        let _cse_822_ = (_cse_823_ + _cse_824_);
        let _cse_826_ = (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f);
        let _cse_821_ = (_cse_822_ + _cse_826_);
        let _cse_820_ = (_cse_821_ - _cse_1860_);
        let _cse_818_ = (_cse_1860_ + _cse_820_);
        let _cse_808_ = vec2<f32>(_cse_809_, _cse_818_);
        let _cse_807_ = _cse_808_.x;
        let _cse_833_ = (_cse_1856_ * 0.625f);
        let _cse_834_ = (_cse_1850_ * 0.375f);
        let _cse_832_ = (_cse_833_ + _cse_834_);
        let _cse_837_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_836_ = dot(_cse_837_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_835_ = (_cse_836_ * 0.125f);
        let _cse_831_ = (_cse_832_ + _cse_835_);
        let _cse_830_ = (_cse_831_ - _cse_1856_);
        let _cse_829_ = (_cse_1856_ + _cse_830_);
        let _cse_842_ = (_cse_1866_ * 0.625f);
        let _cse_843_ = (_cse_1860_ * 0.375f);
        let _cse_841_ = (_cse_842_ + _cse_843_);
        let _cse_846_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_845_ = dot(_cse_846_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_844_ = (_cse_845_ * 0.125f);
        let _cse_840_ = (_cse_841_ + _cse_844_);
        let _cse_839_ = (_cse_840_ - _cse_1866_);
        let _cse_838_ = (_cse_1866_ + _cse_839_);
        let _cse_828_ = vec2<f32>(_cse_829_, _cse_838_);
        let _cse_827_ = _cse_828_.x;
        let _cse_849_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_848_ = (_cse_849_ - _e234);
        let _cse_847_ = (_e234 + _cse_848_);
        let _cse_850_ = normal_vec.x;
        let _cse_858_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e4680 = lambda;
        let _cse_857_ = (_cse_858_ * _e4680);
        let _cse_856_ = (_cse_857_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _cse_855_ = _cse_856_.x;
        let _cse_864_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e4691 = lambda;
        let _cse_863_ = (_cse_864_ * _e4691);
        let _cse_862_ = (_cse_863_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _cse_861_ = _cse_862_.y;
        let _cse_860_ = (_cse_855_ + _cse_861_);
        let _cse_859_ = (0.6666667f * _cse_860_);
        let _cse_854_ = (_cse_855_ - _cse_859_);
        let _cse_853_ = (_cse_854_ * _cse_850_);
        let _cse_866_ = _cse_862_.x;
        let _e4704 = normal_vec.y;
        let _cse_865_ = (_cse_866_ * _e4704);
        let _cse_852_ = (_cse_853_ + _cse_865_);
        let _e4709 = constants.viscosity;
        let _cse_851_ = (_e4709 * _cse_852_);
        let _cse_870_ = (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_869_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_870_);
        let _cse_868_ = (_cse_869_ - _e616);
        let _cse_867_ = (_e616 + _cse_868_);
        u_l_1_ = _cse_807_;
        u_r_1_ = _cse_827_;
        let _e4732 = normal_vec;
        let _e4737 = constants.eos_r;
        f_l_1_ = (((_cse_807_ * dot(((_cse_808_ * 1f) / vec2(_cse_847_)), _e4732)) + (((_cse_847_ * _e4737) * ((((_e121 + (_e121 * 0.625f)) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) * _cse_850_)) - _cse_851_);
        let _e4760 = normal_vec;
        let _e4765 = constants.eos_r;
        f_r_1_ = (((_cse_827_ * dot(((_cse_828_ * 1f) / vec2(_cse_867_)), _e4760)) + (((_cse_867_ * _e4765) * ((((_e394 + (_e394 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)) * _cse_850_)) - _cse_851_);
    }
    let _e4790 = constants.scheme;
    if ((_e4790 == 3u) && !(is_boundary_1)) {
        let _cse_877_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_879_ = (_cse_1856_ - _cse_1850_);
        let _cse_878_ = min(_cse_879_, 0f);
        let _cse_876_ = max(_cse_877_, _cse_878_);
        let _cse_881_ = max(_cse_879_, 0f);
        let _cse_875_ = min(_cse_876_, _cse_881_);
        let _cse_873_ = (_cse_1850_ + _cse_875_);
        let _cse_886_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_888_ = (_cse_1866_ - _cse_1860_);
        let _cse_887_ = min(_cse_888_, 0f);
        let _cse_885_ = max(_cse_886_, _cse_887_);
        let _cse_890_ = max(_cse_888_, 0f);
        let _cse_884_ = min(_cse_885_, _cse_890_);
        let _cse_882_ = (_cse_1860_ + _cse_884_);
        let _cse_872_ = vec2<f32>(_cse_873_, _cse_882_);
        let _cse_871_ = _cse_872_.x;
        let _cse_897_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_896_ = dot(_cse_897_, (face_center_vec - c_neigh_cell_vec));
        let _cse_899_ = (_cse_1850_ - _cse_1856_);
        let _cse_898_ = min(_cse_899_, 0f);
        let _cse_895_ = max(_cse_896_, _cse_898_);
        let _cse_900_ = max(_cse_899_, 0f);
        let _cse_894_ = min(_cse_895_, _cse_900_);
        let _cse_893_ = (_cse_1856_ + _cse_894_);
        let _cse_905_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_904_ = dot(_cse_905_, (face_center_vec - c_neigh_cell_vec));
        let _cse_907_ = (_cse_1860_ - _cse_1866_);
        let _cse_906_ = min(_cse_907_, 0f);
        let _cse_903_ = max(_cse_904_, _cse_906_);
        let _cse_908_ = max(_cse_907_, 0f);
        let _cse_902_ = min(_cse_903_, _cse_908_);
        let _cse_901_ = (_cse_1866_ + _cse_902_);
        let _cse_892_ = vec2<f32>(_cse_893_, _cse_901_);
        let _cse_891_ = _cse_892_.x;
        let _cse_911_ = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e616 - _e234), 0f));
        let _cse_910_ = min(_cse_911_, max((_e616 - _e234), 0f));
        let _cse_909_ = (_e234 + _cse_910_);
        let _cse_912_ = normal_vec.x;
        let _cse_920_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e4870 = lambda;
        let _cse_919_ = (_cse_920_ * _e4870);
        let _cse_921_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_918_ = (_cse_919_ + _cse_921_);
        let _cse_917_ = _cse_918_.x;
        let _cse_927_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e4881 = lambda;
        let _cse_926_ = (_cse_927_ * _e4881);
        let _cse_928_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_925_ = (_cse_926_ + _cse_928_);
        let _cse_924_ = _cse_925_.y;
        let _cse_923_ = (_cse_917_ + _cse_924_);
        let _cse_922_ = (0.6666667f * _cse_923_);
        let _cse_916_ = (_cse_917_ - _cse_922_);
        let _cse_915_ = (_cse_916_ * _cse_912_);
        let _cse_930_ = _cse_925_.x;
        let _e4894 = normal_vec.y;
        let _cse_929_ = (_cse_930_ * _e4894);
        let _cse_914_ = (_cse_915_ + _cse_929_);
        let _e4899 = constants.viscosity;
        let _cse_913_ = (_e4899 * _cse_914_);
        let _cse_934_ = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec));
        let _cse_933_ = max(_cse_934_, min((_e234 - _e616), 0f));
        let _cse_932_ = min(_cse_933_, max((_e234 - _e616), 0f));
        let _cse_931_ = (_e616 + _cse_932_);
        u_l_1_ = _cse_871_;
        u_r_1_ = _cse_891_;
        let _e4921 = normal_vec;
        let _e4926 = constants.eos_r;
        f_l_1_ = (((_cse_871_ * dot(((_cse_872_ * 1f) / vec2(_cse_909_)), _e4921)) + (((_cse_909_ * _e4926) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f)))) * _cse_912_)) - _cse_913_);
        let _e4948 = normal_vec;
        let _e4953 = constants.eos_r;
        f_r_1_ = (((_cse_891_ * dot(((_cse_892_ * 1f) / vec2(_cse_931_)), _e4948)) + (((_cse_931_ * _e4953) * (_e394 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f)))) * _cse_912_)) - _cse_913_);
    }
    let _e4977 = constants.scheme;
    if ((_e4977 == 4u) && !(is_boundary_1)) {
        let _cse_938_ = (vec2<f32>(_cse_1856_, _cse_1866_) - vec2<f32>(_cse_1850_, _cse_1860_));
        let _cse_949_ = vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_948_ = dot(_cse_938_, _cse_949_);
        let _cse_950_ = dot(_cse_938_, _cse_938_);
        let _cse_947_ = (_cse_948_ * _cse_950_);
        let _cse_952_ = (_cse_950_ * _cse_950_);
        let _cse_951_ = (_cse_952_ + 0.000000000000000000000000000001f);
        let _cse_946_ = (_cse_947_ / _cse_951_);
        let _cse_945_ = (2f * _cse_946_);
        let _cse_944_ = (_cse_945_ - 1f);
        let _cse_943_ = min(_cse_944_, 1999f);
        let _cse_942_ = max(-2001f, _cse_943_);
        let _cse_953_ = abs(_cse_942_);
        let _cse_941_ = (_cse_942_ + _cse_953_);
        let _cse_954_ = (1f + _cse_953_);
        let _cse_940_ = (_cse_941_ / _cse_954_);
        let _cse_939_ = (_cse_940_ * lambda_other);
        let _cse_937_ = (_cse_938_ * _cse_939_);
        let _cse_936_ = (vec2<f32>(_cse_1850_, _cse_1860_) + _cse_937_);
        let _cse_935_ = _cse_936_.x;
        let _cse_970_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_969_ = dot((c_neigh_cell_vec - c_owner_vec), _cse_970_);
        let _cse_972_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_971_ = dot((c_neigh_cell_vec - c_owner_vec), _cse_972_);
        let _cse_968_ = vec2<f32>(_cse_969_, _cse_971_);
        let _cse_967_ = dot(_cse_938_, _cse_968_);
        let _cse_966_ = (_cse_967_ * _cse_950_);
        let _cse_965_ = (_cse_966_ / _cse_951_);
        let _cse_964_ = (2f * _cse_965_);
        let _cse_963_ = (_cse_964_ - 1f);
        let _cse_962_ = min(_cse_963_, 1999f);
        let _cse_961_ = max(-2001f, _cse_962_);
        let _cse_973_ = abs(_cse_961_);
        let _cse_960_ = (_cse_961_ + _cse_973_);
        let _cse_974_ = (1f + _cse_973_);
        let _cse_959_ = (_cse_960_ / _cse_974_);
        let _e5048 = lambda;
        let _cse_958_ = (_cse_959_ * _e5048);
        let _cse_957_ = (_cse_938_ * _cse_958_);
        let _cse_956_ = (vec2<f32>(_cse_1856_, _cse_1866_) - _cse_957_);
        let _cse_955_ = _cse_956_.x;
        let _cse_984_ = (((_e616 - _e234) * (_e616 - _e234)) + 0.000000000000000000000000000001f);
        let _cse_983_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (_e616 - _e234)) / _cse_984_);
        let _cse_982_ = (2f * _cse_983_);
        let _cse_981_ = (_cse_982_ - 1f);
        let _cse_980_ = min(_cse_981_, 1999f);
        let _cse_979_ = max(-2001f, _cse_980_);
        let _cse_985_ = abs(_cse_979_);
        let _cse_978_ = ((_cse_979_ + _cse_985_) / (1f + _cse_985_));
        let _cse_977_ = (_cse_978_ * lambda_other);
        let _cse_976_ = (_cse_977_ * (_e616 - _e234));
        let _cse_975_ = (_e234 + _cse_976_);
        let _e5087 = lambda;
        let _e5098 = lambda;
        let _e5109 = lambda;
        let _e5120 = normal_vec.x;
        let _e5127 = lambda;
        let _e5134 = normal_vec.y;
        let _cse_987_ = (((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e5087) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x - (0.6666667f * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e5098) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e5109) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y))) * _e5120) + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e5127) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).x * _e5134));
        let _e5139 = constants.viscosity;
        let _cse_986_ = (_e5139 * _cse_987_);
        let _cse_997_ = (dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e616 - _e234));
        let _cse_996_ = (_cse_997_ / _cse_984_);
        let _cse_995_ = (2f * _cse_996_);
        let _cse_994_ = (_cse_995_ - 1f);
        let _cse_993_ = min(_cse_994_, 1999f);
        let _cse_992_ = max(-2001f, _cse_993_);
        let _cse_998_ = abs(_cse_992_);
        let _cse_991_ = ((_cse_992_ + _cse_998_) / (1f + _cse_998_));
        let _e5164 = lambda;
        let _cse_990_ = (_cse_991_ * _e5164);
        let _cse_989_ = (_cse_990_ * (_e616 - _e234));
        let _cse_988_ = (_e616 - _cse_989_);
        u_l_1_ = _cse_935_;
        u_r_1_ = _cse_955_;
        let _e5173 = normal_vec;
        let _e5178 = constants.eos_r;
        let _e5249 = normal_vec.x;
        f_l_1_ = (((_cse_935_ * dot(((_cse_936_ * 1f) / vec2(_cse_975_)), _e5173)) + (((_cse_975_ * _e5178) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e394 - _e121)))) * _e5249)) - _cse_986_);
        let _e5257 = normal_vec;
        let _e5262 = constants.eos_r;
        let _e5339 = lambda;
        let _e5346 = normal_vec.x;
        f_r_1_ = (((_cse_955_ * dot(((_cse_956_ * 1f) / vec2(_cse_988_)), _e5257)) + (((_cse_988_ * _e5262) * (_e394 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e5339) * (_e394 - _e121)))) * _e5346)) - _cse_986_);
    }
    let _e5352 = constants.scheme;
    if ((_e5352 == 5u) && !(is_boundary_1)) {
        let _cse_1007_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_1006_ = (_cse_1007_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1005_ = (_cse_1006_ - _cse_1850_);
        let _cse_1010_ = (_cse_1856_ - _cse_1850_);
        let _cse_1009_ = min(_cse_1010_, 0f);
        let _cse_1004_ = max(_cse_1005_, _cse_1009_);
        let _cse_1011_ = max(_cse_1010_, 0f);
        let _cse_1003_ = min(_cse_1004_, _cse_1011_);
        let _cse_1001_ = (_cse_1850_ + _cse_1003_);
        let _cse_1018_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_1017_ = (_cse_1018_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1016_ = (_cse_1017_ - _cse_1860_);
        let _cse_1021_ = (_cse_1866_ - _cse_1860_);
        let _cse_1020_ = min(_cse_1021_, 0f);
        let _cse_1015_ = max(_cse_1016_, _cse_1020_);
        let _cse_1022_ = max(_cse_1021_, 0f);
        let _cse_1014_ = min(_cse_1015_, _cse_1022_);
        let _cse_1012_ = (_cse_1860_ + _cse_1014_);
        let _cse_1000_ = vec2<f32>(_cse_1001_, _cse_1012_);
        let _cse_999_ = _cse_1000_.x;
        let _cse_1030_ = ((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f));
        let _cse_1031_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1029_ = (_cse_1030_ + _cse_1031_);
        let _cse_1028_ = (_cse_1029_ - _cse_1856_);
        let _cse_1033_ = (_cse_1850_ - _cse_1856_);
        let _cse_1032_ = min(_cse_1033_, 0f);
        let _cse_1027_ = max(_cse_1028_, _cse_1032_);
        let _cse_1034_ = max(_cse_1033_, 0f);
        let _cse_1026_ = min(_cse_1027_, _cse_1034_);
        let _cse_1025_ = (_cse_1856_ + _cse_1026_);
        let _cse_1040_ = ((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f));
        let _cse_1041_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1039_ = (_cse_1040_ + _cse_1041_);
        let _cse_1038_ = (_cse_1039_ - _cse_1866_);
        let _cse_1043_ = (_cse_1860_ - _cse_1866_);
        let _cse_1042_ = min(_cse_1043_, 0f);
        let _cse_1037_ = max(_cse_1038_, _cse_1042_);
        let _cse_1044_ = max(_cse_1043_, 0f);
        let _cse_1036_ = min(_cse_1037_, _cse_1044_);
        let _cse_1035_ = (_cse_1866_ + _cse_1036_);
        let _cse_1024_ = vec2<f32>(_cse_1025_, _cse_1035_);
        let _cse_1023_ = _cse_1024_.x;
        let _cse_1046_ = min(max(((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e616 - _e234), 0f)), max((_e616 - _e234), 0f));
        let _cse_1045_ = (_e234 + _cse_1046_);
        let _cse_1054_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e5475 = lambda;
        let _cse_1053_ = (_cse_1054_ * _e5475);
        let _cse_1052_ = (_cse_1053_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _cse_1051_ = _cse_1052_.x;
        let _cse_1059_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e5486 = lambda;
        let _cse_1058_ = (_cse_1059_ * _e5486);
        let _cse_1057_ = (_cse_1058_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _cse_1056_ = (_cse_1051_ + _cse_1057_.y);
        let _cse_1055_ = (0.6666667f * _cse_1056_);
        let _cse_1050_ = (_cse_1051_ - _cse_1055_);
        let _e5497 = normal_vec.x;
        let _cse_1049_ = (_cse_1050_ * _e5497);
        let _e5501 = normal_vec.y;
        let _cse_1048_ = (_cse_1049_ + (_cse_1057_.x * _e5501));
        let _e5506 = constants.viscosity;
        let _cse_1047_ = (_e5506 * _cse_1048_);
        let _cse_1062_ = max(((((_e616 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e616), min((_e234 - _e616), 0f));
        let _cse_1061_ = min(_cse_1062_, max((_e234 - _e616), 0f));
        let _cse_1060_ = (_e616 + _cse_1061_);
        u_l_1_ = _cse_999_;
        u_r_1_ = _cse_1023_;
        let _e5537 = normal_vec;
        let _e5542 = constants.eos_r;
        let _e5567 = normal_vec.x;
        f_l_1_ = (((_cse_999_ * dot(((_cse_1000_ * 1f) / vec2(_cse_1045_)), _e5537)) + (((_cse_1045_ * _e5542) * (_e121 + min(max(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f)))) * _e5567)) - _cse_1047_);
        let _e5575 = normal_vec;
        let _e5580 = constants.eos_r;
        let _e5609 = normal_vec.x;
        f_r_1_ = (((_cse_1023_ * dot(((_cse_1024_ * 1f) / vec2(_cse_1060_)), _e5575)) + (((_cse_1060_ * _e5580) * (_e394 + min(max(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f)))) * _e5609)) - _cse_1047_);
    }
    let _e5615 = constants.scheme;
    if ((_e5615 == 6u) && !(is_boundary_1)) {
        let _cse_1071_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_1070_ = (_cse_1071_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1069_ = (_cse_1070_ - _cse_1850_);
        let _cse_1074_ = (_cse_1856_ - _cse_1850_);
        let _cse_1075_ = max(abs(_cse_1074_), (abs(_cse_1069_) + 0.00000001f));
        let _cse_1073_ = (abs(_cse_1074_) / _cse_1075_);
        let _cse_1068_ = (_cse_1069_ * _cse_1073_);
        let _cse_1077_ = (_cse_1074_ * _cse_1069_);
        let _cse_1076_ = (max(_cse_1077_, 0f) / max(abs(_cse_1077_), 0.00000001f));
        let _cse_1067_ = (_cse_1068_ * _cse_1076_);
        let _cse_1065_ = (_cse_1850_ + _cse_1067_);
        let _cse_1084_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_1083_ = (_cse_1084_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1082_ = (_cse_1083_ - _cse_1860_);
        let _cse_1087_ = (_cse_1866_ - _cse_1860_);
        let _cse_1088_ = max(abs(_cse_1087_), (abs(_cse_1082_) + 0.00000001f));
        let _cse_1086_ = (abs(_cse_1087_) / _cse_1088_);
        let _cse_1081_ = (_cse_1082_ * _cse_1086_);
        let _cse_1090_ = (_cse_1087_ * _cse_1082_);
        let _cse_1089_ = (max(_cse_1090_, 0f) / max(abs(_cse_1090_), 0.00000001f));
        let _cse_1080_ = (_cse_1081_ * _cse_1089_);
        let _cse_1078_ = (_cse_1860_ + _cse_1080_);
        let _cse_1064_ = vec2<f32>(_cse_1065_, _cse_1078_);
        let _cse_1063_ = _cse_1064_.x;
        let _cse_1098_ = ((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f));
        let _cse_1100_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1099_ = (_cse_1100_ * 0.125f);
        let _cse_1097_ = (_cse_1098_ + _cse_1099_);
        let _cse_1096_ = (_cse_1097_ - _cse_1856_);
        let _cse_1102_ = (_cse_1850_ - _cse_1856_);
        let _cse_1103_ = max(abs(_cse_1102_), (abs(_cse_1096_) + 0.00000001f));
        let _cse_1101_ = (abs(_cse_1102_) / _cse_1103_);
        let _cse_1095_ = (_cse_1096_ * _cse_1101_);
        let _cse_1106_ = (_cse_1102_ * _cse_1096_);
        let _cse_1105_ = max(_cse_1106_, 0f);
        let _cse_1108_ = abs(_cse_1106_);
        let _cse_1107_ = max(_cse_1108_, 0.00000001f);
        let _cse_1104_ = (_cse_1105_ / _cse_1107_);
        let _cse_1094_ = (_cse_1095_ * _cse_1104_);
        let _cse_1093_ = (_cse_1856_ + _cse_1094_);
        let _cse_1114_ = ((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f));
        let _cse_1116_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1115_ = (_cse_1116_ * 0.125f);
        let _cse_1113_ = (_cse_1114_ + _cse_1115_);
        let _cse_1112_ = (_cse_1113_ - _cse_1866_);
        let _cse_1118_ = (_cse_1860_ - _cse_1866_);
        let _cse_1119_ = max(abs(_cse_1118_), (abs(_cse_1112_) + 0.00000001f));
        let _cse_1117_ = (abs(_cse_1118_) / _cse_1119_);
        let _cse_1111_ = (_cse_1112_ * _cse_1117_);
        let _cse_1122_ = (_cse_1118_ * _cse_1112_);
        let _cse_1121_ = max(_cse_1122_, 0f);
        let _cse_1124_ = abs(_cse_1122_);
        let _cse_1123_ = max(_cse_1124_, 0.00000001f);
        let _cse_1120_ = (_cse_1121_ / _cse_1123_);
        let _cse_1110_ = (_cse_1111_ * _cse_1120_);
        let _cse_1109_ = (_cse_1866_ + _cse_1110_);
        let _cse_1092_ = vec2<f32>(_cse_1093_, _cse_1109_);
        let _cse_1091_ = _cse_1092_.x;
        let _cse_1126_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1125_ = (_cse_1126_ - _e616);
        u_l_1_ = _cse_1063_;
        u_r_1_ = _cse_1091_;
        let _e5842 = normal_vec;
        let _e5917 = constants.eos_r;
        let _e5991 = normal_vec.x;
        let _e5996 = constants.viscosity;
        let _e6002 = lambda;
        let _e6013 = lambda;
        let _e6024 = lambda;
        let _e6035 = normal_vec.x;
        let _e6042 = lambda;
        let _e6049 = normal_vec.y;
        f_l_1_ = (((_cse_1063_ * dot(((_cse_1064_ * 1f) / vec2((_e234 + ((((((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e616 - _e234))) / max(abs((_e616 - _e234)), (abs(((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))))), _e5842)) + ((((_e234 + ((((((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e616 - _e234))) / max(abs((_e616 - _e234)), (abs(((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))) * _e5917) * (_e121 + ((((((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e394 - _e121))) / max(abs((_e394 - _e121)), (abs(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) * _e5991)) - (_e5996 * (((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6002) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x - (0.6666667f * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6013) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6024) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y))) * _e6035) + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6042) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).x * _e6049))));
        let _e6080 = normal_vec;
        let _e6107 = constants.eos_r;
        let _e6197 = normal_vec.x;
        let _e6202 = constants.viscosity;
        let _e6208 = lambda;
        let _e6219 = lambda;
        let _e6230 = lambda;
        let _e6241 = normal_vec.x;
        let _e6248 = lambda;
        let _e6255 = normal_vec.y;
        f_r_1_ = (((_cse_1091_ * dot(((_cse_1092_ * 1f) / vec2((_e616 + ((((_cse_1125_ * abs((_e234 - _e616))) / max(abs((_e234 - _e616)), (abs(_cse_1125_) + 0.00000001f))) * max(((_e234 - _e616) * _cse_1125_), 0f)) / max(abs(((_e234 - _e616) * _cse_1125_)), 0.00000001f))))), _e6080)) + ((((_e616 + ((((_cse_1125_ * abs((_e234 - _e616))) / max(abs((_e234 - _e616)), (abs(_cse_1125_) + 0.00000001f))) * max(((_e234 - _e616) * _cse_1125_), 0f)) / max(abs(((_e234 - _e616) * _cse_1125_)), 0.00000001f))) * _e6107) * (_e394 + ((((((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394) * abs((_e121 - _e394))) / max(abs((_e121 - _e394)), (abs(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)) + 0.00000001f))) * max(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)), 0f)) / max(abs(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394))), 0.00000001f)))) * _e6197)) - (_e6202 * (((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6208) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x - (0.6666667f * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6219) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6230) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y))) * _e6241) + (((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6248) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).x * _e6255))));
    }
    let _e6266 = a_plus;
    let _e6267 = f_l_1_;
    let _e6269 = a_minus;
    let _e6270 = f_r_1_;
    let _e6273 = a_plus;
    let _e6274 = a_minus;
    let _e6276 = u_r_1_;
    let _e6277 = u_l_1_;
    fluxes[((idx * 8u) + 1u)] = (((((_e6266 * _e6267) - (_e6269 * _e6270)) + ((_e6273 * _e6274) * (_e6276 - _e6277))) / denom) * area);
    let _cse_1128_ = vec2<f32>(_cse_1850_, _cse_1860_);
    let _cse_1127_ = _cse_1128_.y;
    let _cse_1132_ = vec2<f32>(_cse_1856_, _cse_1866_);
    let _cse_1131_ = _cse_1132_.y;
    let _cse_1135_ = normal_vec.y;
    let _cse_1142_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
    let _e6294 = lambda;
    let _cse_1141_ = (_cse_1142_ * _e6294);
    let _cse_1143_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
    let _cse_1140_ = (_cse_1141_ + _cse_1143_);
    let _cse_1139_ = _cse_1140_.y;
    let _cse_1144_ = normal_vec.x;
    let _cse_1138_ = (_cse_1139_ * _cse_1144_);
    let _cse_1150_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
    let _e6308 = lambda;
    let _cse_1149_ = (_cse_1150_ * _e6308);
    let _cse_1151_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
    let _cse_1148_ = (_cse_1149_ + _cse_1151_);
    let _cse_1147_ = _cse_1148_.y;
    let _cse_1154_ = _cse_1140_.x;
    let _cse_1153_ = (_cse_1154_ + _cse_1147_);
    let _cse_1152_ = (0.6666667f * _cse_1153_);
    let _cse_1146_ = (_cse_1147_ - _cse_1152_);
    let _cse_1145_ = (_cse_1146_ * _cse_1135_);
    let _cse_1137_ = (_cse_1138_ + _cse_1145_);
    let _e6323 = constants.viscosity;
    let _cse_1136_ = (_e6323 * _cse_1137_);
    u_l_2_ = _cse_1127_;
    u_r_2_ = _cse_1131_;
    let _e6331 = normal_vec;
    let _e6336 = constants.eos_r;
    f_l_2_ = (((_cse_1127_ * dot(((_cse_1128_ * 1f) / vec2(_e234)), _e6331)) + (((_e234 * _e6336) * _e121) * _cse_1135_)) - _cse_1136_);
    let _e6347 = normal_vec;
    let _e6352 = constants.eos_r;
    f_r_2_ = (((_cse_1131_ * dot(((_cse_1132_ * 1f) / vec2(_e616)), _e6347)) + (((_e616 * _e6352) * _e394) * _cse_1135_)) - _cse_1136_);
    let _e6361 = constants.scheme;
    if ((_e6361 == 1u) && !(is_boundary_1)) {
        let _cse_1159_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_1157_ = (_cse_1850_ + _cse_1159_);
        let _cse_1162_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_1160_ = (_cse_1860_ + _cse_1162_);
        let _cse_1156_ = vec2<f32>(_cse_1157_, _cse_1160_);
        let _cse_1155_ = _cse_1156_.y;
        let _cse_1168_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_1167_ = dot(_cse_1168_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1165_ = (_cse_1856_ + _cse_1167_);
        let _cse_1172_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_1171_ = dot(_cse_1172_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1169_ = (_cse_1866_ + _cse_1171_);
        let _cse_1164_ = vec2<f32>(_cse_1165_, _cse_1169_);
        let _cse_1163_ = _cse_1164_.y;
        let _cse_1174_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_1173_ = (_e234 + _cse_1174_);
        let _cse_1175_ = normal_vec.y;
        let _cse_1182_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e6405 = lambda;
        let _cse_1181_ = (_cse_1182_ * _e6405);
        let _cse_1183_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_1180_ = (_cse_1181_ + _cse_1183_);
        let _cse_1179_ = _cse_1180_.y;
        let _cse_1184_ = normal_vec.x;
        let _cse_1178_ = (_cse_1179_ * _cse_1184_);
        let _cse_1190_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e6419 = lambda;
        let _cse_1189_ = (_cse_1190_ * _e6419);
        let _cse_1191_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_1188_ = (_cse_1189_ + _cse_1191_);
        let _cse_1187_ = _cse_1188_.y;
        let _cse_1194_ = _cse_1180_.x;
        let _cse_1193_ = (_cse_1194_ + _cse_1187_);
        let _cse_1192_ = (0.6666667f * _cse_1193_);
        let _cse_1186_ = (_cse_1187_ - _cse_1192_);
        let _cse_1185_ = (_cse_1186_ * _cse_1175_);
        let _cse_1177_ = (_cse_1178_ + _cse_1185_);
        let _e6434 = constants.viscosity;
        let _cse_1176_ = (_e6434 * _cse_1177_);
        let _cse_1197_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1196_ = dot(_cse_1197_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1195_ = (_e616 + _cse_1196_);
        u_l_2_ = _cse_1155_;
        u_r_2_ = _cse_1163_;
        let _e6448 = normal_vec;
        let _e6453 = constants.eos_r;
        f_l_2_ = (((_cse_1155_ * dot(((_cse_1156_ * 1f) / vec2(_cse_1173_)), _e6448)) + (((_cse_1173_ * _e6453) * (_e121 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)))) * _cse_1175_)) - _cse_1176_);
        let _e6467 = normal_vec;
        let _e6472 = constants.eos_r;
        f_r_2_ = (((_cse_1163_ * dot(((_cse_1164_ * 1f) / vec2(_cse_1195_)), _e6467)) + (((_cse_1195_ * _e6472) * (_e394 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)))) * _cse_1175_)) - _cse_1176_);
    }
    let _e6488 = constants.scheme;
    if ((_e6488 == 2u) && !(is_boundary_1)) {
        let _cse_1205_ = (_cse_1850_ * 0.625f);
        let _cse_1206_ = (_cse_1856_ * 0.375f);
        let _cse_1204_ = (_cse_1205_ + _cse_1206_);
        let _cse_1208_ = (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f);
        let _cse_1203_ = (_cse_1204_ + _cse_1208_);
        let _cse_1202_ = (_cse_1203_ - _cse_1850_);
        let _cse_1200_ = (_cse_1850_ + _cse_1202_);
        let _cse_1214_ = (_cse_1860_ * 0.625f);
        let _cse_1215_ = (_cse_1866_ * 0.375f);
        let _cse_1213_ = (_cse_1214_ + _cse_1215_);
        let _cse_1217_ = (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f);
        let _cse_1212_ = (_cse_1213_ + _cse_1217_);
        let _cse_1211_ = (_cse_1212_ - _cse_1860_);
        let _cse_1209_ = (_cse_1860_ + _cse_1211_);
        let _cse_1199_ = vec2<f32>(_cse_1200_, _cse_1209_);
        let _cse_1198_ = _cse_1199_.y;
        let _cse_1224_ = (_cse_1856_ * 0.625f);
        let _cse_1225_ = (_cse_1850_ * 0.375f);
        let _cse_1223_ = (_cse_1224_ + _cse_1225_);
        let _cse_1228_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_1227_ = dot(_cse_1228_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1226_ = (_cse_1227_ * 0.125f);
        let _cse_1222_ = (_cse_1223_ + _cse_1226_);
        let _cse_1221_ = (_cse_1222_ - _cse_1856_);
        let _cse_1220_ = (_cse_1856_ + _cse_1221_);
        let _cse_1233_ = (_cse_1866_ * 0.625f);
        let _cse_1234_ = (_cse_1860_ * 0.375f);
        let _cse_1232_ = (_cse_1233_ + _cse_1234_);
        let _cse_1237_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_1236_ = dot(_cse_1237_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1235_ = (_cse_1236_ * 0.125f);
        let _cse_1231_ = (_cse_1232_ + _cse_1235_);
        let _cse_1230_ = (_cse_1231_ - _cse_1866_);
        let _cse_1229_ = (_cse_1866_ + _cse_1230_);
        let _cse_1219_ = vec2<f32>(_cse_1220_, _cse_1229_);
        let _cse_1218_ = _cse_1219_.y;
        let _cse_1240_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1239_ = (_cse_1240_ - _e234);
        let _cse_1238_ = (_e234 + _cse_1239_);
        let _cse_1241_ = normal_vec.y;
        let _cse_1248_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e6577 = lambda;
        let _cse_1247_ = (_cse_1248_ * _e6577);
        let _cse_1246_ = (_cse_1247_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _cse_1245_ = _cse_1246_.y;
        let _e6584 = normal_vec.x;
        let _cse_1244_ = (_cse_1245_ * _e6584);
        let _cse_1254_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e6591 = lambda;
        let _cse_1253_ = (_cse_1254_ * _e6591);
        let _cse_1252_ = (_cse_1253_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _cse_1251_ = _cse_1252_.y;
        let _cse_1257_ = _cse_1246_.x;
        let _cse_1256_ = (_cse_1257_ + _cse_1251_);
        let _cse_1255_ = (0.6666667f * _cse_1256_);
        let _cse_1250_ = (_cse_1251_ - _cse_1255_);
        let _cse_1249_ = (_cse_1250_ * _cse_1241_);
        let _cse_1243_ = (_cse_1244_ + _cse_1249_);
        let _e6606 = constants.viscosity;
        let _cse_1242_ = (_e6606 * _cse_1243_);
        let _cse_1261_ = (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1260_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_1261_);
        let _cse_1259_ = (_cse_1260_ - _e616);
        let _cse_1258_ = (_e616 + _cse_1259_);
        u_l_2_ = _cse_1198_;
        u_r_2_ = _cse_1218_;
        let _e6629 = normal_vec;
        let _e6634 = constants.eos_r;
        f_l_2_ = (((_cse_1198_ * dot(((_cse_1199_ * 1f) / vec2(_cse_1238_)), _e6629)) + (((_cse_1238_ * _e6634) * ((((_e121 + (_e121 * 0.625f)) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) * _cse_1241_)) - _cse_1242_);
        let _e6657 = normal_vec;
        let _e6662 = constants.eos_r;
        f_r_2_ = (((_cse_1218_ * dot(((_cse_1219_ * 1f) / vec2(_cse_1258_)), _e6657)) + (((_cse_1258_ * _e6662) * ((((_e394 + (_e394 * 0.625f)) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)) * _cse_1241_)) - _cse_1242_);
    }
    let _e6687 = constants.scheme;
    if ((_e6687 == 3u) && !(is_boundary_1)) {
        let _cse_1268_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_1270_ = (_cse_1856_ - _cse_1850_);
        let _cse_1269_ = min(_cse_1270_, 0f);
        let _cse_1267_ = max(_cse_1268_, _cse_1269_);
        let _cse_1272_ = max(_cse_1270_, 0f);
        let _cse_1266_ = min(_cse_1267_, _cse_1272_);
        let _cse_1264_ = (_cse_1850_ + _cse_1266_);
        let _cse_1277_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_1279_ = (_cse_1866_ - _cse_1860_);
        let _cse_1278_ = min(_cse_1279_, 0f);
        let _cse_1276_ = max(_cse_1277_, _cse_1278_);
        let _cse_1281_ = max(_cse_1279_, 0f);
        let _cse_1275_ = min(_cse_1276_, _cse_1281_);
        let _cse_1273_ = (_cse_1860_ + _cse_1275_);
        let _cse_1263_ = vec2<f32>(_cse_1264_, _cse_1273_);
        let _cse_1262_ = _cse_1263_.y;
        let _cse_1288_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_1287_ = dot(_cse_1288_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1290_ = (_cse_1850_ - _cse_1856_);
        let _cse_1289_ = min(_cse_1290_, 0f);
        let _cse_1286_ = max(_cse_1287_, _cse_1289_);
        let _cse_1291_ = max(_cse_1290_, 0f);
        let _cse_1285_ = min(_cse_1286_, _cse_1291_);
        let _cse_1284_ = (_cse_1856_ + _cse_1285_);
        let _cse_1296_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_1295_ = dot(_cse_1296_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1298_ = (_cse_1860_ - _cse_1866_);
        let _cse_1297_ = min(_cse_1298_, 0f);
        let _cse_1294_ = max(_cse_1295_, _cse_1297_);
        let _cse_1299_ = max(_cse_1298_, 0f);
        let _cse_1293_ = min(_cse_1294_, _cse_1299_);
        let _cse_1292_ = (_cse_1866_ + _cse_1293_);
        let _cse_1283_ = vec2<f32>(_cse_1284_, _cse_1292_);
        let _cse_1282_ = _cse_1283_.y;
        let _cse_1302_ = max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec)), min((_e616 - _e234), 0f));
        let _cse_1301_ = min(_cse_1302_, max((_e616 - _e234), 0f));
        let _cse_1300_ = (_e234 + _cse_1301_);
        let _cse_1303_ = normal_vec.y;
        let _cse_1310_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e6767 = lambda;
        let _cse_1309_ = (_cse_1310_ * _e6767);
        let _cse_1311_ = (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other);
        let _cse_1308_ = (_cse_1309_ + _cse_1311_);
        let _cse_1307_ = _cse_1308_.y;
        let _e6774 = normal_vec.x;
        let _cse_1306_ = (_cse_1307_ * _e6774);
        let _cse_1317_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e6781 = lambda;
        let _cse_1316_ = (_cse_1317_ * _e6781);
        let _cse_1318_ = (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other);
        let _cse_1315_ = (_cse_1316_ + _cse_1318_);
        let _cse_1314_ = _cse_1315_.y;
        let _cse_1321_ = _cse_1308_.x;
        let _cse_1320_ = (_cse_1321_ + _cse_1314_);
        let _cse_1319_ = (0.6666667f * _cse_1320_);
        let _cse_1313_ = (_cse_1314_ - _cse_1319_);
        let _cse_1312_ = (_cse_1313_ * _cse_1303_);
        let _cse_1305_ = (_cse_1306_ + _cse_1312_);
        let _e6796 = constants.viscosity;
        let _cse_1304_ = (_e6796 * _cse_1305_);
        let _cse_1325_ = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec));
        let _cse_1324_ = max(_cse_1325_, min((_e234 - _e616), 0f));
        let _cse_1323_ = min(_cse_1324_, max((_e234 - _e616), 0f));
        let _cse_1322_ = (_e616 + _cse_1323_);
        u_l_2_ = _cse_1262_;
        u_r_2_ = _cse_1282_;
        let _e6818 = normal_vec;
        let _e6823 = constants.eos_r;
        f_l_2_ = (((_cse_1262_ * dot(((_cse_1263_ * 1f) / vec2(_cse_1300_)), _e6818)) + (((_cse_1300_ * _e6823) * (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f)))) * _cse_1303_)) - _cse_1304_);
        let _e6845 = normal_vec;
        let _e6850 = constants.eos_r;
        f_r_2_ = (((_cse_1282_ * dot(((_cse_1283_ * 1f) / vec2(_cse_1322_)), _e6845)) + (((_cse_1322_ * _e6850) * (_e394 + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f)))) * _cse_1303_)) - _cse_1304_);
    }
    let _e6874 = constants.scheme;
    if ((_e6874 == 4u) && !(is_boundary_1)) {
        let _cse_1329_ = (vec2<f32>(_cse_1856_, _cse_1866_) - vec2<f32>(_cse_1850_, _cse_1860_));
        let _cse_1340_ = vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)));
        let _cse_1339_ = dot(_cse_1329_, _cse_1340_);
        let _cse_1341_ = dot(_cse_1329_, _cse_1329_);
        let _cse_1338_ = (_cse_1339_ * _cse_1341_);
        let _cse_1343_ = (_cse_1341_ * _cse_1341_);
        let _cse_1342_ = (_cse_1343_ + 0.000000000000000000000000000001f);
        let _cse_1337_ = (_cse_1338_ / _cse_1342_);
        let _cse_1336_ = (2f * _cse_1337_);
        let _cse_1335_ = (_cse_1336_ - 1f);
        let _cse_1334_ = min(_cse_1335_, 1999f);
        let _cse_1333_ = max(-2001f, _cse_1334_);
        let _cse_1344_ = abs(_cse_1333_);
        let _cse_1332_ = (_cse_1333_ + _cse_1344_);
        let _cse_1345_ = (1f + _cse_1344_);
        let _cse_1331_ = (_cse_1332_ / _cse_1345_);
        let _cse_1330_ = (_cse_1331_ * lambda_other);
        let _cse_1328_ = (_cse_1329_ * _cse_1330_);
        let _cse_1327_ = (vec2<f32>(_cse_1850_, _cse_1860_) + _cse_1328_);
        let _cse_1326_ = _cse_1327_.y;
        let _cse_1361_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_1360_ = dot((c_neigh_cell_vec - c_owner_vec), _cse_1361_);
        let _cse_1363_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_1362_ = dot((c_neigh_cell_vec - c_owner_vec), _cse_1363_);
        let _cse_1359_ = vec2<f32>(_cse_1360_, _cse_1362_);
        let _cse_1358_ = dot(_cse_1329_, _cse_1359_);
        let _cse_1357_ = (_cse_1358_ * _cse_1341_);
        let _cse_1356_ = (_cse_1357_ / _cse_1342_);
        let _cse_1355_ = (2f * _cse_1356_);
        let _cse_1354_ = (_cse_1355_ - 1f);
        let _cse_1353_ = min(_cse_1354_, 1999f);
        let _cse_1352_ = max(-2001f, _cse_1353_);
        let _cse_1364_ = abs(_cse_1352_);
        let _cse_1351_ = (_cse_1352_ + _cse_1364_);
        let _cse_1365_ = (1f + _cse_1364_);
        let _cse_1350_ = (_cse_1351_ / _cse_1365_);
        let _e6945 = lambda;
        let _cse_1349_ = (_cse_1350_ * _e6945);
        let _cse_1348_ = (_cse_1329_ * _cse_1349_);
        let _cse_1347_ = (vec2<f32>(_cse_1856_, _cse_1866_) - _cse_1348_);
        let _cse_1346_ = _cse_1347_.y;
        let _cse_1375_ = (((_e616 - _e234) * (_e616 - _e234)) + 0.000000000000000000000000000001f);
        let _cse_1374_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (_e616 - _e234)) / _cse_1375_);
        let _cse_1373_ = (2f * _cse_1374_);
        let _cse_1372_ = (_cse_1373_ - 1f);
        let _cse_1371_ = min(_cse_1372_, 1999f);
        let _cse_1370_ = max(-2001f, _cse_1371_);
        let _cse_1376_ = abs(_cse_1370_);
        let _cse_1369_ = ((_cse_1370_ + _cse_1376_) / (1f + _cse_1376_));
        let _cse_1368_ = (_cse_1369_ * lambda_other);
        let _cse_1367_ = (_cse_1368_ * (_e616 - _e234));
        let _cse_1366_ = (_e234 + _cse_1367_);
        let _e6984 = lambda;
        let _e6991 = normal_vec.x;
        let _e6998 = lambda;
        let _e7009 = lambda;
        let _e7020 = lambda;
        let _e7031 = normal_vec.y;
        let _cse_1378_ = ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e6984) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).y * _e6991) + ((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e6998) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y - (0.6666667f * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e7009) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e7020) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y))) * _e7031));
        let _e7036 = constants.viscosity;
        let _cse_1377_ = (_e7036 * _cse_1378_);
        let _cse_1388_ = (dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e616 - _e234));
        let _cse_1387_ = (_cse_1388_ / _cse_1375_);
        let _cse_1386_ = (2f * _cse_1387_);
        let _cse_1385_ = (_cse_1386_ - 1f);
        let _cse_1384_ = min(_cse_1385_, 1999f);
        let _cse_1383_ = max(-2001f, _cse_1384_);
        let _cse_1389_ = abs(_cse_1383_);
        let _cse_1382_ = ((_cse_1383_ + _cse_1389_) / (1f + _cse_1389_));
        let _e7061 = lambda;
        let _cse_1381_ = (_cse_1382_ * _e7061);
        let _cse_1380_ = (_cse_1381_ * (_e616 - _e234));
        let _cse_1379_ = (_e616 - _cse_1380_);
        u_l_2_ = _cse_1326_;
        u_r_2_ = _cse_1346_;
        let _e7070 = normal_vec;
        let _e7075 = constants.eos_r;
        let _e7146 = normal_vec.y;
        f_l_2_ = (((_cse_1326_ * dot(((_cse_1327_ * 1f) / vec2(_cse_1366_)), _e7070)) + (((_cse_1366_ * _e7075) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e394 - _e121)))) * _e7146)) - _cse_1377_);
        let _e7154 = normal_vec;
        let _e7159 = constants.eos_r;
        let _e7236 = lambda;
        let _e7243 = normal_vec.y;
        f_r_2_ = (((_cse_1346_ * dot(((_cse_1347_ * 1f) / vec2(_cse_1379_)), _e7154)) + (((_cse_1379_ * _e7159) * (_e394 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e7236) * (_e394 - _e121)))) * _e7243)) - _cse_1377_);
    }
    let _e7249 = constants.scheme;
    if ((_e7249 == 5u) && !(is_boundary_1)) {
        let _cse_1398_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_1397_ = (_cse_1398_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1396_ = (_cse_1397_ - _cse_1850_);
        let _cse_1401_ = (_cse_1856_ - _cse_1850_);
        let _cse_1400_ = min(_cse_1401_, 0f);
        let _cse_1395_ = max(_cse_1396_, _cse_1400_);
        let _cse_1402_ = max(_cse_1401_, 0f);
        let _cse_1394_ = min(_cse_1395_, _cse_1402_);
        let _cse_1392_ = (_cse_1850_ + _cse_1394_);
        let _cse_1409_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_1408_ = (_cse_1409_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1407_ = (_cse_1408_ - _cse_1860_);
        let _cse_1412_ = (_cse_1866_ - _cse_1860_);
        let _cse_1411_ = min(_cse_1412_, 0f);
        let _cse_1406_ = max(_cse_1407_, _cse_1411_);
        let _cse_1413_ = max(_cse_1412_, 0f);
        let _cse_1405_ = min(_cse_1406_, _cse_1413_);
        let _cse_1403_ = (_cse_1860_ + _cse_1405_);
        let _cse_1391_ = vec2<f32>(_cse_1392_, _cse_1403_);
        let _cse_1390_ = _cse_1391_.y;
        let _cse_1421_ = ((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f));
        let _cse_1422_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1420_ = (_cse_1421_ + _cse_1422_);
        let _cse_1419_ = (_cse_1420_ - _cse_1856_);
        let _cse_1424_ = (_cse_1850_ - _cse_1856_);
        let _cse_1423_ = min(_cse_1424_, 0f);
        let _cse_1418_ = max(_cse_1419_, _cse_1423_);
        let _cse_1425_ = max(_cse_1424_, 0f);
        let _cse_1417_ = min(_cse_1418_, _cse_1425_);
        let _cse_1416_ = (_cse_1856_ + _cse_1417_);
        let _cse_1431_ = ((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f));
        let _cse_1432_ = (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f);
        let _cse_1430_ = (_cse_1431_ + _cse_1432_);
        let _cse_1429_ = (_cse_1430_ - _cse_1866_);
        let _cse_1434_ = (_cse_1860_ - _cse_1866_);
        let _cse_1433_ = min(_cse_1434_, 0f);
        let _cse_1428_ = max(_cse_1429_, _cse_1433_);
        let _cse_1435_ = max(_cse_1434_, 0f);
        let _cse_1427_ = min(_cse_1428_, _cse_1435_);
        let _cse_1426_ = (_cse_1866_ + _cse_1427_);
        let _cse_1415_ = vec2<f32>(_cse_1416_, _cse_1426_);
        let _cse_1414_ = _cse_1415_.y;
        let _cse_1437_ = min(max(((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234), min((_e616 - _e234), 0f)), max((_e616 - _e234), 0f));
        let _cse_1436_ = (_e234 + _cse_1437_);
        let _cse_1442_ = vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1));
        let _e7372 = lambda;
        let _cse_1441_ = (_cse_1442_ * _e7372);
        let _cse_1440_ = (_cse_1441_ + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other));
        let _cse_1448_ = vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1));
        let _e7382 = lambda;
        let _cse_1447_ = (_cse_1448_ * _e7382);
        let _cse_1446_ = (_cse_1447_ + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other));
        let _cse_1445_ = _cse_1446_.y;
        let _cse_1450_ = (_cse_1440_.x + _cse_1445_);
        let _cse_1449_ = (0.6666667f * _cse_1450_);
        let _cse_1444_ = (_cse_1445_ - _cse_1449_);
        let _e7394 = normal_vec.y;
        let _cse_1443_ = (_cse_1444_ * _e7394);
        let _e7398 = normal_vec.x;
        let _cse_1439_ = ((_cse_1440_.y * _e7398) + _cse_1443_);
        let _e7403 = constants.viscosity;
        let _cse_1438_ = (_e7403 * _cse_1439_);
        let _cse_1453_ = max(((((_e616 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e616), min((_e234 - _e616), 0f));
        let _cse_1452_ = min(_cse_1453_, max((_e234 - _e616), 0f));
        let _cse_1451_ = (_e616 + _cse_1452_);
        u_l_2_ = _cse_1390_;
        u_r_2_ = _cse_1414_;
        let _e7434 = normal_vec;
        let _e7439 = constants.eos_r;
        let _e7464 = normal_vec.y;
        f_l_2_ = (((_cse_1390_ * dot(((_cse_1391_ * 1f) / vec2(_cse_1436_)), _e7434)) + (((_cse_1436_ * _e7439) * (_e121 + min(max(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f)))) * _e7464)) - _cse_1438_);
        let _e7472 = normal_vec;
        let _e7477 = constants.eos_r;
        let _e7506 = normal_vec.y;
        f_r_2_ = (((_cse_1414_ * dot(((_cse_1415_ * 1f) / vec2(_cse_1451_)), _e7472)) + (((_cse_1451_ * _e7477) * (_e394 + min(max(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f)))) * _e7506)) - _cse_1438_);
    }
    let _e7512 = constants.scheme;
    if ((_e7512 == 6u) && !(is_boundary_1)) {
        let _cse_1462_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_1461_ = (_cse_1462_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1460_ = (_cse_1461_ - _cse_1850_);
        let _cse_1465_ = (_cse_1856_ - _cse_1850_);
        let _cse_1466_ = max(abs(_cse_1465_), (abs(_cse_1460_) + 0.00000001f));
        let _cse_1464_ = (abs(_cse_1465_) / _cse_1466_);
        let _cse_1459_ = (_cse_1460_ * _cse_1464_);
        let _cse_1468_ = (_cse_1465_ * _cse_1460_);
        let _cse_1467_ = (max(_cse_1468_, 0f) / max(abs(_cse_1468_), 0.00000001f));
        let _cse_1458_ = (_cse_1459_ * _cse_1467_);
        let _cse_1456_ = (_cse_1850_ + _cse_1458_);
        let _cse_1475_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_1474_ = (_cse_1475_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1473_ = (_cse_1474_ - _cse_1860_);
        let _cse_1478_ = (_cse_1866_ - _cse_1860_);
        let _cse_1479_ = max(abs(_cse_1478_), (abs(_cse_1473_) + 0.00000001f));
        let _cse_1477_ = (abs(_cse_1478_) / _cse_1479_);
        let _cse_1472_ = (_cse_1473_ * _cse_1477_);
        let _cse_1481_ = (_cse_1478_ * _cse_1473_);
        let _cse_1480_ = (max(_cse_1481_, 0f) / max(abs(_cse_1481_), 0.00000001f));
        let _cse_1471_ = (_cse_1472_ * _cse_1480_);
        let _cse_1469_ = (_cse_1860_ + _cse_1471_);
        let _cse_1455_ = vec2<f32>(_cse_1456_, _cse_1469_);
        let _cse_1454_ = _cse_1455_.y;
        let _cse_1489_ = ((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f));
        let _cse_1491_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1490_ = (_cse_1491_ * 0.125f);
        let _cse_1488_ = (_cse_1489_ + _cse_1490_);
        let _cse_1487_ = (_cse_1488_ - _cse_1856_);
        let _cse_1493_ = (_cse_1850_ - _cse_1856_);
        let _cse_1494_ = max(abs(_cse_1493_), (abs(_cse_1487_) + 0.00000001f));
        let _cse_1492_ = (abs(_cse_1493_) / _cse_1494_);
        let _cse_1486_ = (_cse_1487_ * _cse_1492_);
        let _cse_1497_ = (_cse_1493_ * _cse_1487_);
        let _cse_1496_ = max(_cse_1497_, 0f);
        let _cse_1499_ = abs(_cse_1497_);
        let _cse_1498_ = max(_cse_1499_, 0.00000001f);
        let _cse_1495_ = (_cse_1496_ / _cse_1498_);
        let _cse_1485_ = (_cse_1486_ * _cse_1495_);
        let _cse_1484_ = (_cse_1856_ + _cse_1485_);
        let _cse_1505_ = ((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f));
        let _cse_1507_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1506_ = (_cse_1507_ * 0.125f);
        let _cse_1504_ = (_cse_1505_ + _cse_1506_);
        let _cse_1503_ = (_cse_1504_ - _cse_1866_);
        let _cse_1509_ = (_cse_1860_ - _cse_1866_);
        let _cse_1510_ = max(abs(_cse_1509_), (abs(_cse_1503_) + 0.00000001f));
        let _cse_1508_ = (abs(_cse_1509_) / _cse_1510_);
        let _cse_1502_ = (_cse_1503_ * _cse_1508_);
        let _cse_1513_ = (_cse_1509_ * _cse_1503_);
        let _cse_1512_ = max(_cse_1513_, 0f);
        let _cse_1515_ = abs(_cse_1513_);
        let _cse_1514_ = max(_cse_1515_, 0.00000001f);
        let _cse_1511_ = (_cse_1512_ / _cse_1514_);
        let _cse_1501_ = (_cse_1502_ * _cse_1511_);
        let _cse_1500_ = (_cse_1866_ + _cse_1501_);
        let _cse_1483_ = vec2<f32>(_cse_1484_, _cse_1500_);
        let _cse_1482_ = _cse_1483_.y;
        let _cse_1517_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1516_ = (_cse_1517_ - _e616);
        u_l_2_ = _cse_1454_;
        u_r_2_ = _cse_1482_;
        let _e7739 = normal_vec;
        let _e7814 = constants.eos_r;
        let _e7888 = normal_vec.y;
        let _e7893 = constants.viscosity;
        let _e7899 = lambda;
        let _e7906 = normal_vec.x;
        let _e7913 = lambda;
        let _e7924 = lambda;
        let _e7935 = lambda;
        let _e7946 = normal_vec.y;
        f_l_2_ = (((_cse_1454_ * dot(((_cse_1455_ * 1f) / vec2((_e234 + ((((((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e616 - _e234))) / max(abs((_e616 - _e234)), (abs(((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))))), _e7739)) + ((((_e234 + ((((((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234) * abs((_e616 - _e234))) / max(abs((_e616 - _e234)), (abs(((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)) + 0.00000001f))) * max(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234)), 0f)) / max(abs(((_e616 - _e234) * ((((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e234))), 0.00000001f))) * _e7814) * (_e121 + ((((((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e394 - _e121))) / max(abs((_e394 - _e121)), (abs(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f)))) * _e7888)) - (_e7893 * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e7899) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).y * _e7906) + ((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e7913) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y - (0.6666667f * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e7924) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e7935) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y))) * _e7946))));
        let _e7977 = normal_vec;
        let _e8004 = constants.eos_r;
        let _e8094 = normal_vec.y;
        let _e8099 = constants.viscosity;
        let _e8105 = lambda;
        let _e8112 = normal_vec.x;
        let _e8119 = lambda;
        let _e8130 = lambda;
        let _e8141 = lambda;
        let _e8152 = normal_vec.y;
        f_r_2_ = (((_cse_1482_ * dot(((_cse_1483_ * 1f) / vec2((_e616 + ((((_cse_1516_ * abs((_e234 - _e616))) / max(abs((_e234 - _e616)), (abs(_cse_1516_) + 0.00000001f))) * max(((_e234 - _e616) * _cse_1516_), 0f)) / max(abs(((_e234 - _e616) * _cse_1516_)), 0.00000001f))))), _e7977)) + ((((_e616 + ((((_cse_1516_ * abs((_e234 - _e616))) / max(abs((_e234 - _e616)), (abs(_cse_1516_) + 0.00000001f))) * max(((_e234 - _e616) * _cse_1516_), 0f)) / max(abs(((_e234 - _e616) * _cse_1516_)), 0.00000001f))) * _e8004) * (_e394 + ((((((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394) * abs((_e121 - _e394))) / max(abs((_e121 - _e394)), (abs(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)) + 0.00000001f))) * max(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)), 0f)) / max(abs(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394))), 0.00000001f)))) * _e8094)) - (_e8099 * ((((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8105) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).y * _e8112) + ((((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e8119) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y - (0.6666667f * (((vec2<f32>(select(s_neigh_grad_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_u_x_y, 0f, is_boundary_1)) * _e8130) + (vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)).x + ((vec2<f32>(select(s_neigh_grad_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_u_y_y, 0f, is_boundary_1)) * _e8141) + (vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)).y))) * _e8152))));
    }
    let _e8163 = a_plus;
    let _e8164 = f_l_2_;
    let _e8166 = a_minus;
    let _e8167 = f_r_2_;
    let _e8170 = a_plus;
    let _e8171 = a_minus;
    let _e8173 = u_r_2_;
    let _e8174 = u_l_2_;
    fluxes[((idx * 8u) + 2u)] = (((((_e8163 * _e8164) - (_e8166 * _e8167)) + ((_e8170 * _e8171) * (_e8173 - _e8174))) / denom) * area);
    let _e8182 = constants.eos_r;
    let _cse_1520_ = ((_e234 * _e8182) * _e121);
    let _e8187 = constants.eos_gm1_;
    let _cse_1519_ = (_cse_1520_ / max(_e8187, 0.000000000001f));
    let _cse_1524_ = vec2<f32>(_cse_1850_, _cse_1860_);
    let _cse_1523_ = ((_cse_1524_ * 1f) / vec2(_e234));
    let _cse_1522_ = dot(_cse_1523_, _cse_1523_);
    let _cse_1521_ = ((0.5f * _e234) * _cse_1522_);
    let _cse_1518_ = (_cse_1519_ + _cse_1521_);
    let _e8203 = constants.eos_r;
    let _cse_1529_ = ((_e616 * _e8203) * _e394);
    let _e8208 = constants.eos_gm1_;
    let _cse_1528_ = (_cse_1529_ / max(_e8208, 0.000000000001f));
    let _cse_1533_ = vec2<f32>(_cse_1856_, _cse_1866_);
    let _cse_1532_ = ((_cse_1533_ * 1f) / vec2(_e616));
    let _cse_1531_ = dot(_cse_1532_, _cse_1532_);
    let _cse_1530_ = ((0.5f * _e616) * _cse_1531_);
    let _cse_1527_ = (_cse_1528_ + _cse_1530_);
    u_l_3_ = _cse_1518_;
    u_r_3_ = _cse_1527_;
    let _e8225 = normal_vec;
    f_l_3_ = ((_cse_1518_ + _cse_1520_) * dot(_cse_1523_, _e8225));
    let _e8230 = normal_vec;
    f_r_3_ = ((_cse_1527_ + _cse_1529_) * dot(_cse_1532_, _e8230));
    let _e8236 = constants.scheme;
    if ((_e8236 == 1u) && !(is_boundary_1)) {
        let _cse_1541_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_1540_ = (_e234 + _cse_1541_);
        let _e8247 = constants.eos_r;
        let _cse_1539_ = (_cse_1540_ * _e8247);
        let _cse_1543_ = dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec));
        let _cse_1542_ = (_e121 + _cse_1543_);
        let _cse_1538_ = (_cse_1539_ * _cse_1542_);
        let _e8256 = constants.eos_gm1_;
        let _cse_1537_ = (_cse_1538_ / max(_e8256, 0.000000000001f));
        let _cse_1545_ = (0.5f * _cse_1540_);
        let _cse_1551_ = dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec));
        let _cse_1549_ = (_cse_1850_ + _cse_1551_);
        let _cse_1554_ = dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec));
        let _cse_1552_ = (_cse_1860_ + _cse_1554_);
        let _cse_1548_ = vec2<f32>(_cse_1549_, _cse_1552_);
        let _cse_1555_ = (1f / _cse_1540_);
        let _cse_1547_ = (_cse_1548_ * _cse_1555_);
        let _cse_1546_ = dot(_cse_1547_, _cse_1547_);
        let _cse_1544_ = (_cse_1545_ * _cse_1546_);
        let _cse_1536_ = (_cse_1537_ + _cse_1544_);
        let _cse_1562_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1561_ = dot(_cse_1562_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1560_ = (_e616 + _cse_1561_);
        let _e8287 = constants.eos_r;
        let _cse_1559_ = (_cse_1560_ * _e8287);
        let _cse_1565_ = vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1));
        let _cse_1564_ = dot(_cse_1565_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1563_ = (_e394 + _cse_1564_);
        let _cse_1558_ = (_cse_1559_ * _cse_1563_);
        let _e8300 = constants.eos_gm1_;
        let _cse_1557_ = (_cse_1558_ / max(_e8300, 0.000000000001f));
        let _cse_1567_ = (0.5f * _cse_1560_);
        let _cse_1574_ = vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1));
        let _cse_1573_ = dot(_cse_1574_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1571_ = (_cse_1856_ + _cse_1573_);
        let _cse_1578_ = vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1));
        let _cse_1577_ = dot(_cse_1578_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1575_ = (_cse_1866_ + _cse_1577_);
        let _cse_1570_ = vec2<f32>(_cse_1571_, _cse_1575_);
        let _cse_1579_ = (1f / _cse_1560_);
        let _cse_1569_ = (_cse_1570_ * _cse_1579_);
        let _cse_1568_ = dot(_cse_1569_, _cse_1569_);
        let _cse_1566_ = (_cse_1567_ * _cse_1568_);
        let _cse_1556_ = (_cse_1557_ + _cse_1566_);
        u_l_3_ = _cse_1536_;
        u_r_3_ = _cse_1556_;
        let _e8330 = normal_vec;
        f_l_3_ = ((_cse_1536_ + _cse_1538_) * dot(_cse_1547_, _e8330));
        let _e8334 = normal_vec;
        f_r_3_ = ((_cse_1556_ + _cse_1558_) * dot(_cse_1569_, _e8334));
    }
    let _e8339 = constants.scheme;
    if ((_e8339 == 2u) && !(is_boundary_1)) {
        let _cse_1587_ = ((_e234 * 0.625f) + (_e616 * 0.375f));
        let _cse_1589_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1588_ = (_cse_1589_ * 0.125f);
        let _cse_1586_ = (_cse_1587_ + _cse_1588_);
        let _cse_1585_ = (_cse_1586_ - _e234);
        let _cse_1584_ = (_e234 + _cse_1585_);
        let _e8359 = constants.eos_r;
        let _cse_1583_ = (_cse_1584_ * _e8359);
        let _cse_1582_ = (_cse_1583_ * ((((_e121 + (_e121 * 0.625f)) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121));
        let _e8377 = constants.eos_gm1_;
        let _cse_1581_ = (_cse_1582_ / max(_e8377, 0.000000000001f));
        let _cse_1599_ = (_cse_1850_ * 0.625f);
        let _cse_1600_ = (_cse_1856_ * 0.375f);
        let _cse_1598_ = (_cse_1599_ + _cse_1600_);
        let _cse_1597_ = (_cse_1598_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1596_ = (_cse_1597_ - _cse_1850_);
        let _cse_1594_ = (_cse_1850_ + _cse_1596_);
        let _cse_1607_ = (_cse_1860_ * 0.625f);
        let _cse_1608_ = (_cse_1866_ * 0.375f);
        let _cse_1606_ = (_cse_1607_ + _cse_1608_);
        let _cse_1605_ = (_cse_1606_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1604_ = (_cse_1605_ - _cse_1860_);
        let _cse_1602_ = (_cse_1860_ + _cse_1604_);
        let _cse_1593_ = vec2<f32>(_cse_1594_, _cse_1602_);
        let _cse_1610_ = (1f / _cse_1584_);
        let _cse_1592_ = (_cse_1593_ * _cse_1610_);
        let _cse_1591_ = dot(_cse_1592_, _cse_1592_);
        let _cse_1590_ = ((0.5f * _cse_1584_) * _cse_1591_);
        let _cse_1580_ = (_cse_1581_ + _cse_1590_);
        let _cse_1618_ = ((_e616 * 0.625f) + (_e234 * 0.375f));
        let _cse_1621_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1620_ = dot(_cse_1621_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1619_ = (_cse_1620_ * 0.125f);
        let _cse_1617_ = (_cse_1618_ + _cse_1619_);
        let _cse_1616_ = (_cse_1617_ - _e616);
        let _cse_1615_ = (_e616 + _cse_1616_);
        let _e8435 = constants.eos_r;
        let _cse_1614_ = (_cse_1615_ * _e8435);
        let _cse_1624_ = (((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1623_ = (_cse_1624_ - _e394);
        let _cse_1622_ = (_e394 + _cse_1623_);
        let _cse_1613_ = (_cse_1614_ * _cse_1622_);
        let _e8457 = constants.eos_gm1_;
        let _cse_1612_ = (_cse_1613_ / max(_e8457, 0.000000000001f));
        let _cse_1633_ = (_cse_1856_ * 0.625f);
        let _cse_1634_ = (_cse_1850_ * 0.375f);
        let _cse_1632_ = (_cse_1633_ + _cse_1634_);
        let _cse_1636_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1635_ = (_cse_1636_ * 0.125f);
        let _cse_1631_ = (_cse_1632_ + _cse_1635_);
        let _cse_1630_ = (_cse_1631_ - _cse_1856_);
        let _cse_1629_ = (_cse_1856_ + _cse_1630_);
        let _cse_1640_ = ((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f));
        let _cse_1642_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1641_ = (_cse_1642_ * 0.125f);
        let _cse_1639_ = (_cse_1640_ + _cse_1641_);
        let _cse_1638_ = (_cse_1639_ - _cse_1866_);
        let _cse_1637_ = (_cse_1866_ + _cse_1638_);
        let _cse_1628_ = vec2<f32>(_cse_1629_, _cse_1637_);
        let _cse_1643_ = (1f / _cse_1615_);
        let _cse_1627_ = (_cse_1628_ * _cse_1643_);
        let _cse_1626_ = dot(_cse_1627_, _cse_1627_);
        let _cse_1625_ = ((0.5f * _cse_1615_) * _cse_1626_);
        let _cse_1611_ = (_cse_1612_ + _cse_1625_);
        u_l_3_ = _cse_1580_;
        u_r_3_ = _cse_1611_;
        let _e8505 = normal_vec;
        f_l_3_ = ((_cse_1580_ + _cse_1582_) * dot(_cse_1592_, _e8505));
        let _e8509 = normal_vec;
        f_r_3_ = ((_cse_1611_ + _cse_1613_) * dot(_cse_1627_, _e8509));
    }
    let _e8514 = constants.scheme;
    if ((_e8514 == 3u) && !(is_boundary_1)) {
        let _cse_1651_ = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (face_center_vec - c_owner_vec));
        let _cse_1652_ = min((_e616 - _e234), 0f);
        let _cse_1650_ = max(_cse_1651_, _cse_1652_);
        let _cse_1653_ = max((_e616 - _e234), 0f);
        let _cse_1649_ = min(_cse_1650_, _cse_1653_);
        let _cse_1648_ = (_e234 + _cse_1649_);
        let _e8533 = constants.eos_r;
        let _cse_1647_ = (_cse_1648_ * _e8533);
        let _cse_1654_ = (_e121 + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (face_center_vec - c_owner_vec)), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f)));
        let _cse_1646_ = (_cse_1647_ * _cse_1654_);
        let _e8550 = constants.eos_gm1_;
        let _cse_1645_ = (_cse_1646_ / max(_e8550, 0.000000000001f));
        let _cse_1664_ = (_cse_1856_ - _cse_1850_);
        let _cse_1663_ = min(_cse_1664_, 0f);
        let _cse_1662_ = max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (face_center_vec - c_owner_vec)), _cse_1663_);
        let _cse_1666_ = max(_cse_1664_, 0f);
        let _cse_1661_ = min(_cse_1662_, _cse_1666_);
        let _cse_1659_ = (_cse_1850_ + _cse_1661_);
        let _cse_1672_ = (_cse_1866_ - _cse_1860_);
        let _cse_1671_ = min(_cse_1672_, 0f);
        let _cse_1670_ = max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (face_center_vec - c_owner_vec)), _cse_1671_);
        let _cse_1674_ = max(_cse_1672_, 0f);
        let _cse_1669_ = min(_cse_1670_, _cse_1674_);
        let _cse_1667_ = (_cse_1860_ + _cse_1669_);
        let _cse_1658_ = vec2<f32>(_cse_1659_, _cse_1667_);
        let _cse_1675_ = (1f / _cse_1648_);
        let _cse_1657_ = (_cse_1658_ * _cse_1675_);
        let _cse_1656_ = dot(_cse_1657_, _cse_1657_);
        let _cse_1655_ = ((0.5f * _cse_1648_) * _cse_1656_);
        let _cse_1644_ = (_cse_1645_ + _cse_1655_);
        let _cse_1684_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1683_ = dot(_cse_1684_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1685_ = min((_e234 - _e616), 0f);
        let _cse_1682_ = max(_cse_1683_, _cse_1685_);
        let _cse_1686_ = max((_e234 - _e616), 0f);
        let _cse_1681_ = min(_cse_1682_, _cse_1686_);
        let _cse_1680_ = (_e616 + _cse_1681_);
        let _e8603 = constants.eos_r;
        let _cse_1679_ = (_cse_1680_ * _e8603);
        let _cse_1688_ = min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec)), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f));
        let _cse_1687_ = (_e394 + _cse_1688_);
        let _cse_1678_ = (_cse_1679_ * _cse_1687_);
        let _e8624 = constants.eos_gm1_;
        let _cse_1677_ = (_cse_1678_ / max(_e8624, 0.000000000001f));
        let _cse_1696_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec));
        let _cse_1698_ = (_cse_1850_ - _cse_1856_);
        let _cse_1697_ = min(_cse_1698_, 0f);
        let _cse_1695_ = max(_cse_1696_, _cse_1697_);
        let _cse_1699_ = max(_cse_1698_, 0f);
        let _cse_1694_ = min(_cse_1695_, _cse_1699_);
        let _cse_1693_ = (_cse_1856_ + _cse_1694_);
        let _cse_1703_ = dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (face_center_vec - c_neigh_cell_vec));
        let _cse_1705_ = (_cse_1860_ - _cse_1866_);
        let _cse_1704_ = min(_cse_1705_, 0f);
        let _cse_1702_ = max(_cse_1703_, _cse_1704_);
        let _cse_1706_ = max(_cse_1705_, 0f);
        let _cse_1701_ = min(_cse_1702_, _cse_1706_);
        let _cse_1700_ = (_cse_1866_ + _cse_1701_);
        let _cse_1692_ = vec2<f32>(_cse_1693_, _cse_1700_);
        let _cse_1707_ = (1f / _cse_1680_);
        let _cse_1691_ = (_cse_1692_ * _cse_1707_);
        let _cse_1690_ = dot(_cse_1691_, _cse_1691_);
        let _cse_1689_ = ((0.5f * _cse_1680_) * _cse_1690_);
        let _cse_1676_ = (_cse_1677_ + _cse_1689_);
        u_l_3_ = _cse_1644_;
        u_r_3_ = _cse_1676_;
        let _e8668 = normal_vec;
        f_l_3_ = ((_cse_1644_ + _cse_1646_) * dot(_cse_1657_, _e8668));
        let _e8672 = normal_vec;
        f_r_3_ = ((_cse_1676_ + _cse_1678_) * dot(_cse_1691_, _e8672));
    }
    let _e8677 = constants.scheme;
    if ((_e8677 == 4u) && !(is_boundary_1)) {
        let _cse_1719_ = (((_e616 - _e234) * (_e616 - _e234)) + 0.000000000000000000000000000001f);
        let _cse_1718_ = ((dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (_e616 - _e234)) / _cse_1719_);
        let _cse_1717_ = (2f * _cse_1718_);
        let _cse_1716_ = (_cse_1717_ - 1f);
        let _cse_1715_ = min(_cse_1716_, 1999f);
        let _cse_1714_ = max(-2001f, _cse_1715_);
        let _cse_1720_ = abs(_cse_1714_);
        let _cse_1713_ = (_cse_1714_ + _cse_1720_);
        let _cse_1712_ = (_cse_1713_ / (1f + _cse_1720_));
        let _cse_1711_ = (_cse_1712_ * lambda_other);
        let _cse_1710_ = (_cse_1711_ * (_e616 - _e234));
        let _cse_1709_ = (_e234 + _cse_1710_);
        let _cse_1726_ = (vec2<f32>(_cse_1856_, _cse_1866_) - vec2<f32>(_cse_1850_, _cse_1860_));
        let _cse_1736_ = dot(_cse_1726_, _cse_1726_);
        let _cse_1735_ = (dot(_cse_1726_, vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_1736_);
        let _cse_1738_ = (_cse_1736_ * _cse_1736_);
        let _cse_1737_ = (_cse_1738_ + 0.000000000000000000000000000001f);
        let _cse_1734_ = (_cse_1735_ / _cse_1737_);
        let _cse_1733_ = (2f * _cse_1734_);
        let _cse_1732_ = (_cse_1733_ - 1f);
        let _cse_1731_ = min(_cse_1732_, 1999f);
        let _cse_1730_ = max(-2001f, _cse_1731_);
        let _cse_1739_ = abs(_cse_1730_);
        let _cse_1729_ = (_cse_1730_ + _cse_1739_);
        let _cse_1728_ = (_cse_1729_ / (1f + _cse_1739_));
        let _cse_1727_ = (_cse_1728_ * lambda_other);
        let _cse_1725_ = (_cse_1726_ * _cse_1727_);
        let _cse_1724_ = (vec2<f32>(_cse_1850_, _cse_1860_) + _cse_1725_);
        let _cse_1723_ = ((_cse_1724_ * 1f) / vec2(_cse_1709_));
        let _cse_1722_ = dot(_cse_1723_, _cse_1723_);
        let _cse_1721_ = ((0.5f * _cse_1709_) * _cse_1722_);
        let _e8754 = constants.eos_r;
        let _e8826 = constants.eos_gm1_;
        let _cse_1708_ = ((((_cse_1709_ * _e8754) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e394 - _e121)))) / max(_e8826, 0.000000000001f)) + _cse_1721_);
        let _cse_1752_ = (dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1))) * (_e616 - _e234));
        let _cse_1751_ = (_cse_1752_ / _cse_1719_);
        let _cse_1750_ = (2f * _cse_1751_);
        let _cse_1749_ = (_cse_1750_ - 1f);
        let _cse_1748_ = min(_cse_1749_, 1999f);
        let _cse_1747_ = max(-2001f, _cse_1748_);
        let _cse_1753_ = abs(_cse_1747_);
        let _cse_1746_ = (_cse_1747_ + _cse_1753_);
        let _cse_1745_ = (_cse_1746_ / (1f + _cse_1753_));
        let _e8854 = lambda;
        let _cse_1744_ = (_cse_1745_ * _e8854);
        let _cse_1743_ = (_cse_1744_ * (_e616 - _e234));
        let _cse_1742_ = (_e616 - _cse_1743_);
        let _e8861 = constants.eos_r;
        let _e8938 = lambda;
        let _cse_1741_ = ((_cse_1742_ * _e8861) * (_e394 - ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * _e8938) * (_e394 - _e121))));
        let _cse_1769_ = vec2<f32>(dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1))), dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1))));
        let _cse_1768_ = dot(_cse_1726_, _cse_1769_);
        let _cse_1767_ = (_cse_1768_ * _cse_1736_);
        let _cse_1766_ = (_cse_1767_ / _cse_1737_);
        let _cse_1765_ = (2f * _cse_1766_);
        let _cse_1764_ = (_cse_1765_ - 1f);
        let _cse_1763_ = min(_cse_1764_, 1999f);
        let _cse_1762_ = max(-2001f, _cse_1763_);
        let _cse_1770_ = abs(_cse_1762_);
        let _cse_1761_ = (_cse_1762_ + _cse_1770_);
        let _cse_1760_ = (_cse_1761_ / (1f + _cse_1770_));
        let _e8975 = lambda;
        let _cse_1759_ = (_cse_1760_ * _e8975);
        let _cse_1758_ = (_cse_1726_ * _cse_1759_);
        let _cse_1757_ = (vec2<f32>(_cse_1856_, _cse_1866_) - _cse_1758_);
        let _cse_1771_ = (1f / _cse_1742_);
        let _cse_1756_ = (_cse_1757_ * _cse_1771_);
        let _cse_1755_ = dot(_cse_1756_, _cse_1756_);
        let _cse_1754_ = ((0.5f * _cse_1742_) * _cse_1755_);
        let _e8989 = constants.eos_gm1_;
        let _cse_1740_ = ((_cse_1741_ / max(_e8989, 0.000000000001f)) + _cse_1754_);
        u_l_3_ = _cse_1708_;
        u_r_3_ = _cse_1740_;
        let _e8996 = constants.eos_r;
        let _e9067 = normal_vec;
        f_l_3_ = ((_cse_1708_ + ((_cse_1709_ * _e8996) * (_e121 + ((((max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)) + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f)))) / (1f + abs(max(-2001f, min(((((2f * dot((c_neigh_cell_vec - c_owner_vec), vec2<f32>(s_own_grad_T_x, s_own_grad_T_y))) * (_e394 - _e121)) / (((_e394 - _e121) * (_e394 - _e121)) + 0.000000000000000000000000000001f)) - 1f), 1999f))))) * lambda_other) * (_e394 - _e121))))) * dot(_cse_1723_, _e9067));
        let _e9071 = normal_vec;
        f_r_3_ = ((_cse_1740_ + _cse_1741_) * dot(_cse_1756_, _e9071));
    }
    let _e9076 = constants.scheme;
    if ((_e9076 == 5u) && !(is_boundary_1)) {
        let _cse_1779_ = (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f);
        let _cse_1778_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + _cse_1779_);
        let _cse_1777_ = (_cse_1778_ - _e234);
        let _cse_1776_ = max(_cse_1777_, min((_e616 - _e234), 0f));
        let _cse_1775_ = min(_cse_1776_, max((_e616 - _e234), 0f));
        let _cse_1774_ = (_e234 + _cse_1775_);
        let _e9104 = constants.eos_r;
        let _cse_1773_ = ((_cse_1774_ * _e9104) * (_e121 + min(max(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121), min((_e394 - _e121), 0f)), max((_e394 - _e121), 0f))));
        let _cse_1790_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_1789_ = (_cse_1790_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1788_ = (_cse_1789_ - _cse_1850_);
        let _cse_1793_ = (_cse_1856_ - _cse_1850_);
        let _cse_1792_ = min(_cse_1793_, 0f);
        let _cse_1787_ = max(_cse_1788_, _cse_1792_);
        let _cse_1794_ = max(_cse_1793_, 0f);
        let _cse_1786_ = min(_cse_1787_, _cse_1794_);
        let _cse_1784_ = (_cse_1850_ + _cse_1786_);
        let _cse_1801_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_1800_ = (_cse_1801_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1799_ = (_cse_1800_ - _cse_1860_);
        let _cse_1803_ = (_cse_1866_ - _cse_1860_);
        let _cse_1798_ = max(_cse_1799_, min(_cse_1803_, 0f));
        let _cse_1797_ = min(_cse_1798_, max(_cse_1803_, 0f));
        let _cse_1795_ = (_cse_1860_ + _cse_1797_);
        let _cse_1783_ = vec2<f32>(_cse_1784_, _cse_1795_);
        let _cse_1804_ = (1f / _cse_1774_);
        let _cse_1782_ = (_cse_1783_ * _cse_1804_);
        let _cse_1781_ = dot(_cse_1782_, _cse_1782_);
        let _cse_1780_ = ((0.5f * _cse_1774_) * _cse_1781_);
        let _e9178 = constants.eos_gm1_;
        let _cse_1772_ = ((_cse_1773_ / max(_e9178, 0.000000000001f)) + _cse_1780_);
        let _cse_1816_ = vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1));
        let _cse_1815_ = dot(_cse_1816_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1814_ = (_cse_1815_ * 0.125f);
        let _cse_1813_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_1814_);
        let _cse_1812_ = (_cse_1813_ - _e616);
        let _cse_1811_ = max(_cse_1812_, min((_e234 - _e616), 0f));
        let _cse_1810_ = min(_cse_1811_, max((_e234 - _e616), 0f));
        let _cse_1809_ = (_e616 + _cse_1810_);
        let _e9210 = constants.eos_r;
        let _cse_1808_ = (_cse_1809_ * _e9210);
        let _cse_1807_ = (_cse_1808_ * (_e394 + min(max(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394), min((_e121 - _e394), 0f)), max((_e121 - _e394), 0f))));
        let _e9240 = constants.eos_gm1_;
        let _cse_1806_ = (_cse_1807_ / max(_e9240, 0.000000000001f));
        let _cse_1826_ = ((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f));
        let _cse_1825_ = (_cse_1826_ + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1824_ = (_cse_1825_ - _cse_1856_);
        let _cse_1827_ = (_cse_1850_ - _cse_1856_);
        let _cse_1823_ = max(_cse_1824_, min(_cse_1827_, 0f));
        let _cse_1822_ = min(_cse_1823_, max(_cse_1827_, 0f));
        let _cse_1821_ = (_cse_1856_ + _cse_1822_);
        let _cse_1833_ = ((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f));
        let _cse_1832_ = (_cse_1833_ + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1831_ = (_cse_1832_ - _cse_1866_);
        let _cse_1834_ = (_cse_1860_ - _cse_1866_);
        let _cse_1830_ = max(_cse_1831_, min(_cse_1834_, 0f));
        let _cse_1829_ = min(_cse_1830_, max(_cse_1834_, 0f));
        let _cse_1828_ = (_cse_1866_ + _cse_1829_);
        let _cse_1820_ = vec2<f32>(_cse_1821_, _cse_1828_);
        let _cse_1835_ = (1f / _cse_1809_);
        let _cse_1819_ = (_cse_1820_ * _cse_1835_);
        let _cse_1818_ = dot(_cse_1819_, _cse_1819_);
        let _cse_1817_ = ((0.5f * _cse_1809_) * _cse_1818_);
        let _cse_1805_ = (_cse_1806_ + _cse_1817_);
        u_l_3_ = _cse_1772_;
        u_r_3_ = _cse_1805_;
        let _e9302 = normal_vec;
        f_l_3_ = ((_cse_1772_ + _cse_1773_) * dot(_cse_1782_, _e9302));
        let _e9306 = normal_vec;
        f_r_3_ = ((_cse_1805_ + _cse_1807_) * dot(_cse_1819_, _e9306));
    }
    let _e9311 = constants.scheme;
    if ((_e9311 == 6u) && !(is_boundary_1)) {
        let _cse_1842_ = (((_e234 * 0.625f) + (_e616 * 0.375f)) + (dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1841_ = (_cse_1842_ - _e234);
        let _cse_1840_ = ((_cse_1841_ * abs((_e616 - _e234))) / max(abs((_e616 - _e234)), (abs(_cse_1841_) + 0.00000001f)));
        let _cse_1844_ = ((_e616 - _e234) * _cse_1841_);
        let _cse_1843_ = (max(_cse_1844_, 0f) / max(abs(_cse_1844_), 0.00000001f));
        let _cse_1839_ = (_cse_1840_ * _cse_1843_);
        let _cse_1838_ = (_e234 + _cse_1839_);
        let _e9350 = constants.eos_r;
        let _cse_1837_ = ((_cse_1838_ * _e9350) * (_e121 + ((((((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121) * abs((_e394 - _e121))) / max(abs((_e394 - _e121)), (abs(((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)) + 0.00000001f))) * max(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121)), 0f)) / max(abs(((_e394 - _e121) * ((((_e121 * 0.625f) + (_e394 * 0.375f)) + (dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _e121))), 0.00000001f))));
        let _cse_1855_ = ((_cse_1850_ * 0.625f) + (_cse_1856_ * 0.375f));
        let _cse_1854_ = (_cse_1855_ + (dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1853_ = (_cse_1854_ - _cse_1850_);
        let _cse_1852_ = ((_cse_1853_ * abs((_cse_1856_ - _cse_1850_))) / max(abs((_cse_1856_ - _cse_1850_)), (abs(_cse_1853_) + 0.00000001f)));
        let _cse_1858_ = ((_cse_1856_ - _cse_1850_) * _cse_1853_);
        let _cse_1857_ = (max(_cse_1858_, 0f) / max(abs(_cse_1858_), 0.00000001f));
        let _cse_1851_ = (_cse_1852_ * _cse_1857_);
        let _cse_1849_ = (_cse_1850_ + _cse_1851_);
        let _cse_1865_ = ((_cse_1860_ * 0.625f) + (_cse_1866_ * 0.375f));
        let _cse_1864_ = (_cse_1865_ + (dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1863_ = (_cse_1864_ - _cse_1860_);
        let _cse_1862_ = ((_cse_1863_ * abs((_cse_1866_ - _cse_1860_))) / max(abs((_cse_1866_ - _cse_1860_)), (abs(_cse_1863_) + 0.00000001f)));
        let _cse_1868_ = ((_cse_1866_ - _cse_1860_) * _cse_1863_);
        let _cse_1867_ = (max(_cse_1868_, 0f) / max(abs(_cse_1868_), 0.00000001f));
        let _cse_1861_ = (_cse_1862_ * _cse_1867_);
        let _cse_1859_ = (_cse_1860_ + _cse_1861_);
        let _cse_1848_ = vec2<f32>(_cse_1849_, _cse_1859_);
        let _cse_1869_ = (1f / _cse_1838_);
        let _cse_1847_ = (_cse_1848_ * _cse_1869_);
        let _cse_1846_ = dot(_cse_1847_, _cse_1847_);
        let _cse_1845_ = ((0.5f * _cse_1838_) * _cse_1846_);
        let _e9497 = constants.eos_gm1_;
        let _cse_1836_ = ((_cse_1837_ / max(_e9497, 0.000000000001f)) + _cse_1845_);
        let _cse_1878_ = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0f, is_boundary_1), select(s_neigh_grad_rho_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1877_ = (_cse_1878_ * 0.125f);
        let _cse_1876_ = (((_e616 * 0.625f) + (_e234 * 0.375f)) + _cse_1877_);
        let _cse_1875_ = (_cse_1876_ - _e616);
        let _cse_1874_ = ((_cse_1875_ * abs((_e234 - _e616))) / max(abs((_e234 - _e616)), (abs(_cse_1875_) + 0.00000001f)));
        let _cse_1880_ = ((_e234 - _e616) * _cse_1875_);
        let _cse_1879_ = (max(_cse_1880_, 0f) / max(abs(_cse_1880_), 0.00000001f));
        let _cse_1873_ = (_cse_1874_ * _cse_1879_);
        let _cse_1872_ = (_e616 + _cse_1873_);
        let _e9540 = constants.eos_r;
        let _cse_1871_ = ((_cse_1872_ * _e9540) * (_e394 + ((((((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394) * abs((_e121 - _e394))) / max(abs((_e121 - _e394)), (abs(((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)) + 0.00000001f))) * max(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394)), 0f)) / max(abs(((_e121 - _e394) * ((((_e394 * 0.625f) + (_e121 * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_T_x, 0f, is_boundary_1), select(s_neigh_grad_T_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e394))), 0.00000001f))));
        let _cse_1889_ = (((_cse_1856_ * 0.625f) + (_cse_1850_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_x_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1888_ = (_cse_1889_ - _cse_1856_);
        let _cse_1887_ = ((_cse_1888_ * abs((_cse_1850_ - _cse_1856_))) / max(abs((_cse_1850_ - _cse_1856_)), (abs(_cse_1888_) + 0.00000001f)));
        let _cse_1891_ = ((_cse_1850_ - _cse_1856_) * _cse_1888_);
        let _cse_1890_ = (max(_cse_1891_, 0f) / max(abs(_cse_1891_), 0.00000001f));
        let _cse_1886_ = (_cse_1887_ * _cse_1890_);
        let _cse_1885_ = (_cse_1856_ + _cse_1886_);
        let _cse_1896_ = (((_cse_1866_ * 0.625f) + (_cse_1860_ * 0.375f)) + (dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0f, is_boundary_1), select(s_neigh_grad_rho_u_y_y, 0f, is_boundary_1)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1895_ = (_cse_1896_ - _cse_1866_);
        let _cse_1894_ = ((_cse_1895_ * abs((_cse_1860_ - _cse_1866_))) / max(abs((_cse_1860_ - _cse_1866_)), (abs(_cse_1895_) + 0.00000001f)));
        let _cse_1898_ = ((_cse_1860_ - _cse_1866_) * _cse_1895_);
        let _cse_1897_ = (max(_cse_1898_, 0f) / max(abs(_cse_1898_), 0.00000001f));
        let _cse_1893_ = (_cse_1894_ * _cse_1897_);
        let _cse_1892_ = (_cse_1866_ + _cse_1893_);
        let _cse_1884_ = vec2<f32>(_cse_1885_, _cse_1892_);
        let _cse_1899_ = (1f / _cse_1872_);
        let _cse_1883_ = (_cse_1884_ * _cse_1899_);
        let _cse_1882_ = dot(_cse_1883_, _cse_1883_);
        let _cse_1881_ = ((0.5f * _cse_1872_) * _cse_1882_);
        let _e9711 = constants.eos_gm1_;
        let _cse_1870_ = ((_cse_1871_ / max(_e9711, 0.000000000001f)) + _cse_1881_);
        u_l_3_ = _cse_1836_;
        u_r_3_ = _cse_1870_;
        let _e9717 = normal_vec;
        f_l_3_ = ((_cse_1836_ + _cse_1837_) * dot(_cse_1847_, _e9717));
        let _e9721 = normal_vec;
        f_r_3_ = ((_cse_1870_ + _cse_1871_) * dot(_cse_1883_, _e9721));
    }
    let _e9730 = a_plus;
    let _e9731 = f_l_3_;
    let _e9733 = a_minus;
    let _e9734 = f_r_3_;
    let _e9737 = a_plus;
    let _e9738 = a_minus;
    let _e9740 = u_r_3_;
    let _e9741 = u_l_3_;
    fluxes[((idx * 8u) + 3u)] = (((((_e9730 * _e9731) - (_e9733 * _e9734)) + ((_e9737 * _e9738) * (_e9740 - _e9741))) / denom) * area);
    let _e9749 = constants.scheme;
    if ((_e9749 == 1u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e9764 = constants.scheme;
    if ((_e9764 == 2u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e9775 = constants.scheme;
    if ((_e9775 == 3u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e9786 = constants.scheme;
    if ((_e9786 == 4u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e9797 = constants.scheme;
    if ((_e9797 == 5u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e9808 = constants.scheme;
    if ((_e9808 == 6u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e9823 = a_plus;
    let _e9824 = f_l_4_;
    let _e9826 = a_minus;
    let _e9827 = f_r_4_;
    let _e9830 = a_plus;
    let _e9831 = a_minus;
    let _e9833 = u_r_4_;
    let _e9834 = u_l_4_;
    fluxes[((idx * 8u) + 4u)] = (((((_e9823 * _e9824) - (_e9826 * _e9827)) + ((_e9830 * _e9831) * (_e9833 - _e9834))) / denom) * area);
    let _e9842 = constants.scheme;
    if ((_e9842 == 1u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e9857 = constants.scheme;
    if ((_e9857 == 2u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e9868 = constants.scheme;
    if ((_e9868 == 3u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e9879 = constants.scheme;
    if ((_e9879 == 4u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e9890 = constants.scheme;
    if ((_e9890 == 5u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e9901 = constants.scheme;
    if ((_e9901 == 6u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e9916 = a_plus;
    let _e9917 = f_l_5_;
    let _e9919 = a_minus;
    let _e9920 = f_r_5_;
    let _e9923 = a_plus;
    let _e9924 = a_minus;
    let _e9926 = u_r_5_;
    let _e9927 = u_l_5_;
    fluxes[((idx * 8u) + 5u)] = (((((_e9916 * _e9917) - (_e9919 * _e9920)) + ((_e9923 * _e9924) * (_e9926 - _e9927))) / denom) * area);
    let _e9935 = constants.scheme;
    if ((_e9935 == 1u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e9950 = constants.scheme;
    if ((_e9950 == 2u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e9961 = constants.scheme;
    if ((_e9961 == 3u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e9972 = constants.scheme;
    if ((_e9972 == 4u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e9983 = constants.scheme;
    if ((_e9983 == 5u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e9994 = constants.scheme;
    if ((_e9994 == 6u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e10009 = a_plus;
    let _e10010 = f_l_6_;
    let _e10012 = a_minus;
    let _e10013 = f_r_6_;
    let _e10016 = a_plus;
    let _e10017 = a_minus;
    let _e10019 = u_r_6_;
    let _e10020 = u_l_6_;
    fluxes[((idx * 8u) + 6u)] = (((((_e10009 * _e10010) - (_e10012 * _e10013)) + ((_e10016 * _e10017) * (_e10019 - _e10020))) / denom) * area);
    let _e10028 = constants.scheme;
    if ((_e10028 == 1u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e10043 = constants.scheme;
    if ((_e10043 == 2u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e10054 = constants.scheme;
    if ((_e10054 == 3u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e10065 = constants.scheme;
    if ((_e10065 == 4u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e10076 = constants.scheme;
    if ((_e10076 == 5u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e10087 = constants.scheme;
    if ((_e10087 == 6u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e10102 = a_plus;
    let _e10103 = f_l_7_;
    let _e10105 = a_minus;
    let _e10106 = f_r_7_;
    let _e10109 = a_plus;
    let _e10110 = a_minus;
    let _e10112 = u_r_7_;
    let _e10113 = u_l_7_;
    fluxes[((idx * 8u) + 7u)] = (((((_e10102 * _e10103) - (_e10105 * _e10106)) + ((_e10109 * _e10110) * (_e10112 - _e10113))) / denom) * area);
    return;
}
"#;
    }
    pub mod flux_module_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_gradients_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_rho_u_x: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho_u_y: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_rho_e: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_T: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_u_x: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_u_y: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 22u) + 1u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 22u) + 1u)];
            let _e129 = state[((idx * 22u) + 1u)];
            let _e136 = bc_value[((face_idx * 8u) + 1u)];
            let _e143 = bc_kind[((face_idx * 8u) + 1u)];
            let _e153 = state[((idx * 22u) + 1u)];
            let _e160 = bc_value[((face_idx * 8u) + 1u)];
            let _e169 = bc_kind[((face_idx * 8u) + 1u)];
            let _e180 = state[((idx * 22u) + 1u)];
            let _e187 = state[((idx * 22u) + 1u)];
            let _e189 = normal_vec.x;
            let _e197 = state[((idx * 22u) + 2u)];
            let _e199 = normal_vec.y;
            let _e203 = normal_vec.x;
            let _e215 = grad_acc_rho_u_x;
            grad_acc_rho_u_x = (_e215 + ((_e105 * ((_e112 * _e113) + (select(select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary), (_e180 - (((_e187 * _e189) + (_e197 * _e199)) * _e203)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e217 = normal_vec;
            let _e224 = state[((idx * 22u) + 2u)];
            let _e225 = lambda;
            let _e227 = other_idx;
            let _e234 = state[((_e227 * 22u) + 2u)];
            let _e241 = state[((idx * 22u) + 2u)];
            let _e248 = bc_value[((face_idx * 8u) + 2u)];
            let _e255 = bc_kind[((face_idx * 8u) + 2u)];
            let _e265 = state[((idx * 22u) + 2u)];
            let _e272 = bc_value[((face_idx * 8u) + 2u)];
            let _e281 = bc_kind[((face_idx * 8u) + 2u)];
            let _e292 = state[((idx * 22u) + 2u)];
            let _e299 = state[((idx * 22u) + 1u)];
            let _e301 = normal_vec.x;
            let _e309 = state[((idx * 22u) + 2u)];
            let _e311 = normal_vec.y;
            let _e315 = normal_vec.y;
            let _e327 = grad_acc_rho_u_y;
            grad_acc_rho_u_y = (_e327 + ((_e217 * ((_e224 * _e225) + (select(select(_e234, select(select(_e241, _e248, (_e255 == 1u)), (_e265 + (_e272 * d_own)), (_e281 == 2u)), is_boundary), (_e292 - (((_e299 * _e301) + (_e309 * _e311)) * _e315)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 22u) + 0u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 22u) + 0u)];
            let _e353 = state[((idx * 22u) + 0u)];
            let _e360 = bc_value[((face_idx * 8u) + 0u)];
            let _e367 = bc_kind[((face_idx * 8u) + 0u)];
            let _e377 = state[((idx * 22u) + 0u)];
            let _e384 = bc_value[((face_idx * 8u) + 0u)];
            let _e393 = bc_kind[((face_idx * 8u) + 0u)];
            let _e403 = grad_acc_rho;
            grad_acc_rho = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 22u) + 7u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 22u) + 7u)];
            let _e429 = state[((idx * 22u) + 7u)];
            let _e436 = bc_value[((face_idx * 8u) + 3u)];
            let _e443 = bc_kind[((face_idx * 8u) + 3u)];
            let _e453 = state[((idx * 22u) + 7u)];
            let _e460 = bc_value[((face_idx * 8u) + 3u)];
            let _e469 = bc_kind[((face_idx * 8u) + 3u)];
            let _e479 = grad_acc_rho_e;
            grad_acc_rho_e = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 22u) + 9u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 22u) + 9u)];
            let _e505 = state[((idx * 22u) + 9u)];
            let _e512 = bc_value[((face_idx * 8u) + 7u)];
            let _e519 = bc_kind[((face_idx * 8u) + 7u)];
            let _e529 = state[((idx * 22u) + 9u)];
            let _e536 = bc_value[((face_idx * 8u) + 7u)];
            let _e545 = bc_kind[((face_idx * 8u) + 7u)];
            let _e555 = grad_acc_T;
            grad_acc_T = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 22u) + 10u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 22u) + 10u)];
            let _e581 = state[((idx * 22u) + 10u)];
            let _e588 = bc_value[((face_idx * 8u) + 4u)];
            let _e595 = bc_kind[((face_idx * 8u) + 4u)];
            let _e605 = state[((idx * 22u) + 10u)];
            let _e612 = bc_value[((face_idx * 8u) + 4u)];
            let _e621 = bc_kind[((face_idx * 8u) + 4u)];
            let _e632 = state[((idx * 22u) + 10u)];
            let _e639 = state[((idx * 22u) + 10u)];
            let _e641 = normal_vec.x;
            let _e649 = state[((idx * 22u) + 11u)];
            let _e651 = normal_vec.y;
            let _e655 = normal_vec.x;
            let _e667 = grad_acc_u_x;
            grad_acc_u_x = (_e667 + ((_e557 * ((_e564 * _e565) + (select(select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary), (_e632 - (((_e639 * _e641) + (_e649 * _e651)) * _e655)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
            let _e669 = normal_vec;
            let _e676 = state[((idx * 22u) + 11u)];
            let _e677 = lambda;
            let _e679 = other_idx;
            let _e686 = state[((_e679 * 22u) + 11u)];
            let _e693 = state[((idx * 22u) + 11u)];
            let _e700 = bc_value[((face_idx * 8u) + 5u)];
            let _e707 = bc_kind[((face_idx * 8u) + 5u)];
            let _e717 = state[((idx * 22u) + 11u)];
            let _e724 = bc_value[((face_idx * 8u) + 5u)];
            let _e733 = bc_kind[((face_idx * 8u) + 5u)];
            let _e744 = state[((idx * 22u) + 11u)];
            let _e751 = state[((idx * 22u) + 10u)];
            let _e753 = normal_vec.x;
            let _e761 = state[((idx * 22u) + 11u)];
            let _e763 = normal_vec.y;
            let _e767 = normal_vec.y;
            let _e779 = grad_acc_u_y;
            grad_acc_u_y = (_e779 + ((_e669 * ((_e676 * _e677) + (select(select(_e686, select(select(_e693, _e700, (_e707 == 1u)), (_e717 + (_e724 * d_own)), (_e733 == 2u)), is_boundary), (_e744 - (((_e751 * _e753) + (_e761 * _e763)) * _e767)), (is_boundary && (boundary_type == 4u))) * lambda_other))) * area));
        }
        continuing {
            let _e782 = k;
            k = (_e782 + 1u);
        }
    }
    let _e784 = grad_acc_rho_u_x;
    let grad_out_rho_u_x = ((_e784 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 3u)] = grad_out_rho_u_x.x;
    state[((idx * 22u) + 4u)] = grad_out_rho_u_x.y;
    let _e805 = grad_acc_rho_u_y;
    let grad_out_rho_u_y = ((_e805 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 5u)] = grad_out_rho_u_y.x;
    state[((idx * 22u) + 6u)] = grad_out_rho_u_y.y;
    let _e826 = grad_acc_rho;
    let grad_out_rho = ((_e826 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 12u)] = grad_out_rho.x;
    state[((idx * 22u) + 13u)] = grad_out_rho.y;
    let _e847 = grad_acc_rho_e;
    let grad_out_rho_e = ((_e847 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 14u)] = grad_out_rho_e.x;
    state[((idx * 22u) + 15u)] = grad_out_rho_e.y;
    let _e868 = grad_acc_T;
    let grad_out_T = ((_e868 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 16u)] = grad_out_T.x;
    state[((idx * 22u) + 17u)] = grad_out_T.y;
    let _e889 = grad_acc_u_x;
    let grad_out_u_x = ((_e889 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 18u)] = grad_out_u_x.x;
    state[((idx * 22u) + 19u)] = grad_out_u_x.y;
    let _e910 = grad_acc_u_y;
    let grad_out_u_y = ((_e910 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 22u) + 20u)] = grad_out_u_y.x;
    state[((idx * 22u) + 21u)] = grad_out_u_y.y;
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 8u) + 2u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 8u) + 2u)];
            let _e129 = state[((idx * 8u) + 2u)];
            let _e136 = bc_value[((face_idx * 3u) + 2u)];
            let _e143 = bc_kind[((face_idx * 3u) + 2u)];
            let _e153 = state[((idx * 8u) + 2u)];
            let _e160 = bc_value[((face_idx * 3u) + 2u)];
            let _e169 = bc_kind[((face_idx * 3u) + 2u)];
            let _e179 = grad_acc_p;
            grad_acc_p = (_e179 + ((_e105 * ((_e112 * _e113) + (select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e182 = k;
            k = (_e182 + 1u);
        }
    }
    let _e184 = grad_acc_p;
    let grad_out_p = ((_e184 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let _e69 = normal_vec;
    let d_own_1 = abs(dot((face_center_vec - c_owner_vec), _e69));
    let _e72 = c_neigh_vec;
    let _e74 = normal_vec;
    let d_neigh = abs(dot((_e72 - face_center_vec), _e74));
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e82 = lambda;
    let lambda_other = (1f - _e82);
    let _e85 = c_neigh_vec;
    let d_vec = (_e85 - c_owner_vec);
    let _e87 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e87));
    let dist = max(dist_proj, 0.000001f);
    let _e98 = state[((owner_1 * 8u) + 0u)];
    let _e105 = state[((owner_1 * 8u) + 0u)];
    let _e112 = bc_kind[((idx * 3u) + 0u)];
    let _e119 = bc_value[((idx * 3u) + 0u)];
    let _e120 = bc_neighbor_scalar(_e98, _e105, _e112, _e119, d_own_1, is_boundary_1);
    let _e127 = state[((owner_1 * 8u) + 0u)];
    let _e134 = state[((owner_1 * 8u) + 0u)];
    let _e136 = normal_vec.x;
    let _e144 = state[((owner_1 * 8u) + 1u)];
    let _e146 = normal_vec.y;
    let _e150 = normal_vec.x;
    let s_own_U_x = select(_e120, (_e127 - (((_e134 * _e136) + (_e144 * _e146)) * _e150)), (is_boundary_1 && (boundary_type == 4u)));
    let _e163 = state[((owner_1 * 8u) + 1u)];
    let _e170 = state[((owner_1 * 8u) + 1u)];
    let _e177 = bc_kind[((idx * 3u) + 1u)];
    let _e184 = bc_value[((idx * 3u) + 1u)];
    let _e185 = bc_neighbor_scalar(_e163, _e170, _e177, _e184, d_own_1, is_boundary_1);
    let _e192 = state[((owner_1 * 8u) + 1u)];
    let _e199 = state[((owner_1 * 8u) + 0u)];
    let _e201 = normal_vec.x;
    let _e209 = state[((owner_1 * 8u) + 1u)];
    let _e211 = normal_vec.y;
    let _e215 = normal_vec.y;
    let s_own_U_y = select(_e185, (_e192 - (((_e199 * _e201) + (_e209 * _e211)) * _e215)), (is_boundary_1 && (boundary_type == 4u)));
    let s_own_d_p = state[((owner_1 * 8u) + 3u)];
    let s_own_grad_p_x = state[((owner_1 * 8u) + 4u)];
    let s_own_grad_p_y = state[((owner_1 * 8u) + 5u)];
    let _e249 = state[((owner_1 * 8u) + 2u)];
    let _e256 = state[((owner_1 * 8u) + 2u)];
    let _e263 = bc_kind[((idx * 3u) + 2u)];
    let _e270 = bc_value[((idx * 3u) + 2u)];
    let _e271 = bc_neighbor_scalar(_e249, _e256, _e263, _e270, d_own_1, is_boundary_1);
    let _e272 = neigh_idx;
    let _e279 = state[((_e272 * 8u) + 0u)];
    let _e286 = state[((owner_1 * 8u) + 0u)];
    let _e293 = bc_kind[((idx * 3u) + 0u)];
    let _e300 = bc_value[((idx * 3u) + 0u)];
    let _e301 = bc_neighbor_scalar(_e279, _e286, _e293, _e300, d_own_1, is_boundary_1);
    let _e308 = state[((owner_1 * 8u) + 0u)];
    let _e315 = state[((owner_1 * 8u) + 0u)];
    let _e317 = normal_vec.x;
    let _e325 = state[((owner_1 * 8u) + 1u)];
    let _e327 = normal_vec.y;
    let _e331 = normal_vec.x;
    let s_neigh_U_x = select(_e301, (_e308 - (((_e315 * _e317) + (_e325 * _e327)) * _e331)), (is_boundary_1 && (boundary_type == 4u)));
    let _e338 = neigh_idx;
    let _e345 = state[((_e338 * 8u) + 1u)];
    let _e352 = state[((owner_1 * 8u) + 1u)];
    let _e359 = bc_kind[((idx * 3u) + 1u)];
    let _e366 = bc_value[((idx * 3u) + 1u)];
    let _e367 = bc_neighbor_scalar(_e345, _e352, _e359, _e366, d_own_1, is_boundary_1);
    let _e374 = state[((owner_1 * 8u) + 1u)];
    let _e381 = state[((owner_1 * 8u) + 0u)];
    let _e383 = normal_vec.x;
    let _e391 = state[((owner_1 * 8u) + 1u)];
    let _e393 = normal_vec.y;
    let _e397 = normal_vec.y;
    let s_neigh_U_y = select(_e367, (_e374 - (((_e381 * _e383) + (_e391 * _e393)) * _e397)), (is_boundary_1 && (boundary_type == 4u)));
    let _e404 = neigh_idx;
    let _e411 = state[((_e404 * 8u) + 3u)];
    let _e418 = state[((owner_1 * 8u) + 3u)];
    let s_neigh_d_p = select(_e411, _e418, is_boundary_1);
    let _e420 = neigh_idx;
    let _e427 = state[((_e420 * 8u) + 4u)];
    let _e434 = state[((owner_1 * 8u) + 4u)];
    let s_neigh_grad_p_x = select(_e427, _e434, is_boundary_1);
    let _e436 = neigh_idx;
    let _e443 = state[((_e436 * 8u) + 5u)];
    let _e450 = state[((owner_1 * 8u) + 5u)];
    let s_neigh_grad_p_y = select(_e443, _e450, is_boundary_1);
    let _e452 = neigh_idx;
    let _e459 = state[((_e452 * 8u) + 2u)];
    let _e466 = state[((owner_1 * 8u) + 2u)];
    let _e473 = bc_kind[((idx * 3u) + 2u)];
    let _e480 = bc_value[((idx * 3u) + 2u)];
    let _e481 = bc_neighbor_scalar(_e459, _e466, _e473, _e480, d_own_1, is_boundary_1);
    let _e490 = constants.density;
    let _e492 = lambda;
    let _e498 = lambda;
    let _e515 = lambda;
    let _e521 = normal_vec;
    let _e527 = constants.density;
    let _e528 = lambda;
    fluxes[((idx * 3u) + 0u)] = (((_e490 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e492) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e498) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e515) + (s_neigh_d_p * lambda_other)))), _e521)) * area) - ((((_e527 * ((s_own_d_p * _e528) + (s_neigh_d_p * lambda_other))) * (_e481 - _e271)) / dist) * area));
    let _e546 = constants.density;
    let _e548 = lambda;
    let _e554 = lambda;
    let _e571 = lambda;
    let _e577 = normal_vec;
    let _e583 = constants.density;
    let _e584 = lambda;
    fluxes[((idx * 3u) + 1u)] = (((_e546 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e548) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e554) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e571) + (s_neigh_d_p * lambda_other)))), _e577)) * area) - ((((_e583 * ((s_own_d_p * _e584) + (s_neigh_d_p * lambda_other))) * (_e481 - _e271)) / dist) * area));
    let _e602 = constants.density;
    let _e604 = lambda;
    let _e610 = lambda;
    let _e627 = lambda;
    let _e633 = normal_vec;
    fluxes[((idx * 3u) + 2u)] = ((_e602 * dot((((vec2<f32>(s_own_U_x, s_own_U_y) * _e604) + (vec2<f32>(s_neigh_U_x, s_neigh_U_y) * lambda_other)) + (((vec2<f32>(s_own_grad_p_x, s_own_grad_p_y) * _e610) + (vec2<f32>(select(s_neigh_grad_p_x, 0f, (is_boundary_1 && !((boundary_type == 2u)))), select(s_neigh_grad_p_y, 0f, (is_boundary_1 && !((boundary_type == 2u))))) * lambda_other)) * ((s_own_d_p * _e627) + (s_neigh_d_p * lambda_other)))), _e633)) * area);
    return;
}
"#;
    }
    pub mod generic_coupled_apply {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub row_offsets: wgpu::BufferBinding<'a>,
            pub col_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub row_offsets: wgpu::BindGroupEntry<'a>,
            pub col_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.row_offsets),
                    },
                    col_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.col_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.row_offsets, self.col_indices, self.matrix_values]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"col_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub y: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub y: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    y: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.y),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.x, self.y, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::generic_coupled_apply::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> y: array<f32>;
@group(1) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e5 = constants.stride_x;
    let row = ((global_id.y * _e5) + global_id.x);
    let n = (arrayLength((&row_offsets)) - 1u);
    if (row >= n) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e23 = k;
        if (_e23 < end) {
        } else {
            break;
        }
        {
            let _e26 = k;
            let col = col_indices[_e26];
            let _e30 = k;
            let _e32 = matrix_values[_e30];
            let _e36 = x[col];
            let _e38 = sum;
            sum = (_e38 + (_e32 * _e36));
        }
        continuing {
            let _e41 = k;
            k = (_e41 + 1u);
        }
    }
    let _e45 = sum;
    y[row] = _e45;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup3::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 22u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 22u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 22u) + 0u)];
        let _e750 = state_old_old[((idx * 22u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 22u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 22u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 22u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 22u) + 1u)];
        let _e871 = state_old_old[((idx * 22u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 22u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 22u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 22u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 22u) + 2u)];
        let _e992 = state_old_old[((idx * 22u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 22u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 22u) + 7u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 22u) + 7u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 22u) + 7u)];
        let _e1113 = state_old_old[((idx * 22u) + 7u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 22u) + 7u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 22u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 22u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 22u) + 10u)];
    let _e1332 = state[((idx * 22u) + 10u)];
    let _e1340 = state[((idx * 22u) + 11u)];
    let _e1347 = state[((idx * 22u) + 11u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 22u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1561 = constants.viscosity;
            let _e1564 = constants.viscosity;
            let _e1568 = is_boundary;
            let _e1572 = dist;
            let diff_coeff_rho_u = ((select(_e1558, ((_e1561 + _e1564) * 0.5f), !(_e1568)) * area) / _e1572);
            let _e1574 = is_boundary;
            if !(_e1574) {
                let _e1583 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1583 + diff_coeff_rho_u);
                let _e1592 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1592 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1603 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1603 + diff_coeff_rho_u);
                    let _e1611 = state[((idx * 22u) + 10u)];
                    let _e1618 = state[((idx * 22u) + 10u)];
                    let _e1620 = normal.x;
                    let _e1628 = state[((idx * 22u) + 11u)];
                    let _e1630 = normal.y;
                    let _e1634 = normal.x;
                    let _e1638 = rhs_1_;
                    rhs_1_ = (_e1638 + (diff_coeff_rho_u * (_e1611 - (((_e1618 * _e1620) + (_e1628 * _e1630)) * _e1634))));
                } else {
                    let _e1646 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1646 == 1u) {
                        let _e1656 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                        matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1656 + diff_coeff_rho_u);
                        let _e1664 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1666 = rhs_1_;
                        rhs_1_ = (_e1666 + (diff_coeff_rho_u * _e1664));
                    } else {
                        let _e1674 = bc_kind[((face_idx * 8u) + 4u)];
                        if (_e1674 == 2u) {
                            let _e1679 = constants.viscosity;
                            let _e1682 = constants.viscosity;
                            let _e1685 = constants.viscosity;
                            let _e1689 = is_boundary;
                            let _e1699 = bc_value[((face_idx * 8u) + 4u)];
                            let _e1702 = rhs_1_;
                            rhs_1_ = (_e1702 + -(((select(_e1679, ((_e1682 + _e1685) * 0.5f), !(_e1689)) * area) * _e1699)));
                        }
                    }
                }
            }
            let _e1704 = is_boundary;
            if !(_e1704) {
                let _e1713 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1713 + diff_coeff_rho_u);
                let _e1722 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1722 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1733 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1733 + diff_coeff_rho_u);
                    let _e1741 = state[((idx * 22u) + 11u)];
                    let _e1748 = state[((idx * 22u) + 10u)];
                    let _e1750 = normal.x;
                    let _e1758 = state[((idx * 22u) + 11u)];
                    let _e1760 = normal.y;
                    let _e1764 = normal.y;
                    let _e1768 = rhs_2_;
                    rhs_2_ = (_e1768 + (diff_coeff_rho_u * (_e1741 - (((_e1748 * _e1750) + (_e1758 * _e1760)) * _e1764))));
                } else {
                    let _e1776 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1776 == 1u) {
                        let _e1786 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                        matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1786 + diff_coeff_rho_u);
                        let _e1794 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1796 = rhs_2_;
                        rhs_2_ = (_e1796 + (diff_coeff_rho_u * _e1794));
                    } else {
                        let _e1804 = bc_kind[((face_idx * 8u) + 5u)];
                        if (_e1804 == 2u) {
                            let _e1809 = constants.viscosity;
                            let _e1812 = constants.viscosity;
                            let _e1815 = constants.viscosity;
                            let _e1819 = is_boundary;
                            let _e1829 = bc_value[((face_idx * 8u) + 5u)];
                            let _e1832 = rhs_2_;
                            rhs_2_ = (_e1832 + -(((select(_e1809, ((_e1812 + _e1815) * 0.5f), !(_e1819)) * area) * _e1829)));
                        }
                    }
                }
            }
            let _e1840 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1840;
            if (owner != idx) {
                let _e1843 = phi_1_;
                let _e1846 = phi_1_;
                phi_1_ = (_e1846 - (_e1843 * 2f));
            }
            let _e1848 = phi_1_;
            let _e1849 = rhs_1_;
            rhs_1_ = (_e1849 - _e1848);
            let _e1857 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1857;
            if (owner != idx) {
                let _e1860 = phi_2_;
                let _e1863 = phi_2_;
                phi_2_ = (_e1863 - (_e1860 * 2f));
            }
            let _e1865 = phi_2_;
            let _e1866 = rhs_2_;
            rhs_2_ = (_e1866 - _e1865);
            let _e1874 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1874;
            if (owner != idx) {
                let _e1877 = phi_3_;
                let _e1880 = phi_3_;
                phi_3_ = (_e1880 - (_e1877 * 2f));
            }
            let _e1882 = phi_3_;
            let _e1883 = rhs_3_;
            rhs_3_ = (_e1883 - _e1882);
        }
        continuing {
            let _e1886 = k;
            k = (_e1886 + 1u);
        }
    }
    let _e1895 = diag_0_;
    let _e1896 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1896 + _e1895);
    let _e1904 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1904;
    let _e1912 = diag_1_;
    let _e1913 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1913 + _e1912);
    let _e1921 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1921;
    let _e1929 = diag_2_;
    let _e1930 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1930 + _e1929);
    let _e1938 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1938;
    let _e1946 = diag_3_;
    let _e1947 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1947 + _e1946);
    let _e1955 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1955;
    let _e1963 = diag_4_;
    let _e1964 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1964 + _e1963);
    let _e1973 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1973;
    let _e1981 = diag_5_;
    let _e1982 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1982 + _e1981);
    let _e1991 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1991;
    let _e1999 = diag_6_;
    let _e2000 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e2000 + _e1999);
    let _e2008 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e2008;
    let _e2016 = diag_7_;
    let _e2017 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e2017 + _e2016);
    let _e2026 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e2026;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 22u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 22u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 22u) + 0u)];
        let _e750 = state_old_old[((idx * 22u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 22u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 22u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 22u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 22u) + 1u)];
        let _e871 = state_old_old[((idx * 22u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 22u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 22u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 22u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 22u) + 2u)];
        let _e992 = state_old_old[((idx * 22u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 22u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 22u) + 7u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 22u) + 7u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 22u) + 7u)];
        let _e1113 = state_old_old[((idx * 22u) + 7u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 22u) + 7u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 22u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 22u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 22u) + 10u)];
    let _e1332 = state[((idx * 22u) + 10u)];
    let _e1340 = state[((idx * 22u) + 11u)];
    let _e1347 = state[((idx * 22u) + 11u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 22u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1561 = constants.viscosity;
            let _e1564 = constants.viscosity;
            let _e1568 = is_boundary;
            let _e1572 = dist;
            let diff_coeff_rho_u = ((select(_e1558, ((_e1561 + _e1564) * 0.5f), !(_e1568)) * area) / _e1572);
            let _e1574 = is_boundary;
            if !(_e1574) {
                let _e1583 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1583 + diff_coeff_rho_u);
                let _e1592 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1592 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1603 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1603 + diff_coeff_rho_u);
                    let _e1611 = state[((idx * 22u) + 10u)];
                    let _e1618 = state[((idx * 22u) + 10u)];
                    let _e1620 = normal.x;
                    let _e1628 = state[((idx * 22u) + 11u)];
                    let _e1630 = normal.y;
                    let _e1634 = normal.x;
                    let _e1638 = rhs_1_;
                    rhs_1_ = (_e1638 + (diff_coeff_rho_u * (_e1611 - (((_e1618 * _e1620) + (_e1628 * _e1630)) * _e1634))));
                } else {
                    let _e1646 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1646 == 1u) {
                        let _e1656 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                        matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1656 + diff_coeff_rho_u);
                        let _e1664 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1666 = rhs_1_;
                        rhs_1_ = (_e1666 + (diff_coeff_rho_u * _e1664));
                    } else {
                        let _e1674 = bc_kind[((face_idx * 8u) + 4u)];
                        if (_e1674 == 2u) {
                            let _e1679 = constants.viscosity;
                            let _e1682 = constants.viscosity;
                            let _e1685 = constants.viscosity;
                            let _e1689 = is_boundary;
                            let _e1699 = bc_value[((face_idx * 8u) + 4u)];
                            let _e1702 = rhs_1_;
                            rhs_1_ = (_e1702 + -(((select(_e1679, ((_e1682 + _e1685) * 0.5f), !(_e1689)) * area) * _e1699)));
                        }
                    }
                }
            }
            let _e1704 = is_boundary;
            if !(_e1704) {
                let _e1713 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1713 + diff_coeff_rho_u);
                let _e1722 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1722 - diff_coeff_rho_u);
            } else {
                if (boundary_type == 4u) {
                    let _e1733 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1733 + diff_coeff_rho_u);
                    let _e1741 = state[((idx * 22u) + 11u)];
                    let _e1748 = state[((idx * 22u) + 10u)];
                    let _e1750 = normal.x;
                    let _e1758 = state[((idx * 22u) + 11u)];
                    let _e1760 = normal.y;
                    let _e1764 = normal.y;
                    let _e1768 = rhs_2_;
                    rhs_2_ = (_e1768 + (diff_coeff_rho_u * (_e1741 - (((_e1748 * _e1750) + (_e1758 * _e1760)) * _e1764))));
                } else {
                    let _e1776 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1776 == 1u) {
                        let _e1786 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                        matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1786 + diff_coeff_rho_u);
                        let _e1794 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1796 = rhs_2_;
                        rhs_2_ = (_e1796 + (diff_coeff_rho_u * _e1794));
                    } else {
                        let _e1804 = bc_kind[((face_idx * 8u) + 5u)];
                        if (_e1804 == 2u) {
                            let _e1809 = constants.viscosity;
                            let _e1812 = constants.viscosity;
                            let _e1815 = constants.viscosity;
                            let _e1819 = is_boundary;
                            let _e1829 = bc_value[((face_idx * 8u) + 5u)];
                            let _e1832 = rhs_2_;
                            rhs_2_ = (_e1832 + -(((select(_e1809, ((_e1812 + _e1815) * 0.5f), !(_e1819)) * area) * _e1829)));
                        }
                    }
                }
            }
            let _e1840 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1840;
            if (owner != idx) {
                let _e1843 = phi_1_;
                let _e1846 = phi_1_;
                phi_1_ = (_e1846 - (_e1843 * 2f));
            }
            let _e1848 = phi_1_;
            let _e1849 = rhs_1_;
            rhs_1_ = (_e1849 - _e1848);
            let _e1857 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1857;
            if (owner != idx) {
                let _e1860 = phi_2_;
                let _e1863 = phi_2_;
                phi_2_ = (_e1863 - (_e1860 * 2f));
            }
            let _e1865 = phi_2_;
            let _e1866 = rhs_2_;
            rhs_2_ = (_e1866 - _e1865);
            let _e1874 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1874;
            if (owner != idx) {
                let _e1877 = phi_3_;
                let _e1880 = phi_3_;
                phi_3_ = (_e1880 - (_e1877 * 2f));
            }
            let _e1882 = phi_3_;
            let _e1883 = rhs_3_;
            rhs_3_ = (_e1883 - _e1882);
        }
        continuing {
            let _e1886 = k;
            k = (_e1886 + 1u);
        }
    }
    let _e1895 = diag_0_;
    let _e1896 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1896 + _e1895);
    let _e1904 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1904;
    let _e1912 = diag_1_;
    let _e1913 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1913 + _e1912);
    let _e1921 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1921;
    let _e1929 = diag_2_;
    let _e1930 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1930 + _e1929);
    let _e1938 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1938;
    let _e1946 = diag_3_;
    let _e1947 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1947 + _e1946);
    let _e1955 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1955;
    let _e1963 = diag_4_;
    let _e1964 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1964 + _e1963);
    let _e1973 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1973;
    let _e1981 = diag_5_;
    let _e1982 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1982 + _e1981);
    let _e1991 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1991;
    let _e1999 = diag_6_;
    let _e2000 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e2000 + _e1999);
    let _e2008 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e2008;
    let _e2016 = diag_7_;
    let _e2017 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e2017 + _e2016);
    let _e2026 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e2026;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some(
                    "generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann.wgsl",
                ),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = is_boundary;
            let _e262 = dist;
            let diff_coeff_phi = ((select(1f, 1f, !(_e256)) * area) / _e262);
            let _e264 = is_boundary;
            if !(_e264) {
                let _e266 = diag_0_;
                diag_0_ = (_e266 + diff_coeff_phi);
                let _e275 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e275 - diff_coeff_phi);
            } else {
                let _e283 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e283 == 1u) {
                    let _e286 = diag_0_;
                    diag_0_ = (_e286 + diff_coeff_phi);
                    let _e294 = bc_value[((face_idx * 1u) + 0u)];
                    let _e296 = rhs_0_;
                    rhs_0_ = (_e296 + (diff_coeff_phi * _e294));
                } else {
                    let _e304 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e304 == 2u) {
                        let _e307 = is_boundary;
                        let _e319 = bc_value[((face_idx * 1u) + 0u)];
                        let _e322 = rhs_0_;
                        rhs_0_ = (_e322 + -(((select(1f, 1f, !(_e307)) * area) * _e319)));
                    }
                }
            }
        }
        continuing {
            let _e325 = k;
            k = (_e325 + 1u);
        }
    }
    let _e334 = diag_0_;
    let _e335 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e335 + _e334);
    let _e343 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e343;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e528 = constants.viscosity;
            let _e531 = constants.viscosity;
            let _e535 = is_boundary;
            let _e539 = dist;
            let diff_coeff_U = ((select(_e525, ((_e528 + _e531) * 0.5f), !(_e535)) * area) / _e539);
            let _e541 = is_boundary;
            if !(_e541) {
                let _e543 = diag_0_;
                diag_0_ = (_e543 + diff_coeff_U);
                let _e552 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e552 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e556 = diag_0_;
                    diag_0_ = (_e556 + diff_coeff_U);
                    let _e564 = state[((idx * 8u) + 0u)];
                    let _e571 = state[((idx * 8u) + 0u)];
                    let _e573 = normal.x;
                    let _e581 = state[((idx * 8u) + 1u)];
                    let _e583 = normal.y;
                    let _e587 = normal.x;
                    let _e591 = rhs_0_;
                    rhs_0_ = (_e591 + (diff_coeff_U * (_e564 - (((_e571 * _e573) + (_e581 * _e583)) * _e587))));
                } else {
                    let _e599 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e599 == 1u) {
                        let _e602 = diag_0_;
                        diag_0_ = (_e602 + diff_coeff_U);
                        let _e610 = bc_value[((face_idx * 3u) + 0u)];
                        let _e612 = rhs_0_;
                        rhs_0_ = (_e612 + (diff_coeff_U * _e610));
                    } else {
                        let _e620 = bc_kind[((face_idx * 3u) + 0u)];
                        if (_e620 == 2u) {
                            let _e625 = constants.viscosity;
                            let _e628 = constants.viscosity;
                            let _e631 = constants.viscosity;
                            let _e635 = is_boundary;
                            let _e645 = bc_value[((face_idx * 3u) + 0u)];
                            let _e648 = rhs_0_;
                            rhs_0_ = (_e648 + -(((select(_e625, ((_e628 + _e631) * 0.5f), !(_e635)) * area) * _e645)));
                        }
                    }
                }
            }
            let _e650 = is_boundary;
            if !(_e650) {
                let _e652 = diag_1_;
                diag_1_ = (_e652 + diff_coeff_U);
                let _e661 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e661 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e665 = diag_1_;
                    diag_1_ = (_e665 + diff_coeff_U);
                    let _e673 = state[((idx * 8u) + 1u)];
                    let _e680 = state[((idx * 8u) + 0u)];
                    let _e682 = normal.x;
                    let _e690 = state[((idx * 8u) + 1u)];
                    let _e692 = normal.y;
                    let _e696 = normal.y;
                    let _e700 = rhs_1_;
                    rhs_1_ = (_e700 + (diff_coeff_U * (_e673 - (((_e680 * _e682) + (_e690 * _e692)) * _e696))));
                } else {
                    let _e708 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e708 == 1u) {
                        let _e711 = diag_1_;
                        diag_1_ = (_e711 + diff_coeff_U);
                        let _e719 = bc_value[((face_idx * 3u) + 1u)];
                        let _e721 = rhs_1_;
                        rhs_1_ = (_e721 + (diff_coeff_U * _e719));
                    } else {
                        let _e729 = bc_kind[((face_idx * 3u) + 1u)];
                        if (_e729 == 2u) {
                            let _e734 = constants.viscosity;
                            let _e737 = constants.viscosity;
                            let _e740 = constants.viscosity;
                            let _e744 = is_boundary;
                            let _e754 = bc_value[((face_idx * 3u) + 1u)];
                            let _e757 = rhs_1_;
                            rhs_1_ = (_e757 + -(((select(_e734, ((_e737 + _e740) * 0.5f), !(_e744)) * area) * _e754)));
                        }
                    }
                }
            }
            let _e765 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e765;
            if (owner != idx) {
                let _e768 = phi_0_;
                let _e771 = phi_0_;
                phi_0_ = (_e771 - (_e768 * 2f));
            }
            let _e773 = is_boundary;
            if !(_e773) {
                let _e775 = phi_0_;
                let _e778 = diag_0_;
                diag_0_ = (_e778 + max(_e775, 0f));
                let _e787 = phi_0_;
                let _e790 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e790 + min(_e787, 0f));
                let _e792 = phi_0_;
                let _e799 = state[((idx * 8u) + 0u)];
                let _e800 = other_idx;
                let _e807 = state[((_e800 * 8u) + 0u)];
                let _e808 = phi_0_;
                let _e812 = other_idx;
                let _e819 = state[((_e812 * 8u) + 0u)];
                let _e820 = other_idx;
                let _e828 = grad_state[((_e820 * 8u) + 0u)].x;
                let _e829 = other_idx;
                let _e837 = grad_state[((_e829 * 8u) + 0u)].y;
                let _e843 = other_center.x;
                let _e845 = other_center.y;
                let _e856 = state[((idx * 8u) + 0u)];
                let _e864 = grad_state[((idx * 8u) + 0u)].x;
                let _e872 = grad_state[((idx * 8u) + 0u)].y;
                let _e883 = phi_0_;
                let _e889 = constants.scheme;
                let _e893 = other_idx;
                let _e900 = state[((_e893 * 8u) + 0u)];
                let _e901 = other_idx;
                let _e908 = state[((_e901 * 8u) + 0u)];
                let _e918 = state[((idx * 8u) + 0u)];
                let _e922 = other_idx;
                let _e930 = grad_state[((_e922 * 8u) + 0u)].x;
                let _e931 = other_idx;
                let _e939 = grad_state[((_e931 * 8u) + 0u)].y;
                let _e945 = other_center.x;
                let _e947 = other_center.y;
                let _e954 = other_idx;
                let _e961 = state[((_e954 * 8u) + 0u)];
                let _e969 = state[((idx * 8u) + 0u)];
                let _e976 = state[((idx * 8u) + 0u)];
                let _e980 = other_idx;
                let _e987 = state[((_e980 * 8u) + 0u)];
                let _e998 = grad_state[((idx * 8u) + 0u)].x;
                let _e1006 = grad_state[((idx * 8u) + 0u)].y;
                let _e1009 = other_center.x;
                let _e1011 = other_center.y;
                let _e1027 = state[((idx * 8u) + 0u)];
                let _e1029 = phi_0_;
                let _e1035 = constants.scheme;
                let _e1039 = other_idx;
                let _e1046 = state[((_e1039 * 8u) + 0u)];
                let _e1047 = other_idx;
                let _e1055 = grad_state[((_e1047 * 8u) + 0u)].x;
                let _e1056 = other_idx;
                let _e1064 = grad_state[((_e1056 * 8u) + 0u)].y;
                let _e1070 = other_center.x;
                let _e1072 = other_center.y;
                let _e1082 = state[((idx * 8u) + 0u)];
                let _e1083 = other_idx;
                let _e1090 = state[((_e1083 * 8u) + 0u)];
                let _e1101 = state[((idx * 8u) + 0u)];
                let _e1102 = other_idx;
                let _e1109 = state[((_e1102 * 8u) + 0u)];
                let _e1121 = state[((idx * 8u) + 0u)];
                let _e1129 = grad_state[((idx * 8u) + 0u)].x;
                let _e1137 = grad_state[((idx * 8u) + 0u)].y;
                let _e1147 = other_idx;
                let _e1154 = state[((_e1147 * 8u) + 0u)];
                let _e1161 = state[((idx * 8u) + 0u)];
                let _e1166 = other_idx;
                let _e1173 = state[((_e1166 * 8u) + 0u)];
                let _e1180 = state[((idx * 8u) + 0u)];
                let _e1186 = phi_0_;
                let _e1192 = constants.scheme;
                let _e1196 = other_idx;
                let _e1203 = state[((_e1196 * 8u) + 0u)];
                let _e1204 = other_idx;
                let _e1212 = grad_state[((_e1204 * 8u) + 0u)].x;
                let _e1213 = other_idx;
                let _e1221 = grad_state[((_e1213 * 8u) + 0u)].y;
                let _e1227 = other_center.x;
                let _e1229 = other_center.y;
                let _e1239 = state[((idx * 8u) + 0u)];
                let _e1240 = other_idx;
                let _e1247 = state[((_e1240 * 8u) + 0u)];
                let _e1257 = state[((idx * 8u) + 0u)];
                let _e1258 = other_idx;
                let _e1265 = state[((_e1258 * 8u) + 0u)];
                let _e1268 = other_idx;
                let _e1276 = grad_state[((_e1268 * 8u) + 0u)].x;
                let _e1277 = other_idx;
                let _e1285 = grad_state[((_e1277 * 8u) + 0u)].y;
                let _e1291 = other_center.x;
                let _e1293 = other_center.y;
                let _e1308 = state[((idx * 8u) + 0u)];
                let _e1309 = other_idx;
                let _e1316 = state[((_e1309 * 8u) + 0u)];
                let _e1318 = other_idx;
                let _e1326 = grad_state[((_e1318 * 8u) + 0u)].x;
                let _e1327 = other_idx;
                let _e1335 = grad_state[((_e1327 * 8u) + 0u)].y;
                let _e1341 = other_center.x;
                let _e1343 = other_center.y;
                let _e1357 = state[((idx * 8u) + 0u)];
                let _e1358 = other_idx;
                let _e1365 = state[((_e1358 * 8u) + 0u)];
                let _e1367 = other_idx;
                let _e1375 = grad_state[((_e1367 * 8u) + 0u)].x;
                let _e1376 = other_idx;
                let _e1384 = grad_state[((_e1376 * 8u) + 0u)].y;
                let _e1390 = other_center.x;
                let _e1392 = other_center.y;
                let _e1408 = state[((idx * 8u) + 0u)];
                let _e1416 = grad_state[((idx * 8u) + 0u)].x;
                let _e1424 = grad_state[((idx * 8u) + 0u)].y;
                let _e1434 = other_idx;
                let _e1441 = state[((_e1434 * 8u) + 0u)];
                let _e1448 = state[((idx * 8u) + 0u)];
                let _e1452 = other_idx;
                let _e1459 = state[((_e1452 * 8u) + 0u)];
                let _e1466 = state[((idx * 8u) + 0u)];
                let _e1476 = grad_state[((idx * 8u) + 0u)].x;
                let _e1484 = grad_state[((idx * 8u) + 0u)].y;
                let _e1499 = other_idx;
                let _e1506 = state[((_e1499 * 8u) + 0u)];
                let _e1513 = state[((idx * 8u) + 0u)];
                let _e1522 = grad_state[((idx * 8u) + 0u)].x;
                let _e1530 = grad_state[((idx * 8u) + 0u)].y;
                let _e1544 = other_idx;
                let _e1551 = state[((_e1544 * 8u) + 0u)];
                let _e1558 = state[((idx * 8u) + 0u)];
                let _e1567 = grad_state[((idx * 8u) + 0u)].x;
                let _e1575 = grad_state[((idx * 8u) + 0u)].y;
                let _e1591 = phi_0_;
                let _e1597 = constants.scheme;
                let _e1601 = other_idx;
                let _e1608 = state[((_e1601 * 8u) + 0u)];
                let _e1609 = other_idx;
                let _e1616 = state[((_e1609 * 8u) + 0u)];
                let _e1625 = state[((idx * 8u) + 0u)];
                let _e1629 = other_idx;
                let _e1637 = grad_state[((_e1629 * 8u) + 0u)].x;
                let _e1638 = other_idx;
                let _e1646 = grad_state[((_e1638 * 8u) + 0u)].y;
                let _e1652 = other_center.x;
                let _e1654 = other_center.y;
                let _e1661 = other_idx;
                let _e1668 = state[((_e1661 * 8u) + 0u)];
                let _e1676 = state[((idx * 8u) + 0u)];
                let _e1677 = other_idx;
                let _e1684 = state[((_e1677 * 8u) + 0u)];
                let _e1695 = state[((idx * 8u) + 0u)];
                let _e1696 = other_idx;
                let _e1703 = state[((_e1696 * 8u) + 0u)];
                let _e1715 = state[((idx * 8u) + 0u)];
                let _e1722 = state[((idx * 8u) + 0u)];
                let _e1725 = other_idx;
                let _e1732 = state[((_e1725 * 8u) + 0u)];
                let _e1743 = grad_state[((idx * 8u) + 0u)].x;
                let _e1751 = grad_state[((idx * 8u) + 0u)].y;
                let _e1754 = other_center.x;
                let _e1756 = other_center.y;
                let _e1772 = state[((idx * 8u) + 0u)];
                let _e1774 = other_idx;
                let _e1781 = state[((_e1774 * 8u) + 0u)];
                let _e1788 = state[((idx * 8u) + 0u)];
                let _e1793 = other_idx;
                let _e1800 = state[((_e1793 * 8u) + 0u)];
                let _e1807 = state[((idx * 8u) + 0u)];
                let _e1813 = phi_0_;
                let _e1819 = constants.scheme;
                let _e1823 = other_idx;
                let _e1830 = state[((_e1823 * 8u) + 0u)];
                let _e1831 = other_idx;
                let _e1838 = state[((_e1831 * 8u) + 0u)];
                let _e1847 = state[((idx * 8u) + 0u)];
                let _e1851 = other_idx;
                let _e1859 = grad_state[((_e1851 * 8u) + 0u)].x;
                let _e1860 = other_idx;
                let _e1868 = grad_state[((_e1860 * 8u) + 0u)].y;
                let _e1874 = other_center.x;
                let _e1876 = other_center.y;
                let _e1883 = other_idx;
                let _e1890 = state[((_e1883 * 8u) + 0u)];
                let _e1898 = state[((idx * 8u) + 0u)];
                let _e1899 = other_idx;
                let _e1906 = state[((_e1899 * 8u) + 0u)];
                let _e1916 = state[((idx * 8u) + 0u)];
                let _e1917 = other_idx;
                let _e1924 = state[((_e1917 * 8u) + 0u)];
                let _e1927 = other_idx;
                let _e1934 = state[((_e1927 * 8u) + 0u)];
                let _e1943 = state[((idx * 8u) + 0u)];
                let _e1947 = other_idx;
                let _e1955 = grad_state[((_e1947 * 8u) + 0u)].x;
                let _e1956 = other_idx;
                let _e1964 = grad_state[((_e1956 * 8u) + 0u)].y;
                let _e1970 = other_center.x;
                let _e1972 = other_center.y;
                let _e1979 = other_idx;
                let _e1986 = state[((_e1979 * 8u) + 0u)];
                let _e1999 = state[((idx * 8u) + 0u)];
                let _e2000 = other_idx;
                let _e2007 = state[((_e2000 * 8u) + 0u)];
                let _e2009 = other_idx;
                let _e2016 = state[((_e2009 * 8u) + 0u)];
                let _e2025 = state[((idx * 8u) + 0u)];
                let _e2029 = other_idx;
                let _e2037 = grad_state[((_e2029 * 8u) + 0u)].x;
                let _e2038 = other_idx;
                let _e2046 = grad_state[((_e2038 * 8u) + 0u)].y;
                let _e2052 = other_center.x;
                let _e2054 = other_center.y;
                let _e2061 = other_idx;
                let _e2068 = state[((_e2061 * 8u) + 0u)];
                let _e2080 = state[((idx * 8u) + 0u)];
                let _e2081 = other_idx;
                let _e2088 = state[((_e2081 * 8u) + 0u)];
                let _e2090 = other_idx;
                let _e2097 = state[((_e2090 * 8u) + 0u)];
                let _e2106 = state[((idx * 8u) + 0u)];
                let _e2110 = other_idx;
                let _e2118 = grad_state[((_e2110 * 8u) + 0u)].x;
                let _e2119 = other_idx;
                let _e2127 = grad_state[((_e2119 * 8u) + 0u)].y;
                let _e2133 = other_center.x;
                let _e2135 = other_center.y;
                let _e2142 = other_idx;
                let _e2149 = state[((_e2142 * 8u) + 0u)];
                let _e2163 = state[((idx * 8u) + 0u)];
                let _e2170 = state[((idx * 8u) + 0u)];
                let _e2173 = other_idx;
                let _e2180 = state[((_e2173 * 8u) + 0u)];
                let _e2191 = grad_state[((idx * 8u) + 0u)].x;
                let _e2199 = grad_state[((idx * 8u) + 0u)].y;
                let _e2202 = other_center.x;
                let _e2204 = other_center.y;
                let _e2220 = state[((idx * 8u) + 0u)];
                let _e2222 = other_idx;
                let _e2229 = state[((_e2222 * 8u) + 0u)];
                let _e2236 = state[((idx * 8u) + 0u)];
                let _e2240 = other_idx;
                let _e2247 = state[((_e2240 * 8u) + 0u)];
                let _e2254 = state[((idx * 8u) + 0u)];
                let _e2263 = state[((idx * 8u) + 0u)];
                let _e2266 = other_idx;
                let _e2273 = state[((_e2266 * 8u) + 0u)];
                let _e2284 = grad_state[((idx * 8u) + 0u)].x;
                let _e2292 = grad_state[((idx * 8u) + 0u)].y;
                let _e2295 = other_center.x;
                let _e2297 = other_center.y;
                let _e2313 = state[((idx * 8u) + 0u)];
                let _e2320 = other_idx;
                let _e2327 = state[((_e2320 * 8u) + 0u)];
                let _e2334 = state[((idx * 8u) + 0u)];
                let _e2342 = state[((idx * 8u) + 0u)];
                let _e2345 = other_idx;
                let _e2352 = state[((_e2345 * 8u) + 0u)];
                let _e2363 = grad_state[((idx * 8u) + 0u)].x;
                let _e2371 = grad_state[((idx * 8u) + 0u)].y;
                let _e2374 = other_center.x;
                let _e2376 = other_center.y;
                let _e2392 = state[((idx * 8u) + 0u)];
                let _e2398 = other_idx;
                let _e2405 = state[((_e2398 * 8u) + 0u)];
                let _e2412 = state[((idx * 8u) + 0u)];
                let _e2420 = state[((idx * 8u) + 0u)];
                let _e2423 = other_idx;
                let _e2430 = state[((_e2423 * 8u) + 0u)];
                let _e2441 = grad_state[((idx * 8u) + 0u)].x;
                let _e2449 = grad_state[((idx * 8u) + 0u)].y;
                let _e2452 = other_center.x;
                let _e2454 = other_center.y;
                let _e2470 = state[((idx * 8u) + 0u)];
                let _e2478 = phi_0_;
                let _e2484 = constants.scheme;
                let _e2494 = state[((idx * 8u) + 0u)];
                let _e2495 = other_idx;
                let _e2502 = state[((_e2495 * 8u) + 0u)];
                let _e2503 = phi_0_;
                let _e2509 = rhs_0_;
                rhs_0_ = (_e2509 - (_e792 * (select(select(select(select(select(select(select(_e799, _e807, (_e808 < 0f)), select((_e819 + dot(vec2<f32>(_e828, _e837), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e843, _e845)))), (_e856 + dot(vec2<f32>(_e864, _e872), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e883 > 0f)), (_e889 == 1u)), select(((((_e900 + (_e908 * 0.625f)) + (_e918 * 0.375f)) + (dot(vec2<f32>(_e930, _e939), (vec2<f32>(center.x, center.y) - vec2<f32>(_e945, _e947))) * 0.125f)) - _e961), ((((_e969 + (_e976 * 0.625f)) + (_e987 * 0.375f)) + (dot(vec2<f32>(_e998, _e1006), (vec2<f32>(_e1009, _e1011) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1027), (_e1029 > 0f)), (_e1035 == 2u)), select((_e1046 + min(max(dot(vec2<f32>(_e1055, _e1064), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1070, _e1072))), min((_e1082 - _e1090), 0f)), max((_e1101 - _e1109), 0f))), (_e1121 + min(max(dot(vec2<f32>(_e1129, _e1137), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1154 - _e1161), 0f)), max((_e1173 - _e1180), 0f))), (_e1186 > 0f)), (_e1192 == 3u)), select((_e1203 + ((((dot(vec2<f32>(_e1212, _e1221), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1227, _e1229))) * abs((_e1239 - _e1247))) / max(abs((_e1257 - _e1265)), (abs(dot(vec2<f32>(_e1276, _e1285), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1291, _e1293)))) + 0.00000001f))) * max(((_e1308 - _e1316) * dot(vec2<f32>(_e1326, _e1335), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1341, _e1343)))), 0f)) / max(abs(((_e1357 - _e1365) * dot(vec2<f32>(_e1375, _e1384), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1390, _e1392))))), 0.00000001f))), (_e1408 + ((((dot(vec2<f32>(_e1416, _e1424), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1441 - _e1448))) / max(abs((_e1459 - _e1466)), (abs(dot(vec2<f32>(_e1476, _e1484), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1506 - _e1513) * dot(vec2<f32>(_e1522, _e1530), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1551 - _e1558) * dot(vec2<f32>(_e1567, _e1575), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1591 > 0f)), (_e1597 == 4u)), select((_e1608 + min(max(((((_e1616 * 0.625f) + (_e1625 * 0.375f)) + (dot(vec2<f32>(_e1637, _e1646), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1652, _e1654))) * 0.125f)) - _e1668), min((_e1676 - _e1684), 0f)), max((_e1695 - _e1703), 0f))), (_e1715 + min(max(((((_e1722 * 0.625f) + (_e1732 * 0.375f)) + (dot(vec2<f32>(_e1743, _e1751), (vec2<f32>(_e1754, _e1756) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1772), min((_e1781 - _e1788), 0f)), max((_e1800 - _e1807), 0f))), (_e1813 > 0f)), (_e1819 == 5u)), select((_e1830 + ((((((((_e1838 * 0.625f) + (_e1847 * 0.375f)) + (dot(vec2<f32>(_e1859, _e1868), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1874, _e1876))) * 0.125f)) - _e1890) * abs((_e1898 - _e1906))) / max(abs((_e1916 - _e1924)), (abs(((((_e1934 * 0.625f) + (_e1943 * 0.375f)) + (dot(vec2<f32>(_e1955, _e1964), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1970, _e1972))) * 0.125f)) - _e1986)) + 0.00000001f))) * max(((_e1999 - _e2007) * ((((_e2016 * 0.625f) + (_e2025 * 0.375f)) + (dot(vec2<f32>(_e2037, _e2046), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2052, _e2054))) * 0.125f)) - _e2068)), 0f)) / max(abs(((_e2080 - _e2088) * ((((_e2097 * 0.625f) + (_e2106 * 0.375f)) + (dot(vec2<f32>(_e2118, _e2127), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2133, _e2135))) * 0.125f)) - _e2149))), 0.00000001f))), (_e2163 + ((((((((_e2170 * 0.625f) + (_e2180 * 0.375f)) + (dot(vec2<f32>(_e2191, _e2199), (vec2<f32>(_e2202, _e2204) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2220) * abs((_e2229 - _e2236))) / max(abs((_e2247 - _e2254)), (abs(((((_e2263 * 0.625f) + (_e2273 * 0.375f)) + (dot(vec2<f32>(_e2284, _e2292), (vec2<f32>(_e2295, _e2297) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2313)) + 0.00000001f))) * max(((_e2327 - _e2334) * ((((_e2342 * 0.625f) + (_e2352 * 0.375f)) + (dot(vec2<f32>(_e2363, _e2371), (vec2<f32>(_e2374, _e2376) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2392)), 0f)) / max(abs(((_e2405 - _e2412) * ((((_e2420 * 0.625f) + (_e2430 * 0.375f)) + (dot(vec2<f32>(_e2441, _e2449), (vec2<f32>(_e2452, _e2454) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2470))), 0.00000001f))), (_e2478 > 0f)), (_e2484 == 6u)) - select(_e2494, _e2502, (_e2503 < 0f)))));
            } else {
                let _e2517 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e2517 == 1u) {
                    let _e2520 = phi_0_;
                    let _e2523 = diag_0_;
                    diag_0_ = (_e2523 + max(_e2520, 0f));
                    let _e2525 = phi_0_;
                    let _e2534 = bc_value[((face_idx * 3u) + 0u)];
                    let _e2536 = rhs_0_;
                    rhs_0_ = (_e2536 - (min(_e2525, 0f) * _e2534));
                } else {
                    let _e2538 = phi_0_;
                    let _e2539 = diag_0_;
                    diag_0_ = (_e2539 + _e2538);
                }
            }
            let _e2547 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e2547;
            if (owner != idx) {
                let _e2550 = phi_1_;
                let _e2553 = phi_1_;
                phi_1_ = (_e2553 - (_e2550 * 2f));
            }
            let _e2555 = is_boundary;
            if !(_e2555) {
                let _e2557 = phi_1_;
                let _e2560 = diag_1_;
                diag_1_ = (_e2560 + max(_e2557, 0f));
                let _e2569 = phi_1_;
                let _e2572 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e2572 + min(_e2569, 0f));
                let _e2574 = phi_1_;
                let _e2581 = state[((idx * 8u) + 1u)];
                let _e2582 = other_idx;
                let _e2589 = state[((_e2582 * 8u) + 1u)];
                let _e2590 = phi_1_;
                let _e2594 = other_idx;
                let _e2601 = state[((_e2594 * 8u) + 1u)];
                let _e2602 = other_idx;
                let _e2610 = grad_state[((_e2602 * 8u) + 1u)].x;
                let _e2611 = other_idx;
                let _e2619 = grad_state[((_e2611 * 8u) + 1u)].y;
                let _e2625 = other_center.x;
                let _e2627 = other_center.y;
                let _e2638 = state[((idx * 8u) + 1u)];
                let _e2646 = grad_state[((idx * 8u) + 1u)].x;
                let _e2654 = grad_state[((idx * 8u) + 1u)].y;
                let _e2665 = phi_1_;
                let _e2671 = constants.scheme;
                let _e2675 = other_idx;
                let _e2682 = state[((_e2675 * 8u) + 1u)];
                let _e2683 = other_idx;
                let _e2690 = state[((_e2683 * 8u) + 1u)];
                let _e2700 = state[((idx * 8u) + 1u)];
                let _e2704 = other_idx;
                let _e2712 = grad_state[((_e2704 * 8u) + 1u)].x;
                let _e2713 = other_idx;
                let _e2721 = grad_state[((_e2713 * 8u) + 1u)].y;
                let _e2727 = other_center.x;
                let _e2729 = other_center.y;
                let _e2736 = other_idx;
                let _e2743 = state[((_e2736 * 8u) + 1u)];
                let _e2751 = state[((idx * 8u) + 1u)];
                let _e2758 = state[((idx * 8u) + 1u)];
                let _e2762 = other_idx;
                let _e2769 = state[((_e2762 * 8u) + 1u)];
                let _e2780 = grad_state[((idx * 8u) + 1u)].x;
                let _e2788 = grad_state[((idx * 8u) + 1u)].y;
                let _e2791 = other_center.x;
                let _e2793 = other_center.y;
                let _e2809 = state[((idx * 8u) + 1u)];
                let _e2811 = phi_1_;
                let _e2817 = constants.scheme;
                let _e2821 = other_idx;
                let _e2828 = state[((_e2821 * 8u) + 1u)];
                let _e2829 = other_idx;
                let _e2837 = grad_state[((_e2829 * 8u) + 1u)].x;
                let _e2838 = other_idx;
                let _e2846 = grad_state[((_e2838 * 8u) + 1u)].y;
                let _e2852 = other_center.x;
                let _e2854 = other_center.y;
                let _e2864 = state[((idx * 8u) + 1u)];
                let _e2865 = other_idx;
                let _e2872 = state[((_e2865 * 8u) + 1u)];
                let _e2883 = state[((idx * 8u) + 1u)];
                let _e2884 = other_idx;
                let _e2891 = state[((_e2884 * 8u) + 1u)];
                let _e2903 = state[((idx * 8u) + 1u)];
                let _e2911 = grad_state[((idx * 8u) + 1u)].x;
                let _e2919 = grad_state[((idx * 8u) + 1u)].y;
                let _e2929 = other_idx;
                let _e2936 = state[((_e2929 * 8u) + 1u)];
                let _e2943 = state[((idx * 8u) + 1u)];
                let _e2948 = other_idx;
                let _e2955 = state[((_e2948 * 8u) + 1u)];
                let _e2962 = state[((idx * 8u) + 1u)];
                let _e2968 = phi_1_;
                let _e2974 = constants.scheme;
                let _e2978 = other_idx;
                let _e2985 = state[((_e2978 * 8u) + 1u)];
                let _e2986 = other_idx;
                let _e2994 = grad_state[((_e2986 * 8u) + 1u)].x;
                let _e2995 = other_idx;
                let _e3003 = grad_state[((_e2995 * 8u) + 1u)].y;
                let _e3009 = other_center.x;
                let _e3011 = other_center.y;
                let _e3021 = state[((idx * 8u) + 1u)];
                let _e3022 = other_idx;
                let _e3029 = state[((_e3022 * 8u) + 1u)];
                let _e3039 = state[((idx * 8u) + 1u)];
                let _e3040 = other_idx;
                let _e3047 = state[((_e3040 * 8u) + 1u)];
                let _e3050 = other_idx;
                let _e3058 = grad_state[((_e3050 * 8u) + 1u)].x;
                let _e3059 = other_idx;
                let _e3067 = grad_state[((_e3059 * 8u) + 1u)].y;
                let _e3073 = other_center.x;
                let _e3075 = other_center.y;
                let _e3090 = state[((idx * 8u) + 1u)];
                let _e3091 = other_idx;
                let _e3098 = state[((_e3091 * 8u) + 1u)];
                let _e3100 = other_idx;
                let _e3108 = grad_state[((_e3100 * 8u) + 1u)].x;
                let _e3109 = other_idx;
                let _e3117 = grad_state[((_e3109 * 8u) + 1u)].y;
                let _e3123 = other_center.x;
                let _e3125 = other_center.y;
                let _e3139 = state[((idx * 8u) + 1u)];
                let _e3140 = other_idx;
                let _e3147 = state[((_e3140 * 8u) + 1u)];
                let _e3149 = other_idx;
                let _e3157 = grad_state[((_e3149 * 8u) + 1u)].x;
                let _e3158 = other_idx;
                let _e3166 = grad_state[((_e3158 * 8u) + 1u)].y;
                let _e3172 = other_center.x;
                let _e3174 = other_center.y;
                let _e3190 = state[((idx * 8u) + 1u)];
                let _e3198 = grad_state[((idx * 8u) + 1u)].x;
                let _e3206 = grad_state[((idx * 8u) + 1u)].y;
                let _e3216 = other_idx;
                let _e3223 = state[((_e3216 * 8u) + 1u)];
                let _e3230 = state[((idx * 8u) + 1u)];
                let _e3234 = other_idx;
                let _e3241 = state[((_e3234 * 8u) + 1u)];
                let _e3248 = state[((idx * 8u) + 1u)];
                let _e3258 = grad_state[((idx * 8u) + 1u)].x;
                let _e3266 = grad_state[((idx * 8u) + 1u)].y;
                let _e3281 = other_idx;
                let _e3288 = state[((_e3281 * 8u) + 1u)];
                let _e3295 = state[((idx * 8u) + 1u)];
                let _e3304 = grad_state[((idx * 8u) + 1u)].x;
                let _e3312 = grad_state[((idx * 8u) + 1u)].y;
                let _e3326 = other_idx;
                let _e3333 = state[((_e3326 * 8u) + 1u)];
                let _e3340 = state[((idx * 8u) + 1u)];
                let _e3349 = grad_state[((idx * 8u) + 1u)].x;
                let _e3357 = grad_state[((idx * 8u) + 1u)].y;
                let _e3373 = phi_1_;
                let _e3379 = constants.scheme;
                let _e3383 = other_idx;
                let _e3390 = state[((_e3383 * 8u) + 1u)];
                let _e3391 = other_idx;
                let _e3398 = state[((_e3391 * 8u) + 1u)];
                let _e3407 = state[((idx * 8u) + 1u)];
                let _e3411 = other_idx;
                let _e3419 = grad_state[((_e3411 * 8u) + 1u)].x;
                let _e3420 = other_idx;
                let _e3428 = grad_state[((_e3420 * 8u) + 1u)].y;
                let _e3434 = other_center.x;
                let _e3436 = other_center.y;
                let _e3443 = other_idx;
                let _e3450 = state[((_e3443 * 8u) + 1u)];
                let _e3458 = state[((idx * 8u) + 1u)];
                let _e3459 = other_idx;
                let _e3466 = state[((_e3459 * 8u) + 1u)];
                let _e3477 = state[((idx * 8u) + 1u)];
                let _e3478 = other_idx;
                let _e3485 = state[((_e3478 * 8u) + 1u)];
                let _e3497 = state[((idx * 8u) + 1u)];
                let _e3504 = state[((idx * 8u) + 1u)];
                let _e3507 = other_idx;
                let _e3514 = state[((_e3507 * 8u) + 1u)];
                let _e3525 = grad_state[((idx * 8u) + 1u)].x;
                let _e3533 = grad_state[((idx * 8u) + 1u)].y;
                let _e3536 = other_center.x;
                let _e3538 = other_center.y;
                let _e3554 = state[((idx * 8u) + 1u)];
                let _e3556 = other_idx;
                let _e3563 = state[((_e3556 * 8u) + 1u)];
                let _e3570 = state[((idx * 8u) + 1u)];
                let _e3575 = other_idx;
                let _e3582 = state[((_e3575 * 8u) + 1u)];
                let _e3589 = state[((idx * 8u) + 1u)];
                let _e3595 = phi_1_;
                let _e3601 = constants.scheme;
                let _e3605 = other_idx;
                let _e3612 = state[((_e3605 * 8u) + 1u)];
                let _e3613 = other_idx;
                let _e3620 = state[((_e3613 * 8u) + 1u)];
                let _e3629 = state[((idx * 8u) + 1u)];
                let _e3633 = other_idx;
                let _e3641 = grad_state[((_e3633 * 8u) + 1u)].x;
                let _e3642 = other_idx;
                let _e3650 = grad_state[((_e3642 * 8u) + 1u)].y;
                let _e3656 = other_center.x;
                let _e3658 = other_center.y;
                let _e3665 = other_idx;
                let _e3672 = state[((_e3665 * 8u) + 1u)];
                let _e3680 = state[((idx * 8u) + 1u)];
                let _e3681 = other_idx;
                let _e3688 = state[((_e3681 * 8u) + 1u)];
                let _e3698 = state[((idx * 8u) + 1u)];
                let _e3699 = other_idx;
                let _e3706 = state[((_e3699 * 8u) + 1u)];
                let _e3709 = other_idx;
                let _e3716 = state[((_e3709 * 8u) + 1u)];
                let _e3725 = state[((idx * 8u) + 1u)];
                let _e3729 = other_idx;
                let _e3737 = grad_state[((_e3729 * 8u) + 1u)].x;
                let _e3738 = other_idx;
                let _e3746 = grad_state[((_e3738 * 8u) + 1u)].y;
                let _e3752 = other_center.x;
                let _e3754 = other_center.y;
                let _e3761 = other_idx;
                let _e3768 = state[((_e3761 * 8u) + 1u)];
                let _e3781 = state[((idx * 8u) + 1u)];
                let _e3782 = other_idx;
                let _e3789 = state[((_e3782 * 8u) + 1u)];
                let _e3791 = other_idx;
                let _e3798 = state[((_e3791 * 8u) + 1u)];
                let _e3807 = state[((idx * 8u) + 1u)];
                let _e3811 = other_idx;
                let _e3819 = grad_state[((_e3811 * 8u) + 1u)].x;
                let _e3820 = other_idx;
                let _e3828 = grad_state[((_e3820 * 8u) + 1u)].y;
                let _e3834 = other_center.x;
                let _e3836 = other_center.y;
                let _e3843 = other_idx;
                let _e3850 = state[((_e3843 * 8u) + 1u)];
                let _e3862 = state[((idx * 8u) + 1u)];
                let _e3863 = other_idx;
                let _e3870 = state[((_e3863 * 8u) + 1u)];
                let _e3872 = other_idx;
                let _e3879 = state[((_e3872 * 8u) + 1u)];
                let _e3888 = state[((idx * 8u) + 1u)];
                let _e3892 = other_idx;
                let _e3900 = grad_state[((_e3892 * 8u) + 1u)].x;
                let _e3901 = other_idx;
                let _e3909 = grad_state[((_e3901 * 8u) + 1u)].y;
                let _e3915 = other_center.x;
                let _e3917 = other_center.y;
                let _e3924 = other_idx;
                let _e3931 = state[((_e3924 * 8u) + 1u)];
                let _e3945 = state[((idx * 8u) + 1u)];
                let _e3952 = state[((idx * 8u) + 1u)];
                let _e3955 = other_idx;
                let _e3962 = state[((_e3955 * 8u) + 1u)];
                let _e3973 = grad_state[((idx * 8u) + 1u)].x;
                let _e3981 = grad_state[((idx * 8u) + 1u)].y;
                let _e3984 = other_center.x;
                let _e3986 = other_center.y;
                let _e4002 = state[((idx * 8u) + 1u)];
                let _e4004 = other_idx;
                let _e4011 = state[((_e4004 * 8u) + 1u)];
                let _e4018 = state[((idx * 8u) + 1u)];
                let _e4022 = other_idx;
                let _e4029 = state[((_e4022 * 8u) + 1u)];
                let _e4036 = state[((idx * 8u) + 1u)];
                let _e4045 = state[((idx * 8u) + 1u)];
                let _e4048 = other_idx;
                let _e4055 = state[((_e4048 * 8u) + 1u)];
                let _e4066 = grad_state[((idx * 8u) + 1u)].x;
                let _e4074 = grad_state[((idx * 8u) + 1u)].y;
                let _e4077 = other_center.x;
                let _e4079 = other_center.y;
                let _e4095 = state[((idx * 8u) + 1u)];
                let _e4102 = other_idx;
                let _e4109 = state[((_e4102 * 8u) + 1u)];
                let _e4116 = state[((idx * 8u) + 1u)];
                let _e4124 = state[((idx * 8u) + 1u)];
                let _e4127 = other_idx;
                let _e4134 = state[((_e4127 * 8u) + 1u)];
                let _e4145 = grad_state[((idx * 8u) + 1u)].x;
                let _e4153 = grad_state[((idx * 8u) + 1u)].y;
                let _e4156 = other_center.x;
                let _e4158 = other_center.y;
                let _e4174 = state[((idx * 8u) + 1u)];
                let _e4180 = other_idx;
                let _e4187 = state[((_e4180 * 8u) + 1u)];
                let _e4194 = state[((idx * 8u) + 1u)];
                let _e4202 = state[((idx * 8u) + 1u)];
                let _e4205 = other_idx;
                let _e4212 = state[((_e4205 * 8u) + 1u)];
                let _e4223 = grad_state[((idx * 8u) + 1u)].x;
                let _e4231 = grad_state[((idx * 8u) + 1u)].y;
                let _e4234 = other_center.x;
                let _e4236 = other_center.y;
                let _e4252 = state[((idx * 8u) + 1u)];
                let _e4260 = phi_1_;
                let _e4266 = constants.scheme;
                let _e4276 = state[((idx * 8u) + 1u)];
                let _e4277 = other_idx;
                let _e4284 = state[((_e4277 * 8u) + 1u)];
                let _e4285 = phi_1_;
                let _e4291 = rhs_1_;
                rhs_1_ = (_e4291 - (_e2574 * (select(select(select(select(select(select(select(_e2581, _e2589, (_e2590 < 0f)), select((_e2601 + dot(vec2<f32>(_e2610, _e2619), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2625, _e2627)))), (_e2638 + dot(vec2<f32>(_e2646, _e2654), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e2665 > 0f)), (_e2671 == 1u)), select(((((_e2682 + (_e2690 * 0.625f)) + (_e2700 * 0.375f)) + (dot(vec2<f32>(_e2712, _e2721), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2727, _e2729))) * 0.125f)) - _e2743), ((((_e2751 + (_e2758 * 0.625f)) + (_e2769 * 0.375f)) + (dot(vec2<f32>(_e2780, _e2788), (vec2<f32>(_e2791, _e2793) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2809), (_e2811 > 0f)), (_e2817 == 2u)), select((_e2828 + min(max(dot(vec2<f32>(_e2837, _e2846), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2852, _e2854))), min((_e2864 - _e2872), 0f)), max((_e2883 - _e2891), 0f))), (_e2903 + min(max(dot(vec2<f32>(_e2911, _e2919), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e2936 - _e2943), 0f)), max((_e2955 - _e2962), 0f))), (_e2968 > 0f)), (_e2974 == 3u)), select((_e2985 + ((((dot(vec2<f32>(_e2994, _e3003), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3009, _e3011))) * abs((_e3021 - _e3029))) / max(abs((_e3039 - _e3047)), (abs(dot(vec2<f32>(_e3058, _e3067), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3073, _e3075)))) + 0.00000001f))) * max(((_e3090 - _e3098) * dot(vec2<f32>(_e3108, _e3117), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3123, _e3125)))), 0f)) / max(abs(((_e3139 - _e3147) * dot(vec2<f32>(_e3157, _e3166), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3172, _e3174))))), 0.00000001f))), (_e3190 + ((((dot(vec2<f32>(_e3198, _e3206), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e3223 - _e3230))) / max(abs((_e3241 - _e3248)), (abs(dot(vec2<f32>(_e3258, _e3266), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e3288 - _e3295) * dot(vec2<f32>(_e3304, _e3312), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e3333 - _e3340) * dot(vec2<f32>(_e3349, _e3357), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e3373 > 0f)), (_e3379 == 4u)), select((_e3390 + min(max(((((_e3398 * 0.625f) + (_e3407 * 0.375f)) + (dot(vec2<f32>(_e3419, _e3428), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3434, _e3436))) * 0.125f)) - _e3450), min((_e3458 - _e3466), 0f)), max((_e3477 - _e3485), 0f))), (_e3497 + min(max(((((_e3504 * 0.625f) + (_e3514 * 0.375f)) + (dot(vec2<f32>(_e3525, _e3533), (vec2<f32>(_e3536, _e3538) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3554), min((_e3563 - _e3570), 0f)), max((_e3582 - _e3589), 0f))), (_e3595 > 0f)), (_e3601 == 5u)), select((_e3612 + ((((((((_e3620 * 0.625f) + (_e3629 * 0.375f)) + (dot(vec2<f32>(_e3641, _e3650), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3656, _e3658))) * 0.125f)) - _e3672) * abs((_e3680 - _e3688))) / max(abs((_e3698 - _e3706)), (abs(((((_e3716 * 0.625f) + (_e3725 * 0.375f)) + (dot(vec2<f32>(_e3737, _e3746), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3752, _e3754))) * 0.125f)) - _e3768)) + 0.00000001f))) * max(((_e3781 - _e3789) * ((((_e3798 * 0.625f) + (_e3807 * 0.375f)) + (dot(vec2<f32>(_e3819, _e3828), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3834, _e3836))) * 0.125f)) - _e3850)), 0f)) / max(abs(((_e3862 - _e3870) * ((((_e3879 * 0.625f) + (_e3888 * 0.375f)) + (dot(vec2<f32>(_e3900, _e3909), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3915, _e3917))) * 0.125f)) - _e3931))), 0.00000001f))), (_e3945 + ((((((((_e3952 * 0.625f) + (_e3962 * 0.375f)) + (dot(vec2<f32>(_e3973, _e3981), (vec2<f32>(_e3984, _e3986) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4002) * abs((_e4011 - _e4018))) / max(abs((_e4029 - _e4036)), (abs(((((_e4045 * 0.625f) + (_e4055 * 0.375f)) + (dot(vec2<f32>(_e4066, _e4074), (vec2<f32>(_e4077, _e4079) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4095)) + 0.00000001f))) * max(((_e4109 - _e4116) * ((((_e4124 * 0.625f) + (_e4134 * 0.375f)) + (dot(vec2<f32>(_e4145, _e4153), (vec2<f32>(_e4156, _e4158) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4174)), 0f)) / max(abs(((_e4187 - _e4194) * ((((_e4202 * 0.625f) + (_e4212 * 0.375f)) + (dot(vec2<f32>(_e4223, _e4231), (vec2<f32>(_e4234, _e4236) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4252))), 0.00000001f))), (_e4260 > 0f)), (_e4266 == 6u)) - select(_e4276, _e4284, (_e4285 < 0f)))));
            } else {
                let _e4299 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e4299 == 1u) {
                    let _e4302 = phi_1_;
                    let _e4305 = diag_1_;
                    diag_1_ = (_e4305 + max(_e4302, 0f));
                    let _e4307 = phi_1_;
                    let _e4316 = bc_value[((face_idx * 3u) + 1u)];
                    let _e4318 = rhs_1_;
                    rhs_1_ = (_e4318 - (min(_e4307, 0f) * _e4316));
                } else {
                    let _e4320 = phi_1_;
                    let _e4321 = diag_1_;
                    diag_1_ = (_e4321 + _e4320);
                }
            }
            let _e4326 = normal.x;
            let _e4334 = state[((idx * 8u) + 2u)];
            let _e4335 = other_idx;
            let _e4342 = state[((_e4335 * 8u) + 2u)];
            let _e4345 = rhs_0_;
            rhs_0_ = (_e4345 - (((0.5f * area) * _e4326) * (_e4334 + _e4342)));
            let _e4350 = normal.y;
            let _e4358 = state[((idx * 8u) + 2u)];
            let _e4359 = other_idx;
            let _e4366 = state[((_e4359 * 8u) + 2u)];
            let _e4369 = rhs_1_;
            rhs_1_ = (_e4369 - (((0.5f * area) * _e4350) * (_e4358 + _e4366)));
            let _e4373 = constants.density;
            let _e4380 = state[((idx * 8u) + 3u)];
            let _e4384 = constants.density;
            let _e4391 = state[((idx * 8u) + 3u)];
            let _e4395 = constants.density;
            let _e4396 = other_idx;
            let _e4403 = state[((_e4396 * 8u) + 3u)];
            let _e4408 = is_boundary;
            let _e4412 = dist;
            let diff_coeff_p = ((select((_e4373 * _e4380), (((_e4384 * _e4391) + (_e4395 * _e4403)) * 0.5f), !(_e4408)) * area) / _e4412);
            let _e4414 = is_boundary;
            if !(_e4414) {
                let _e4417 = diag_2_;
                diag_2_ = (_e4417 + diff_coeff_p);
                let _e4426 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e4426 - diff_coeff_p);
            } else {
                let _e4434 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e4434 == 1u) {
                    let _e4437 = diag_2_;
                    diag_2_ = (_e4437 + diff_coeff_p);
                    let _e4446 = bc_value[((face_idx * 3u) + 2u)];
                    let _e4448 = rhs_2_;
                    rhs_2_ = (_e4448 + (diff_coeff_p * _e4446));
                } else {
                    let _e4456 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e4456 == 2u) {
                        let _e4461 = constants.density;
                        let _e4468 = state[((idx * 8u) + 3u)];
                        let _e4472 = constants.density;
                        let _e4479 = state[((idx * 8u) + 3u)];
                        let _e4483 = constants.density;
                        let _e4484 = other_idx;
                        let _e4491 = state[((_e4484 * 8u) + 3u)];
                        let _e4496 = is_boundary;
                        let _e4506 = bc_value[((face_idx * 3u) + 2u)];
                        let _e4509 = rhs_2_;
                        rhs_2_ = (_e4509 + -(((select((_e4461 * _e4468), (((_e4472 * _e4479) + (_e4483 * _e4491)) * 0.5f), !(_e4496)) * area) * _e4506)));
                    }
                }
            }
            let _e4517 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e4517;
            if (owner != idx) {
                let _e4520 = phi_2_;
                let _e4523 = phi_2_;
                phi_2_ = (_e4523 - (_e4520 * 2f));
            }
            let _e4525 = phi_2_;
            let _e4526 = rhs_2_;
            rhs_2_ = (_e4526 - _e4525);
        }
        continuing {
            let _e4529 = k;
            k = (_e4529 + 1u);
        }
    }
    let _e4538 = diag_0_;
    let _e4539 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e4539 + _e4538);
    let _e4547 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e4547;
    let _e4555 = diag_1_;
    let _e4556 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e4556 + _e4555);
    let _e4564 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e4564;
    let _e4572 = diag_2_;
    let _e4573 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e4573 + _e4572);
    let _e4581 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e4581;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e528 = constants.viscosity;
            let _e531 = constants.viscosity;
            let _e535 = is_boundary;
            let _e539 = dist;
            let diff_coeff_U = ((select(_e525, ((_e528 + _e531) * 0.5f), !(_e535)) * area) / _e539);
            let _e541 = is_boundary;
            if !(_e541) {
                let _e543 = diag_0_;
                diag_0_ = (_e543 + diff_coeff_U);
                let _e552 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e552 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e556 = diag_0_;
                    diag_0_ = (_e556 + diff_coeff_U);
                    let _e564 = state[((idx * 8u) + 0u)];
                    let _e571 = state[((idx * 8u) + 0u)];
                    let _e573 = normal.x;
                    let _e581 = state[((idx * 8u) + 1u)];
                    let _e583 = normal.y;
                    let _e587 = normal.x;
                    let _e591 = rhs_0_;
                    rhs_0_ = (_e591 + (diff_coeff_U * (_e564 - (((_e571 * _e573) + (_e581 * _e583)) * _e587))));
                } else {
                    let _e599 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e599 == 1u) {
                        let _e602 = diag_0_;
                        diag_0_ = (_e602 + diff_coeff_U);
                        let _e610 = bc_value[((face_idx * 3u) + 0u)];
                        let _e612 = rhs_0_;
                        rhs_0_ = (_e612 + (diff_coeff_U * _e610));
                    } else {
                        let _e620 = bc_kind[((face_idx * 3u) + 0u)];
                        if (_e620 == 2u) {
                            let _e625 = constants.viscosity;
                            let _e628 = constants.viscosity;
                            let _e631 = constants.viscosity;
                            let _e635 = is_boundary;
                            let _e645 = bc_value[((face_idx * 3u) + 0u)];
                            let _e648 = rhs_0_;
                            rhs_0_ = (_e648 + -(((select(_e625, ((_e628 + _e631) * 0.5f), !(_e635)) * area) * _e645)));
                        }
                    }
                }
            }
            let _e650 = is_boundary;
            if !(_e650) {
                let _e652 = diag_1_;
                diag_1_ = (_e652 + diff_coeff_U);
                let _e661 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e661 - diff_coeff_U);
            } else {
                if (boundary_type == 4u) {
                    let _e665 = diag_1_;
                    diag_1_ = (_e665 + diff_coeff_U);
                    let _e673 = state[((idx * 8u) + 1u)];
                    let _e680 = state[((idx * 8u) + 0u)];
                    let _e682 = normal.x;
                    let _e690 = state[((idx * 8u) + 1u)];
                    let _e692 = normal.y;
                    let _e696 = normal.y;
                    let _e700 = rhs_1_;
                    rhs_1_ = (_e700 + (diff_coeff_U * (_e673 - (((_e680 * _e682) + (_e690 * _e692)) * _e696))));
                } else {
                    let _e708 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e708 == 1u) {
                        let _e711 = diag_1_;
                        diag_1_ = (_e711 + diff_coeff_U);
                        let _e719 = bc_value[((face_idx * 3u) + 1u)];
                        let _e721 = rhs_1_;
                        rhs_1_ = (_e721 + (diff_coeff_U * _e719));
                    } else {
                        let _e729 = bc_kind[((face_idx * 3u) + 1u)];
                        if (_e729 == 2u) {
                            let _e734 = constants.viscosity;
                            let _e737 = constants.viscosity;
                            let _e740 = constants.viscosity;
                            let _e744 = is_boundary;
                            let _e754 = bc_value[((face_idx * 3u) + 1u)];
                            let _e757 = rhs_1_;
                            rhs_1_ = (_e757 + -(((select(_e734, ((_e737 + _e740) * 0.5f), !(_e744)) * area) * _e754)));
                        }
                    }
                }
            }
            let _e765 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e765;
            if (owner != idx) {
                let _e768 = phi_0_;
                let _e771 = phi_0_;
                phi_0_ = (_e771 - (_e768 * 2f));
            }
            let _e773 = is_boundary;
            if !(_e773) {
                let _e775 = phi_0_;
                let _e778 = diag_0_;
                diag_0_ = (_e778 + max(_e775, 0f));
                let _e787 = phi_0_;
                let _e790 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e790 + min(_e787, 0f));
                let _e792 = phi_0_;
                let _e799 = state[((idx * 8u) + 0u)];
                let _e800 = other_idx;
                let _e807 = state[((_e800 * 8u) + 0u)];
                let _e808 = phi_0_;
                let _e812 = other_idx;
                let _e819 = state[((_e812 * 8u) + 0u)];
                let _e820 = other_idx;
                let _e827 = state[((_e820 * 8u) + 0u)];
                let _e834 = state[((idx * 8u) + 0u)];
                let _e843 = other_idx;
                let _e850 = state[((_e843 * 8u) + 0u)];
                let _e857 = state[((idx * 8u) + 0u)];
                let _e871 = other_center.x;
                let _e873 = other_center.y;
                let _e884 = state[((idx * 8u) + 0u)];
                let _e885 = other_idx;
                let _e892 = state[((_e885 * 8u) + 0u)];
                let _e899 = state[((idx * 8u) + 0u)];
                let _e908 = other_idx;
                let _e915 = state[((_e908 * 8u) + 0u)];
                let _e922 = state[((idx * 8u) + 0u)];
                let _e941 = phi_0_;
                let _e947 = constants.scheme;
                let _e951 = other_idx;
                let _e958 = state[((_e951 * 8u) + 0u)];
                let _e959 = other_idx;
                let _e966 = state[((_e959 * 8u) + 0u)];
                let _e976 = state[((idx * 8u) + 0u)];
                let _e980 = other_idx;
                let _e987 = state[((_e980 * 8u) + 0u)];
                let _e994 = state[((idx * 8u) + 0u)];
                let _e1003 = other_idx;
                let _e1010 = state[((_e1003 * 8u) + 0u)];
                let _e1017 = state[((idx * 8u) + 0u)];
                let _e1031 = other_center.x;
                let _e1033 = other_center.y;
                let _e1040 = other_idx;
                let _e1047 = state[((_e1040 * 8u) + 0u)];
                let _e1055 = state[((idx * 8u) + 0u)];
                let _e1062 = state[((idx * 8u) + 0u)];
                let _e1066 = other_idx;
                let _e1073 = state[((_e1066 * 8u) + 0u)];
                let _e1077 = other_idx;
                let _e1084 = state[((_e1077 * 8u) + 0u)];
                let _e1091 = state[((idx * 8u) + 0u)];
                let _e1100 = other_idx;
                let _e1107 = state[((_e1100 * 8u) + 0u)];
                let _e1114 = state[((idx * 8u) + 0u)];
                let _e1125 = other_center.x;
                let _e1127 = other_center.y;
                let _e1143 = state[((idx * 8u) + 0u)];
                let _e1145 = phi_0_;
                let _e1151 = constants.scheme;
                let _e1155 = other_idx;
                let _e1162 = state[((_e1155 * 8u) + 0u)];
                let _e1163 = other_idx;
                let _e1170 = state[((_e1163 * 8u) + 0u)];
                let _e1177 = state[((idx * 8u) + 0u)];
                let _e1186 = other_idx;
                let _e1193 = state[((_e1186 * 8u) + 0u)];
                let _e1200 = state[((idx * 8u) + 0u)];
                let _e1214 = other_center.x;
                let _e1216 = other_center.y;
                let _e1226 = state[((idx * 8u) + 0u)];
                let _e1227 = other_idx;
                let _e1234 = state[((_e1227 * 8u) + 0u)];
                let _e1245 = state[((idx * 8u) + 0u)];
                let _e1246 = other_idx;
                let _e1253 = state[((_e1246 * 8u) + 0u)];
                let _e1265 = state[((idx * 8u) + 0u)];
                let _e1266 = other_idx;
                let _e1273 = state[((_e1266 * 8u) + 0u)];
                let _e1280 = state[((idx * 8u) + 0u)];
                let _e1289 = other_idx;
                let _e1296 = state[((_e1289 * 8u) + 0u)];
                let _e1303 = state[((idx * 8u) + 0u)];
                let _e1321 = other_idx;
                let _e1328 = state[((_e1321 * 8u) + 0u)];
                let _e1335 = state[((idx * 8u) + 0u)];
                let _e1340 = other_idx;
                let _e1347 = state[((_e1340 * 8u) + 0u)];
                let _e1354 = state[((idx * 8u) + 0u)];
                let _e1360 = phi_0_;
                let _e1366 = constants.scheme;
                let _e1370 = other_idx;
                let _e1377 = state[((_e1370 * 8u) + 0u)];
                let _e1378 = other_idx;
                let _e1385 = state[((_e1378 * 8u) + 0u)];
                let _e1392 = state[((idx * 8u) + 0u)];
                let _e1401 = other_idx;
                let _e1408 = state[((_e1401 * 8u) + 0u)];
                let _e1415 = state[((idx * 8u) + 0u)];
                let _e1429 = other_center.x;
                let _e1431 = other_center.y;
                let _e1441 = state[((idx * 8u) + 0u)];
                let _e1442 = other_idx;
                let _e1449 = state[((_e1442 * 8u) + 0u)];
                let _e1459 = state[((idx * 8u) + 0u)];
                let _e1460 = other_idx;
                let _e1467 = state[((_e1460 * 8u) + 0u)];
                let _e1470 = other_idx;
                let _e1477 = state[((_e1470 * 8u) + 0u)];
                let _e1484 = state[((idx * 8u) + 0u)];
                let _e1493 = other_idx;
                let _e1500 = state[((_e1493 * 8u) + 0u)];
                let _e1507 = state[((idx * 8u) + 0u)];
                let _e1521 = other_center.x;
                let _e1523 = other_center.y;
                let _e1538 = state[((idx * 8u) + 0u)];
                let _e1539 = other_idx;
                let _e1546 = state[((_e1539 * 8u) + 0u)];
                let _e1548 = other_idx;
                let _e1555 = state[((_e1548 * 8u) + 0u)];
                let _e1562 = state[((idx * 8u) + 0u)];
                let _e1571 = other_idx;
                let _e1578 = state[((_e1571 * 8u) + 0u)];
                let _e1585 = state[((idx * 8u) + 0u)];
                let _e1599 = other_center.x;
                let _e1601 = other_center.y;
                let _e1615 = state[((idx * 8u) + 0u)];
                let _e1616 = other_idx;
                let _e1623 = state[((_e1616 * 8u) + 0u)];
                let _e1625 = other_idx;
                let _e1632 = state[((_e1625 * 8u) + 0u)];
                let _e1639 = state[((idx * 8u) + 0u)];
                let _e1648 = other_idx;
                let _e1655 = state[((_e1648 * 8u) + 0u)];
                let _e1662 = state[((idx * 8u) + 0u)];
                let _e1676 = other_center.x;
                let _e1678 = other_center.y;
                let _e1694 = state[((idx * 8u) + 0u)];
                let _e1695 = other_idx;
                let _e1702 = state[((_e1695 * 8u) + 0u)];
                let _e1709 = state[((idx * 8u) + 0u)];
                let _e1718 = other_idx;
                let _e1725 = state[((_e1718 * 8u) + 0u)];
                let _e1732 = state[((idx * 8u) + 0u)];
                let _e1750 = other_idx;
                let _e1757 = state[((_e1750 * 8u) + 0u)];
                let _e1764 = state[((idx * 8u) + 0u)];
                let _e1768 = other_idx;
                let _e1775 = state[((_e1768 * 8u) + 0u)];
                let _e1782 = state[((idx * 8u) + 0u)];
                let _e1785 = other_idx;
                let _e1792 = state[((_e1785 * 8u) + 0u)];
                let _e1799 = state[((idx * 8u) + 0u)];
                let _e1808 = other_idx;
                let _e1815 = state[((_e1808 * 8u) + 0u)];
                let _e1822 = state[((idx * 8u) + 0u)];
                let _e1845 = other_idx;
                let _e1852 = state[((_e1845 * 8u) + 0u)];
                let _e1859 = state[((idx * 8u) + 0u)];
                let _e1861 = other_idx;
                let _e1868 = state[((_e1861 * 8u) + 0u)];
                let _e1875 = state[((idx * 8u) + 0u)];
                let _e1884 = other_idx;
                let _e1891 = state[((_e1884 * 8u) + 0u)];
                let _e1898 = state[((idx * 8u) + 0u)];
                let _e1920 = other_idx;
                let _e1927 = state[((_e1920 * 8u) + 0u)];
                let _e1934 = state[((idx * 8u) + 0u)];
                let _e1936 = other_idx;
                let _e1943 = state[((_e1936 * 8u) + 0u)];
                let _e1950 = state[((idx * 8u) + 0u)];
                let _e1959 = other_idx;
                let _e1966 = state[((_e1959 * 8u) + 0u)];
                let _e1973 = state[((idx * 8u) + 0u)];
                let _e1997 = phi_0_;
                let _e2003 = constants.scheme;
                let _e2007 = other_idx;
                let _e2014 = state[((_e2007 * 8u) + 0u)];
                let _e2015 = other_idx;
                let _e2022 = state[((_e2015 * 8u) + 0u)];
                let _e2031 = state[((idx * 8u) + 0u)];
                let _e2035 = other_idx;
                let _e2042 = state[((_e2035 * 8u) + 0u)];
                let _e2049 = state[((idx * 8u) + 0u)];
                let _e2058 = other_idx;
                let _e2065 = state[((_e2058 * 8u) + 0u)];
                let _e2072 = state[((idx * 8u) + 0u)];
                let _e2086 = other_center.x;
                let _e2088 = other_center.y;
                let _e2095 = other_idx;
                let _e2102 = state[((_e2095 * 8u) + 0u)];
                let _e2110 = state[((idx * 8u) + 0u)];
                let _e2111 = other_idx;
                let _e2118 = state[((_e2111 * 8u) + 0u)];
                let _e2129 = state[((idx * 8u) + 0u)];
                let _e2130 = other_idx;
                let _e2137 = state[((_e2130 * 8u) + 0u)];
                let _e2149 = state[((idx * 8u) + 0u)];
                let _e2156 = state[((idx * 8u) + 0u)];
                let _e2159 = other_idx;
                let _e2166 = state[((_e2159 * 8u) + 0u)];
                let _e2170 = other_idx;
                let _e2177 = state[((_e2170 * 8u) + 0u)];
                let _e2184 = state[((idx * 8u) + 0u)];
                let _e2193 = other_idx;
                let _e2200 = state[((_e2193 * 8u) + 0u)];
                let _e2207 = state[((idx * 8u) + 0u)];
                let _e2218 = other_center.x;
                let _e2220 = other_center.y;
                let _e2236 = state[((idx * 8u) + 0u)];
                let _e2238 = other_idx;
                let _e2245 = state[((_e2238 * 8u) + 0u)];
                let _e2252 = state[((idx * 8u) + 0u)];
                let _e2257 = other_idx;
                let _e2264 = state[((_e2257 * 8u) + 0u)];
                let _e2271 = state[((idx * 8u) + 0u)];
                let _e2277 = phi_0_;
                let _e2283 = constants.scheme;
                let _e2287 = other_idx;
                let _e2294 = state[((_e2287 * 8u) + 0u)];
                let _e2295 = other_idx;
                let _e2302 = state[((_e2295 * 8u) + 0u)];
                let _e2311 = state[((idx * 8u) + 0u)];
                let _e2315 = other_idx;
                let _e2322 = state[((_e2315 * 8u) + 0u)];
                let _e2329 = state[((idx * 8u) + 0u)];
                let _e2338 = other_idx;
                let _e2345 = state[((_e2338 * 8u) + 0u)];
                let _e2352 = state[((idx * 8u) + 0u)];
                let _e2366 = other_center.x;
                let _e2368 = other_center.y;
                let _e2375 = other_idx;
                let _e2382 = state[((_e2375 * 8u) + 0u)];
                let _e2390 = state[((idx * 8u) + 0u)];
                let _e2391 = other_idx;
                let _e2398 = state[((_e2391 * 8u) + 0u)];
                let _e2408 = state[((idx * 8u) + 0u)];
                let _e2409 = other_idx;
                let _e2416 = state[((_e2409 * 8u) + 0u)];
                let _e2419 = other_idx;
                let _e2426 = state[((_e2419 * 8u) + 0u)];
                let _e2435 = state[((idx * 8u) + 0u)];
                let _e2439 = other_idx;
                let _e2446 = state[((_e2439 * 8u) + 0u)];
                let _e2453 = state[((idx * 8u) + 0u)];
                let _e2462 = other_idx;
                let _e2469 = state[((_e2462 * 8u) + 0u)];
                let _e2476 = state[((idx * 8u) + 0u)];
                let _e2490 = other_center.x;
                let _e2492 = other_center.y;
                let _e2499 = other_idx;
                let _e2506 = state[((_e2499 * 8u) + 0u)];
                let _e2519 = state[((idx * 8u) + 0u)];
                let _e2520 = other_idx;
                let _e2527 = state[((_e2520 * 8u) + 0u)];
                let _e2529 = other_idx;
                let _e2536 = state[((_e2529 * 8u) + 0u)];
                let _e2545 = state[((idx * 8u) + 0u)];
                let _e2549 = other_idx;
                let _e2556 = state[((_e2549 * 8u) + 0u)];
                let _e2563 = state[((idx * 8u) + 0u)];
                let _e2572 = other_idx;
                let _e2579 = state[((_e2572 * 8u) + 0u)];
                let _e2586 = state[((idx * 8u) + 0u)];
                let _e2600 = other_center.x;
                let _e2602 = other_center.y;
                let _e2609 = other_idx;
                let _e2616 = state[((_e2609 * 8u) + 0u)];
                let _e2628 = state[((idx * 8u) + 0u)];
                let _e2629 = other_idx;
                let _e2636 = state[((_e2629 * 8u) + 0u)];
                let _e2638 = other_idx;
                let _e2645 = state[((_e2638 * 8u) + 0u)];
                let _e2654 = state[((idx * 8u) + 0u)];
                let _e2658 = other_idx;
                let _e2665 = state[((_e2658 * 8u) + 0u)];
                let _e2672 = state[((idx * 8u) + 0u)];
                let _e2681 = other_idx;
                let _e2688 = state[((_e2681 * 8u) + 0u)];
                let _e2695 = state[((idx * 8u) + 0u)];
                let _e2709 = other_center.x;
                let _e2711 = other_center.y;
                let _e2718 = other_idx;
                let _e2725 = state[((_e2718 * 8u) + 0u)];
                let _e2739 = state[((idx * 8u) + 0u)];
                let _e2746 = state[((idx * 8u) + 0u)];
                let _e2749 = other_idx;
                let _e2756 = state[((_e2749 * 8u) + 0u)];
                let _e2760 = other_idx;
                let _e2767 = state[((_e2760 * 8u) + 0u)];
                let _e2774 = state[((idx * 8u) + 0u)];
                let _e2783 = other_idx;
                let _e2790 = state[((_e2783 * 8u) + 0u)];
                let _e2797 = state[((idx * 8u) + 0u)];
                let _e2808 = other_center.x;
                let _e2810 = other_center.y;
                let _e2826 = state[((idx * 8u) + 0u)];
                let _e2828 = other_idx;
                let _e2835 = state[((_e2828 * 8u) + 0u)];
                let _e2842 = state[((idx * 8u) + 0u)];
                let _e2846 = other_idx;
                let _e2853 = state[((_e2846 * 8u) + 0u)];
                let _e2860 = state[((idx * 8u) + 0u)];
                let _e2869 = state[((idx * 8u) + 0u)];
                let _e2872 = other_idx;
                let _e2879 = state[((_e2872 * 8u) + 0u)];
                let _e2883 = other_idx;
                let _e2890 = state[((_e2883 * 8u) + 0u)];
                let _e2897 = state[((idx * 8u) + 0u)];
                let _e2906 = other_idx;
                let _e2913 = state[((_e2906 * 8u) + 0u)];
                let _e2920 = state[((idx * 8u) + 0u)];
                let _e2931 = other_center.x;
                let _e2933 = other_center.y;
                let _e2949 = state[((idx * 8u) + 0u)];
                let _e2956 = other_idx;
                let _e2963 = state[((_e2956 * 8u) + 0u)];
                let _e2970 = state[((idx * 8u) + 0u)];
                let _e2978 = state[((idx * 8u) + 0u)];
                let _e2981 = other_idx;
                let _e2988 = state[((_e2981 * 8u) + 0u)];
                let _e2992 = other_idx;
                let _e2999 = state[((_e2992 * 8u) + 0u)];
                let _e3006 = state[((idx * 8u) + 0u)];
                let _e3015 = other_idx;
                let _e3022 = state[((_e3015 * 8u) + 0u)];
                let _e3029 = state[((idx * 8u) + 0u)];
                let _e3040 = other_center.x;
                let _e3042 = other_center.y;
                let _e3058 = state[((idx * 8u) + 0u)];
                let _e3064 = other_idx;
                let _e3071 = state[((_e3064 * 8u) + 0u)];
                let _e3078 = state[((idx * 8u) + 0u)];
                let _e3086 = state[((idx * 8u) + 0u)];
                let _e3089 = other_idx;
                let _e3096 = state[((_e3089 * 8u) + 0u)];
                let _e3100 = other_idx;
                let _e3107 = state[((_e3100 * 8u) + 0u)];
                let _e3114 = state[((idx * 8u) + 0u)];
                let _e3123 = other_idx;
                let _e3130 = state[((_e3123 * 8u) + 0u)];
                let _e3137 = state[((idx * 8u) + 0u)];
                let _e3148 = other_center.x;
                let _e3150 = other_center.y;
                let _e3166 = state[((idx * 8u) + 0u)];
                let _e3174 = phi_0_;
                let _e3180 = constants.scheme;
                let _e3190 = state[((idx * 8u) + 0u)];
                let _e3191 = other_idx;
                let _e3198 = state[((_e3191 * 8u) + 0u)];
                let _e3199 = phi_0_;
                let _e3205 = rhs_0_;
                rhs_0_ = (_e3205 - (_e792 * (select(select(select(select(select(select(select(_e799, _e807, (_e808 < 0f)), select((_e819 + dot(vec2<f32>((((_e827 - _e834) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e850 - _e857) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e871, _e873)))), (_e884 + dot(vec2<f32>((((_e892 - _e899) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e915 - _e922) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e941 > 0f)), (_e947 == 1u)), select(((((_e958 + (_e966 * 0.625f)) + (_e976 * 0.375f)) + (dot(vec2<f32>((((_e987 - _e994) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1010 - _e1017) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1031, _e1033))) * 0.125f)) - _e1047), ((((_e1055 + (_e1062 * 0.625f)) + (_e1073 * 0.375f)) + (dot(vec2<f32>((((_e1084 - _e1091) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1107 - _e1114) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e1125, _e1127) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1143), (_e1145 > 0f)), (_e1151 == 2u)), select((_e1162 + min(max(dot(vec2<f32>((((_e1170 - _e1177) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1193 - _e1200) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1214, _e1216))), min((_e1226 - _e1234), 0f)), max((_e1245 - _e1253), 0f))), (_e1265 + min(max(dot(vec2<f32>((((_e1273 - _e1280) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1296 - _e1303) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1328 - _e1335), 0f)), max((_e1347 - _e1354), 0f))), (_e1360 > 0f)), (_e1366 == 3u)), select((_e1377 + ((((dot(vec2<f32>((((_e1385 - _e1392) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1408 - _e1415) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1429, _e1431))) * abs((_e1441 - _e1449))) / max(abs((_e1459 - _e1467)), (abs(dot(vec2<f32>((((_e1477 - _e1484) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1500 - _e1507) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1521, _e1523)))) + 0.00000001f))) * max(((_e1538 - _e1546) * dot(vec2<f32>((((_e1555 - _e1562) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1578 - _e1585) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1599, _e1601)))), 0f)) / max(abs(((_e1615 - _e1623) * dot(vec2<f32>((((_e1632 - _e1639) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1655 - _e1662) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1676, _e1678))))), 0.00000001f))), (_e1694 + ((((dot(vec2<f32>((((_e1702 - _e1709) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1725 - _e1732) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1757 - _e1764))) / max(abs((_e1775 - _e1782)), (abs(dot(vec2<f32>((((_e1792 - _e1799) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1815 - _e1822) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1852 - _e1859) * dot(vec2<f32>((((_e1868 - _e1875) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1891 - _e1898) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1927 - _e1934) * dot(vec2<f32>((((_e1943 - _e1950) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1966 - _e1973) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1997 > 0f)), (_e2003 == 4u)), select((_e2014 + min(max(((((_e2022 * 0.625f) + (_e2031 * 0.375f)) + (dot(vec2<f32>((((_e2042 - _e2049) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2065 - _e2072) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2086, _e2088))) * 0.125f)) - _e2102), min((_e2110 - _e2118), 0f)), max((_e2129 - _e2137), 0f))), (_e2149 + min(max(((((_e2156 * 0.625f) + (_e2166 * 0.375f)) + (dot(vec2<f32>((((_e2177 - _e2184) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2200 - _e2207) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2218, _e2220) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2236), min((_e2245 - _e2252), 0f)), max((_e2264 - _e2271), 0f))), (_e2277 > 0f)), (_e2283 == 5u)), select((_e2294 + ((((((((_e2302 * 0.625f) + (_e2311 * 0.375f)) + (dot(vec2<f32>((((_e2322 - _e2329) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2345 - _e2352) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2366, _e2368))) * 0.125f)) - _e2382) * abs((_e2390 - _e2398))) / max(abs((_e2408 - _e2416)), (abs(((((_e2426 * 0.625f) + (_e2435 * 0.375f)) + (dot(vec2<f32>((((_e2446 - _e2453) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2469 - _e2476) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2490, _e2492))) * 0.125f)) - _e2506)) + 0.00000001f))) * max(((_e2519 - _e2527) * ((((_e2536 * 0.625f) + (_e2545 * 0.375f)) + (dot(vec2<f32>((((_e2556 - _e2563) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2579 - _e2586) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2600, _e2602))) * 0.125f)) - _e2616)), 0f)) / max(abs(((_e2628 - _e2636) * ((((_e2645 * 0.625f) + (_e2654 * 0.375f)) + (dot(vec2<f32>((((_e2665 - _e2672) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2688 - _e2695) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2709, _e2711))) * 0.125f)) - _e2725))), 0.00000001f))), (_e2739 + ((((((((_e2746 * 0.625f) + (_e2756 * 0.375f)) + (dot(vec2<f32>((((_e2767 - _e2774) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2790 - _e2797) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2808, _e2810) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2826) * abs((_e2835 - _e2842))) / max(abs((_e2853 - _e2860)), (abs(((((_e2869 * 0.625f) + (_e2879 * 0.375f)) + (dot(vec2<f32>((((_e2890 - _e2897) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2913 - _e2920) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2931, _e2933) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2949)) + 0.00000001f))) * max(((_e2963 - _e2970) * ((((_e2978 * 0.625f) + (_e2988 * 0.375f)) + (dot(vec2<f32>((((_e2999 - _e3006) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3022 - _e3029) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3040, _e3042) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3058)), 0f)) / max(abs(((_e3071 - _e3078) * ((((_e3086 * 0.625f) + (_e3096 * 0.375f)) + (dot(vec2<f32>((((_e3107 - _e3114) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3130 - _e3137) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3148, _e3150) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3166))), 0.00000001f))), (_e3174 > 0f)), (_e3180 == 6u)) - select(_e3190, _e3198, (_e3199 < 0f)))));
            } else {
                let _e3213 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3213 == 1u) {
                    let _e3216 = phi_0_;
                    let _e3219 = diag_0_;
                    diag_0_ = (_e3219 + max(_e3216, 0f));
                    let _e3221 = phi_0_;
                    let _e3230 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3232 = rhs_0_;
                    rhs_0_ = (_e3232 - (min(_e3221, 0f) * _e3230));
                } else {
                    let _e3234 = phi_0_;
                    let _e3235 = diag_0_;
                    diag_0_ = (_e3235 + _e3234);
                }
            }
            let _e3243 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3243;
            if (owner != idx) {
                let _e3246 = phi_1_;
                let _e3249 = phi_1_;
                phi_1_ = (_e3249 - (_e3246 * 2f));
            }
            let _e3251 = is_boundary;
            if !(_e3251) {
                let _e3253 = phi_1_;
                let _e3256 = diag_1_;
                diag_1_ = (_e3256 + max(_e3253, 0f));
                let _e3265 = phi_1_;
                let _e3268 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3268 + min(_e3265, 0f));
                let _e3270 = phi_1_;
                let _e3277 = state[((idx * 8u) + 1u)];
                let _e3278 = other_idx;
                let _e3285 = state[((_e3278 * 8u) + 1u)];
                let _e3286 = phi_1_;
                let _e3290 = other_idx;
                let _e3297 = state[((_e3290 * 8u) + 1u)];
                let _e3298 = other_idx;
                let _e3305 = state[((_e3298 * 8u) + 1u)];
                let _e3312 = state[((idx * 8u) + 1u)];
                let _e3321 = other_idx;
                let _e3328 = state[((_e3321 * 8u) + 1u)];
                let _e3335 = state[((idx * 8u) + 1u)];
                let _e3349 = other_center.x;
                let _e3351 = other_center.y;
                let _e3362 = state[((idx * 8u) + 1u)];
                let _e3363 = other_idx;
                let _e3370 = state[((_e3363 * 8u) + 1u)];
                let _e3377 = state[((idx * 8u) + 1u)];
                let _e3386 = other_idx;
                let _e3393 = state[((_e3386 * 8u) + 1u)];
                let _e3400 = state[((idx * 8u) + 1u)];
                let _e3419 = phi_1_;
                let _e3425 = constants.scheme;
                let _e3429 = other_idx;
                let _e3436 = state[((_e3429 * 8u) + 1u)];
                let _e3437 = other_idx;
                let _e3444 = state[((_e3437 * 8u) + 1u)];
                let _e3454 = state[((idx * 8u) + 1u)];
                let _e3458 = other_idx;
                let _e3465 = state[((_e3458 * 8u) + 1u)];
                let _e3472 = state[((idx * 8u) + 1u)];
                let _e3481 = other_idx;
                let _e3488 = state[((_e3481 * 8u) + 1u)];
                let _e3495 = state[((idx * 8u) + 1u)];
                let _e3509 = other_center.x;
                let _e3511 = other_center.y;
                let _e3518 = other_idx;
                let _e3525 = state[((_e3518 * 8u) + 1u)];
                let _e3533 = state[((idx * 8u) + 1u)];
                let _e3540 = state[((idx * 8u) + 1u)];
                let _e3544 = other_idx;
                let _e3551 = state[((_e3544 * 8u) + 1u)];
                let _e3555 = other_idx;
                let _e3562 = state[((_e3555 * 8u) + 1u)];
                let _e3569 = state[((idx * 8u) + 1u)];
                let _e3578 = other_idx;
                let _e3585 = state[((_e3578 * 8u) + 1u)];
                let _e3592 = state[((idx * 8u) + 1u)];
                let _e3603 = other_center.x;
                let _e3605 = other_center.y;
                let _e3621 = state[((idx * 8u) + 1u)];
                let _e3623 = phi_1_;
                let _e3629 = constants.scheme;
                let _e3633 = other_idx;
                let _e3640 = state[((_e3633 * 8u) + 1u)];
                let _e3641 = other_idx;
                let _e3648 = state[((_e3641 * 8u) + 1u)];
                let _e3655 = state[((idx * 8u) + 1u)];
                let _e3664 = other_idx;
                let _e3671 = state[((_e3664 * 8u) + 1u)];
                let _e3678 = state[((idx * 8u) + 1u)];
                let _e3692 = other_center.x;
                let _e3694 = other_center.y;
                let _e3704 = state[((idx * 8u) + 1u)];
                let _e3705 = other_idx;
                let _e3712 = state[((_e3705 * 8u) + 1u)];
                let _e3723 = state[((idx * 8u) + 1u)];
                let _e3724 = other_idx;
                let _e3731 = state[((_e3724 * 8u) + 1u)];
                let _e3743 = state[((idx * 8u) + 1u)];
                let _e3744 = other_idx;
                let _e3751 = state[((_e3744 * 8u) + 1u)];
                let _e3758 = state[((idx * 8u) + 1u)];
                let _e3767 = other_idx;
                let _e3774 = state[((_e3767 * 8u) + 1u)];
                let _e3781 = state[((idx * 8u) + 1u)];
                let _e3799 = other_idx;
                let _e3806 = state[((_e3799 * 8u) + 1u)];
                let _e3813 = state[((idx * 8u) + 1u)];
                let _e3818 = other_idx;
                let _e3825 = state[((_e3818 * 8u) + 1u)];
                let _e3832 = state[((idx * 8u) + 1u)];
                let _e3838 = phi_1_;
                let _e3844 = constants.scheme;
                let _e3848 = other_idx;
                let _e3855 = state[((_e3848 * 8u) + 1u)];
                let _e3856 = other_idx;
                let _e3863 = state[((_e3856 * 8u) + 1u)];
                let _e3870 = state[((idx * 8u) + 1u)];
                let _e3879 = other_idx;
                let _e3886 = state[((_e3879 * 8u) + 1u)];
                let _e3893 = state[((idx * 8u) + 1u)];
                let _e3907 = other_center.x;
                let _e3909 = other_center.y;
                let _e3919 = state[((idx * 8u) + 1u)];
                let _e3920 = other_idx;
                let _e3927 = state[((_e3920 * 8u) + 1u)];
                let _e3937 = state[((idx * 8u) + 1u)];
                let _e3938 = other_idx;
                let _e3945 = state[((_e3938 * 8u) + 1u)];
                let _e3948 = other_idx;
                let _e3955 = state[((_e3948 * 8u) + 1u)];
                let _e3962 = state[((idx * 8u) + 1u)];
                let _e3971 = other_idx;
                let _e3978 = state[((_e3971 * 8u) + 1u)];
                let _e3985 = state[((idx * 8u) + 1u)];
                let _e3999 = other_center.x;
                let _e4001 = other_center.y;
                let _e4016 = state[((idx * 8u) + 1u)];
                let _e4017 = other_idx;
                let _e4024 = state[((_e4017 * 8u) + 1u)];
                let _e4026 = other_idx;
                let _e4033 = state[((_e4026 * 8u) + 1u)];
                let _e4040 = state[((idx * 8u) + 1u)];
                let _e4049 = other_idx;
                let _e4056 = state[((_e4049 * 8u) + 1u)];
                let _e4063 = state[((idx * 8u) + 1u)];
                let _e4077 = other_center.x;
                let _e4079 = other_center.y;
                let _e4093 = state[((idx * 8u) + 1u)];
                let _e4094 = other_idx;
                let _e4101 = state[((_e4094 * 8u) + 1u)];
                let _e4103 = other_idx;
                let _e4110 = state[((_e4103 * 8u) + 1u)];
                let _e4117 = state[((idx * 8u) + 1u)];
                let _e4126 = other_idx;
                let _e4133 = state[((_e4126 * 8u) + 1u)];
                let _e4140 = state[((idx * 8u) + 1u)];
                let _e4154 = other_center.x;
                let _e4156 = other_center.y;
                let _e4172 = state[((idx * 8u) + 1u)];
                let _e4173 = other_idx;
                let _e4180 = state[((_e4173 * 8u) + 1u)];
                let _e4187 = state[((idx * 8u) + 1u)];
                let _e4196 = other_idx;
                let _e4203 = state[((_e4196 * 8u) + 1u)];
                let _e4210 = state[((idx * 8u) + 1u)];
                let _e4228 = other_idx;
                let _e4235 = state[((_e4228 * 8u) + 1u)];
                let _e4242 = state[((idx * 8u) + 1u)];
                let _e4246 = other_idx;
                let _e4253 = state[((_e4246 * 8u) + 1u)];
                let _e4260 = state[((idx * 8u) + 1u)];
                let _e4263 = other_idx;
                let _e4270 = state[((_e4263 * 8u) + 1u)];
                let _e4277 = state[((idx * 8u) + 1u)];
                let _e4286 = other_idx;
                let _e4293 = state[((_e4286 * 8u) + 1u)];
                let _e4300 = state[((idx * 8u) + 1u)];
                let _e4323 = other_idx;
                let _e4330 = state[((_e4323 * 8u) + 1u)];
                let _e4337 = state[((idx * 8u) + 1u)];
                let _e4339 = other_idx;
                let _e4346 = state[((_e4339 * 8u) + 1u)];
                let _e4353 = state[((idx * 8u) + 1u)];
                let _e4362 = other_idx;
                let _e4369 = state[((_e4362 * 8u) + 1u)];
                let _e4376 = state[((idx * 8u) + 1u)];
                let _e4398 = other_idx;
                let _e4405 = state[((_e4398 * 8u) + 1u)];
                let _e4412 = state[((idx * 8u) + 1u)];
                let _e4414 = other_idx;
                let _e4421 = state[((_e4414 * 8u) + 1u)];
                let _e4428 = state[((idx * 8u) + 1u)];
                let _e4437 = other_idx;
                let _e4444 = state[((_e4437 * 8u) + 1u)];
                let _e4451 = state[((idx * 8u) + 1u)];
                let _e4475 = phi_1_;
                let _e4481 = constants.scheme;
                let _e4485 = other_idx;
                let _e4492 = state[((_e4485 * 8u) + 1u)];
                let _e4493 = other_idx;
                let _e4500 = state[((_e4493 * 8u) + 1u)];
                let _e4509 = state[((idx * 8u) + 1u)];
                let _e4513 = other_idx;
                let _e4520 = state[((_e4513 * 8u) + 1u)];
                let _e4527 = state[((idx * 8u) + 1u)];
                let _e4536 = other_idx;
                let _e4543 = state[((_e4536 * 8u) + 1u)];
                let _e4550 = state[((idx * 8u) + 1u)];
                let _e4564 = other_center.x;
                let _e4566 = other_center.y;
                let _e4573 = other_idx;
                let _e4580 = state[((_e4573 * 8u) + 1u)];
                let _e4588 = state[((idx * 8u) + 1u)];
                let _e4589 = other_idx;
                let _e4596 = state[((_e4589 * 8u) + 1u)];
                let _e4607 = state[((idx * 8u) + 1u)];
                let _e4608 = other_idx;
                let _e4615 = state[((_e4608 * 8u) + 1u)];
                let _e4627 = state[((idx * 8u) + 1u)];
                let _e4634 = state[((idx * 8u) + 1u)];
                let _e4637 = other_idx;
                let _e4644 = state[((_e4637 * 8u) + 1u)];
                let _e4648 = other_idx;
                let _e4655 = state[((_e4648 * 8u) + 1u)];
                let _e4662 = state[((idx * 8u) + 1u)];
                let _e4671 = other_idx;
                let _e4678 = state[((_e4671 * 8u) + 1u)];
                let _e4685 = state[((idx * 8u) + 1u)];
                let _e4696 = other_center.x;
                let _e4698 = other_center.y;
                let _e4714 = state[((idx * 8u) + 1u)];
                let _e4716 = other_idx;
                let _e4723 = state[((_e4716 * 8u) + 1u)];
                let _e4730 = state[((idx * 8u) + 1u)];
                let _e4735 = other_idx;
                let _e4742 = state[((_e4735 * 8u) + 1u)];
                let _e4749 = state[((idx * 8u) + 1u)];
                let _e4755 = phi_1_;
                let _e4761 = constants.scheme;
                let _e4765 = other_idx;
                let _e4772 = state[((_e4765 * 8u) + 1u)];
                let _e4773 = other_idx;
                let _e4780 = state[((_e4773 * 8u) + 1u)];
                let _e4789 = state[((idx * 8u) + 1u)];
                let _e4793 = other_idx;
                let _e4800 = state[((_e4793 * 8u) + 1u)];
                let _e4807 = state[((idx * 8u) + 1u)];
                let _e4816 = other_idx;
                let _e4823 = state[((_e4816 * 8u) + 1u)];
                let _e4830 = state[((idx * 8u) + 1u)];
                let _e4844 = other_center.x;
                let _e4846 = other_center.y;
                let _e4853 = other_idx;
                let _e4860 = state[((_e4853 * 8u) + 1u)];
                let _e4868 = state[((idx * 8u) + 1u)];
                let _e4869 = other_idx;
                let _e4876 = state[((_e4869 * 8u) + 1u)];
                let _e4886 = state[((idx * 8u) + 1u)];
                let _e4887 = other_idx;
                let _e4894 = state[((_e4887 * 8u) + 1u)];
                let _e4897 = other_idx;
                let _e4904 = state[((_e4897 * 8u) + 1u)];
                let _e4913 = state[((idx * 8u) + 1u)];
                let _e4917 = other_idx;
                let _e4924 = state[((_e4917 * 8u) + 1u)];
                let _e4931 = state[((idx * 8u) + 1u)];
                let _e4940 = other_idx;
                let _e4947 = state[((_e4940 * 8u) + 1u)];
                let _e4954 = state[((idx * 8u) + 1u)];
                let _e4968 = other_center.x;
                let _e4970 = other_center.y;
                let _e4977 = other_idx;
                let _e4984 = state[((_e4977 * 8u) + 1u)];
                let _e4997 = state[((idx * 8u) + 1u)];
                let _e4998 = other_idx;
                let _e5005 = state[((_e4998 * 8u) + 1u)];
                let _e5007 = other_idx;
                let _e5014 = state[((_e5007 * 8u) + 1u)];
                let _e5023 = state[((idx * 8u) + 1u)];
                let _e5027 = other_idx;
                let _e5034 = state[((_e5027 * 8u) + 1u)];
                let _e5041 = state[((idx * 8u) + 1u)];
                let _e5050 = other_idx;
                let _e5057 = state[((_e5050 * 8u) + 1u)];
                let _e5064 = state[((idx * 8u) + 1u)];
                let _e5078 = other_center.x;
                let _e5080 = other_center.y;
                let _e5087 = other_idx;
                let _e5094 = state[((_e5087 * 8u) + 1u)];
                let _e5106 = state[((idx * 8u) + 1u)];
                let _e5107 = other_idx;
                let _e5114 = state[((_e5107 * 8u) + 1u)];
                let _e5116 = other_idx;
                let _e5123 = state[((_e5116 * 8u) + 1u)];
                let _e5132 = state[((idx * 8u) + 1u)];
                let _e5136 = other_idx;
                let _e5143 = state[((_e5136 * 8u) + 1u)];
                let _e5150 = state[((idx * 8u) + 1u)];
                let _e5159 = other_idx;
                let _e5166 = state[((_e5159 * 8u) + 1u)];
                let _e5173 = state[((idx * 8u) + 1u)];
                let _e5187 = other_center.x;
                let _e5189 = other_center.y;
                let _e5196 = other_idx;
                let _e5203 = state[((_e5196 * 8u) + 1u)];
                let _e5217 = state[((idx * 8u) + 1u)];
                let _e5224 = state[((idx * 8u) + 1u)];
                let _e5227 = other_idx;
                let _e5234 = state[((_e5227 * 8u) + 1u)];
                let _e5238 = other_idx;
                let _e5245 = state[((_e5238 * 8u) + 1u)];
                let _e5252 = state[((idx * 8u) + 1u)];
                let _e5261 = other_idx;
                let _e5268 = state[((_e5261 * 8u) + 1u)];
                let _e5275 = state[((idx * 8u) + 1u)];
                let _e5286 = other_center.x;
                let _e5288 = other_center.y;
                let _e5304 = state[((idx * 8u) + 1u)];
                let _e5306 = other_idx;
                let _e5313 = state[((_e5306 * 8u) + 1u)];
                let _e5320 = state[((idx * 8u) + 1u)];
                let _e5324 = other_idx;
                let _e5331 = state[((_e5324 * 8u) + 1u)];
                let _e5338 = state[((idx * 8u) + 1u)];
                let _e5347 = state[((idx * 8u) + 1u)];
                let _e5350 = other_idx;
                let _e5357 = state[((_e5350 * 8u) + 1u)];
                let _e5361 = other_idx;
                let _e5368 = state[((_e5361 * 8u) + 1u)];
                let _e5375 = state[((idx * 8u) + 1u)];
                let _e5384 = other_idx;
                let _e5391 = state[((_e5384 * 8u) + 1u)];
                let _e5398 = state[((idx * 8u) + 1u)];
                let _e5409 = other_center.x;
                let _e5411 = other_center.y;
                let _e5427 = state[((idx * 8u) + 1u)];
                let _e5434 = other_idx;
                let _e5441 = state[((_e5434 * 8u) + 1u)];
                let _e5448 = state[((idx * 8u) + 1u)];
                let _e5456 = state[((idx * 8u) + 1u)];
                let _e5459 = other_idx;
                let _e5466 = state[((_e5459 * 8u) + 1u)];
                let _e5470 = other_idx;
                let _e5477 = state[((_e5470 * 8u) + 1u)];
                let _e5484 = state[((idx * 8u) + 1u)];
                let _e5493 = other_idx;
                let _e5500 = state[((_e5493 * 8u) + 1u)];
                let _e5507 = state[((idx * 8u) + 1u)];
                let _e5518 = other_center.x;
                let _e5520 = other_center.y;
                let _e5536 = state[((idx * 8u) + 1u)];
                let _e5542 = other_idx;
                let _e5549 = state[((_e5542 * 8u) + 1u)];
                let _e5556 = state[((idx * 8u) + 1u)];
                let _e5564 = state[((idx * 8u) + 1u)];
                let _e5567 = other_idx;
                let _e5574 = state[((_e5567 * 8u) + 1u)];
                let _e5578 = other_idx;
                let _e5585 = state[((_e5578 * 8u) + 1u)];
                let _e5592 = state[((idx * 8u) + 1u)];
                let _e5601 = other_idx;
                let _e5608 = state[((_e5601 * 8u) + 1u)];
                let _e5615 = state[((idx * 8u) + 1u)];
                let _e5626 = other_center.x;
                let _e5628 = other_center.y;
                let _e5644 = state[((idx * 8u) + 1u)];
                let _e5652 = phi_1_;
                let _e5658 = constants.scheme;
                let _e5668 = state[((idx * 8u) + 1u)];
                let _e5669 = other_idx;
                let _e5676 = state[((_e5669 * 8u) + 1u)];
                let _e5677 = phi_1_;
                let _e5683 = rhs_1_;
                rhs_1_ = (_e5683 - (_e3270 * (select(select(select(select(select(select(select(_e3277, _e3285, (_e3286 < 0f)), select((_e3297 + dot(vec2<f32>((((_e3305 - _e3312) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3328 - _e3335) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3349, _e3351)))), (_e3362 + dot(vec2<f32>((((_e3370 - _e3377) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3393 - _e3400) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3419 > 0f)), (_e3425 == 1u)), select(((((_e3436 + (_e3444 * 0.625f)) + (_e3454 * 0.375f)) + (dot(vec2<f32>((((_e3465 - _e3472) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3488 - _e3495) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3509, _e3511))) * 0.125f)) - _e3525), ((((_e3533 + (_e3540 * 0.625f)) + (_e3551 * 0.375f)) + (dot(vec2<f32>((((_e3562 - _e3569) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3585 - _e3592) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3603, _e3605) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3621), (_e3623 > 0f)), (_e3629 == 2u)), select((_e3640 + min(max(dot(vec2<f32>((((_e3648 - _e3655) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3671 - _e3678) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3692, _e3694))), min((_e3704 - _e3712), 0f)), max((_e3723 - _e3731), 0f))), (_e3743 + min(max(dot(vec2<f32>((((_e3751 - _e3758) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3774 - _e3781) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e3806 - _e3813), 0f)), max((_e3825 - _e3832), 0f))), (_e3838 > 0f)), (_e3844 == 3u)), select((_e3855 + ((((dot(vec2<f32>((((_e3863 - _e3870) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3886 - _e3893) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3907, _e3909))) * abs((_e3919 - _e3927))) / max(abs((_e3937 - _e3945)), (abs(dot(vec2<f32>((((_e3955 - _e3962) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3978 - _e3985) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3999, _e4001)))) + 0.00000001f))) * max(((_e4016 - _e4024) * dot(vec2<f32>((((_e4033 - _e4040) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4056 - _e4063) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4077, _e4079)))), 0f)) / max(abs(((_e4093 - _e4101) * dot(vec2<f32>((((_e4110 - _e4117) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4133 - _e4140) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4154, _e4156))))), 0.00000001f))), (_e4172 + ((((dot(vec2<f32>((((_e4180 - _e4187) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4203 - _e4210) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e4235 - _e4242))) / max(abs((_e4253 - _e4260)), (abs(dot(vec2<f32>((((_e4270 - _e4277) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4293 - _e4300) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e4330 - _e4337) * dot(vec2<f32>((((_e4346 - _e4353) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4369 - _e4376) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e4405 - _e4412) * dot(vec2<f32>((((_e4421 - _e4428) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4444 - _e4451) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e4475 > 0f)), (_e4481 == 4u)), select((_e4492 + min(max(((((_e4500 * 0.625f) + (_e4509 * 0.375f)) + (dot(vec2<f32>((((_e4520 - _e4527) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4543 - _e4550) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4564, _e4566))) * 0.125f)) - _e4580), min((_e4588 - _e4596), 0f)), max((_e4607 - _e4615), 0f))), (_e4627 + min(max(((((_e4634 * 0.625f) + (_e4644 * 0.375f)) + (dot(vec2<f32>((((_e4655 - _e4662) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4678 - _e4685) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e4696, _e4698) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4714), min((_e4723 - _e4730), 0f)), max((_e4742 - _e4749), 0f))), (_e4755 > 0f)), (_e4761 == 5u)), select((_e4772 + ((((((((_e4780 * 0.625f) + (_e4789 * 0.375f)) + (dot(vec2<f32>((((_e4800 - _e4807) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4823 - _e4830) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4844, _e4846))) * 0.125f)) - _e4860) * abs((_e4868 - _e4876))) / max(abs((_e4886 - _e4894)), (abs(((((_e4904 * 0.625f) + (_e4913 * 0.375f)) + (dot(vec2<f32>((((_e4924 - _e4931) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4947 - _e4954) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4968, _e4970))) * 0.125f)) - _e4984)) + 0.00000001f))) * max(((_e4997 - _e5005) * ((((_e5014 * 0.625f) + (_e5023 * 0.375f)) + (dot(vec2<f32>((((_e5034 - _e5041) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5057 - _e5064) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5078, _e5080))) * 0.125f)) - _e5094)), 0f)) / max(abs(((_e5106 - _e5114) * ((((_e5123 * 0.625f) + (_e5132 * 0.375f)) + (dot(vec2<f32>((((_e5143 - _e5150) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5166 - _e5173) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5187, _e5189))) * 0.125f)) - _e5203))), 0.00000001f))), (_e5217 + ((((((((_e5224 * 0.625f) + (_e5234 * 0.375f)) + (dot(vec2<f32>((((_e5245 - _e5252) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5268 - _e5275) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5286, _e5288) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5304) * abs((_e5313 - _e5320))) / max(abs((_e5331 - _e5338)), (abs(((((_e5347 * 0.625f) + (_e5357 * 0.375f)) + (dot(vec2<f32>((((_e5368 - _e5375) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5391 - _e5398) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5409, _e5411) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5427)) + 0.00000001f))) * max(((_e5441 - _e5448) * ((((_e5456 * 0.625f) + (_e5466 * 0.375f)) + (dot(vec2<f32>((((_e5477 - _e5484) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5500 - _e5507) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5518, _e5520) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5536)), 0f)) / max(abs(((_e5549 - _e5556) * ((((_e5564 * 0.625f) + (_e5574 * 0.375f)) + (dot(vec2<f32>((((_e5585 - _e5592) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5608 - _e5615) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5626, _e5628) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5644))), 0.00000001f))), (_e5652 > 0f)), (_e5658 == 6u)) - select(_e5668, _e5676, (_e5677 < 0f)))));
            } else {
                let _e5691 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e5691 == 1u) {
                    let _e5694 = phi_1_;
                    let _e5697 = diag_1_;
                    diag_1_ = (_e5697 + max(_e5694, 0f));
                    let _e5699 = phi_1_;
                    let _e5708 = bc_value[((face_idx * 3u) + 1u)];
                    let _e5710 = rhs_1_;
                    rhs_1_ = (_e5710 - (min(_e5699, 0f) * _e5708));
                } else {
                    let _e5712 = phi_1_;
                    let _e5713 = diag_1_;
                    diag_1_ = (_e5713 + _e5712);
                }
            }
            let _e5718 = normal.x;
            let _e5726 = state[((idx * 8u) + 2u)];
            let _e5727 = other_idx;
            let _e5734 = state[((_e5727 * 8u) + 2u)];
            let _e5737 = rhs_0_;
            rhs_0_ = (_e5737 - (((0.5f * area) * _e5718) * (_e5726 + _e5734)));
            let _e5742 = normal.y;
            let _e5750 = state[((idx * 8u) + 2u)];
            let _e5751 = other_idx;
            let _e5758 = state[((_e5751 * 8u) + 2u)];
            let _e5761 = rhs_1_;
            rhs_1_ = (_e5761 - (((0.5f * area) * _e5742) * (_e5750 + _e5758)));
            let _e5765 = constants.density;
            let _e5772 = state[((idx * 8u) + 3u)];
            let _e5776 = constants.density;
            let _e5783 = state[((idx * 8u) + 3u)];
            let _e5787 = constants.density;
            let _e5788 = other_idx;
            let _e5795 = state[((_e5788 * 8u) + 3u)];
            let _e5800 = is_boundary;
            let _e5804 = dist;
            let diff_coeff_p = ((select((_e5765 * _e5772), (((_e5776 * _e5783) + (_e5787 * _e5795)) * 0.5f), !(_e5800)) * area) / _e5804);
            let _e5806 = is_boundary;
            if !(_e5806) {
                let _e5809 = diag_2_;
                diag_2_ = (_e5809 + diff_coeff_p);
                let _e5818 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e5818 - diff_coeff_p);
            } else {
                let _e5826 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e5826 == 1u) {
                    let _e5829 = diag_2_;
                    diag_2_ = (_e5829 + diff_coeff_p);
                    let _e5838 = bc_value[((face_idx * 3u) + 2u)];
                    let _e5840 = rhs_2_;
                    rhs_2_ = (_e5840 + (diff_coeff_p * _e5838));
                } else {
                    let _e5848 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e5848 == 2u) {
                        let _e5853 = constants.density;
                        let _e5860 = state[((idx * 8u) + 3u)];
                        let _e5864 = constants.density;
                        let _e5871 = state[((idx * 8u) + 3u)];
                        let _e5875 = constants.density;
                        let _e5876 = other_idx;
                        let _e5883 = state[((_e5876 * 8u) + 3u)];
                        let _e5888 = is_boundary;
                        let _e5898 = bc_value[((face_idx * 3u) + 2u)];
                        let _e5901 = rhs_2_;
                        rhs_2_ = (_e5901 + -(((select((_e5853 * _e5860), (((_e5864 * _e5871) + (_e5875 * _e5883)) * 0.5f), !(_e5888)) * area) * _e5898)));
                    }
                }
            }
            let _e5909 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e5909;
            if (owner != idx) {
                let _e5912 = phi_2_;
                let _e5915 = phi_2_;
                phi_2_ = (_e5915 - (_e5912 * 2f));
            }
            let _e5917 = phi_2_;
            let _e5918 = rhs_2_;
            rhs_2_ = (_e5918 - _e5917);
        }
        continuing {
            let _e5921 = k;
            k = (_e5921 + 1u);
        }
    }
    let _e5930 = diag_0_;
    let _e5931 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e5931 + _e5930);
    let _e5939 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e5939;
    let _e5947 = diag_1_;
    let _e5948 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e5948 + _e5947);
    let _e5956 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e5956;
    let _e5964 = diag_2_;
    let _e5965 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e5965 + _e5964);
    let _e5973 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e5973;
    return;
}
"#;
    }
    pub mod generic_coupled_update_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_compressible :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 22u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 22u) + 0u)];
    let _e32 = x[((idx * 8u) + 0u)];
    let _e39 = state[((idx * 22u) + 0u)];
    let _e46 = x[((idx * 8u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e52 = constants.dtau;
    let _e64 = state[((idx * 22u) + 0u)];
    let _e71 = state[((idx * 22u) + 0u)];
    let _e79 = state[((idx * 22u) + 0u)];
    let _e91 = x[((idx * 8u) + 0u)];
    let _e98 = x[((idx * 8u) + 0u)];
    let _e106 = x[((idx * 8u) + 0u)];
    state[((idx * 22u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, select(1f, _e49, (_e52 > 0f))), ((_e64 == _e71) && (abs(_e79) < 340000000000000000000000000000000000000f))), ((_e91 == _e98) && (abs(_e106) < 340000000000000000000000000000000000000f)));
    let _e124 = state[((idx * 22u) + 0u)];
    let _e131 = x[((idx * 8u) + 0u)];
    let _e138 = state[((idx * 22u) + 0u)];
    let _e145 = x[((idx * 8u) + 0u)];
    let _e148 = constants.alpha_u;
    let _e151 = constants.dtau;
    let _e163 = state[((idx * 22u) + 0u)];
    let _e170 = state[((idx * 22u) + 0u)];
    let _e178 = state[((idx * 22u) + 0u)];
    let _e190 = x[((idx * 8u) + 0u)];
    let _e197 = x[((idx * 8u) + 0u)];
    let _e205 = x[((idx * 8u) + 0u)];
    x[((idx * 8u) + 0u)] = select(_e124, select(_e131, mix(_e138, _e145, select(1f, _e148, (_e151 > 0f))), ((_e163 == _e170) && (abs(_e178) < 340000000000000000000000000000000000000f))), ((_e190 == _e197) && (abs(_e205) < 340000000000000000000000000000000000000f)));
    let _e223 = state[((idx * 22u) + 1u)];
    let _e230 = x[((idx * 8u) + 1u)];
    let _e237 = state[((idx * 22u) + 1u)];
    let _e244 = x[((idx * 8u) + 1u)];
    let _e247 = constants.alpha_u;
    let _e250 = constants.dtau;
    let _e262 = state[((idx * 22u) + 1u)];
    let _e269 = state[((idx * 22u) + 1u)];
    let _e277 = state[((idx * 22u) + 1u)];
    let _e289 = x[((idx * 8u) + 1u)];
    let _e296 = x[((idx * 8u) + 1u)];
    let _e304 = x[((idx * 8u) + 1u)];
    state[((idx * 22u) + 1u)] = select(_e223, select(_e230, mix(_e237, _e244, select(1f, _e247, (_e250 > 0f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f))), ((_e289 == _e296) && (abs(_e304) < 340000000000000000000000000000000000000f)));
    let _e322 = state[((idx * 22u) + 1u)];
    let _e329 = x[((idx * 8u) + 1u)];
    let _e336 = state[((idx * 22u) + 1u)];
    let _e343 = x[((idx * 8u) + 1u)];
    let _e346 = constants.alpha_u;
    let _e349 = constants.dtau;
    let _e361 = state[((idx * 22u) + 1u)];
    let _e368 = state[((idx * 22u) + 1u)];
    let _e376 = state[((idx * 22u) + 1u)];
    let _e388 = x[((idx * 8u) + 1u)];
    let _e395 = x[((idx * 8u) + 1u)];
    let _e403 = x[((idx * 8u) + 1u)];
    x[((idx * 8u) + 1u)] = select(_e322, select(_e329, mix(_e336, _e343, select(1f, _e346, (_e349 > 0f))), ((_e361 == _e368) && (abs(_e376) < 340000000000000000000000000000000000000f))), ((_e388 == _e395) && (abs(_e403) < 340000000000000000000000000000000000000f)));
    let _e421 = state[((idx * 22u) + 2u)];
    let _e428 = x[((idx * 8u) + 2u)];
    let _e435 = state[((idx * 22u) + 2u)];
    let _e442 = x[((idx * 8u) + 2u)];
    let _e445 = constants.alpha_u;
    let _e448 = constants.dtau;
    let _e460 = state[((idx * 22u) + 2u)];
    let _e467 = state[((idx * 22u) + 2u)];
    let _e475 = state[((idx * 22u) + 2u)];
    let _e487 = x[((idx * 8u) + 2u)];
    let _e494 = x[((idx * 8u) + 2u)];
    let _e502 = x[((idx * 8u) + 2u)];
    state[((idx * 22u) + 2u)] = select(_e421, select(_e428, mix(_e435, _e442, select(1f, _e445, (_e448 > 0f))), ((_e460 == _e467) && (abs(_e475) < 340000000000000000000000000000000000000f))), ((_e487 == _e494) && (abs(_e502) < 340000000000000000000000000000000000000f)));
    let _e520 = state[((idx * 22u) + 2u)];
    let _e527 = x[((idx * 8u) + 2u)];
    let _e534 = state[((idx * 22u) + 2u)];
    let _e541 = x[((idx * 8u) + 2u)];
    let _e544 = constants.alpha_u;
    let _e547 = constants.dtau;
    let _e559 = state[((idx * 22u) + 2u)];
    let _e566 = state[((idx * 22u) + 2u)];
    let _e574 = state[((idx * 22u) + 2u)];
    let _e586 = x[((idx * 8u) + 2u)];
    let _e593 = x[((idx * 8u) + 2u)];
    let _e601 = x[((idx * 8u) + 2u)];
    x[((idx * 8u) + 2u)] = select(_e520, select(_e527, mix(_e534, _e541, select(1f, _e544, (_e547 > 0f))), ((_e559 == _e566) && (abs(_e574) < 340000000000000000000000000000000000000f))), ((_e586 == _e593) && (abs(_e601) < 340000000000000000000000000000000000000f)));
    let _e619 = state[((idx * 22u) + 7u)];
    let _e626 = x[((idx * 8u) + 3u)];
    let _e633 = state[((idx * 22u) + 7u)];
    let _e640 = x[((idx * 8u) + 3u)];
    let _e643 = constants.alpha_u;
    let _e646 = constants.dtau;
    let _e658 = state[((idx * 22u) + 7u)];
    let _e665 = state[((idx * 22u) + 7u)];
    let _e673 = state[((idx * 22u) + 7u)];
    let _e685 = x[((idx * 8u) + 3u)];
    let _e692 = x[((idx * 8u) + 3u)];
    let _e700 = x[((idx * 8u) + 3u)];
    state[((idx * 22u) + 7u)] = select(_e619, select(_e626, mix(_e633, _e640, select(1f, _e643, (_e646 > 0f))), ((_e658 == _e665) && (abs(_e673) < 340000000000000000000000000000000000000f))), ((_e685 == _e692) && (abs(_e700) < 340000000000000000000000000000000000000f)));
    let _e718 = state[((idx * 22u) + 7u)];
    let _e725 = x[((idx * 8u) + 3u)];
    let _e732 = state[((idx * 22u) + 7u)];
    let _e739 = x[((idx * 8u) + 3u)];
    let _e742 = constants.alpha_u;
    let _e745 = constants.dtau;
    let _e757 = state[((idx * 22u) + 7u)];
    let _e764 = state[((idx * 22u) + 7u)];
    let _e772 = state[((idx * 22u) + 7u)];
    let _e784 = x[((idx * 8u) + 3u)];
    let _e791 = x[((idx * 8u) + 3u)];
    let _e799 = x[((idx * 8u) + 3u)];
    x[((idx * 8u) + 3u)] = select(_e718, select(_e725, mix(_e732, _e739, select(1f, _e742, (_e745 > 0f))), ((_e757 == _e764) && (abs(_e772) < 340000000000000000000000000000000000000f))), ((_e784 == _e791) && (abs(_e799) < 340000000000000000000000000000000000000f)));
    let _e817 = state[((idx * 22u) + 10u)];
    let _e824 = x[((idx * 8u) + 4u)];
    let _e831 = state[((idx * 22u) + 10u)];
    let _e838 = x[((idx * 8u) + 4u)];
    let _e841 = constants.alpha_u;
    let _e844 = constants.dtau;
    let _e856 = state[((idx * 22u) + 10u)];
    let _e863 = state[((idx * 22u) + 10u)];
    let _e871 = state[((idx * 22u) + 10u)];
    let _e883 = x[((idx * 8u) + 4u)];
    let _e890 = x[((idx * 8u) + 4u)];
    let _e898 = x[((idx * 8u) + 4u)];
    state[((idx * 22u) + 10u)] = select(_e817, select(_e824, mix(_e831, _e838, select(1f, _e841, (_e844 > 0f))), ((_e856 == _e863) && (abs(_e871) < 340000000000000000000000000000000000000f))), ((_e883 == _e890) && (abs(_e898) < 340000000000000000000000000000000000000f)));
    let _e916 = state[((idx * 22u) + 10u)];
    let _e923 = x[((idx * 8u) + 4u)];
    let _e930 = state[((idx * 22u) + 10u)];
    let _e937 = x[((idx * 8u) + 4u)];
    let _e940 = constants.alpha_u;
    let _e943 = constants.dtau;
    let _e955 = state[((idx * 22u) + 10u)];
    let _e962 = state[((idx * 22u) + 10u)];
    let _e970 = state[((idx * 22u) + 10u)];
    let _e982 = x[((idx * 8u) + 4u)];
    let _e989 = x[((idx * 8u) + 4u)];
    let _e997 = x[((idx * 8u) + 4u)];
    x[((idx * 8u) + 4u)] = select(_e916, select(_e923, mix(_e930, _e937, select(1f, _e940, (_e943 > 0f))), ((_e955 == _e962) && (abs(_e970) < 340000000000000000000000000000000000000f))), ((_e982 == _e989) && (abs(_e997) < 340000000000000000000000000000000000000f)));
    let _e1015 = state[((idx * 22u) + 11u)];
    let _e1022 = x[((idx * 8u) + 5u)];
    let _e1029 = state[((idx * 22u) + 11u)];
    let _e1036 = x[((idx * 8u) + 5u)];
    let _e1039 = constants.alpha_u;
    let _e1042 = constants.dtau;
    let _e1054 = state[((idx * 22u) + 11u)];
    let _e1061 = state[((idx * 22u) + 11u)];
    let _e1069 = state[((idx * 22u) + 11u)];
    let _e1081 = x[((idx * 8u) + 5u)];
    let _e1088 = x[((idx * 8u) + 5u)];
    let _e1096 = x[((idx * 8u) + 5u)];
    state[((idx * 22u) + 11u)] = select(_e1015, select(_e1022, mix(_e1029, _e1036, select(1f, _e1039, (_e1042 > 0f))), ((_e1054 == _e1061) && (abs(_e1069) < 340000000000000000000000000000000000000f))), ((_e1081 == _e1088) && (abs(_e1096) < 340000000000000000000000000000000000000f)));
    let _e1114 = state[((idx * 22u) + 11u)];
    let _e1121 = x[((idx * 8u) + 5u)];
    let _e1128 = state[((idx * 22u) + 11u)];
    let _e1135 = x[((idx * 8u) + 5u)];
    let _e1138 = constants.alpha_u;
    let _e1141 = constants.dtau;
    let _e1153 = state[((idx * 22u) + 11u)];
    let _e1160 = state[((idx * 22u) + 11u)];
    let _e1168 = state[((idx * 22u) + 11u)];
    let _e1180 = x[((idx * 8u) + 5u)];
    let _e1187 = x[((idx * 8u) + 5u)];
    let _e1195 = x[((idx * 8u) + 5u)];
    x[((idx * 8u) + 5u)] = select(_e1114, select(_e1121, mix(_e1128, _e1135, select(1f, _e1138, (_e1141 > 0f))), ((_e1153 == _e1160) && (abs(_e1168) < 340000000000000000000000000000000000000f))), ((_e1180 == _e1187) && (abs(_e1195) < 340000000000000000000000000000000000000f)));
    let _e1213 = state[((idx * 22u) + 8u)];
    let _e1220 = x[((idx * 8u) + 6u)];
    let _e1227 = state[((idx * 22u) + 8u)];
    let _e1234 = x[((idx * 8u) + 6u)];
    let _e1237 = constants.alpha_p;
    let _e1240 = constants.dtau;
    let _e1252 = state[((idx * 22u) + 8u)];
    let _e1259 = state[((idx * 22u) + 8u)];
    let _e1267 = state[((idx * 22u) + 8u)];
    let _e1279 = x[((idx * 8u) + 6u)];
    let _e1286 = x[((idx * 8u) + 6u)];
    let _e1294 = x[((idx * 8u) + 6u)];
    state[((idx * 22u) + 8u)] = select(_e1213, select(_e1220, mix(_e1227, _e1234, select(1f, _e1237, (_e1240 > 0f))), ((_e1252 == _e1259) && (abs(_e1267) < 340000000000000000000000000000000000000f))), ((_e1279 == _e1286) && (abs(_e1294) < 340000000000000000000000000000000000000f)));
    let _e1312 = state[((idx * 22u) + 8u)];
    let _e1319 = x[((idx * 8u) + 6u)];
    let _e1326 = state[((idx * 22u) + 8u)];
    let _e1333 = x[((idx * 8u) + 6u)];
    let _e1336 = constants.alpha_p;
    let _e1339 = constants.dtau;
    let _e1351 = state[((idx * 22u) + 8u)];
    let _e1358 = state[((idx * 22u) + 8u)];
    let _e1366 = state[((idx * 22u) + 8u)];
    let _e1378 = x[((idx * 8u) + 6u)];
    let _e1385 = x[((idx * 8u) + 6u)];
    let _e1393 = x[((idx * 8u) + 6u)];
    x[((idx * 8u) + 6u)] = select(_e1312, select(_e1319, mix(_e1326, _e1333, select(1f, _e1336, (_e1339 > 0f))), ((_e1351 == _e1358) && (abs(_e1366) < 340000000000000000000000000000000000000f))), ((_e1378 == _e1385) && (abs(_e1393) < 340000000000000000000000000000000000000f)));
    let _e1411 = state[((idx * 22u) + 9u)];
    let _e1418 = x[((idx * 8u) + 7u)];
    let _e1425 = state[((idx * 22u) + 9u)];
    let _e1432 = x[((idx * 8u) + 7u)];
    let _e1435 = constants.alpha_u;
    let _e1438 = constants.dtau;
    let _e1450 = state[((idx * 22u) + 9u)];
    let _e1457 = state[((idx * 22u) + 9u)];
    let _e1465 = state[((idx * 22u) + 9u)];
    let _e1477 = x[((idx * 8u) + 7u)];
    let _e1484 = x[((idx * 8u) + 7u)];
    let _e1492 = x[((idx * 8u) + 7u)];
    state[((idx * 22u) + 9u)] = select(_e1411, select(_e1418, mix(_e1425, _e1432, select(1f, _e1435, (_e1438 > 0f))), ((_e1450 == _e1457) && (abs(_e1465) < 340000000000000000000000000000000000000f))), ((_e1477 == _e1484) && (abs(_e1492) < 340000000000000000000000000000000000000f)));
    let _e1510 = state[((idx * 22u) + 9u)];
    let _e1517 = x[((idx * 8u) + 7u)];
    let _e1524 = state[((idx * 22u) + 9u)];
    let _e1531 = x[((idx * 8u) + 7u)];
    let _e1534 = constants.alpha_u;
    let _e1537 = constants.dtau;
    let _e1549 = state[((idx * 22u) + 9u)];
    let _e1556 = state[((idx * 22u) + 9u)];
    let _e1564 = state[((idx * 22u) + 9u)];
    let _e1576 = x[((idx * 8u) + 7u)];
    let _e1583 = x[((idx * 8u) + 7u)];
    let _e1591 = x[((idx * 8u) + 7u)];
    x[((idx * 8u) + 7u)] = select(_e1510, select(_e1517, mix(_e1524, _e1531, select(1f, _e1534, (_e1537 > 0f))), ((_e1549 == _e1556) && (abs(_e1564) < 340000000000000000000000000000000000000f))), ((_e1576 == _e1583) && (abs(_e1591) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 3u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 3u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e57 = state[((idx * 8u) + 0u)];
    let _e64 = state[((idx * 8u) + 0u)];
    let _e72 = state[((idx * 8u) + 0u)];
    let _e84 = x[((idx * 3u) + 0u)];
    let _e91 = x[((idx * 3u) + 0u)];
    let _e99 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, _e49), ((_e57 == _e64) && (abs(_e72) < 340000000000000000000000000000000000000f))), ((_e84 == _e91) && (abs(_e99) < 340000000000000000000000000000000000000f)));
    let _e117 = state[((idx * 8u) + 0u)];
    let _e124 = x[((idx * 3u) + 0u)];
    let _e131 = state[((idx * 8u) + 0u)];
    let _e138 = x[((idx * 3u) + 0u)];
    let _e141 = constants.alpha_u;
    let _e149 = state[((idx * 8u) + 0u)];
    let _e156 = state[((idx * 8u) + 0u)];
    let _e164 = state[((idx * 8u) + 0u)];
    let _e176 = x[((idx * 3u) + 0u)];
    let _e183 = x[((idx * 3u) + 0u)];
    let _e191 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e117, select(_e124, mix(_e131, _e138, _e141), ((_e149 == _e156) && (abs(_e164) < 340000000000000000000000000000000000000f))), ((_e176 == _e183) && (abs(_e191) < 340000000000000000000000000000000000000f)));
    let _e209 = state[((idx * 8u) + 1u)];
    let _e216 = x[((idx * 3u) + 1u)];
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 3u) + 1u)];
    let _e233 = constants.alpha_u;
    let _e241 = state[((idx * 8u) + 1u)];
    let _e248 = state[((idx * 8u) + 1u)];
    let _e256 = state[((idx * 8u) + 1u)];
    let _e268 = x[((idx * 3u) + 1u)];
    let _e275 = x[((idx * 3u) + 1u)];
    let _e283 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e209, select(_e216, mix(_e223, _e230, _e233), ((_e241 == _e248) && (abs(_e256) < 340000000000000000000000000000000000000f))), ((_e268 == _e275) && (abs(_e283) < 340000000000000000000000000000000000000f)));
    let _e301 = state[((idx * 8u) + 1u)];
    let _e308 = x[((idx * 3u) + 1u)];
    let _e315 = state[((idx * 8u) + 1u)];
    let _e322 = x[((idx * 3u) + 1u)];
    let _e325 = constants.alpha_u;
    let _e333 = state[((idx * 8u) + 1u)];
    let _e340 = state[((idx * 8u) + 1u)];
    let _e348 = state[((idx * 8u) + 1u)];
    let _e360 = x[((idx * 3u) + 1u)];
    let _e367 = x[((idx * 3u) + 1u)];
    let _e375 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e301, select(_e308, mix(_e315, _e322, _e325), ((_e333 == _e340) && (abs(_e348) < 340000000000000000000000000000000000000f))), ((_e360 == _e367) && (abs(_e375) < 340000000000000000000000000000000000000f)));
    let _e393 = state[((idx * 8u) + 2u)];
    let _e400 = x[((idx * 3u) + 2u)];
    let _e407 = state[((idx * 8u) + 2u)];
    let _e414 = x[((idx * 3u) + 2u)];
    let _e417 = constants.alpha_p;
    let _e425 = state[((idx * 8u) + 2u)];
    let _e432 = state[((idx * 8u) + 2u)];
    let _e440 = state[((idx * 8u) + 2u)];
    let _e452 = x[((idx * 3u) + 2u)];
    let _e459 = x[((idx * 3u) + 2u)];
    let _e467 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e393, select(_e400, mix(_e407, _e414, _e417), ((_e425 == _e432) && (abs(_e440) < 340000000000000000000000000000000000000f))), ((_e452 == _e459) && (abs(_e467) < 340000000000000000000000000000000000000f)));
    let _e485 = state[((idx * 8u) + 2u)];
    let _e492 = x[((idx * 3u) + 2u)];
    let _e499 = state[((idx * 8u) + 2u)];
    let _e506 = x[((idx * 3u) + 2u)];
    let _e509 = constants.alpha_p;
    let _e517 = state[((idx * 8u) + 2u)];
    let _e524 = state[((idx * 8u) + 2u)];
    let _e532 = state[((idx * 8u) + 2u)];
    let _e544 = x[((idx * 3u) + 2u)];
    let _e551 = x[((idx * 3u) + 2u)];
    let _e559 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e485, select(_e492, mix(_e499, _e506, _e509), ((_e517 == _e524) && (abs(_e532) < 340000000000000000000000000000000000000f))), ((_e544 == _e551) && (abs(_e559) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod packed_state_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_3_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_4_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_5_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_6_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_7_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 22u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 22u) + 0u)];
            let _e125 = state[((idx * 22u) + 0u)];
            let _e132 = bc_value[((face_idx * 8u) + 0u)];
            let _e139 = bc_kind[((face_idx * 8u) + 0u)];
            let _e149 = state[((idx * 22u) + 0u)];
            let _e156 = bc_value[((face_idx * 8u) + 0u)];
            let _e165 = bc_kind[((face_idx * 8u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 22u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 22u) + 1u)];
            let _e201 = state[((idx * 22u) + 1u)];
            let _e208 = bc_value[((face_idx * 8u) + 1u)];
            let _e215 = bc_kind[((face_idx * 8u) + 1u)];
            let _e225 = state[((idx * 22u) + 1u)];
            let _e232 = bc_value[((face_idx * 8u) + 1u)];
            let _e241 = bc_kind[((face_idx * 8u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 22u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 22u) + 2u)];
            let _e277 = state[((idx * 22u) + 2u)];
            let _e284 = bc_value[((face_idx * 8u) + 2u)];
            let _e291 = bc_kind[((face_idx * 8u) + 2u)];
            let _e301 = state[((idx * 22u) + 2u)];
            let _e308 = bc_value[((face_idx * 8u) + 2u)];
            let _e317 = bc_kind[((face_idx * 8u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 22u) + 3u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 22u) + 3u)];
            let _e353 = state[((idx * 22u) + 3u)];
            let _e360 = bc_value[((face_idx * 8u) + 3u)];
            let _e367 = bc_kind[((face_idx * 8u) + 3u)];
            let _e377 = state[((idx * 22u) + 3u)];
            let _e384 = bc_value[((face_idx * 8u) + 3u)];
            let _e393 = bc_kind[((face_idx * 8u) + 3u)];
            let _e403 = grad_acc_3_;
            grad_acc_3_ = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 22u) + 4u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 22u) + 4u)];
            let _e429 = state[((idx * 22u) + 4u)];
            let _e436 = bc_value[((face_idx * 8u) + 4u)];
            let _e443 = bc_kind[((face_idx * 8u) + 4u)];
            let _e453 = state[((idx * 22u) + 4u)];
            let _e460 = bc_value[((face_idx * 8u) + 4u)];
            let _e469 = bc_kind[((face_idx * 8u) + 4u)];
            let _e479 = grad_acc_4_;
            grad_acc_4_ = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 22u) + 5u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 22u) + 5u)];
            let _e505 = state[((idx * 22u) + 5u)];
            let _e512 = bc_value[((face_idx * 8u) + 5u)];
            let _e519 = bc_kind[((face_idx * 8u) + 5u)];
            let _e529 = state[((idx * 22u) + 5u)];
            let _e536 = bc_value[((face_idx * 8u) + 5u)];
            let _e545 = bc_kind[((face_idx * 8u) + 5u)];
            let _e555 = grad_acc_5_;
            grad_acc_5_ = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 22u) + 6u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 22u) + 6u)];
            let _e581 = state[((idx * 22u) + 6u)];
            let _e588 = bc_value[((face_idx * 8u) + 6u)];
            let _e595 = bc_kind[((face_idx * 8u) + 6u)];
            let _e605 = state[((idx * 22u) + 6u)];
            let _e612 = bc_value[((face_idx * 8u) + 6u)];
            let _e621 = bc_kind[((face_idx * 8u) + 6u)];
            let _e631 = grad_acc_6_;
            grad_acc_6_ = (_e631 + ((_e557 * ((_e564 * _e565) + (select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary) * lambda_other))) * area));
            let _e633 = normal_vec;
            let _e640 = state[((idx * 22u) + 7u)];
            let _e641 = lambda;
            let _e643 = other_idx;
            let _e650 = state[((_e643 * 22u) + 7u)];
            let _e657 = state[((idx * 22u) + 7u)];
            let _e664 = bc_value[((face_idx * 8u) + 7u)];
            let _e671 = bc_kind[((face_idx * 8u) + 7u)];
            let _e681 = state[((idx * 22u) + 7u)];
            let _e688 = bc_value[((face_idx * 8u) + 7u)];
            let _e697 = bc_kind[((face_idx * 8u) + 7u)];
            let _e707 = grad_acc_7_;
            grad_acc_7_ = (_e707 + ((_e633 * ((_e640 * _e641) + (select(_e650, select(select(_e657, _e664, (_e671 == 1u)), (_e681 + (_e688 * d_own)), (_e697 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e710 = k;
            k = (_e710 + 1u);
        }
    }
    let _e712 = grad_acc_0_;
    let grad_out_0_ = ((_e712 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 22u) + 0u)].y = grad_out_0_.y;
    let _e735 = grad_acc_1_;
    let grad_out_1_ = ((_e735 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 22u) + 1u)].y = grad_out_1_.y;
    let _e758 = grad_acc_2_;
    let grad_out_2_ = ((_e758 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 22u) + 2u)].y = grad_out_2_.y;
    let _e781 = grad_acc_3_;
    let grad_out_3_ = ((_e781 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 3u)].x = grad_out_3_.x;
    grad_state[((idx * 22u) + 3u)].y = grad_out_3_.y;
    let _e804 = grad_acc_4_;
    let grad_out_4_ = ((_e804 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 4u)].x = grad_out_4_.x;
    grad_state[((idx * 22u) + 4u)].y = grad_out_4_.y;
    let _e827 = grad_acc_5_;
    let grad_out_5_ = ((_e827 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 5u)].x = grad_out_5_.x;
    grad_state[((idx * 22u) + 5u)].y = grad_out_5_.y;
    let _e850 = grad_acc_6_;
    let grad_out_6_ = ((_e850 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 6u)].x = grad_out_6_.x;
    grad_state[((idx * 22u) + 6u)].y = grad_out_6_.y;
    let _e873 = grad_acc_7_;
    let grad_out_7_ = ((_e873 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 22u) + 7u)].x = grad_out_7_.x;
    grad_state[((idx * 22u) + 7u)].y = grad_out_7_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 3u) + 0u)];
            let _e139 = bc_kind[((face_idx * 3u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 3u) + 0u)];
            let _e165 = bc_kind[((face_idx * 3u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 3u) + 1u)];
            let _e215 = bc_kind[((face_idx * 3u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 3u) + 1u)];
            let _e241 = bc_kind[((face_idx * 3u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 3u) + 2u)];
            let _e291 = bc_kind[((face_idx * 3u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 3u) + 2u)];
            let _e317 = bc_kind[((face_idx * 3u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e330 = k;
            k = (_e330 + 1u);
        }
    }
    let _e332 = grad_acc_0_;
    let grad_out_0_ = ((_e332 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e355 = grad_acc_1_;
    let grad_out_1_ = ((_e355 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e378 = grad_acc_2_;
    let grad_out_2_ = ((_e378 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_delta_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_correct_velocity_delta_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityDeltaIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_delta_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * 8u);
    let d_p = state[(base + 3u)];
    let grad_px = state[(base + 4u)];
    let grad_py = state[(base + 5u)];
    let grad_old_x = state[(base + 6u)];
    let grad_old_y = state[(base + 7u)];
    let corr_x = (d_p * (grad_px - grad_old_x));
    let corr_y = (d_p * (grad_py - grad_old_y));
    let _e52 = state[(base + 0u)];
    state[(base + 0u)] = (_e52 - corr_x);
    let _e62 = state[(base + 1u)];
    state[(base + 1u)] = (_e62 - corr_y);
    return;
}
"#;
    }
    pub mod rhie_chow_grad_p_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_grad_p_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedRhieChowGradPUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_grad_p_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let _e88 = normal_vec;
            let d_own = abs(dot((face_center_vec - cell_center_vec), _e88));
            let _e91 = other_center_vec;
            let _e93 = normal_vec;
            let d_neigh = abs(dot((_e91 - face_center_vec), _e93));
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e102 = lambda;
            let lambda_other = (1f - _e102);
            let _e105 = normal_vec;
            let _e112 = state[((idx * 8u) + 2u)];
            let _e113 = lambda;
            let _e115 = other_idx;
            let _e122 = state[((_e115 * 8u) + 2u)];
            let _e129 = state[((idx * 8u) + 2u)];
            let _e136 = bc_value[((face_idx * 3u) + 2u)];
            let _e143 = bc_kind[((face_idx * 3u) + 2u)];
            let _e153 = state[((idx * 8u) + 2u)];
            let _e160 = bc_value[((face_idx * 3u) + 2u)];
            let _e169 = bc_kind[((face_idx * 3u) + 2u)];
            let _e179 = grad_acc_p;
            grad_acc_p = (_e179 + ((_e105 * ((_e112 * _e113) + (select(_e122, select(select(_e129, _e136, (_e143 == 1u)), (_e153 + (_e160 * d_own)), (_e169 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e182 = k;
            k = (_e182 + 1u);
        }
    }
    let _e184 = grad_acc_p;
    let grad_out_p = ((_e184 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod rhie_chow_store_grad_p_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowStoreGradPIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_store_grad_p_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedRhieChowStoreGradPIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedRhieChowStoreGradPIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_store_grad_p_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * 8u);
    let _e23 = state[(base + 4u)];
    state[(base + 6u)] = _e23;
    let _e32 = state[(base + 5u)];
    state[(base + 7u)] = _e32;
    return;
}
"#;
    }
}
pub mod generic_coupled_schur_setup {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 16, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl SetupParams {
        pub const fn new(
            num_cells: u32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                num_cells,
                unknowns_per_cell,
                p,
                u_len,
                u0123,
                u4567,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_DIAG_AND_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_diag_and_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_diag_and_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_diag_and_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_DIAG_AND_PRESSURE: &str = "build_diag_and_pressure";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        pub diagonal_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        pub diagonal_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalar_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                },
                diagonal_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
                params: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.scalar_row_offsets,
                self.diagonal_indices,
                self.matrix_values,
                self.diag_u_inv,
                self.diag_p_inv,
                self.p_matrix_values,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalar_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diagonal_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(6): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::generic_coupled_schur_setup::SetupParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GenericCoupledSchurSetup::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("generic_coupled_schur_setup.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SetupParams {
    num_cells: u32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> p_matrix_values: array<f32>;
@group(0) @binding(6) 
var<uniform> params: SetupParams;

fn u_index(i_1: u32) -> u32 {
    if (i_1 < 4u) {
        let _e6 = params.u0123_[i_1];
        return _e6;
    }
    let _e12 = params.u4567_[(i_1 - 4u)];
    return _e12;
}

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_diag_and_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var i: u32 = 0u;
    var rank: u32 = 0u;

    let cell = ((global_id.y * (num_workgroups.x * 64u)) + global_id.x);
    let _e12 = params.num_cells;
    if (cell >= _e12) {
        return;
    }
    let scalar_offset = scalar_row_offsets[cell];
    let scalar_end = scalar_row_offsets[(cell + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[cell];
    let diag_rank = (_e25 - scalar_offset);
    let _e29 = params.unknowns_per_cell;
    let _e32 = params.unknowns_per_cell;
    let block_stride = (_e29 * _e32);
    let start_row_0_ = (scalar_offset * block_stride);
    let _e37 = params.unknowns_per_cell;
    let row_stride = (num_neighbors * _e37);
    let _e41 = params.p;
    let start_row_p = (start_row_0_ + (_e41 * row_stride));
    let _e46 = params.unknowns_per_cell;
    let _e52 = params.p;
    let diag_p = matrix_values[((start_row_p + (diag_rank * _e46)) + _e52)];
    loop {
        let _e57 = i;
        let _e60 = params.u_len;
        if (_e57 < _e60) {
        } else {
            break;
        }
        {
            let _e62 = i;
            let _e63 = u_index(_e62);
            let start_row_u = (start_row_0_ + (_e63 * row_stride));
            let _e69 = params.unknowns_per_cell;
            let diag_u = matrix_values[((start_row_u + (diag_rank * _e69)) + _e63)];
            let _e75 = safe_inverse(diag_u);
            let _e79 = params.u_len;
            let _e81 = i;
            diag_u_inv[((cell * _e79) + _e81)] = _e75;
        }
        continuing {
            let _e85 = i;
            i = (_e85 + 1u);
        }
    }
    let _e89 = safe_inverse(diag_p);
    diag_p_inv[cell] = _e89;
    loop {
        let _e91 = rank;
        if (_e91 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e94 = rank;
            let _e97 = rank;
            let _e100 = params.unknowns_per_cell;
            let _e106 = params.p;
            let _e109 = matrix_values[((start_row_p + (_e97 * _e100)) + _e106)];
            p_matrix_values[(scalar_offset + _e94)] = _e109;
        }
        continuing {
            let _e111 = rank;
            rank = (_e111 + 1u);
        }
    }
    return;
}
"#;
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let j = params.num_iters;
    let n = params.n;
    let num_groups_n = ((n + 63u) / WORKGROUP_SIZE);
    let stride_x = (num_workgroups.x * WORKGROUP_SIZE);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
    if (group_flat >= num_groups_n) {
        return;
    }
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e39 = b_w[idx];
        w_val = _e39;
    }
    loop {
        let _e42 = i;
        if (_e42 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e48 = i;
                if (_e48 <= j) {
                    let _e52 = i;
                    let _e56 = b_basis[((_e52 * stride_words) + idx)];
                    v.x = _e56;
                }
                let _e57 = i;
                if ((_e57 + 1u) <= j) {
                    let _e62 = i;
                    let _e69 = b_basis[(((_e62 + 1u) * stride_words) + idx)];
                    v.y = _e69;
                }
                let _e70 = i;
                if ((_e70 + 2u) <= j) {
                    let _e75 = i;
                    let _e82 = b_basis[(((_e75 + 2u) * stride_words) + idx)];
                    v.z = _e82;
                }
                let _e83 = i;
                if ((_e83 + 3u) <= j) {
                    let _e88 = i;
                    let _e95 = b_basis[(((_e88 + 3u) * stride_words) + idx)];
                    v.w = _e95;
                }
            }
            let _e96 = v;
            let _e97 = w_val;
            let prod = (_e96 * _e97);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e114 = sdata_vec4_[(local_id.x + 32u)];
                let _e115 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e115 + _e114);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e128 = sdata_vec4_[(local_id.x + 16u)];
                let _e129 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e129 + _e128);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e142 = sdata_vec4_[(local_id.x + 8u)];
                let _e143 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e143 + _e142);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e156 = sdata_vec4_[(local_id.x + 4u)];
                let _e157 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e157 + _e156);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e170 = sdata_vec4_[(local_id.x + 2u)];
                let _e171 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e171 + _e170);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e184 = sdata_vec4_[(local_id.x + 1u)];
                let _e185 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e185 + _e184);
                let sum_1 = sdata_vec4_[0];
                let _e190 = i;
                if (_e190 <= j) {
                    let _e193 = i;
                    b_dot_partial[((_e193 * num_groups_n) + group_flat)] = sum_1.x;
                }
                let _e198 = i;
                if ((_e198 + 1u) <= j) {
                    let _e202 = i;
                    b_dot_partial[(((_e202 + 1u) * num_groups_n) + group_flat)] = sum_1.y;
                }
                let _e210 = i;
                if ((_e210 + 2u) <= j) {
                    let _e214 = i;
                    b_dot_partial[(((_e214 + 2u) * num_groups_n) + group_flat)] = sum_1.z;
                }
                let _e222 = i;
                if ((_e222 + 3u) <= j) {
                    let _e226 = i;
                    b_dot_partial[(((_e226 + 3u) * num_groups_n) + group_flat)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e235 = i;
            i = (_e235 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e8 = params.n;
    let num_groups_n_1 = ((_e8 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e16 = k;
        if (_e16 < num_groups_n_1) {
        } else {
            break;
        }
        {
            let _e21 = k;
            let _e24 = b_dot_partial[((i_2 * num_groups_n_1) + _e21)];
            let _e25 = sum;
            sum = (_e25 + _e24);
        }
        continuing {
            let _e28 = k;
            k = (_e28 + 64u);
        }
    }
    let _e33 = sum;
    sdata[local_id_1.x] = _e33;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e45 = sdata[(local_id_1.x + 32u)];
        let _e46 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e46 + _e45);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e59 = sdata[(local_id_1.x + 16u)];
        let _e60 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e60 + _e59);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e73 = sdata[(local_id_1.x + 8u)];
        let _e74 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e74 + _e73);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e87 = sdata[(local_id_1.x + 4u)];
        let _e88 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e88 + _e87);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e101 = sdata[(local_id_1.x + 2u)];
        let _e102 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e102 + _e101);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e115 = sdata[(local_id_1.x + 1u)];
        let _e116 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e116 + _e115);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e129 = sdata[0];
        b_hessenberg[h_idx] = _e129;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let stride_x_1 = (num_workgroups_1.x * WORKGROUP_SIZE);
    let idx_1 = ((global_id_2.y * stride_x_1) + global_id_2.x);
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e30 = i_1;
        if (_e30 <= j_2) {
        } else {
            break;
        }
        {
            let _e32 = i_1;
            if (_e32 <= j_2) {
                let _e38 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e38)];
                let _e43 = i_1;
                let v_val = b_basis[((_e43 * stride_words_1) + idx_1)];
                let _e50 = correction;
                correction = (_e50 + (h_val * v_val));
            }
            let _e52 = i_1;
            if ((_e52 + 1u) <= j_2) {
                let _e59 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e59 + 1u))];
                let _e66 = i_1;
                let v_val_1 = b_basis[(((_e66 + 1u) * stride_words_1) + idx_1)];
                let _e75 = correction;
                correction = (_e75 + (h_val_1 * v_val_1));
            }
            let _e77 = i_1;
            if ((_e77 + 2u) <= j_2) {
                let _e84 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e84 + 2u))];
                let _e91 = i_1;
                let v_val_2 = b_basis[(((_e91 + 2u) * stride_words_1) + idx_1)];
                let _e100 = correction;
                correction = (_e100 + (h_val_2 * v_val_2));
            }
            let _e102 = i_1;
            if ((_e102 + 3u) <= j_2) {
                let _e109 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e109 + 3u))];
                let _e116 = i_1;
                let v_val_3 = b_basis[(((_e116 + 3u) * stride_words_1) + idx_1)];
                let _e125 = correction;
                correction = (_e125 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e128 = i_1;
            i_1 = (_e128 + 4u);
        }
    }
    let _e134 = b_w[idx_1];
    let _e135 = correction;
    b_w[idx_1] = (_e134 - _e135);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.iter_params, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let j_1 = iter_params.current_idx;
    loop {
        let _e7 = i;
        if (_e7 < j_1) {
        } else {
            break;
        }
        {
            let _e9 = i;
            let _e10 = h_idx(_e9, j_1);
            let _e11 = i;
            let _e14 = h_idx((_e11 + 1u), j_1);
            let h_ij = hessenberg[_e10];
            let h_i1j = hessenberg[_e14];
            let _e22 = i;
            let cs = givens[_e22];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e10] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e14] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e39 = i;
            i = (_e39 + 1u);
        }
    }
    let _e41 = h_idx(j_1, j_1);
    let _e44 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e41];
    let h_j1j = hessenberg[_e44];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e56 = rho;
    if (abs(_e56) > 0.00000000000000000001f) {
        let _e60 = rho;
        c = (h_jj / _e60);
        let _e63 = rho;
        s = (h_j1j / _e63);
    }
    let _e68 = c;
    let _e69 = s;
    givens[j_1] = vec2<f32>(_e68, _e69);
    let _e73 = rho;
    hessenberg[_e41] = _e73;
    hessenberg[_e44] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e87 = c;
    let _e89 = s;
    g_rhs[j_1] = ((_e87 * g_j) + (_e89 * g_j1_));
    let _e96 = s;
    let _e99 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e96) * g_j) + (_e99 * g_j1_));
    let _e108 = g_rhs[(j_1 + 1u)];
    scalars[0] = abs(_e108);
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let k = iter_params.current_idx;
    loop {
        let _e5 = loop_i;
        if (_e5 < k) {
        } else {
            break;
        }
        {
            let _e9 = loop_i;
            let i_1 = ((k - 1u) - _e9);
            let _e13 = g_rhs[i_1];
            sum = _e13;
            j = (i_1 + 1u);
            loop {
                let _e18 = j;
                if (_e18 < k) {
                } else {
                    break;
                }
                {
                    let _e20 = j;
                    let _e21 = h_idx(i_1, _e20);
                    let _e24 = hessenberg[_e21];
                    let _e26 = j;
                    let _e28 = y_sol[_e26];
                    let _e30 = sum;
                    sum = (_e30 - (_e24 * _e28));
                }
                continuing {
                    let _e33 = j;
                    j = (_e33 + 1u);
                }
            }
            let _e35 = h_idx(i_1, i_1);
            let diag = hessenberg[_e35];
            if (abs(diag) > 0.000000000001f) {
                let _e44 = sum;
                y_sol[i_1] = (_e44 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e50 = loop_i;
            loop_i = (_e50 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const EXTRACT_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_extract_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline extract_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("extract_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    pub const ENTRY_EXTRACT_DIAG_INV: &str = "extract_diag_inv";
    pub const ENTRY_APPLY_DIAG_INV: &str = "apply_diag_inv";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn global_index(global_id_14: vec3<u32>, num_workgroups_12: vec3<u32>) -> u32 {
    return ((global_id_14.y * (num_workgroups_12.x * WORKGROUP_SIZE)) + global_id_14.x);
}

fn workgroup_index(group_id_2: vec3<u32>, num_workgroups_13: vec3<u32>) -> u32 {
    return ((group_id_2.y * num_workgroups_13.x) + group_id_2.x);
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val_1 = matrix_values[_e24];
            let _e30 = vec_x[col];
            let _e32 = sum;
            sum = (_e32 + (val_1 * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    vec_y[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let _e2 = global_index(global_id_1, num_workgroups_1);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha = scalars[0];
    let _e14 = vec_x[_e2];
    let _e18 = vec_y[_e2];
    vec_y[_e2] = ((alpha * _e14) + _e18);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    let _e2 = global_index(global_id_2, num_workgroups_2);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e10 = iter_params.current_idx;
    let alpha_1 = y_sol[_e10];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_y[_e2] = ((alpha_1 * _e17) + _e21);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let _e2 = global_index(global_id_3, num_workgroups_3);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_z[_e2] = ((alpha_2 * _e17) + (beta * _e21));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>, @builtin(num_workgroups) num_workgroups_4: vec3<u32>) {
    let _e2 = global_index(global_id_4, num_workgroups_4);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (alpha_3 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>, @builtin(num_workgroups) num_workgroups_5: vec3<u32>) {
    let _e2 = global_index(global_id_5, num_workgroups_5);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e14 = vec_y[_e2];
    vec_y[_e2] = (alpha_4 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>, @builtin(num_workgroups) num_workgroups_6: vec3<u32>) {
    let _e2 = global_index(global_id_6, num_workgroups_6);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = vec_x[_e2];
    vec_y[_e2] = _e11;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups_7: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e4 = global_index(global_id_7, num_workgroups_7);
    let lid = local_id.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let _e13 = vec_x[_e4];
        let _e16 = vec_y[_e4];
        local_sum = (_e13 * _e16);
    }
    let _e21 = local_sum;
    partial_sums[lid] = _e21;
    workgroupBarrier();
    loop {
        let _e23 = stride;
        if (_e23 > 0u) {
        } else {
            break;
        }
        {
            let _e26 = stride;
            if (lid < _e26) {
                let _e31 = stride;
                let _e34 = partial_sums[(lid + _e31)];
                let _e35 = partial_sums[lid];
                partial_sums[lid] = (_e35 + _e34);
            }
            workgroupBarrier();
        }
        continuing {
            let _e38 = stride;
            stride = (_e38 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e43 = workgroup_index(group_id, num_workgroups_7);
        let _e46 = params.n;
        let num_groups_n = ((_e46 + 63u) / WORKGROUP_SIZE);
        if (_e43 < num_groups_n) {
            let _e56 = partial_sums[0];
            vec_z[_e43] = _e56;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_8: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e4 = global_index(global_id_8, num_workgroups_8);
    let lid_1 = local_id_1.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let val_2 = vec_x[_e4];
        local_sum_1 = (val_2 * val_2);
    }
    let _e18 = local_sum_1;
    partial_sums[lid_1] = _e18;
    workgroupBarrier();
    loop {
        let _e20 = stride_1;
        if (_e20 > 0u) {
        } else {
            break;
        }
        {
            let _e23 = stride_1;
            if (lid_1 < _e23) {
                let _e28 = stride_1;
                let _e31 = partial_sums[(lid_1 + _e28)];
                let _e32 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e32 + _e31);
            }
            workgroupBarrier();
        }
        continuing {
            let _e35 = stride_1;
            stride_1 = (_e35 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e40 = workgroup_index(group_id_1, num_workgroups_8);
        let _e43 = params.n;
        let num_groups_n_1 = ((_e43 + 63u) / WORKGROUP_SIZE);
        if (_e40 < num_groups_n_1) {
            let _e53 = partial_sums[0];
            vec_z[_e40] = _e53;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>, @builtin(num_workgroups) num_workgroups_9: vec3<u32>) {
    let _e2 = global_index(global_id_9, num_workgroups_9);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let h = scalars[0];
    let _e14 = vec_y[_e2];
    let _e17 = vec_x[_e2];
    vec_y[_e2] = (_e14 - (h * _e17));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let num_partials_1 = params.n;
    loop {
        let _e6 = i_1;
        if (_e6 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e10 = i_1;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum_1;
            total_sum_1 = (_e13 + _e12);
        }
        continuing {
            let _e16 = i_1;
            i_1 = (_e16 + 1u);
        }
    }
    let _e18 = total_sum_1;
    let norm = sqrt(_e18);
    let _e23 = iter_params.current_idx;
    hessenberg[_e23] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn extract_diag_inv(@builtin(global_invocation_id) global_id_12: vec3<u32>, @builtin(num_workgroups) num_workgroups_10: vec3<u32>) {
    var diag: f32 = 1f;
    var k_1: u32;

    let _e3 = global_index(global_id_12, num_workgroups_10);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start_1 = row_offsets[_e3];
    let end_1 = row_offsets[(_e3 + 1u)];
    k_1 = start_1;
    loop {
        let _e17 = k_1;
        if (_e17 < end_1) {
        } else {
            break;
        }
        {
            let _e20 = k_1;
            let _e22 = col_indices[_e20];
            if (_e22 == _e3) {
                let _e25 = k_1;
                let _e27 = matrix_values[_e25];
                diag = _e27;
                break;
            }
        }
        continuing {
            let _e29 = k_1;
            k_1 = (_e29 + 1u);
        }
    }
    let _e32 = diag;
    let _e33 = safe_inverse(_e32);
    diag_u[_e3] = _e33;
    diag_v[_e3] = _e33;
    diag_p[_e3] = _e33;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_diag_inv(@builtin(global_invocation_id) global_id_13: vec3<u32>, @builtin(num_workgroups) num_workgroups_11: vec3<u32>) {
    let _e2 = global_index(global_id_13, num_workgroups_11);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = diag_u[_e2];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (_e11 * _e14);
    return;
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.x, self.r, self.p, self.v]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

fn global_index(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = matrix_values[_e24];
            let _e30 = p[col];
            let _e32 = sum;
            sum = (_e32 + (val * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    v[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var alpha: f32 = 0f;

    let _e3 = global_index(global_id_1, num_workgroups_1);
    let _e6 = scalars.r0_v;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_old;
        let _e15 = scalars.r0_v;
        alpha = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (_e3 >= _e25) {
        return;
    }
    let _e29 = alpha;
    let _e32 = p[_e3];
    let _e34 = x[_e3];
    x[_e3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha;
    let _e41 = v[_e3];
    let _e43 = r[_e3];
    r[_e3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var beta: f32 = 0f;

    let _e3 = global_index(global_id_2, num_workgroups_2);
    let _e6 = scalars.rho_old;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_new;
        let _e15 = scalars.rho_old;
        beta = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = beta;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (_e3 >= _e30) {
        return;
    }
    let _e36 = r[_e3];
    let _e37 = beta;
    let _e40 = p[_e3];
    p[_e3] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod outer_convergence {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub stride: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_targets: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl Params {
        pub const fn new(num_cells: u32, stride: u32, num_targets: u32, _pad0: u32) -> Self {
            Self {
                num_cells,
                stride,
                num_targets,
                _pad0,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct TargetDesc {
        #[doc = "offset: 0, size: 16, type: `array<u32, 4>`"]
        pub offsets: [u32; 4],
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub num_comps: u32,
        #[doc = "offset: 20, size: 12, type: `array<u32, 3>`"]
        pub _pad0: [u32; 3],
    }
    impl TargetDesc {
        pub const fn new(offsets: [u32; 4], num_comps: u32, _pad0: [u32; 3]) -> Self {
            Self {
                offsets,
                num_comps,
                _pad0,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input: wgpu::BufferBinding<'a>,
        pub targets: wgpu::BufferBinding<'a>,
        pub out_bits: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input: wgpu::BindGroupEntry<'a>,
        pub targets: wgpu::BindGroupEntry<'a>,
        pub out_bits: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input),
                },
                targets: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.targets),
                },
                out_bits: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.out_bits),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.input, self.targets, self.out_bits, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("OuterConvergence::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"targets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"out_bits\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::outer_convergence::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("OuterConvergence::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("OuterConvergence::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("outer_convergence.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    num_cells: u32,
    stride: u32,
    num_targets: u32,
    _pad0_: u32,
}

struct TargetDesc {
    offsets: array<u32, 4>,
    num_comps: u32,
    _pad0_: array<u32, 3>,
}

@group(0) @binding(0) 
var<storage> input: array<f32>;
@group(0) @binding(1) 
var<storage> targets: array<TargetDesc>;
@group(0) @binding(2) 
var<storage, read_write> out_bits: array<atomic<u32>>;
@group(0) @binding(3) 
var<uniform> params: Params;

@compute @workgroup_size(256, 1, 1) 
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    var t: u32 = 0u;
    var mag2_: f32;
    var c: u32;

    let cell = gid.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let _e9 = params.stride;
    let base = (cell * _e9);
    loop {
        let _e12 = t;
        let _e15 = params.num_targets;
        if (_e12 < _e15) {
        } else {
            break;
        }
        {
            let _e18 = t;
            let desc = targets[_e18];
            mag2_ = 0f;
            c = 0u;
            loop {
                let _e25 = c;
                if (_e25 < desc.num_comps) {
                } else {
                    break;
                }
                {
                    let _e29 = c;
                    let off = desc.offsets[_e29];
                    let v = input[(base + off)];
                    let _e35 = mag2_;
                    mag2_ = (_e35 + (v * v));
                }
                continuing {
                    let _e38 = c;
                    c = (_e38 + 1u);
                }
            }
            let _e41 = mag2_;
            let mag = sqrt(_e41);
            let bits = bitcast<u32>(mag);
            let _e45 = t;
            let _e47 = atomicMax((&out_bits[_e45]), bits);
        }
        continuing {
            let _e48 = t;
            t = (_e48 + 1u);
        }
    }
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_4;
            i_4 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_2] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_5;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_5;
            if (lid_2 < _e27) {
                let _e32 = i_5;
                let _e35 = scratch1_[(lid_2 + _e32)];
                let _e36 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_5;
            i_5 = (_e39 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u0: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            u0: u32,
            u1: u32,
            p: u32,
            _pad0: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                u0,
                u1,
                p,
                _pad0,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    u0_: u32,
    u1_: u32,
    p: u32,
    _pad0_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u = (base + _e14);
    let _e18 = params.u1_;
    let row_v = (base + _e18);
    let p_val = p_sol[_e3];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e32 = k_1;
        if (_e32 < end_u) {
        } else {
            break;
        }
        {
            let _e35 = k_1;
            let col = col_indices[_e35];
            let _e40 = params.unknowns_per_cell;
            let _e44 = params.p;
            if ((col % _e40) == _e44) {
                let _e48 = params.unknowns_per_cell;
                let p_cell = (col / _e48);
                let _e51 = k_1;
                let _e53 = matrix_values[_e51];
                let _e57 = p_sol[p_cell];
                let _e59 = correction_u;
                correction_u = (_e59 + (_e53 * _e57));
            }
        }
        continuing {
            let _e62 = k_1;
            k_1 = (_e62 + 1u);
        }
    }
    let _e68 = diag_u_inv[_e3];
    let _e69 = correction_u;
    let _e71 = z_out[row_u];
    z_out[row_u] = (_e71 - (_e68 * _e69));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e82 = k_2;
        if (_e82 < end_v) {
        } else {
            break;
        }
        {
            let _e85 = k_2;
            let col_1 = col_indices[_e85];
            let _e90 = params.unknowns_per_cell;
            let _e94 = params.p;
            if ((col_1 % _e90) == _e94) {
                let _e98 = params.unknowns_per_cell;
                let p_cell_1 = (col_1 / _e98);
                let _e101 = k_2;
                let _e103 = matrix_values[_e101];
                let _e107 = p_sol[p_cell_1];
                let _e109 = correction_v;
                correction_v = (_e109 + (_e103 * _e107));
            }
        }
        continuing {
            let _e112 = k_2;
            k_2 = (_e112 + 1u);
        }
    }
    let _e118 = diag_v_inv[_e3];
    let _e119 = correction_v;
    let _e121 = z_out[row_v];
    z_out[row_v] = (_e121 - (_e118 * _e119));
    let _e126 = params.p;
    z_out[(base + _e126)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u_1 = (base_1 + _e14);
    let _e18 = params.u1_;
    let row_v_1 = (base_1 + _e18);
    let _e22 = params.p;
    let row_p = (base_1 + _e22);
    loop {
        let _e25 = c;
        let _e28 = params.unknowns_per_cell;
        if (_e25 < _e28) {
        } else {
            break;
        }
        {
            let _e31 = c;
            let _e35 = c;
            let _e38 = r_in[(base_1 + _e35)];
            z_out[(base_1 + _e31)] = _e38;
        }
        continuing {
            let _e40 = c;
            c = (_e40 + 1u);
        }
    }
    let r_u = r_in[row_u_1];
    let r_v = r_in[row_v_1];
    let _e52 = diag_u_inv[_e3];
    z_out[row_u_1] = (_e52 * r_u);
    let _e58 = diag_v_inv[_e3];
    z_out[row_v_1] = (_e58 * r_v);
    z_out[row_p] = 0f;
    let _e65 = r_in[row_p];
    rhs_p = _e65;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e76 = k_3;
        if (_e76 < end_1) {
        } else {
            break;
        }
        {
            let _e79 = k_3;
            let col_2 = col_indices[_e79];
            let _e84 = params.unknowns_per_cell;
            let rem = (col_2 % _e84);
            z_val = 0f;
            let _e90 = params.u0_;
            if (rem == _e90) {
                let _e94 = params.unknowns_per_cell;
                let c_1 = (col_2 / _e94);
                let _e98 = r_in[col_2];
                let _e101 = diag_u_inv[c_1];
                z_val = (_e98 * _e101);
            } else {
                let _e105 = params.u1_;
                if (rem == _e105) {
                    let _e109 = params.unknowns_per_cell;
                    let c_2 = (col_2 / _e109);
                    let _e113 = r_in[col_2];
                    let _e116 = diag_v_inv[c_2];
                    z_val = (_e113 * _e116);
                }
            }
            let _e119 = k_3;
            let _e121 = matrix_values[_e119];
            let _e122 = z_val;
            let _e124 = rhs_p;
            rhs_p = (_e124 - (_e121 * _e122));
        }
        continuing {
            let _e127 = k_3;
            k_3 = (_e127 + 1u);
        }
    }
    let _e131 = rhs_p;
    temp_p[_e3] = _e131;
    let _e136 = diag_p_inv[_e3];
    let _e137 = rhs_p;
    p_sol[_e3] = (_e136 * _e137);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
pub mod schur_precond_generic {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            _pad0: u32,
            _pad1: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                p,
                u_len,
                _pad0,
                _pad1,
                u0123,
                u4567,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u_inv, self.diag_p_inv, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond_generic::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecondGeneric::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond_generic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    _pad0_: u32,
    _pad1_: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(2) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn u_index(i_3: u32) -> u32 {
    if (i_3 < 4u) {
        let _e6 = params.u0123_[i_3];
        return _e6;
    }
    let _e12 = params.u4567_[(i_3 - 4u)];
    return _e12;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var i: u32 = 0u;
    var correction_u: f32;
    var k_1: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let p_val = p_sol[_e3];
    loop {
        let _e16 = i;
        let _e19 = params.u_len;
        if (_e16 < _e19) {
        } else {
            break;
        }
        {
            let _e21 = i;
            let _e22 = u_index(_e21);
            let row_u = (base + _e22);
            let start_u = row_offsets[row_u];
            let end_u = row_offsets[(row_u + 1u)];
            correction_u = 0f;
            k_1 = start_u;
            loop {
                let _e35 = k_1;
                if (_e35 < end_u) {
                } else {
                    break;
                }
                {
                    let _e38 = k_1;
                    let col = col_indices[_e38];
                    let _e43 = params.unknowns_per_cell;
                    let _e47 = params.p;
                    if ((col % _e43) == _e47) {
                        let _e51 = params.unknowns_per_cell;
                        let p_cell = (col / _e51);
                        let _e54 = k_1;
                        let _e56 = matrix_values[_e54];
                        let _e59 = p_sol[p_cell];
                        let _e61 = correction_u;
                        correction_u = (_e61 + (_e56 * _e59));
                    }
                }
                continuing {
                    let _e64 = k_1;
                    k_1 = (_e64 + 1u);
                }
            }
            let _e71 = params.u_len;
            let _e73 = i;
            let _e76 = diag_u_inv[((_e3 * _e71) + _e73)];
            let _e77 = correction_u;
            let _e79 = z_out[row_u];
            z_out[row_u] = (_e79 - (_e76 * _e77));
        }
        continuing {
            let _e82 = i;
            i = (_e82 + 1u);
        }
    }
    let _e87 = params.p;
    z_out[(base + _e87)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var i_1: u32 = 0u;
    var rhs_p: f32;
    var k_2: u32;
    var z_val: f32;
    var i_2: u32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.p;
    let row_p = (base_1 + _e14);
    loop {
        let _e17 = c;
        let _e20 = params.unknowns_per_cell;
        if (_e17 < _e20) {
        } else {
            break;
        }
        {
            let _e23 = c;
            let _e27 = c;
            let _e30 = r_in[(base_1 + _e27)];
            z_out[(base_1 + _e23)] = _e30;
        }
        continuing {
            let _e32 = c;
            c = (_e32 + 1u);
        }
    }
    loop {
        let _e35 = i_1;
        let _e38 = params.u_len;
        if (_e35 < _e38) {
        } else {
            break;
        }
        {
            let _e40 = i_1;
            let _e41 = u_index(_e40);
            let row_u_1 = (base_1 + _e41);
            let _e48 = params.u_len;
            let _e50 = i_1;
            let _e53 = diag_u_inv[((_e3 * _e48) + _e50)];
            let _e56 = r_in[row_u_1];
            z_out[row_u_1] = (_e53 * _e56);
        }
        continuing {
            let _e59 = i_1;
            i_1 = (_e59 + 1u);
        }
    }
    z_out[row_p] = 0f;
    let _e66 = r_in[row_p];
    rhs_p = _e66;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_2 = start_1;
    loop {
        let _e77 = k_2;
        if (_e77 < end_1) {
        } else {
            break;
        }
        {
            let _e80 = k_2;
            let col_1 = col_indices[_e80];
            let _e85 = params.unknowns_per_cell;
            let rem = (col_1 % _e85);
            z_val = 0f;
            i_2 = 0u;
            loop {
                let _e91 = i_2;
                let _e94 = params.u_len;
                if (_e91 < _e94) {
                } else {
                    break;
                }
                {
                    let _e96 = i_2;
                    let _e97 = u_index(_e96);
                    if (rem == _e97) {
                        let _e101 = params.unknowns_per_cell;
                        let c_1 = (col_1 / _e101);
                        let _e105 = r_in[col_1];
                        let _e109 = params.u_len;
                        let _e111 = i_2;
                        let _e114 = diag_u_inv[((c_1 * _e109) + _e111)];
                        z_val = (_e105 * _e114);
                        break;
                    }
                }
                continuing {
                    let _e117 = i_2;
                    i_2 = (_e117 + 1u);
                }
            }
            let _e120 = k_2;
            let _e122 = matrix_values[_e120];
            let _e123 = z_val;
            let _e125 = rhs_p;
            rhs_p = (_e125 - (_e122 * _e123));
        }
        continuing {
            let _e128 = k_2;
            k_2 = (_e128 + 1u);
        }
    }
    let _e132 = rhs_p;
    temp_p[_e3] = _e132;
    let _e137 = diag_p_inv[_e3];
    let _e138 = rhs_p;
    p_sol[_e3] = (_e137 * _e138);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
