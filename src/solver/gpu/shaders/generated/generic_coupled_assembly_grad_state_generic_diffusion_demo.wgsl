// GENERATED BY CFD2 CODEGEN (unified_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<uniform> constants: Constants;

@group(1) @binding(4) 
var<storage, read> grad_state: array<Vector2>;

// Group 2: Solver (block CSR values + RHS)

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

// Group 3: Boundary conditions (per face x unknown)

@group(3) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(3) @binding(1) 
var<storage, read> bc_value: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let scalar_offset = scalar_row_offsets[idx];
    let diag_rank = diagonal_indices[idx] - scalar_offset;
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = scalar_offset * 1u;
    for (var rank = 0u; rank < num_neighbors; rank++) {
        matrix_values[start_row_0 + rank * 1u + 0u] = 0.0;
    }
    var diag_0: f32 = 0.0;
    var rhs_0: f32 = 0.0;
    diag_0 += vol * 1.0 / constants.dt;
    rhs_0 += vol * 1.0 / constants.dt * state_old[idx * 1u + 0u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * 1.0 / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_0 = diag_0 - vol * 1.0 / constants.dt + diag_bdf2;
        rhs_0 = rhs_0 - vol * 1.0 / constants.dt * state_old[idx * 1u + 0u] + vol * 1.0 / constants.dt * (factor_n * state_old[idx * 1u + 0u] - factor_nm1 * state_old_old[idx * 1u + 0u]);
    }
    for (var k = start; k < end; k++) {
        let face_idx = cell_faces[k];
        let owner = face_owner[face_idx];
        let neighbor_raw = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        let f_center = face_centers[face_idx];
        var normal: Vector2 = face_normals[face_idx];
        var is_boundary: bool = false;
        var other_idx: u32 = idx;
        var other_center: Vector2;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        if (neighbor_raw != -1) {
            let neighbor = u32(neighbor_raw);
            other_idx = neighbor;
            if (owner != idx) {
                other_idx = owner;
            }
            other_center = cell_centers[other_idx];
        } else {
            is_boundary = true;
            other_idx = idx;
            other_center = f_center;
        }
        let dx = other_center.x - center.x;
        let dy = other_center.y - center.y;
        let dist_proj = abs(dx * normal.x + dy * normal.y);
        let dist_euc = sqrt(dx * dx + dy * dy);
        var dist: f32 = max(dist_euc, 0.000001);
        if (dist_proj > 0.000001) {
            dist = dist_proj;
        }
        let scalar_mat_idx = cell_face_matrix_indices[k];
        let neighbor_rank = scalar_mat_idx - scalar_offset;
        let diff_coeff_phi = 1.0 * area / dist;
        if (!is_boundary) {
            diag_0 += diff_coeff_phi;
            matrix_values[start_row_0 + neighbor_rank * 1u + 0u] -= diff_coeff_phi;
        } else {
            if (bc_kind[face_idx * 1u + 0u] == 1u) {
                diag_0 += diff_coeff_phi;
                rhs_0 += diff_coeff_phi * bc_value[face_idx * 1u + 0u];
            } else {
                if (bc_kind[face_idx * 1u + 0u] == 2u) {
                    rhs_0 += -(1.0 * area * bc_value[face_idx * 1u + 0u]);
                }
            }
        }
    }
    matrix_values[start_row_0 + diag_rank * 1u + 0u] += diag_0;
    rhs[idx * 1u + 0u] = rhs_0;
}
