use std::collections::HashMap;

use super::dsl as typed;
use super::state_access::state_component;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::model::backend::ast::{Coefficient, Discretization};
use crate::solver::model::backend::StateLayout;
use crate::solver::codegen::ir::{DiscreteOpKind, DiscreteSystem};

pub fn generate_generic_coupled_assembly_wgsl(system: &DiscreteSystem, layout: &StateLayout) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (generic_coupled_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_assembly_items());
    module.push(Item::Function(main_assembly_fn(system, layout)));
    module.to_wgsl()
}

pub fn generate_generic_coupled_update_wgsl(system: &DiscreteSystem, layout: &StateLayout) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (generic_coupled_update)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_update_items());
    module.push(Item::Function(main_update_fn(system, layout)));
    module.to_wgsl()
}

pub fn generate_generic_coupled_apply_wgsl() -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (generic_coupled_apply)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_apply_items());
    module.push(Item::Function(main_apply_fn()));
    module.to_wgsl()
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("precond_type", Type::U32),
            StructField::new("precond_model", Type::U32),
            StructField::new("precond_theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn base_mesh_items() -> Vec<Item> {
    vec![
        Item::Struct(vector2_struct()),
        Item::Struct(constants_struct()),
        Item::Comment("Group 0: Mesh".to_string()),
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var("face_neighbor", Type::array(Type::I32), 0, 1, AccessMode::Read),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
    ]
}

fn base_state_items() -> Vec<Item> {
    vec![
        Item::Comment("Group 1: Fields".to_string()),
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var("state_old_old", Type::array(Type::F32), 1, 2, AccessMode::Read),
        uniform_var(
            "constants",
            Type::Custom("Constants".to_string()),
            1,
            3,
        ),
    ]
}

fn base_assembly_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.extend(base_mesh_items());
    items.extend(base_state_items());
    items.push(Item::Comment("Group 2: Solver (block CSR values + RHS)".to_string()));
    items.push(storage_var(
        "matrix_values",
        Type::array(Type::F32),
        2,
        0,
        AccessMode::ReadWrite,
    ));
    items.push(storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite));
    items.push(storage_var(
        "scalar_row_offsets",
        Type::array(Type::U32),
        2,
        2,
        AccessMode::Read,
    ));
    items
}

fn base_update_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Fields".to_string()));
    items.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        0,
        AccessMode::ReadWrite,
    ));
    items.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        1,
    ));
    items.push(Item::Comment("Group 1: Solution".to_string()));
    items.push(storage_var("x", Type::array(Type::F32), 1, 0, AccessMode::Read));
    items
}

fn base_apply_items() -> Vec<Item> {
    vec![
        Item::Comment("Group 0: CSR matrix".to_string()),
        storage_var("row_offsets", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var("col_indices", Type::array(Type::U32), 0, 1, AccessMode::Read),
        storage_var("matrix_values", Type::array(Type::F32), 0, 2, AccessMode::Read),
        Item::Comment("Group 1: vectors".to_string()),
        storage_var("x", Type::array(Type::F32), 1, 0, AccessMode::Read),
        storage_var("y", Type::array(Type::F32), 1, 1, AccessMode::ReadWrite),
    ]
}

fn coupled_unknown_components(system: &DiscreteSystem) -> Vec<(crate::solver::model::backend::ast::FieldRef, u32)> {
    let mut out = Vec::new();
    for equation in &system.equations {
        let count = equation.target.kind().component_count() as u32;
        for component in 0..count {
            out.push((equation.target, component));
        }
    }
    out
}

fn coupled_offsets(system: &DiscreteSystem) -> HashMap<String, u32> {
    let mut offsets = HashMap::new();
    let mut current = 0u32;
    for equation in &system.equations {
        offsets.insert(equation.target.name().to_string(), current);
        current += equation.target.kind().component_count() as u32;
    }
    offsets
}

fn coefficient_value_expr(
    layout: &StateLayout,
    coeff: Option<&Coefficient>,
    idx_ident: &str,
    default: Expr,
) -> Expr {
    match coeff {
        None => default,
        Some(Coefficient::Constant { value, .. }) => (*value as f32).into(),
        Some(Coefficient::Field(field)) => {
            let name = field.name();
            if name == "rho" {
                Expr::ident("constants").field("density")
            } else if name == "mu" {
                Expr::ident("constants").field("viscosity")
            } else if layout.offset_for(name).is_some() {
                state_component(layout, "state", idx_ident, name, 0)
            } else {
                default
            }
        }
        Some(Coefficient::Product(lhs, rhs)) => {
            coefficient_value_expr(layout, Some(lhs), idx_ident, default.clone())
                * coefficient_value_expr(layout, Some(rhs), idx_ident, default)
        }
    }
}

fn main_assembly_fn(system: &DiscreteSystem, layout: &StateLayout) -> Function {
    let _stride = layout.stride();
    let unknowns = coupled_unknown_components(system);
    let coupled_stride = unknowns.len() as u32;
    let block_stride = coupled_stride * coupled_stride;
    let offsets = coupled_offsets(system);

    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let block_shape = typed::BlockShape::new(coupled_stride as u8, coupled_stride as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        dsl::array_access("scalar_row_offsets", Expr::ident("idx") + 1u32)
            - Expr::ident("scalar_offset"),
    ));

    // start_row_i = scalar_offset * block_stride + num_neighbors * coupled_stride * i
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::ident("scalar_offset") * block_stride,
    ));
    for row in 1..coupled_stride {
        let name = format!("start_row_{row}");
        stmts.push(dsl::let_expr(
            &name,
            Expr::ident("start_row_0")
                + Expr::ident("num_neighbors") * coupled_stride * row,
        ));
    }

    // Clear all block entries for this cell's rows.
    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("rank", 0u32),
        Expr::ident("rank").lt(Expr::ident("num_neighbors")),
        dsl::for_step_increment_expr(Expr::ident("rank")),
        dsl::block(dsl::for_each_mat_entry_block(coupled_stride as usize, |r, c| {
            vec![dsl::assign_expr(
                block_matrix.entry(&Expr::ident("rank"), r as u8, c as u8).expr,
                0.0,
            )]
        })),
    ));

    // diag_i / rhs_i accumulators
    for i in 0..coupled_stride {
        let diag_name = format!("diag_{i}");
        stmts.push(dsl::var_typed_expr(&diag_name, Type::F32, Some(0.0.into())));
        let rhs_name = format!("rhs_{i}");
        stmts.push(dsl::var_typed_expr(&rhs_name, Type::F32, Some(0.0.into())));
    }

    // Time derivative contributions (implicit only).
    for equation in &system.equations {
        let Some(ddt_op) = equation
            .ops
            .iter()
            .find(|op| op.kind == DiscreteOpKind::TimeDerivative && op.discretization == Discretization::Implicit)
        else {
            continue;
        };

        let base_offset = *offsets
            .get(equation.target.name())
            .expect("missing target offset");
        let rho_expr = coefficient_value_expr(
            layout,
            ddt_op.coeff.as_ref(),
            "idx",
            Expr::ident("constants").field("density"),
        );
        let base_coeff =
            Expr::ident("vol") * rho_expr / Expr::ident("constants").field("dt");

        let dt = Expr::ident("constants").field("dt");
        let dt_old = Expr::ident("constants").field("dt_old");
        let time_scheme = Expr::ident("constants").field("time_scheme");

        for component in 0..equation.target.kind().component_count() as u32 {
            let u_idx = base_offset + component;
            let phi_n = state_component(layout, "state_old", "idx", equation.target.name(), component);
            let phi_nm1 =
                state_component(layout, "state_old_old", "idx", equation.target.name(), component);

            // Default BDF1
            stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(format!("diag_{u_idx}")),
                base_coeff.clone(),
            ));
            stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(format!("rhs_{u_idx}")),
                base_coeff.clone() * phi_n.clone(),
            ));

            // Optional BDF2.
            stmts.push(dsl::if_block_expr(
                time_scheme.eq(1u32), // TimeScheme::BDF2 == 1
                dsl::block(vec![
                    dsl::let_expr("r", dt.clone() / dt_old.clone()),
                    dsl::let_expr(
                        "diag_bdf2",
                        base_coeff.clone()
                            * (Expr::ident("r") * 2.0 + 1.0)
                            / (Expr::ident("r") + 1.0),
                    ),
                    dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
                    dsl::let_expr(
                        "factor_nm1",
                        (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
                    ),
                    dsl::assign_expr(Expr::ident(format!("diag_{u_idx}")), Expr::ident(format!("diag_{u_idx}")) - base_coeff.clone() + Expr::ident("diag_bdf2")),
                    dsl::assign_expr(
                        Expr::ident(format!("rhs_{u_idx}")),
                        Expr::ident(format!("rhs_{u_idx}"))
                            - base_coeff.clone() * phi_n.clone()
                            + base_coeff.clone()
                                * (Expr::ident("factor_n") * phi_n
                                    - Expr::ident("factor_nm1") * phi_nm1),
                    ),
                ]),
                None,
            ));
        }
    }

    let diffusion_face_stmts = {
        let mut out = Vec::new();
        for equation in &system.equations {
            let Some(diff_op) = equation.ops.iter().find(|op| {
                op.kind == DiscreteOpKind::Diffusion && op.discretization == Discretization::Implicit
            }) else {
                continue;
            };
            let base_offset = *offsets
                .get(equation.target.name())
                .expect("missing target offset");
            let kappa = coefficient_value_expr(
                layout,
                diff_op.coeff.as_ref(),
                "idx",
                Expr::ident("constants").field("viscosity"),
            );
            let coeff_name = format!("diff_coeff_{}", equation.target.name());
            out.push(dsl::let_expr(
                &coeff_name,
                kappa * Expr::ident("area") / Expr::ident("dist"),
            ));
            for component in 0..equation.target.kind().component_count() as u32 {
                let u_idx = base_offset + component;
                out.push(dsl::assign_op_expr(
                    AssignOp::Add,
                    Expr::ident(format!("diag_{u_idx}")),
                    Expr::ident(&coeff_name),
                ));
                out.push(dsl::assign_op_expr(
                    AssignOp::Sub,
                    block_matrix
                        .entry(&Expr::ident("neighbor_rank"), u_idx as u8, u_idx as u8)
                        .expr,
                    Expr::ident(&coeff_name),
                ));
            }
        }
        out
    };

    // Face loop for diffusion contributions (implicit only, Neumann boundaries).
    let mut face_neighbor_stmts = vec![
        dsl::let_expr(
            "other_idx",
            Expr::call_named("u32", vec![Expr::ident("other_raw")]),
        ),
        dsl::let_expr(
            "other_center",
            dsl::array_access("cell_centers", Expr::ident("other_idx")),
        ),
        dsl::let_expr(
            "normal",
            dsl::array_access("face_normals", Expr::ident("face")),
        ),
        dsl::let_expr(
            "dx",
            Expr::ident("other_center").field("x") - Expr::ident("center").field("x"),
        ),
        dsl::let_expr(
            "dy",
            Expr::ident("other_center").field("y") - Expr::ident("center").field("y"),
        ),
        dsl::let_expr(
            "dist",
            dsl::abs(
                Expr::ident("dx") * Expr::ident("normal").field("x")
                    + Expr::ident("dy") * Expr::ident("normal").field("y"),
            ),
        ),
        dsl::let_expr("area", dsl::array_access("face_areas", Expr::ident("face"))),
        dsl::let_expr(
            "scalar_mat_idx",
            dsl::array_access("cell_face_matrix_indices", Expr::ident("k")),
        ),
        dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ),
    ];
    face_neighbor_stmts.extend(diffusion_face_stmts);

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(vec![
            dsl::let_expr("face", dsl::array_access("cell_faces", Expr::ident("k"))),
            dsl::let_expr(
                "other_raw",
                dsl::array_access("face_neighbor", Expr::ident("face")),
            ),
            dsl::if_block_expr(
                Expr::ident("other_raw").lt(0),
                dsl::block(vec![]),
                Some(dsl::block(face_neighbor_stmts)),
            ),
        ]),
    ));

    // Write diagonal block and RHS.
    stmts.push(dsl::let_expr(
        "diag_rank",
        dsl::array_access("diagonal_indices", Expr::ident("idx")) - Expr::ident("scalar_offset"),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    for i in 0..coupled_stride {
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            diag_entry.entry(i as u8, i as u8).expr,
            Expr::ident(format!("diag_{i}")),
        ));
        stmts.push(dsl::assign_expr(
            dsl::array_access_linear("rhs", Expr::ident("idx"), coupled_stride, i),
            Expr::ident(format!("rhs_{i}")),
        ));
    }

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}

fn main_update_fn(system: &DiscreteSystem, layout: &StateLayout) -> Function {
    let stride = layout.stride();
    let unknowns = coupled_unknown_components(system);
    let coupled_stride = unknowns.len() as u32;

    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()]) / stride,
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    for (u_idx, (field, component)) in unknowns.iter().enumerate() {
        let target = state_component(layout, "state", "idx", field.name(), *component);
        let value = dsl::array_access_linear("x", Expr::ident("idx"), coupled_stride, u_idx as u32);
        stmts.push(dsl::assign_expr(target, value));
    }

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}

fn main_apply_fn() -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    let mut stmts = Vec::new();
    stmts.push(dsl::let_expr("row", Expr::ident("global_id").field("x")));
    stmts.push(dsl::let_expr(
        "n",
        Expr::call_named("arrayLength", vec![Expr::ident("row_offsets").addr_of()]) - 1u32,
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("row").ge(Expr::ident("n")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("row_offsets", Expr::ident("row")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("row_offsets", Expr::ident("row") + 1u32),
    ));
    stmts.push(dsl::var_typed_expr("sum", Type::F32, Some(0.0.into())));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(vec![
            dsl::let_expr("col", dsl::array_access("col_indices", Expr::ident("k"))),
            dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident("sum"),
                dsl::array_access("matrix_values", Expr::ident("k"))
                    * dsl::array_access("x", Expr::ident("col")),
            ),
        ]),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access("y", Expr::ident("row")),
        Expr::ident("sum"),
    ));

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        Block::new(stmts),
    )
}
