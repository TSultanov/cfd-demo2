use crate::solver::model::CompressibleFields;
use crate::solver::model::backend::StateLayout;
use super::dsl as typed;
use super::state_access::{state_scalar_expr, state_vec2_expr};
use super::reconstruction::limited_linear_reconstruct_face;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, BinaryOp, Block, Expr, Function, GlobalVar, Item, Module,
    Param, Stmt, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_compressible_assembly_wgsl(
    layout: &StateLayout,
    fields: &CompressibleFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (compressible_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("precond_type", Type::U32),
            StructField::new("precond_model", Type::U32),
            StructField::new("precond_theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_iter",
            Type::array(Type::F32),
            1,
            9,
            AccessMode::Read,
        ),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CompressibleFields) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CompressibleFields) -> Block {
    let mut stmts = Vec::new();
    let rho_field = fields.rho.name();
    let rho_u_field = fields.rho_u.name();
    let rho_e_field = fields.rho_e.name();
    let gamma = "1.4";
    let block_size = 4u32;
    let block_stride = block_size * block_size;
    let block_shape = typed::BlockShape::new(block_size as u8, block_size as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    stmts.push(dsl::let_("idx", "global_id.x"));
    stmts.push(dsl::if_block(
        "idx >= arrayLength(&cell_vols)",
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_("center", "cell_centers[idx]"));
    stmts.push(dsl::let_("start", "cell_face_offsets[idx]"));
    stmts.push(dsl::let_("end", "cell_face_offsets[idx + 1u]"));
    stmts.push(dsl::let_("vol", "cell_vols[idx]"));
    stmts.push(dsl::let_("scalar_offset", "scalar_row_offsets[idx]"));
    stmts.push(dsl::let_(
        "num_neighbors",
        "scalar_row_offsets[idx + 1u] - scalar_offset",
    ));
    stmts.push(dsl::let_(
        "start_row_0",
        &format!("{block_stride}u * scalar_offset"),
    ));
    stmts.push(dsl::let_(
        "start_row_1",
        &format!("start_row_0 + {}u * num_neighbors", block_size),
    ));
    stmts.push(dsl::let_(
        "start_row_2",
        &format!("start_row_0 + {}u * num_neighbors", block_size * 2),
    ));
    stmts.push(dsl::let_(
        "start_row_3",
        &format!("start_row_0 + {}u * num_neighbors", block_size * 3),
    ));
    stmts.push(dsl::let_("scheme_id", "constants.scheme"));

    stmts.push(dsl::comment("Jacobian rows/cols: rho, rho_u_x, rho_u_y, rho_e"));
    stmts.extend(dsl::var_matrix("diag", block_size as usize, "0.0"));

    stmts.push(dsl::var("sum_rho", "0.0"));
    stmts.push(dsl::var("sum_rho_u_x", "0.0"));
    stmts.push(dsl::var("sum_rho_u_y", "0.0"));
    stmts.push(dsl::var("sum_rho_e", "0.0"));

    let rho_expr = state_scalar_expr(layout, "state", "idx", rho_field);
    let rho_u_expr = state_vec2_expr(layout, "state", "idx", rho_u_field);
    let rho_e_expr = state_scalar_expr(layout, "state", "idx", rho_e_field);
    let rho_old_expr = state_scalar_expr(layout, "state_old", "idx", rho_field);
    let rho_u_old_expr = state_vec2_expr(layout, "state_old", "idx", rho_u_field);
    let rho_e_old_expr = state_scalar_expr(layout, "state_old", "idx", rho_e_field);
    let rho_iter_expr = state_scalar_expr(layout, "state_iter", "idx", rho_field);
    let rho_u_iter_expr = state_vec2_expr(layout, "state_iter", "idx", rho_u_field);
    let rho_e_iter_expr = state_scalar_expr(layout, "state_iter", "idx", rho_e_field);
    stmts.push(dsl::let_("rho", &rho_expr));
    stmts.push(dsl::let_("rho_u", &rho_u_expr));
    stmts.push(dsl::let_("rho_e", &rho_e_expr));
    stmts.push(dsl::let_("rho_old", &rho_old_expr));
    stmts.push(dsl::let_("rho_u_old", &rho_u_old_expr));
    stmts.push(dsl::let_("rho_e_old", &rho_e_old_expr));

    stmts.push(dsl::var("coeff_time", "vol / constants.dt"));
    stmts.push(dsl::var("rhs_time_rho", "coeff_time * rho_old"));
    stmts.push(dsl::var("rhs_time_rho_u_x", "coeff_time * rho_u_old.x"));
    stmts.push(dsl::var("rhs_time_rho_u_y", "coeff_time * rho_u_old.y"));
    stmts.push(dsl::var("rhs_time_rho_e", "coeff_time * rho_e_old"));
    stmts.push(dsl::var("coeff_pseudo", "0.0"));
    stmts.push(dsl::var("rhs_pseudo_rho", "0.0"));
    stmts.push(dsl::var("rhs_pseudo_rho_u_x", "0.0"));
    stmts.push(dsl::var("rhs_pseudo_rho_u_y", "0.0"));
    stmts.push(dsl::var("rhs_pseudo_rho_e", "0.0"));

    let pseudo_block = dsl::block(vec![
        dsl::let_("rho_iter", &rho_iter_expr),
        dsl::let_("rho_u_iter", &rho_u_iter_expr),
        dsl::let_("rho_e_iter", &rho_e_iter_expr),
        dsl::assign("coeff_pseudo", "vol / constants.dtau"),
        dsl::assign("rhs_pseudo_rho", "coeff_pseudo * rho_iter"),
        dsl::assign("rhs_pseudo_rho_u_x", "coeff_pseudo * rho_u_iter.x"),
        dsl::assign("rhs_pseudo_rho_u_y", "coeff_pseudo * rho_u_iter.y"),
        dsl::assign("rhs_pseudo_rho_e", "coeff_pseudo * rho_e_iter"),
    ]);
    stmts.push(dsl::if_block(
        "constants.dtau > 0.0",
        pseudo_block,
        None,
    ));

    let rho_old_old_expr = state_scalar_expr(layout, "state_old_old", "idx", rho_field);
    let rho_u_old_old_expr = state_vec2_expr(layout, "state_old_old", "idx", rho_u_field);
    let rho_e_old_old_expr = state_scalar_expr(layout, "state_old_old", "idx", rho_e_field);
    let bdf2_block = dsl::block(vec![
        dsl::let_("dt", "constants.dt"),
        dsl::let_("dt_old", "constants.dt_old"),
        dsl::let_("r", "dt / dt_old"),
        dsl::let_("rho_old_old", &rho_old_old_expr),
        dsl::let_("rho_u_old_old", &rho_u_old_old_expr),
        dsl::let_("rho_e_old_old", &rho_e_old_old_expr),
        dsl::assign(
            "coeff_time",
            "vol / dt * (1.0 + 2.0 * r) / (1.0 + r)",
        ),
        dsl::let_("factor_n", "(1.0 + r)"),
        dsl::let_("factor_nm1", "(r * r) / (1.0 + r)"),
        dsl::assign(
            "rhs_time_rho",
            "(vol / dt) * (factor_n * rho_old - factor_nm1 * rho_old_old)",
        ),
        dsl::assign(
            "rhs_time_rho_u_x",
            "(vol / dt) * (factor_n * rho_u_old.x - factor_nm1 * rho_u_old_old.x)",
        ),
        dsl::assign(
            "rhs_time_rho_u_y",
            "(vol / dt) * (factor_n * rho_u_old.y - factor_nm1 * rho_u_old_old.y)",
        ),
        dsl::assign(
            "rhs_time_rho_e",
            "(vol / dt) * (factor_n * rho_e_old - factor_nm1 * rho_e_old_old)",
        ),
    ]);

    stmts.push(dsl::if_block(
        "constants.time_scheme == 1u",
        bdf2_block,
        None,
    ));

    let rho_r_expr = state_scalar_expr(layout, "state", "other_idx", rho_field);
    let rho_u_r_expr = state_vec2_expr(layout, "state", "other_idx", rho_u_field);
    let rho_e_r_expr = state_scalar_expr(layout, "state", "other_idx", rho_e_field);

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_("face_idx", "cell_faces[face_offset]"));
    loop_body.push(dsl::let_("owner", "face_owner[face_idx]"));
    loop_body.push(dsl::let_("neighbor", "face_neighbor[face_idx]"));
    loop_body.push(dsl::let_("boundary_type", "face_boundary[face_idx]"));
    loop_body.push(dsl::let_("area", "face_areas[face_idx]"));
    loop_body.push(dsl::var("normal", "face_normals[face_idx]"));
    loop_body.push(dsl::let_("f_center", "face_centers[face_idx]"));
    loop_body.push(dsl::var("is_boundary", "false"));
    loop_body.push(dsl::var("other_idx", "0u"));
    loop_body.push(dsl::var_typed(
        "center_r",
        Type::Custom("Vector2".to_string()),
        None,
    ));

    loop_body.push(dsl::if_block(
        "owner != idx",
        dsl::block(vec![
            dsl::assign("normal.x", "-normal.x"),
            dsl::assign("normal.y", "-normal.y"),
        ]),
        None,
    ));

    let interior_block = dsl::block(vec![
        dsl::let_("neigh_idx", "u32(neighbor)"),
        dsl::assign("other_idx", "neigh_idx"),
        dsl::if_block(
            "owner != idx",
            dsl::block(vec![dsl::assign("other_idx", "owner")]),
            None,
        ),
        dsl::assign("center_r", "cell_centers[other_idx]"),
        dsl::let_("rho_neigh", &rho_r_expr),
        dsl::let_("rho_u_neigh", &rho_u_r_expr),
        dsl::let_("rho_e_neigh", &rho_e_r_expr),
        dsl::assign("rho_r", "rho_neigh"),
        dsl::assign("rho_u_r.x", "rho_u_neigh.x"),
        dsl::assign("rho_u_r.y", "rho_u_neigh.y"),
        dsl::assign("rho_e_r", "rho_e_neigh"),
    ]);

    let boundary_block = dsl::block(vec![
        dsl::assign("is_boundary", "true"),
        dsl::assign("other_idx", "idx"),
        dsl::assign("center_r", "f_center"),
    ]);

    let rho_l_expr = state_scalar_expr(layout, "state", "idx", rho_field);
    let rho_u_l_expr = state_vec2_expr(layout, "state", "idx", rho_u_field);
    let rho_e_l_expr = state_scalar_expr(layout, "state", "idx", rho_e_field);
    loop_body.push(dsl::let_("rho_l_cell", &rho_l_expr));
    loop_body.push(dsl::let_("rho_u_l_cell", &rho_u_l_expr));
    loop_body.push(dsl::let_("rho_e_l_cell", &rho_e_l_expr));
    loop_body.push(dsl::var("rho_l", "rho_l_cell"));
    loop_body.push(dsl::var("rho_u_l", "rho_u_l_cell"));
    loop_body.push(dsl::var("rho_e_l", "rho_e_l_cell"));
    loop_body.push(dsl::var("rho_r", "rho_l"));
    loop_body.push(dsl::var("rho_u_r", "rho_u_l"));
    loop_body.push(dsl::var("rho_e_r", "rho_e_l"));

    loop_body.push(dsl::if_block(
        "neighbor != -1",
        interior_block,
        Some(boundary_block),
    ));

    let boundary_state = dsl::block(vec![dsl::if_block(
        "boundary_type == 1u",
        dsl::block(vec![
            dsl::assign("rho_u_r.x", "rho_r * constants.inlet_velocity"),
            dsl::assign("rho_u_r.y", "0.0"),
        ]),
        Some(dsl::block(vec![dsl::if_block(
            "boundary_type == 3u",
            dsl::block(vec![
                // Slip wall: reflect only the normal component of momentum.
                dsl::let_("m_dot_n", "rho_u_l.x * normal.x + rho_u_l.y * normal.y"),
                dsl::assign("rho_u_r.x", "rho_u_l.x - 2.0 * m_dot_n * normal.x"),
                dsl::assign("rho_u_r.y", "rho_u_l.y - 2.0 * m_dot_n * normal.y"),
            ]),
            None,
        )])),
    )]);

    loop_body.push(dsl::if_block("is_boundary", boundary_state, None));

    loop_body.push(dsl::let_("rho_r_cell", "rho_r"));
    loop_body.push(dsl::let_("rho_u_r_cell", "rho_u_r"));
    loop_body.push(dsl::let_("rho_e_r_cell", "rho_e_r"));

    let reconstruct_block = {
        let mut block = Vec::new();
        block.push(dsl::let_expr(
            "r_l_x",
            Expr::binary(
                Expr::ident("f_center").field("x"),
                BinaryOp::Sub,
                Expr::ident("center").field("x"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_l_y",
            Expr::binary(
                Expr::ident("f_center").field("y"),
                BinaryOp::Sub,
                Expr::ident("center").field("y"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_r_x",
            Expr::binary(
                Expr::ident("f_center").field("x"),
                BinaryOp::Sub,
                Expr::ident("center_r").field("x"),
            ),
        ));
        block.push(dsl::let_expr(
            "r_r_y",
            Expr::binary(
                Expr::ident("f_center").field("y"),
                BinaryOp::Sub,
                Expr::ident("center_r").field("y"),
            ),
        ));

        // Reconstruct conservative variables directly for robustness.
        block.push(dsl::let_expr(
            "grad_rho_l",
            Expr::ident("grad_rho").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_l",
            Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_l",
            Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_l",
            Expr::ident("grad_rho_e").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_r",
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_r",
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_r",
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_r",
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        ));

        let (rho_l_stmts, rho_l_face) = limited_linear_reconstruct_face(
            "rho",
            "l",
            Expr::ident("rho_l_cell"),
            Expr::ident("rho_r_cell"),
            Expr::ident("grad_rho_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_l_stmts);
        let (rho_u_x_l_stmts, rho_u_x_l_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "l",
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("grad_rho_u_x_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_x_l_stmts);
        let (rho_u_y_l_stmts, rho_u_y_l_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "l",
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("grad_rho_u_y_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_y_l_stmts);
        let (rho_e_l_stmts, rho_e_l_face) = limited_linear_reconstruct_face(
            "rho_e",
            "l",
            Expr::ident("rho_e_l_cell"),
            Expr::ident("rho_e_r_cell"),
            Expr::ident("grad_rho_e_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_e_l_stmts);

        let (rho_r_stmts, rho_r_face) = limited_linear_reconstruct_face(
            "rho",
            "r",
            Expr::ident("rho_r_cell"),
            Expr::ident("rho_l_cell"),
            Expr::ident("grad_rho_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_r_stmts);
        let (rho_u_x_r_stmts, rho_u_x_r_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "r",
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("grad_rho_u_x_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_x_r_stmts);
        let (rho_u_y_r_stmts, rho_u_y_r_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "r",
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("grad_rho_u_y_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_y_r_stmts);
        let (rho_e_r_stmts, rho_e_r_face) = limited_linear_reconstruct_face(
            "rho_e",
            "r",
            Expr::ident("rho_e_r_cell"),
            Expr::ident("rho_e_l_cell"),
            Expr::ident("grad_rho_e_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_e_r_stmts);

        block.push(dsl::assign_expr(Expr::ident("rho_l"), rho_l_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_l"),
            dsl::vec2_f32(rho_u_x_l_face, rho_u_y_l_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_l"), rho_e_l_face));
        block.push(dsl::assign_expr(Expr::ident("rho_r"), rho_r_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_r"),
            dsl::vec2_f32(rho_u_x_r_face, rho_u_y_r_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_r"), rho_e_r_face));

        dsl::block(block)
    };

    // For compressible KT fluxes, keep reconstruction conservative and stable:
    // - `scheme=0` and `scheme=2` default to piecewise-constant states.
    // - `scheme=1` enables limited linear reconstruction.
    loop_body.push(dsl::if_block(
        "!is_boundary && scheme_id == 1u",
        reconstruct_block,
        None,
    ));

    loop_body.push(dsl::let_("inv_rho_l", "1.0 / max(rho_l, 1e-8)"));
    loop_body.push(dsl::let_("u_l_x", "rho_u_l.x * inv_rho_l"));
    loop_body.push(dsl::let_("u_l_y", "rho_u_l.y * inv_rho_l"));
    loop_body.push(dsl::let_("ke_l", "0.5 * rho_l * (u_l_x * u_l_x + u_l_y * u_l_y)"));
    loop_body.push(dsl::let_(
        "p_l",
        &format!("max(0.0, ({gamma} - 1.0) * (rho_e_l - ke_l))"),
    ));
    loop_body.push(dsl::let_("u_n_l", "u_l_x * normal.x + u_l_y * normal.y"));
    loop_body.push(dsl::let_("c_l", &format!("sqrt({gamma} * p_l * inv_rho_l)")));

    loop_body.push(dsl::let_("inv_rho_r", "1.0 / max(rho_r, 1e-8)"));
    loop_body.push(dsl::let_("u_r_x", "rho_u_r.x * inv_rho_r"));
    loop_body.push(dsl::let_("u_r_y", "rho_u_r.y * inv_rho_r"));
    loop_body.push(dsl::let_("ke_r", "0.5 * rho_r * (u_r_x * u_r_x + u_r_y * u_r_y)"));
    loop_body.push(dsl::let_(
        "p_r",
        &format!("max(0.0, ({gamma} - 1.0) * (rho_e_r - ke_r))"),
    ));
    loop_body.push(dsl::let_("u_n_r", "u_r_x * normal.x + u_r_y * normal.y"));
    loop_body.push(dsl::let_("c_r", &format!("sqrt({gamma} * p_r * inv_rho_r)")));
    loop_body.push(dsl::let_("u_face_x", "0.5 * (u_l_x + u_r_x)"));
    loop_body.push(dsl::let_("u_face_y", "0.5 * (u_l_y + u_r_y)"));
    loop_body.push(dsl::let_("u_face_n", "u_face_x * normal.x + u_face_y * normal.y"));
    loop_body.push(dsl::let_("c_bar", "0.5 * (c_l + c_r)"));
    loop_body.push(dsl::let_("mach", "abs(u_face_n) / max(c_bar, 1e-6)"));
    loop_body.push(dsl::let_("mach2", "mach * mach"));
    // Low-Mach preconditioning (optional). Default is `precond_model=2` (off) for
    // rhoCentralFoam-like transient behavior (e.g., acoustics).
    loop_body.push(dsl::var("c_l_eff", "c_l"));
    loop_body.push(dsl::var("c_r_eff", "c_r"));

    let precond_legacy_block = dsl::block(vec![
        dsl::assign("c_l_eff", "c_l * mach"),
        dsl::assign("c_r_eff", "c_r * mach"),
    ]);
    let precond_weiss_smith_block = dsl::block(vec![
        dsl::let_(
            "theta",
            "min(1.0, max(mach2, constants.precond_theta_floor))",
        ),
        dsl::let_("one_minus_theta", "1.0 - theta"),
        dsl::assign(
            "c_l_eff",
            "sqrt(theta * c_l * c_l + one_minus_theta * u_n_l * u_n_l)",
        ),
        dsl::assign(
            "c_r_eff",
            "sqrt(theta * c_r * c_r + one_minus_theta * u_n_r * u_n_r)",
        ),
    ]);
    let precond_else_block = dsl::block(vec![dsl::if_block(
        "constants.precond_model == 1u",
        precond_weiss_smith_block,
        None,
    )]);
    loop_body.push(dsl::if_block(
        "constants.precond_model == 0u",
        precond_legacy_block,
        Some(precond_else_block),
    ));
    loop_body.push(dsl::let_("flux_adv", "u_face_n * area"));
    loop_body.push(dsl::let_("dx", "center_r.x - center.x"));
    loop_body.push(dsl::let_("dy", "center_r.y - center.y"));
    loop_body.push(dsl::let_("dist", "max(sqrt(dx * dx + dy * dy), 1e-6)"));
    loop_body.push(dsl::let_("mu", "constants.viscosity"));

    loop_body.push(dsl::let_(
        "a_plus",
        "max(0.0, max(u_n_l + c_l_eff, u_n_r + c_r_eff))",
    ));
    loop_body.push(dsl::let_(
        "a_minus",
        "min(0.0, min(u_n_l - c_l_eff, u_n_r - c_r_eff))",
    ));
    loop_body.push(dsl::let_("denom", "max(a_plus - a_minus, 1e-6)"));
    loop_body.push(dsl::let_("a_prod", "a_plus * a_minus"));
    loop_body.push(dsl::let_("a_pos", "a_plus / denom"));
    loop_body.push(dsl::let_("a_neg", "1.0 - a_pos"));
    loop_body.push(dsl::let_("a_prod_scaled", "a_prod / denom"));

    loop_body.push(dsl::let_("flux_rho_l", "rho_l * u_n_l"));
    loop_body.push(dsl::let_("flux_rho_r", "rho_r * u_n_r"));
    loop_body.push(dsl::var(
        "flux_rho",
        "a_pos * flux_rho_l + a_neg * flux_rho_r + a_prod_scaled * (rho_r - rho_l)",
    ));
    loop_body.push(dsl::let_(
        "flux_rho_u_x_l",
        "rho_u_l.x * u_n_l + p_l * normal.x",
    ));
    loop_body.push(dsl::let_(
        "flux_rho_u_x_r",
        "rho_u_r.x * u_n_r + p_r * normal.x",
    ));
    loop_body.push(dsl::var(
        "flux_rho_u_x",
        "a_pos * flux_rho_u_x_l + a_neg * flux_rho_u_x_r + a_prod_scaled * (rho_u_r.x - rho_u_l.x)",
    ));
    loop_body.push(dsl::let_(
        "flux_rho_u_y_l",
        "rho_u_l.y * u_n_l + p_l * normal.y",
    ));
    loop_body.push(dsl::let_(
        "flux_rho_u_y_r",
        "rho_u_r.y * u_n_r + p_r * normal.y",
    ));
    loop_body.push(dsl::var(
        "flux_rho_u_y",
        "a_pos * flux_rho_u_y_l + a_neg * flux_rho_u_y_r + a_prod_scaled * (rho_u_r.y - rho_u_l.y)",
    ));
    loop_body.push(dsl::let_(
        "diff_u_x",
        "-mu * (u_r_x - u_l_x) / dist",
    ));
    loop_body.push(dsl::let_(
        "diff_u_y",
        "-mu * (u_r_y - u_l_y) / dist",
    ));
    loop_body.push(dsl::assign(
        "flux_rho_u_x",
        "flux_rho_u_x + diff_u_x",
    ));
    loop_body.push(dsl::assign(
        "flux_rho_u_y",
        "flux_rho_u_y + diff_u_y",
    ));

    loop_body.push(dsl::let_(
        "flux_rho_e_l",
        "(rho_e_l + p_l) * u_n_l",
    ));
    loop_body.push(dsl::let_(
        "flux_rho_e_r",
        "(rho_e_r + p_r) * u_n_r",
    ));
    loop_body.push(dsl::var(
        "flux_rho_e",
        "a_pos * flux_rho_e_l + a_neg * flux_rho_e_r + a_prod_scaled * (rho_e_r - rho_e_l)",
    ));

    // Rhieâ€“Chow-style pressure flux coupling is only used with low-Mach preconditioning.
    // (In the pure KT mode it can introduce dispersive/odd-even pressure ringing.)
    let pressure_coupling_block = dsl::block(vec![
        dsl::let_("inv_rho_l_cell", "1.0 / max(rho_l_cell, 1e-8)"),
        dsl::let_("inv_rho_r_cell", "1.0 / max(rho_r_cell, 1e-8)"),
        dsl::let_("u_l_x_cell", "rho_u_l_cell.x * inv_rho_l_cell"),
        dsl::let_("u_l_y_cell", "rho_u_l_cell.y * inv_rho_l_cell"),
        dsl::let_("u_r_x_cell", "rho_u_r_cell.x * inv_rho_r_cell"),
        dsl::let_("u_r_y_cell", "rho_u_r_cell.y * inv_rho_r_cell"),
        dsl::let_(
            "u2_l_cell",
            "u_l_x_cell * u_l_x_cell + u_l_y_cell * u_l_y_cell",
        ),
        dsl::let_(
            "u2_r_cell",
            "u_r_x_cell * u_r_x_cell + u_r_y_cell * u_r_y_cell",
        ),
        dsl::let_("grad_rho_l", "grad_rho[idx]"),
        dsl::let_("grad_rho_u_x_l", "grad_rho_u_x[idx]"),
        dsl::let_("grad_rho_u_y_l", "grad_rho_u_y[idx]"),
        dsl::let_("grad_rho_e_l", "grad_rho_e[idx]"),
        dsl::let_("grad_rho_r", "grad_rho[other_idx]"),
        dsl::let_("grad_rho_u_x_r", "grad_rho_u_x[other_idx]"),
        dsl::let_("grad_rho_u_y_r", "grad_rho_u_y[other_idx]"),
        dsl::let_("grad_rho_e_r", "grad_rho_e[other_idx]"),
        dsl::let_(
            "grad_u_x_l_x",
            "(grad_rho_u_x_l.x - u_l_x_cell * grad_rho_l.x) * inv_rho_l_cell",
        ),
        dsl::let_(
            "grad_u_x_l_y",
            "(grad_rho_u_x_l.y - u_l_x_cell * grad_rho_l.y) * inv_rho_l_cell",
        ),
        dsl::let_(
            "grad_u_y_l_x",
            "(grad_rho_u_y_l.x - u_l_y_cell * grad_rho_l.x) * inv_rho_l_cell",
        ),
        dsl::let_(
            "grad_u_y_l_y",
            "(grad_rho_u_y_l.y - u_l_y_cell * grad_rho_l.y) * inv_rho_l_cell",
        ),
        dsl::let_(
            "grad_u_x_r_x",
            "(grad_rho_u_x_r.x - u_r_x_cell * grad_rho_r.x) * inv_rho_r_cell",
        ),
        dsl::let_(
            "grad_u_x_r_y",
            "(grad_rho_u_x_r.y - u_r_x_cell * grad_rho_r.y) * inv_rho_r_cell",
        ),
        dsl::let_(
            "grad_u_y_r_x",
            "(grad_rho_u_y_r.x - u_r_y_cell * grad_rho_r.x) * inv_rho_r_cell",
        ),
        dsl::let_(
            "grad_u_y_r_y",
            "(grad_rho_u_y_r.y - u_r_y_cell * grad_rho_r.y) * inv_rho_r_cell",
        ),
        dsl::let_(
            "grad_u2_l_x",
            "2.0 * u_l_x_cell * grad_u_x_l_x + 2.0 * u_l_y_cell * grad_u_y_l_x",
        ),
        dsl::let_(
            "grad_u2_l_y",
            "2.0 * u_l_x_cell * grad_u_x_l_y + 2.0 * u_l_y_cell * grad_u_y_l_y",
        ),
        dsl::let_(
            "grad_u2_r_x",
            "2.0 * u_r_x_cell * grad_u_x_r_x + 2.0 * u_r_y_cell * grad_u_y_r_x",
        ),
        dsl::let_(
            "grad_u2_r_y",
            "2.0 * u_r_x_cell * grad_u_x_r_y + 2.0 * u_r_y_cell * grad_u_y_r_y",
        ),
        dsl::let_(
            "grad_rho_u2_l_x",
            "u2_l_cell * grad_rho_l.x + rho_l_cell * grad_u2_l_x",
        ),
        dsl::let_(
            "grad_rho_u2_l_y",
            "u2_l_cell * grad_rho_l.y + rho_l_cell * grad_u2_l_y",
        ),
        dsl::let_(
            "grad_rho_u2_r_x",
            "u2_r_cell * grad_rho_r.x + rho_r_cell * grad_u2_r_x",
        ),
        dsl::let_(
            "grad_rho_u2_r_y",
            "u2_r_cell * grad_rho_r.y + rho_r_cell * grad_u2_r_y",
        ),
        dsl::let_(
            "grad_p_l_x",
            &format!("({gamma} - 1.0) * (grad_rho_e_l.x - 0.5 * grad_rho_u2_l_x)"),
        ),
        dsl::let_(
            "grad_p_l_y",
            &format!("({gamma} - 1.0) * (grad_rho_e_l.y - 0.5 * grad_rho_u2_l_y)"),
        ),
        dsl::let_(
            "grad_p_r_x",
            &format!("({gamma} - 1.0) * (grad_rho_e_r.x - 0.5 * grad_rho_u2_r_x)"),
        ),
        dsl::let_(
            "grad_p_r_y",
            &format!("({gamma} - 1.0) * (grad_rho_e_r.y - 0.5 * grad_rho_u2_r_y)"),
        ),
        dsl::let_(
            "grad_p_l_n",
            "grad_p_l_x * normal.x + grad_p_l_y * normal.y",
        ),
        dsl::let_(
            "grad_p_r_n",
            "grad_p_r_x * normal.x + grad_p_r_y * normal.y",
        ),
        dsl::let_("grad_p_face_n", "0.5 * (grad_p_l_n + grad_p_r_n)"),
        dsl::let_("grad_p_jump_n", "(p_r - p_l) / dist"),
        dsl::let_("rho_face", "0.5 * (rho_l + rho_r)"),
        dsl::let_("p_bar", "0.5 * (p_l + p_r)"),
        dsl::let_("dp_rel", "abs(p_r - p_l) / max(p_bar, 1e-6)"),
        dsl::let_(
            "pc_theta",
            "min(1.0, max(mach2, constants.precond_theta_floor))",
        ),
        dsl::let_("pc_low_mach", "1.0 - pc_theta"),
        dsl::let_(
            "pc_smooth",
            "1.0 / (1.0 + (dp_rel / 0.2) * (dp_rel / 0.2))",
        ),
        dsl::let_(
            "pc_alpha",
            "constants.pressure_coupling_alpha * pc_low_mach * pc_smooth",
        ),
        dsl::let_(
            "m_corr",
            "pc_alpha * constants.dt / max(rho_face, 1e-8) * (grad_p_face_n - grad_p_jump_n)",
        ),
        dsl::let_("h_l", "(rho_e_l + p_l) * inv_rho_l"),
        dsl::let_("h_r", "(rho_e_r + p_r) * inv_rho_r"),
        dsl::let_("h_face", "0.5 * (h_l + h_r)"),
        dsl::assign_op(AssignOp::Add, "flux_rho", "m_corr"),
        dsl::assign_op(AssignOp::Add, "flux_rho_u_x", "m_corr * u_face_x"),
        dsl::assign_op(AssignOp::Add, "flux_rho_u_y", "m_corr * u_face_y"),
        dsl::assign_op(AssignOp::Add, "flux_rho_e", "m_corr * h_face"),
    ]);
    loop_body.push(dsl::if_block(
        "!is_boundary && constants.precond_model != 2u && constants.pressure_coupling_alpha > 0.0",
        pressure_coupling_block,
        None,
    ));
    loop_body.push(dsl::assign(
        "flux_rho_e",
        "flux_rho_e + diff_u_x * u_face_x + diff_u_y * u_face_y",
    ));

    loop_body.push(dsl::assign_op(
        AssignOp::Add,
        "sum_rho",
        "flux_rho * area",
    ));
    loop_body.push(dsl::assign_op(
        AssignOp::Add,
        "sum_rho_u_x",
        "flux_rho_u_x * area",
    ));
    loop_body.push(dsl::assign_op(
        AssignOp::Add,
        "sum_rho_u_y",
        "flux_rho_u_y * area",
    ));
    loop_body.push(dsl::assign_op(
        AssignOp::Add,
        "sum_rho_e",
        "flux_rho_e * area",
    ));

    loop_body.push(dsl::let_("q_l", "u_l_x * u_l_x + u_l_y * u_l_y"));
    loop_body.push(dsl::let_(
        "dp_drho_l",
        &format!("0.5 * ({gamma} - 1.0) * q_l"),
    ));
    loop_body.push(dsl::let_(
        "dp_dru_l",
        &format!("-({gamma} - 1.0) * u_l_x"),
    ));
    loop_body.push(dsl::let_(
        "dp_drv_l",
        &format!("-({gamma} - 1.0) * u_l_y"),
    ));
    loop_body.push(dsl::let_("dp_dre_l", &format!("{gamma} - 1.0")));
    loop_body.push(dsl::let_("H_l", "(rho_e_l + p_l) * inv_rho_l"));

    loop_body.push(dsl::let_("q_r", "u_r_x * u_r_x + u_r_y * u_r_y"));
    loop_body.push(dsl::let_(
        "dp_drho_r",
        &format!("0.5 * ({gamma} - 1.0) * q_r"),
    ));
    loop_body.push(dsl::let_(
        "dp_dru_r",
        &format!("-({gamma} - 1.0) * u_r_x"),
    ));
    loop_body.push(dsl::let_(
        "dp_drv_r",
        &format!("-({gamma} - 1.0) * u_r_y"),
    ));
    loop_body.push(dsl::let_("dp_dre_r", &format!("{gamma} - 1.0")));
    loop_body.push(dsl::let_("H_r", "(rho_e_r + p_r) * inv_rho_r"));

    loop_body.push(dsl::let_("a_l", "a_plus / denom"));
    loop_body.push(dsl::let_("a_r", "-a_minus / denom"));

    loop_body.push(dsl::let_("A_l_10", "-u_l_x * u_n_l + dp_drho_l * normal.x"));
    loop_body.push(dsl::let_(
        "A_l_11",
        "u_n_l + u_l_x * normal.x + dp_dru_l * normal.x",
    ));
    loop_body.push(dsl::let_("A_l_12", "u_l_x * normal.y + dp_drv_l * normal.x"));
    loop_body.push(dsl::let_("A_l_13", "dp_dre_l * normal.x"));
    loop_body.push(dsl::let_("A_l_20", "-u_l_y * u_n_l + dp_drho_l * normal.y"));
    loop_body.push(dsl::let_(
        "A_l_21",
        "u_l_y * normal.x + dp_dru_l * normal.y",
    ));
    loop_body.push(dsl::let_(
        "A_l_22",
        "u_n_l + u_l_y * normal.y + dp_drv_l * normal.y",
    ));
    loop_body.push(dsl::let_("A_l_23", "dp_dre_l * normal.y"));
    loop_body.push(dsl::let_("A_l_30", "-H_l * u_n_l + dp_drho_l * u_n_l"));
    loop_body.push(dsl::let_("A_l_31", "H_l * normal.x + dp_dru_l * u_n_l"));
    loop_body.push(dsl::let_("A_l_32", "H_l * normal.y + dp_drv_l * u_n_l"));
    loop_body.push(dsl::let_("A_l_33", &format!("{gamma} * u_n_l")));

    loop_body.push(dsl::let_("A_r_10", "-u_r_x * u_n_r + dp_drho_r * normal.x"));
    loop_body.push(dsl::let_(
        "A_r_11",
        "u_n_r + u_r_x * normal.x + dp_dru_r * normal.x",
    ));
    loop_body.push(dsl::let_("A_r_12", "u_r_x * normal.y + dp_drv_r * normal.x"));
    loop_body.push(dsl::let_("A_r_13", "dp_dre_r * normal.x"));
    loop_body.push(dsl::let_("A_r_20", "-u_r_y * u_n_r + dp_drho_r * normal.y"));
    loop_body.push(dsl::let_(
        "A_r_21",
        "u_r_y * normal.x + dp_dru_r * normal.y",
    ));
    loop_body.push(dsl::let_(
        "A_r_22",
        "u_n_r + u_r_y * normal.y + dp_drv_r * normal.y",
    ));
    loop_body.push(dsl::let_("A_r_23", "dp_dre_r * normal.y"));
    loop_body.push(dsl::let_("A_r_30", "-H_r * u_n_r + dp_drho_r * u_n_r"));
    loop_body.push(dsl::let_("A_r_31", "H_r * normal.x + dp_dru_r * u_n_r"));
    loop_body.push(dsl::let_("A_r_32", "H_r * normal.y + dp_drv_r * u_n_r"));
    loop_body.push(dsl::let_("A_r_33", &format!("{gamma} * u_n_r")));

    loop_body.push(dsl::let_("mu_over_dist", "mu / dist"));
    loop_body.push(dsl::let_("du_lx_drho", "-u_l_x * inv_rho_l"));
    loop_body.push(dsl::let_("du_lx_dru", "inv_rho_l"));
    loop_body.push(dsl::let_("du_lx_drv", "0.0"));
    loop_body.push(dsl::let_("du_ly_drho", "-u_l_y * inv_rho_l"));
    loop_body.push(dsl::let_("du_ly_dru", "0.0"));
    loop_body.push(dsl::let_("du_ly_drv", "inv_rho_l"));

    loop_body.push(dsl::let_("du_rx_drho", "-u_r_x * inv_rho_r"));
    loop_body.push(dsl::let_("du_rx_dru", "inv_rho_r"));
    loop_body.push(dsl::let_("du_rx_drv", "0.0"));
    loop_body.push(dsl::let_("du_ry_drho", "-u_r_y * inv_rho_r"));
    loop_body.push(dsl::let_("du_ry_dru", "0.0"));
    loop_body.push(dsl::let_("du_ry_drv", "inv_rho_r"));

    loop_body.push(dsl::let_("d_diff_x_l_rho", "mu_over_dist * du_lx_drho"));
    loop_body.push(dsl::let_("d_diff_x_l_ru", "mu_over_dist * du_lx_dru"));
    loop_body.push(dsl::let_("d_diff_x_l_rv", "0.0"));
    loop_body.push(dsl::let_("d_diff_x_l_re", "0.0"));
    loop_body.push(dsl::let_("d_diff_y_l_rho", "mu_over_dist * du_ly_drho"));
    loop_body.push(dsl::let_("d_diff_y_l_ru", "0.0"));
    loop_body.push(dsl::let_("d_diff_y_l_rv", "mu_over_dist * du_ly_drv"));
    loop_body.push(dsl::let_("d_diff_y_l_re", "0.0"));

    loop_body.push(dsl::let_("d_diff_x_r_rho", "-mu_over_dist * du_rx_drho"));
    loop_body.push(dsl::let_("d_diff_x_r_ru", "-mu_over_dist * du_rx_dru"));
    loop_body.push(dsl::let_("d_diff_x_r_rv", "0.0"));
    loop_body.push(dsl::let_("d_diff_x_r_re", "0.0"));
    loop_body.push(dsl::let_("d_diff_y_r_rho", "-mu_over_dist * du_ry_drho"));
    loop_body.push(dsl::let_("d_diff_y_r_ru", "0.0"));
    loop_body.push(dsl::let_("d_diff_y_r_rv", "-mu_over_dist * du_ry_drv"));
    loop_body.push(dsl::let_("d_diff_y_r_re", "0.0"));

    loop_body.push(dsl::let_("du_face_x_l_rho", "0.5 * du_lx_drho"));
    loop_body.push(dsl::let_("du_face_x_l_ru", "0.5 * du_lx_dru"));
    loop_body.push(dsl::let_("du_face_x_l_rv", "0.0"));
    loop_body.push(dsl::let_("du_face_x_l_re", "0.0"));
    loop_body.push(dsl::let_("du_face_y_l_rho", "0.5 * du_ly_drho"));
    loop_body.push(dsl::let_("du_face_y_l_ru", "0.0"));
    loop_body.push(dsl::let_("du_face_y_l_rv", "0.5 * du_ly_drv"));
    loop_body.push(dsl::let_("du_face_y_l_re", "0.0"));

    loop_body.push(dsl::let_("du_face_x_r_rho", "0.5 * du_rx_drho"));
    loop_body.push(dsl::let_("du_face_x_r_ru", "0.5 * du_rx_dru"));
    loop_body.push(dsl::let_("du_face_x_r_rv", "0.0"));
    loop_body.push(dsl::let_("du_face_x_r_re", "0.0"));
    loop_body.push(dsl::let_("du_face_y_r_rho", "0.5 * du_ry_drho"));
    loop_body.push(dsl::let_("du_face_y_r_ru", "0.0"));
    loop_body.push(dsl::let_("du_face_y_r_rv", "0.5 * du_ry_drv"));
    loop_body.push(dsl::let_("du_face_y_r_re", "0.0"));

    loop_body.push(dsl::let_(
        "d_e_visc_l_rho",
        "d_diff_x_l_rho * u_face_x + diff_u_x * du_face_x_l_rho + d_diff_y_l_rho * u_face_y + diff_u_y * du_face_y_l_rho",
    ));
    loop_body.push(dsl::let_(
        "d_e_visc_l_ru",
        "d_diff_x_l_ru * u_face_x + diff_u_x * du_face_x_l_ru + d_diff_y_l_ru * u_face_y + diff_u_y * du_face_y_l_ru",
    ));
    loop_body.push(dsl::let_(
        "d_e_visc_l_rv",
        "d_diff_x_l_rv * u_face_x + diff_u_x * du_face_x_l_rv + d_diff_y_l_rv * u_face_y + diff_u_y * du_face_y_l_rv",
    ));
    loop_body.push(dsl::let_(
        "d_e_visc_l_re",
        "d_diff_x_l_re * u_face_x + diff_u_x * du_face_x_l_re + d_diff_y_l_re * u_face_y + diff_u_y * du_face_y_l_re",
    ));

    loop_body.push(dsl::let_(
        "d_e_visc_r_rho",
        "d_diff_x_r_rho * u_face_x + diff_u_x * du_face_x_r_rho + d_diff_y_r_rho * u_face_y + diff_u_y * du_face_y_r_rho",
    ));
    loop_body.push(dsl::let_(
        "d_e_visc_r_ru",
        "d_diff_x_r_ru * u_face_x + diff_u_x * du_face_x_r_ru + d_diff_y_r_ru * u_face_y + diff_u_y * du_face_y_r_ru",
    ));
    loop_body.push(dsl::let_(
        "d_e_visc_r_rv",
        "d_diff_x_r_rv * u_face_x + diff_u_x * du_face_x_r_rv + d_diff_y_r_rv * u_face_y + diff_u_y * du_face_y_r_rv",
    ));
    loop_body.push(dsl::let_(
        "d_e_visc_r_re",
        "d_diff_x_r_re * u_face_x + diff_u_x * du_face_x_r_re + d_diff_y_r_re * u_face_y + diff_u_y * du_face_y_r_re",
    ));

    let a_prod_scaled = Expr::ident("a_prod_scaled");
    let a_l = Expr::ident("a_l");
    let a_r = Expr::ident("a_r");
    let normal = Expr::ident("normal");
    let nx = normal.clone().field("x");
    let ny = normal.clone().field("y");
    let jac_l = typed::MatExpr::<4, 4>::from_fn(|row, col| match (row, col) {
        (0, 0) => Expr::binary(Expr::lit_f32(0.0), BinaryOp::Sub, a_prod_scaled.clone()),
        (0, 1) => Expr::binary(a_l.clone(), BinaryOp::Mul, nx.clone()),
        (0, 2) => Expr::binary(a_l.clone(), BinaryOp::Mul, ny.clone()),
        (0, 3) => Expr::lit_f32(0.0),
        (1, 0) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_10")),
            BinaryOp::Add,
            Expr::ident("d_diff_x_l_rho"),
        ),
        (1, 1) => Expr::binary(
            Expr::binary(
                Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_11")),
                BinaryOp::Sub,
                a_prod_scaled.clone(),
            ),
            BinaryOp::Add,
            Expr::ident("d_diff_x_l_ru"),
        ),
        (1, 2) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_12")),
            BinaryOp::Add,
            Expr::ident("d_diff_x_l_rv"),
        ),
        (1, 3) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_13")),
            BinaryOp::Add,
            Expr::ident("d_diff_x_l_re"),
        ),
        (2, 0) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_20")),
            BinaryOp::Add,
            Expr::ident("d_diff_y_l_rho"),
        ),
        (2, 1) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_21")),
            BinaryOp::Add,
            Expr::ident("d_diff_y_l_ru"),
        ),
        (2, 2) => Expr::binary(
            Expr::binary(
                Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_22")),
                BinaryOp::Sub,
                a_prod_scaled.clone(),
            ),
            BinaryOp::Add,
            Expr::ident("d_diff_y_l_rv"),
        ),
        (2, 3) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_23")),
            BinaryOp::Add,
            Expr::ident("d_diff_y_l_re"),
        ),
        (3, 0) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_30")),
            BinaryOp::Add,
            Expr::ident("d_e_visc_l_rho"),
        ),
        (3, 1) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_31")),
            BinaryOp::Add,
            Expr::ident("d_e_visc_l_ru"),
        ),
        (3, 2) => Expr::binary(
            Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_32")),
            BinaryOp::Add,
            Expr::ident("d_e_visc_l_rv"),
        ),
        (3, 3) => Expr::binary(
            Expr::binary(
                Expr::binary(a_l.clone(), BinaryOp::Mul, Expr::ident("A_l_33")),
                BinaryOp::Sub,
                a_prod_scaled.clone(),
            ),
            BinaryOp::Add,
            Expr::ident("d_e_visc_l_re"),
        ),
        _ => unreachable!("invalid jac_l entry ({row},{col})"),
    });
    let jac_r = typed::MatExpr::<4, 4>::from_fn(|row, col| match (row, col) {
        (0, 0) => a_prod_scaled.clone(),
        (0, 1) => Expr::binary(a_r.clone(), BinaryOp::Mul, nx.clone()),
        (0, 2) => Expr::binary(a_r.clone(), BinaryOp::Mul, ny.clone()),
        (0, 3) => Expr::lit_f32(0.0),
        (1, 0) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_10")),
            BinaryOp::Add,
            Expr::ident("d_diff_x_r_rho"),
        ),
        (1, 1) => Expr::binary(
            Expr::binary(
                Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_11")),
                BinaryOp::Add,
                a_prod_scaled.clone(),
            ),
            BinaryOp::Add,
            Expr::ident("d_diff_x_r_ru"),
        ),
        (1, 2) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_12")),
            BinaryOp::Add,
            Expr::ident("d_diff_x_r_rv"),
        ),
        (1, 3) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_13")),
            BinaryOp::Add,
            Expr::ident("d_diff_x_r_re"),
        ),
        (2, 0) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_20")),
            BinaryOp::Add,
            Expr::ident("d_diff_y_r_rho"),
        ),
        (2, 1) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_21")),
            BinaryOp::Add,
            Expr::ident("d_diff_y_r_ru"),
        ),
        (2, 2) => Expr::binary(
            Expr::binary(
                Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_22")),
                BinaryOp::Add,
                a_prod_scaled.clone(),
            ),
            BinaryOp::Add,
            Expr::ident("d_diff_y_r_rv"),
        ),
        (2, 3) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_23")),
            BinaryOp::Add,
            Expr::ident("d_diff_y_r_re"),
        ),
        (3, 0) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_30")),
            BinaryOp::Add,
            Expr::ident("d_e_visc_r_rho"),
        ),
        (3, 1) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_31")),
            BinaryOp::Add,
            Expr::ident("d_e_visc_r_ru"),
        ),
        (3, 2) => Expr::binary(
            Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_32")),
            BinaryOp::Add,
            Expr::ident("d_e_visc_r_rv"),
        ),
        (3, 3) => Expr::binary(
            Expr::binary(
                Expr::binary(a_r.clone(), BinaryOp::Mul, Expr::ident("A_r_33")),
                BinaryOp::Add,
                a_prod_scaled.clone(),
            ),
            BinaryOp::Add,
            Expr::ident("d_e_visc_r_re"),
        ),
        _ => unreachable!("invalid jac_r entry ({row},{col})"),
    });

    let mut interior_matrix_stmts = vec![
        dsl::let_("scalar_mat_idx", "cell_face_matrix_indices[face_offset]"),
        dsl::var("neighbor_rank", "0u"),
        dsl::if_block(
            "scalar_mat_idx != 4294967295u",
            dsl::block(vec![dsl::assign("neighbor_rank", "scalar_mat_idx - scalar_offset")]),
            Some(dsl::block(vec![dsl::assign(
                "neighbor_rank",
                "scalar_mat_idx - scalar_offset",
            )])),
        ),
    ];

    let neighbor_entry = block_matrix.row_entry(&Expr::ident("neighbor_rank"));
    interior_matrix_stmts.extend(jac_r.scatter_assign_to_block_entry_scaled(
        &neighbor_entry,
        Some(Expr::ident("area")),
    ));
    interior_matrix_stmts.extend(jac_l.assign_op_to_prefix_scaled(
        AssignOp::Add,
        "diag",
        Some(Expr::ident("area")),
    ));

    let interior_matrix = dsl::block(interior_matrix_stmts);

    let boundary_matrix = {
        let area = Expr::ident("area");
        let eff_default = jac_l.add(&jac_r);
        let default_block = dsl::block(eff_default.assign_op_to_prefix_scaled(
            AssignOp::Add,
            "diag",
            Some(area.clone()),
        ));

        let inlet_velocity = Expr::ident("constants").field("inlet_velocity");
        let eff_inlet = typed::MatExpr::<4, 4>::from_fn(|row, col| match col {
            0 => {
                let base = Expr::binary(jac_l.entry(row, 0), BinaryOp::Add, jac_r.entry(row, 0));
                let extra = Expr::binary(jac_r.entry(row, 1), BinaryOp::Mul, inlet_velocity.clone());
                Expr::binary(base, BinaryOp::Add, extra)
            }
            3 => Expr::binary(jac_l.entry(row, col), BinaryOp::Add, jac_r.entry(row, col)),
            _ => jac_l.entry(row, col),
        });
        let inlet_block = dsl::block(eff_inlet.assign_op_to_prefix_scaled(
            AssignOp::Add,
            "diag",
            Some(area.clone()),
        ));

        let wall_block = {
            let mut wall = Vec::new();
            // Wall BC couples the right state to the left state:
            //   m_r = m_l - 2 (m_l Â· n) n
            // This requires applying the momentum reflection matrix to the right-state Jacobian.
            let normal = Expr::ident("normal");
            let nx = normal.clone().field("x");
            let ny = normal.clone().field("y");
            let nx_sq = Expr::binary(nx.clone(), BinaryOp::Mul, nx.clone());
            let ny_sq = Expr::binary(ny.clone(), BinaryOp::Mul, ny.clone());
            wall.extend([
                dsl::let_expr(
                    "r11",
                    Expr::binary(
                        Expr::lit_f32(1.0),
                        BinaryOp::Sub,
                        Expr::binary(Expr::lit_f32(2.0), BinaryOp::Mul, nx_sq),
                    ),
                ),
                dsl::let_expr(
                    "r12",
                    Expr::binary(
                        Expr::lit_f32(-2.0),
                        BinaryOp::Mul,
                        Expr::binary(nx.clone(), BinaryOp::Mul, ny.clone()),
                    ),
                ),
                dsl::let_expr(
                    "r21",
                    Expr::binary(
                        Expr::lit_f32(-2.0),
                        BinaryOp::Mul,
                        Expr::binary(ny.clone(), BinaryOp::Mul, nx.clone()),
                    ),
                ),
                dsl::let_expr(
                    "r22",
                    Expr::binary(
                        Expr::lit_f32(1.0),
                        BinaryOp::Sub,
                        Expr::binary(Expr::lit_f32(2.0), BinaryOp::Mul, ny_sq),
                    ),
                ),
            ]);

            let eff_wall = typed::MatExpr::<4, 4>::from_fn(|row, col| match col {
                1 => {
                    let term1 = Expr::binary(jac_r.entry(row, 1), BinaryOp::Mul, Expr::ident("r11"));
                    let term2 = Expr::binary(jac_r.entry(row, 2), BinaryOp::Mul, Expr::ident("r21"));
                    Expr::binary(
                        jac_l.entry(row, 1),
                        BinaryOp::Add,
                        Expr::binary(term1, BinaryOp::Add, term2),
                    )
                }
                2 => {
                    let term1 = Expr::binary(jac_r.entry(row, 1), BinaryOp::Mul, Expr::ident("r12"));
                    let term2 = Expr::binary(jac_r.entry(row, 2), BinaryOp::Mul, Expr::ident("r22"));
                    Expr::binary(
                        jac_l.entry(row, 2),
                        BinaryOp::Add,
                        Expr::binary(term1, BinaryOp::Add, term2),
                    )
                }
                _ => Expr::binary(jac_l.entry(row, col), BinaryOp::Add, jac_r.entry(row, col)),
            });
            wall.extend(eff_wall.assign_op_to_prefix_scaled(
                AssignOp::Add,
                "diag",
                Some(area.clone()),
            ));
            dsl::block(wall)
        };

        let boundary_stmt = dsl::if_block_expr(
            Expr::binary(
                Expr::ident("boundary_type"),
                BinaryOp::Equal,
                Expr::lit_u32(1),
            ),
            inlet_block,
            Some(dsl::block(vec![dsl::if_block_expr(
                Expr::binary(
                    Expr::ident("boundary_type"),
                    BinaryOp::Equal,
                    Expr::lit_u32(3),
                ),
                wall_block,
                Some(default_block),
            )])),
        );

        dsl::block(vec![boundary_stmt])
    };

    loop_body.push(dsl::if_block(
        "!is_boundary",
        interior_matrix,
        Some(boundary_matrix),
    ));

    stmts.push(dsl::for_loop(
        dsl::for_init_var("face_offset", "start"),
        "face_offset < end",
        dsl::for_step_increment("face_offset"),
        dsl::block(loop_body),
    ));

    stmts.push(dsl::var(
        "rhs_rho",
        "rhs_time_rho + rhs_pseudo_rho - (coeff_time + coeff_pseudo) * rho - sum_rho",
    ));
    stmts.push(dsl::var(
        "rhs_rho_u_x",
        "rhs_time_rho_u_x + rhs_pseudo_rho_u_x - (coeff_time + coeff_pseudo) * rho_u.x - sum_rho_u_x",
    ));
    stmts.push(dsl::var(
        "rhs_rho_u_y",
        "rhs_time_rho_u_y + rhs_pseudo_rho_u_y - (coeff_time + coeff_pseudo) * rho_u.y - sum_rho_u_y",
    ));
    stmts.push(dsl::var(
        "rhs_rho_e",
        "rhs_time_rho_e + rhs_pseudo_rho_e - (coeff_time + coeff_pseudo) * rho_e - sum_rho_e",
    ));

    stmts.extend(dsl::assign_op_matrix_diag(
        AssignOp::Add,
        "diag",
        block_size as usize,
        "coeff_time",
    ));
    stmts.extend(dsl::assign_op_matrix_diag(
        AssignOp::Add,
        "diag",
        block_size as usize,
        "coeff_pseudo",
    ));

    stmts.push(dsl::let_expr(
        "scalar_diag_idx",
        dsl::array_access("diagonal_indices", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "diag_rank",
        Expr::binary(
            Expr::ident("scalar_diag_idx"),
            BinaryOp::Sub,
            Expr::ident("scalar_offset"),
        ),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    let diag_mat = typed::MatExpr::<4, 4>::from_prefix("diag");
    stmts.extend(diag_mat.scatter_assign_to_block_entry_scaled(&diag_entry, None));

    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        0,
        Expr::ident("rhs_rho"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        1,
        Expr::ident("rhs_rho_u_x"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        2,
        Expr::ident("rhs_rho_u_y"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        3,
        Expr::ident("rhs_rho_e"),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_assembly_codegen_emits_bindings() {
        let model = compressible_model();
        let fields = model.fields.compressible().expect("compressible fields");
        let wgsl = generate_compressible_assembly_wgsl(&model.state_layout, fields);
        assert!(wgsl.contains("matrix_values"));
        assert!(wgsl.contains("rhs"));
        assert!(wgsl.contains("scalar_row_offsets"));
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("sum_rho"));
        assert!(wgsl.contains("rhs_time_rho"));
        assert!(wgsl.contains("A_l_10"));
    }
}
