// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: d43c3222f267bec69592ca3855559a6ff7fef0318d72a31e07c2754bba6f26fd

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    AmgPack,
    BlockPrecond,
    DotProduct,
    DotProductPair,
    GeneratedDpInitIncompressibleMomentum,
    GeneratedDpUpdateFromDiagIncompressibleMomentum,
    GeneratedFluxModuleCompressible,
    GeneratedFluxModuleGradientsIncompressibleMomentum,
    GeneratedFluxModuleIncompressibleMomentum,
    GeneratedGenericCoupledApply,
    GeneratedGenericCoupledAssemblyCompressible,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateCompressible,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum,
    GeneratedGenericCoupledAssemblyIncompressibleMomentum,
    GeneratedGenericCoupledUpdateCompressible,
    GeneratedGenericCoupledUpdateGenericDiffusionDemo,
    GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledUpdateIncompressibleMomentum,
    GeneratedPackedStateGradientsCompressible,
    GeneratedPackedStateGradientsGenericDiffusionDemo,
    GeneratedPackedStateGradientsGenericDiffusionDemoNeumann,
    GeneratedPackedStateGradientsIncompressibleMomentum,
    GeneratedRhieChowCorrectVelocityIncompressibleMomentum,
    GenericCoupledSchurSetup,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    OuterConvergence,
    Scalars,
    SchurPrecond,
    SchurPrecondGeneric,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self { Self :: Amg => amg :: create_pipeline_layout (device) , Self :: AmgPack => amg_pack :: create_pipeline_layout (device) , Self :: BlockPrecond => block_precond :: create_pipeline_layout (device) , Self :: DotProduct => dot_product :: create_pipeline_layout (device) , Self :: DotProductPair => dot_product_pair :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentum => generated :: dp_init_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => generated :: dp_update_from_diag_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleCompressible => generated :: flux_module_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => generated :: flux_module_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentum => generated :: flux_module_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledApply => generated :: generic_coupled_apply :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyCompressible => generated :: generic_coupled_assembly_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => generated :: generic_coupled_assembly_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => generated :: generic_coupled_assembly_grad_state_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => generated :: generic_coupled_assembly_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateCompressible => generated :: generic_coupled_update_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => generated :: generic_coupled_update_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => generated :: generic_coupled_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsCompressible => generated :: packed_state_gradients_compressible :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => generated :: packed_state_gradients_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => generated :: packed_state_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentum => generated :: rhie_chow_correct_velocity_incompressible_momentum :: create_pipeline_layout (device) , Self :: GenericCoupledSchurSetup => generic_coupled_schur_setup :: create_pipeline_layout (device) , Self :: GmresCgs => gmres_cgs :: create_pipeline_layout (device) , Self :: GmresLogic => gmres_logic :: create_pipeline_layout (device) , Self :: GmresOps => gmres_ops :: create_pipeline_layout (device) , Self :: LinearSolver => linear_solver :: create_pipeline_layout (device) , Self :: OuterConvergence => outer_convergence :: create_pipeline_layout (device) , Self :: Scalars => scalars :: create_pipeline_layout (device) , Self :: SchurPrecond => schur_precond :: create_pipeline_layout (device) , Self :: SchurPrecondGeneric => schur_precond_generic :: create_pipeline_layout (device) , }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self { Self :: Amg => { amg :: create_shader_module_embed_source (device) } , Self :: AmgPack => { amg_pack :: create_shader_module_embed_source (device) } , Self :: BlockPrecond => { block_precond :: create_shader_module_embed_source (device) } , Self :: DotProduct => { dot_product :: create_shader_module_embed_source (device) } , Self :: DotProductPair => { dot_product_pair :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentum => { generated :: dp_init_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => { generated :: dp_update_from_diag_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleCompressible => { generated :: flux_module_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => { generated :: flux_module_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentum => { generated :: flux_module_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledApply => { generated :: generic_coupled_apply :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyCompressible => { generated :: generic_coupled_assembly_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => { generated :: generic_coupled_assembly_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateCompressible => { generated :: generic_coupled_assembly_grad_state_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum => { generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => { generated :: generic_coupled_assembly_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateCompressible => { generated :: generic_coupled_update_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => { generated :: generic_coupled_update_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => { generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => { generated :: generic_coupled_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsCompressible => { generated :: packed_state_gradients_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemo => { generated :: packed_state_gradients_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsGenericDiffusionDemoNeumann => { generated :: packed_state_gradients_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedPackedStateGradientsIncompressibleMomentum => { generated :: packed_state_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentum => { generated :: rhie_chow_correct_velocity_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GenericCoupledSchurSetup => { generic_coupled_schur_setup :: create_shader_module_embed_source (device) } , Self :: GmresCgs => { gmres_cgs :: create_shader_module_embed_source (device) } , Self :: GmresLogic => { gmres_logic :: create_shader_module_embed_source (device) } , Self :: GmresOps => { gmres_ops :: create_shader_module_embed_source (device) } , Self :: LinearSolver => { linear_solver :: create_shader_module_embed_source (device) } , Self :: OuterConvergence => { outer_convergence :: create_shader_module_embed_source (device) } , Self :: Scalars => { scalars :: create_shader_module_embed_source (device) } , Self :: SchurPrecond => { schur_precond :: create_shader_module_embed_source (device) } , Self :: SchurPrecondGeneric => { schur_precond_generic :: create_shader_module_embed_source (device) } , }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const AMG_PACK_PACK_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg_pack::PackParams, num_cells) == 0);
        assert!(std::mem::offset_of!(amg_pack::PackParams, component) == 4);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad1) == 8);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad2) == 12);
        assert!(std::mem::size_of::<amg_pack::PackParams>() == 16);
    };
    const BLOCK_PRECOND_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(block_precond::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(block_precond::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<block_precond::GmresParams>() == 32);
    };
    const BLOCK_PRECOND_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(block_precond::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<block_precond::IterParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 16);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, num_groups) == 4);
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, padding) == 8);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 16);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dtau) == 8
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, time) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(std::mem::size_of::<generated::dp_init_incompressible_momentum::Constants>() == 48);
    };
    const GENERATED_DP_UPDATE_FROM_DIAG_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_update_from_diag_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::dp_update_from_diag_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_module_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_p) == 28
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gamma) == 48
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gm1) == 52
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_p_offset)
                == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::Constants>() == 72);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_LOW_MACH_PARAMS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, model) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                theta_floor
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::LowMachParams,
                pressure_coupling_alpha
            ) == 8
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::LowMachParams, _pad0) == 12
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::LowMachParams>() == 16);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Constants>(
            ) == 48
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Vector2>() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_APPLY_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, time) == 12);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, viscosity) == 16);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, density) == 20);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, component) == 24);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_p) == 28);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, scheme) == 32);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, alpha_u) == 36);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, stride_x) == 40);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, time_scheme) == 44
        );
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gamma) == 48);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_gm1) == 52);
        assert!(std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_p_offset) == 64
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_apply::Constants, eos_theta_ref) == 68
        );
        assert!(std::mem::size_of::<generated::generic_coupled_apply::Constants>() == 72);
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Vector2>() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Constants>()
                == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_grad_state_compressible::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_compressible::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , x) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 , y) == 4) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Vector2 > () == 8) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: (
    ) = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GRAD_STATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS : () = { assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt) == 0) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dt_old) == 4) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , dtau) == 8) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time) == 12) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , viscosity) == 16) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , density) == 20) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , component) == 24) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_p) == 28) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , scheme) == 32) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , alpha_u) == 36) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , stride_x) == 40) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , time_scheme) == 44) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gamma) == 48) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_gm1) == 52) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_r) == 56) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_dp_drho) == 60) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_p_offset) == 64) ; assert ! (std :: mem :: offset_of ! (generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants , eos_theta_ref) == 68) ; assert ! (std :: mem :: size_of :: < generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () == 72) ; } ;
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_compressible::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::packed_state_gradients_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Vector2>() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_compressible::Constants>() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_PACKED_STATE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::packed_state_gradients_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::packed_state_gradients_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_RHIE_CHOW_CORRECT_VELOCITY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<
                generated::rhie_chow_correct_velocity_incompressible_momentum::Constants,
            >() == 48
        );
    };
    const GENERIC_COUPLED_SCHUR_SETUP_SETUP_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, num_cells) == 0);
        assert!(
            std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, unknowns_per_cell) == 4
        );
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, p) == 8);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u_len) == 12);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u0123) == 16);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u4567) == 32);
        assert!(std::mem::size_of::<generic_coupled_schur_setup::SetupParams>() == 48);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 24);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const OUTER_CONVERGENCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::Params, num_cells) == 0);
        assert!(std::mem::offset_of!(outer_convergence::Params, stride) == 4);
        assert!(std::mem::offset_of!(outer_convergence::Params, num_targets) == 8);
        assert!(std::mem::offset_of!(outer_convergence::Params, _pad0) == 12);
        assert!(std::mem::size_of::<outer_convergence::Params>() == 16);
    };
    const OUTER_CONVERGENCE_TARGET_DESC_ASSERTS: () = {
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, offsets) == 0);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, num_comps) == 16);
        assert!(std::mem::offset_of!(outer_convergence::TargetDesc, _pad0) == 20);
        assert!(std::mem::size_of::<outer_convergence::TargetDesc>() == 32);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 20);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 24);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, unknowns_per_cell) == 12);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u0) == 16);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u1) == 20);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, p) == 24);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, _pad0) == 28);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 32);
    };
    const SCHUR_PRECOND_GENERIC_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, omega) == 8);
        assert!(
            std::mem::offset_of!(schur_precond_generic::PrecondParams, unknowns_per_cell) == 12
        );
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, p) == 16);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u_len) == 20);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad0) == 24);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad1) == 28);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u0123) == 32);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u4567) == 48);
        assert!(std::mem::size_of::<schur_precond_generic::PrecondParams>() == 64);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.coarse_vec]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let stride_x = (num_workgroups.x * 64u);
    let i = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.n;
    if (i >= _e13) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e24 = k;
        if (_e24 < end) {
        } else {
            break;
        }
        {
            let _e27 = k;
            let col = col_indices[_e27];
            let _e31 = k;
            let val = values[_e31];
            if (col == i) {
                diag = val;
            } else {
                let _e39 = x[col];
                let _e41 = sigma;
                sigma = (_e41 + (val * _e39));
            }
        }
        continuing {
            let _e44 = k;
            k = (_e44 + 1u);
        }
    }
    let _e46 = diag;
    if (abs(_e46) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e53 = b[i];
    let _e54 = sigma;
    let _e56 = diag;
    let x_new = ((_e53 - _e54) / _e56);
    let _e62 = x[i];
    let _e65 = params.omega;
    x[i] = mix(_e62, x_new, _e65);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let i_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.n;
    if (i_1 >= _e12) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e23 = k_1;
        if (_e23 < end_1) {
        } else {
            break;
        }
        {
            let _e26 = k_1;
            let coarse_idx = op_col_indices[_e26];
            let _e30 = k_1;
            let val_1 = op_values[_e30];
            let _e36 = coarse_vec[coarse_idx];
            let _e38 = correction;
            correction = (_e38 + (val_1 * _e36));
        }
        continuing {
            let _e41 = k_1;
            k_1 = (_e41 + 1u);
        }
    }
    let _e45 = correction;
    let _e46 = x[i_1];
    x[i_1] = (_e46 + _e45);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let stride_x_2 = (num_workgroups_2.x * 64u);
    let i_2 = ((global_id_2.y * stride_x_2) + global_id_2.x);
    let _e12 = params.n;
    if (i_2 >= _e12) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e23 = k_2;
        if (_e23 < end_2) {
        } else {
            break;
        }
        {
            let _e26 = k_2;
            let fine_idx = op_col_indices[_e26];
            let _e30 = k_2;
            let r_val = op_values[_e30];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e44 = j;
                if (_e44 < a_end) {
                } else {
                    break;
                }
                {
                    let _e47 = j;
                    let _e49 = values[_e47];
                    let _e52 = j;
                    let _e54 = col_indices[_e52];
                    let _e56 = x[_e54];
                    let _e58 = ax;
                    ax = (_e58 + (_e49 * _e56));
                }
                continuing {
                    let _e61 = j;
                    j = (_e61 + 1u);
                }
            }
            let _e65 = b[fine_idx];
            let _e66 = ax;
            let fine_r = (_e65 - _e66);
            let _e70 = sum;
            sum = (_e70 + (r_val * fine_r));
        }
        continuing {
            let _e73 = k_2;
            k_2 = (_e73 + 1u);
        }
    }
    let _e77 = sum;
    coarse_vec[i_2] = _e77;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let stride_x_3 = (num_workgroups_3.x * 64u);
    let i_3 = ((global_id_3.y * stride_x_3) + global_id_3.x);
    let _e11 = params.n;
    if (i_3 >= _e11) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for amg_pack::PackParams {}
    unsafe impl bytemuck::Pod for amg_pack::PackParams {}
    unsafe impl bytemuck::Zeroable for block_precond::GmresParams {}
    unsafe impl bytemuck::Pod for block_precond::GmresParams {}
    unsafe impl bytemuck::Zeroable for block_precond::IterParams {}
    unsafe impl bytemuck::Pod for block_precond::IterParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::dp_update_from_diag_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::dp_update_from_diag_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::LowMachParams {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_apply::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_grad_state_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_compressible::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_grad_state_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::packed_state_gradients_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::packed_state_gradients_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::packed_state_gradients_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::rhie_chow_correct_velocity_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::rhie_chow_correct_velocity_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Pod for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for outer_convergence::Params {}
    unsafe impl bytemuck::Pod for outer_convergence::Params {}
    unsafe impl bytemuck::Zeroable for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Pod for outer_convergence::TargetDesc {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Zeroable for schur_precond_generic::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond_generic::PrecondParams {}
}
pub mod amg_pack {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PackParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub component: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PackParams {
        pub const fn new(num_cells: u32, component: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                num_cells,
                component,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const PACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_pack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline pack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("pack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UNPACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_unpack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline unpack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("unpack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_PACK_COMPONENT: &str = "pack_component";
    pub const ENTRY_UNPACK_COMPONENT: &str = "unpack_component";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input_buf: wgpu::BufferBinding<'a>,
        pub output_buf: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input_buf: wgpu::BindGroupEntry<'a>,
        pub output_buf: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input_buf: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input_buf),
                },
                output_buf: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.output_buf),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.input_buf, self.output_buf]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"output_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg_pack::PackParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AmgPack::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg_pack.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PackParams {
    num_cells: u32,
    component: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> input_buf: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> output_buf: array<f32>;
@group(1) @binding(0) 
var<uniform> params: PackParams;

@compute @workgroup_size(64, 1, 1) 
fn pack_component(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let _e11 = params.num_cells;
    if (idx >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base = ((idx * 4u) + _e17);
    let _e23 = input_buf[base];
    output_buf[idx] = _e23;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn unpack_component(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let stride_x_1 = (num_workgroups_1.x * 64u);
    let idx_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e11 = params.num_cells;
    if (idx_1 >= _e11) {
        return;
    }
    let _e17 = params.component;
    let base_1 = ((idx_1 * 4u) + _e17);
    let _e23 = input_buf[idx_1];
    output_buf[base_1] = _e23;
    return;
}
"#;
}
pub mod block_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const MAX_BLOCK: u32 = 16u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_BLOCK_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_block_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_block_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_block_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_BLOCK_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_block_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_block_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_block_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_BLOCK_INV: &str = "build_block_inv";
    pub const ENTRY_APPLY_BLOCK_PRECOND: &str = "apply_block_precond";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.block_inv]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("BlockPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("block_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const MAX_BLOCK: u32 = 16u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

fn swap_rows(a_1: ptr<function, array<array<f32, 16>, 16>>, b: ptr<function, array<array<f32, 16>, 16>>, r0_: u32, r1_: u32, n: u32) {
    var c_6: u32 = 0u;

    if (r0_ == r1_) {
        return;
    }
    loop {
        let _e6 = c_6;
        if (_e6 < n) {
        } else {
            break;
        }
        {
            let _e10 = c_6;
            let tmp = (*a_1)[r0_][_e10];
            let _e14 = c_6;
            let _e17 = c_6;
            let _e19 = (*a_1)[r1_][_e17];
            (*a_1)[r0_][_e14] = _e19;
            let _e21 = c_6;
            (*a_1)[r1_][_e21] = tmp;
            let _e25 = c_6;
            let tmp_b = (*b)[r0_][_e25];
            let _e29 = c_6;
            let _e32 = c_6;
            let _e34 = (*b)[r1_][_e32];
            (*b)[r0_][_e29] = _e34;
            let _e36 = c_6;
            (*b)[r1_][_e36] = tmp_b;
        }
        continuing {
            let _e38 = c_6;
            c_6 = (_e38 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn build_block_inv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var a: array<array<f32, 16>, 16>;
    var inv: array<array<f32, 16>, 16>;
    var diag_orig: array<f32, 16>;
    var r: u32 = 0u;
    var c: u32;
    var k: u32;
    var singular: bool = false;
    var i: u32 = 0u;
    var pivot: u32;
    var pivot_val: f32;
    var r_1: u32;
    var piv: f32;
    var c_1: u32;
    var r_2: u32;
    var c_2: u32;
    var r_3: u32 = 0u;
    var c_3: u32;
    var r_4: u32 = 0u;
    var c_4: u32;

    let stride_x = (num_workgroups.x * 64u);
    let cell = ((global_id.y * stride_x) + global_id.x);
    let _e13 = params.num_cells;
    if (cell >= _e13) {
        return;
    }
    let _e17 = params.num_cells;
    if (_e17 == 0u) {
        return;
    }
    let _e22 = params.n;
    let _e25 = params.num_cells;
    let b_1 = (_e22 / _e25);
    if ((b_1 == 0u) || (b_1 > MAX_BLOCK)) {
        return;
    }
    let base = (cell * b_1);
    loop {
        let _e34 = r;
        if (_e34 < b_1) {
        } else {
            break;
        }
        {
            c = 0u;
            loop {
                let _e38 = c;
                if (_e38 < b_1) {
                } else {
                    break;
                }
                {
                    let _e41 = r;
                    let _e43 = c;
                    a[_e41][_e43] = 0f;
                    let _e47 = r;
                    let _e49 = c;
                    inv[_e47][_e49] = 0f;
                }
                continuing {
                    let _e52 = c;
                    c = (_e52 + 1u);
                }
            }
            let _e55 = r;
            let row = (base + _e55);
            let start = row_offsets[row];
            let end = row_offsets[(row + 1u)];
            k = start;
            loop {
                let _e66 = k;
                if (_e66 < end) {
                } else {
                    break;
                }
                {
                    let _e69 = k;
                    let col = col_indices[_e69];
                    if ((col >= base) && (col < (base + b_1))) {
                        let local = (col - base);
                        let _e77 = r;
                        let _e81 = k;
                        let _e83 = matrix_values[_e81];
                        a[_e77][local] = _e83;
                    }
                }
                continuing {
                    let _e84 = k;
                    k = (_e84 + 1u);
                }
            }
            let _e87 = r;
            let _e89 = r;
            inv[_e87][_e89] = 1f;
            let _e93 = r;
            let _e95 = r;
            let _e97 = r;
            let _e99 = a[_e95][_e97];
            diag_orig[_e93] = _e99;
        }
        continuing {
            let _e100 = r;
            r = (_e100 + 1u);
        }
    }
    loop {
        let _e104 = i;
        if (_e104 < b_1) {
        } else {
            break;
        }
        {
            let _e106 = i;
            pivot = _e106;
            let _e108 = i;
            let _e110 = i;
            let _e112 = a[_e108][_e110];
            pivot_val = abs(_e112);
            let _e115 = i;
            r_1 = (_e115 + 1u);
            loop {
                let _e119 = r_1;
                if (_e119 < b_1) {
                } else {
                    break;
                }
                {
                    let _e121 = r_1;
                    let _e123 = i;
                    let _e125 = a[_e121][_e123];
                    let val_1 = abs(_e125);
                    let _e127 = pivot_val;
                    if (val_1 > _e127) {
                        pivot_val = val_1;
                        let _e129 = r_1;
                        pivot = _e129;
                    }
                }
                continuing {
                    let _e130 = r_1;
                    r_1 = (_e130 + 1u);
                }
            }
            let _e133 = pivot_val;
            if (_e133 < 0.000000000001f) {
                singular = true;
            }
            let _e138 = i;
            let _e139 = pivot;
            swap_rows((&a), (&inv), _e138, _e139, b_1);
            let _e140 = i;
            let _e142 = i;
            let _e144 = a[_e140][_e142];
            piv = _e144;
            let _e146 = piv;
            if (abs(_e146) < 0.000000000001f) {
                let _e150 = piv;
                piv = select(0.000000000001f, -0.000000000001f, (_e150 < 0f));
            }
            let _e156 = piv;
            let inv_piv = (1f / _e156);
            c_1 = 0u;
            loop {
                let _e161 = c_1;
                if (_e161 < b_1) {
                } else {
                    break;
                }
                {
                    let _e163 = i;
                    let _e165 = c_1;
                    let _e167 = i;
                    let _e169 = c_1;
                    let _e171 = a[_e167][_e169];
                    a[_e163][_e165] = (_e171 * inv_piv);
                    let _e173 = i;
                    let _e175 = c_1;
                    let _e177 = i;
                    let _e179 = c_1;
                    let _e181 = inv[_e177][_e179];
                    inv[_e173][_e175] = (_e181 * inv_piv);
                }
                continuing {
                    let _e183 = c_1;
                    c_1 = (_e183 + 1u);
                }
            }
            r_2 = 0u;
            loop {
                let _e188 = r_2;
                if (_e188 < b_1) {
                } else {
                    break;
                }
                {
                    let _e190 = r_2;
                    let _e191 = i;
                    if (_e190 == _e191) {
                        continue;
                    }
                    let _e193 = r_2;
                    let _e195 = i;
                    let factor = a[_e193][_e195];
                    c_2 = 0u;
                    loop {
                        let _e200 = c_2;
                        if (_e200 < b_1) {
                        } else {
                            break;
                        }
                        {
                            let _e202 = r_2;
                            let _e204 = c_2;
                            let _e206 = r_2;
                            let _e208 = c_2;
                            let _e210 = a[_e206][_e208];
                            let _e211 = i;
                            let _e213 = c_2;
                            let _e215 = a[_e211][_e213];
                            a[_e202][_e204] = (_e210 - (factor * _e215));
                            let _e218 = r_2;
                            let _e220 = c_2;
                            let _e222 = r_2;
                            let _e224 = c_2;
                            let _e226 = inv[_e222][_e224];
                            let _e227 = i;
                            let _e229 = c_2;
                            let _e231 = inv[_e227][_e229];
                            inv[_e218][_e220] = (_e226 - (factor * _e231));
                        }
                        continuing {
                            let _e234 = c_2;
                            c_2 = (_e234 + 1u);
                        }
                    }
                }
                continuing {
                    let _e237 = r_2;
                    r_2 = (_e237 + 1u);
                }
            }
        }
        continuing {
            let _e240 = i;
            i = (_e240 + 1u);
        }
    }
    let _e243 = singular;
    if _e243 {
        loop {
            let _e245 = r_3;
            if (_e245 < b_1) {
            } else {
                break;
            }
            {
                c_3 = 0u;
                loop {
                    let _e249 = c_3;
                    if (_e249 < b_1) {
                    } else {
                        break;
                    }
                    {
                        let _e251 = r_3;
                        let _e253 = c_3;
                        inv[_e251][_e253] = 0f;
                    }
                    continuing {
                        let _e256 = c_3;
                        c_3 = (_e256 + 1u);
                    }
                }
                let _e259 = r_3;
                let _e261 = r_3;
                let _e263 = r_3;
                let _e265 = diag_orig[_e263];
                let _e266 = safe_inverse(_e265);
                inv[_e259][_e261] = _e266;
            }
            continuing {
                let _e267 = r_3;
                r_3 = (_e267 + 1u);
            }
        }
    }
    let offset = (cell * (b_1 * b_1));
    loop {
        let _e273 = r_4;
        if (_e273 < b_1) {
        } else {
            break;
        }
        {
            c_4 = 0u;
            loop {
                let _e277 = c_4;
                if (_e277 < b_1) {
                } else {
                    break;
                }
                {
                    let _e280 = r_4;
                    let _e283 = c_4;
                    let _e286 = r_4;
                    let _e288 = c_4;
                    let _e290 = inv[_e286][_e288];
                    block_inv[((offset + (_e280 * b_1)) + _e283)] = _e290;
                }
                continuing {
                    let _e291 = c_4;
                    c_4 = (_e291 + 1u);
                }
            }
        }
        continuing {
            let _e294 = r_4;
            r_4 = (_e294 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_block_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var r_5: u32 = 0u;
    var sum: f32;
    var c_5: u32;

    let stride_x_1 = (num_workgroups_1.x * 64u);
    let cell_1 = ((global_id_1.y * stride_x_1) + global_id_1.x);
    let _e12 = params.num_cells;
    if (cell_1 >= _e12) {
        return;
    }
    let _e16 = params.num_cells;
    if (_e16 == 0u) {
        return;
    }
    let _e21 = params.n;
    let _e24 = params.num_cells;
    let b_2 = (_e21 / _e24);
    if ((b_2 == 0u) || (b_2 > MAX_BLOCK)) {
        return;
    }
    let base_1 = (cell_1 * b_2);
    let offset_1 = (cell_1 * (b_2 * b_2));
    loop {
        let _e35 = r_5;
        if (_e35 < b_2) {
        } else {
            break;
        }
        {
            sum = 0f;
            c_5 = 0u;
            loop {
                let _e41 = c_5;
                if (_e41 < b_2) {
                } else {
                    break;
                }
                {
                    let _e44 = r_5;
                    let _e47 = c_5;
                    let _e50 = block_inv[((offset_1 + (_e44 * b_2)) + _e47)];
                    let _e52 = c_5;
                    let _e55 = vec_x[(base_1 + _e52)];
                    let _e57 = sum;
                    sum = (_e57 + (_e50 * _e55));
                }
                continuing {
                    let _e59 = c_5;
                    c_5 = (_e59 + 1u);
                }
            }
            let _e63 = r_5;
            let _e66 = sum;
            vec_y[(base_1 + _e63)] = _e66;
        }
        continuing {
            let _e67 = r_5;
            r_5 = (_e67 + 1u);
        }
    }
    return;
}
"#;
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a[idx];
        let _e22 = dot_b[idx];
        val = (_e19 * _e22);
    }
    let _e27 = val;
    scratch[lid] = _e27;
    workgroupBarrier();
    loop {
        let _e29 = i;
        if (_e29 > 0u) {
        } else {
            break;
        }
        {
            let _e32 = i;
            if (lid < _e32) {
                let _e37 = i;
                let _e40 = scratch[(lid + _e37)];
                let _e41 = scratch[lid];
                scratch[lid] = (_e41 + _e40);
            }
            workgroupBarrier();
        }
        continuing {
            let _e44 = i;
            i = (_e44 >> 1u);
        }
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e56 = params.num_groups;
        if (group_flat < _e56) {
            let _e62 = scratch[0];
            dot_result[group_flat] = _e62;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl SolverParams {
        pub const fn new(n: u32, num_groups: u32, padding: [u32; 2]) -> Self {
            Self {
                n,
                num_groups,
                padding,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
    num_groups: u32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let stride_x = (num_workgroups.x * 64u);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let lid = local_id.x;
    let _e15 = params.n;
    if (idx < _e15) {
        let _e19 = dot_a0_[idx];
        let _e22 = dot_b0_[idx];
        val0_ = (_e19 * _e22);
        let _e27 = dot_a1_[idx];
        let _e30 = dot_b1_[idx];
        val1_ = (_e27 * _e30);
    }
    let _e35 = val0_;
    scratch_a[lid] = _e35;
    let _e38 = val1_;
    scratch_b[lid] = _e38;
    workgroupBarrier();
    loop {
        let _e40 = offset;
        if (lid < _e40) {
            let _e45 = offset;
            let _e48 = scratch_a[(lid + _e45)];
            let _e49 = scratch_a[lid];
            scratch_a[lid] = (_e49 + _e48);
            let _e54 = offset;
            let _e57 = scratch_b[(lid + _e54)];
            let _e58 = scratch_b[lid];
            scratch_b[lid] = (_e58 + _e57);
        }
        workgroupBarrier();
        let _e60 = offset;
        if (_e60 == 1u) {
            break;
        }
        let _e63 = offset;
        offset = (_e63 >> 1u);
    }
    if (lid == 0u) {
        let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
        let _e76 = params.num_groups;
        if (group_flat < _e76) {
            let _e82 = scratch_a[0];
            dot_result_a[group_flat] = _e82;
            let _e87 = scratch_b[0];
            dot_result_b[group_flat] = _e87;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod dp_init_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedDpInitIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::dp_init_incompressible_momentum::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e15 = constants.density;
    let rho = max(_e15, 0.000000000001f);
    let _e20 = constants.dt;
    let dt = max(_e20, 0f);
    let _e25 = cell_vols[idx];
    let vol = max(_e25, 0.000000000001f);
    let d_p = (dt / (rho * vol));
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const UNKNOWNS_PER_CELL: u32 = 3u32;
        pub const U_LEN: u32 = 2u32;
        pub const U_0: u32 = 0u32;
        pub const U_1: u32 = 1u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: dp_update_from_diag_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;
const UNKNOWNS_PER_CELL: u32 = 3u;
const U_LEN: u32 = 2u;
const U_0_: u32 = 0u;
const U_1_: u32 = 1u;

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(4) 
var<uniform> constants: Constants;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum_u_inv: f32 = 0f;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let scalar_offset = scalar_row_offsets[idx];
    let scalar_end = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[idx];
    let diag_rank = (_e25 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let row_stride = (num_neighbors * UNKNOWNS_PER_CELL);
    {
        let start_row_u = (start_row_0_ + (U_0_ * row_stride));
        let diag_u = matrix_values[((start_row_u + (diag_rank * UNKNOWNS_PER_CELL)) + U_0_)];
        let _e41 = safe_inverse(diag_u);
        let _e43 = sum_u_inv;
        sum_u_inv = (_e43 + _e41);
    }
    {
        let start_row_u_1 = (start_row_0_ + (U_1_ * row_stride));
        let diag_u_1 = matrix_values[((start_row_u_1 + (diag_rank * UNKNOWNS_PER_CELL)) + U_1_)];
        let _e55 = safe_inverse(diag_u_1);
        let _e56 = sum_u_inv;
        sum_u_inv = (_e56 + _e55);
    }
    let _e58 = sum_u_inv;
    let d_p = (_e58 / 2f);
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod flux_module_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct LowMachParams {
            #[doc = "offset: 0, size: 4, type: `u32`"]
            pub model: u32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub theta_floor: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub pressure_coupling_alpha: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub _pad0: f32,
        }
        impl LowMachParams {
            pub const fn new(
                model: u32,
                theta_floor: f32,
                pressure_coupling_alpha: f32,
                _pad0: f32,
            ) -> Self {
                Self {
                    model,
                    theta_floor,
                    pressure_coupling_alpha,
                    _pad0,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub low_mach_params: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub low_mach_params: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    low_mach_params: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.low_mach_params),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                    self.low_mach_params,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"low_mach_params\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::LowMachParams,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0_: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var a_plus: f32;
    var a_minus: f32;
    var u_l_0_: f32;
    var u_r_0_: f32;
    var f_l_0_: f32;
    var f_r_0_: f32;
    var u_l_1_: f32;
    var u_r_1_: f32;
    var f_l_1_: f32;
    var f_r_1_: f32;
    var u_l_2_: f32;
    var u_r_2_: f32;
    var f_l_2_: f32;
    var f_r_2_: f32;
    var u_l_3_: f32;
    var u_r_3_: f32;
    var f_l_3_: f32;
    var f_r_3_: f32;
    var u_l_4_: f32 = 0f;
    var u_r_4_: f32 = 0f;
    var f_l_4_: f32 = 0f;
    var f_r_4_: f32 = 0f;
    var u_l_5_: f32 = 0f;
    var u_r_5_: f32 = 0f;
    var f_l_5_: f32 = 0f;
    var f_r_5_: f32 = 0f;
    var u_l_6_: f32 = 0f;
    var u_r_6_: f32 = 0f;
    var f_l_6_: f32 = 0f;
    var f_r_6_: f32 = 0f;
    var u_l_7_: f32 = 0f;
    var u_r_7_: f32 = 0f;
    var f_l_7_: f32 = 0f;
    var f_r_7_: f32 = 0f;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e37 = face_normals[idx].x;
    let _e41 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e37, _e41);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e54 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e54) < 0f) {
        let _e58 = normal_vec;
        normal_vec = -(_e58);
    }
    let _e61 = neigh_idx;
    let c_neigh = cell_centers[_e61];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let d_own_1 = distance(c_owner_vec, face_center_vec);
    let _e70 = c_neigh_vec;
    let d_neigh = distance(_e70, face_center_vec);
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e77 = lambda;
    let lambda_other = (1f - _e77);
    let _e80 = c_neigh_vec;
    let d_vec = (_e80 - c_owner_vec);
    let _e82 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e82));
    let dist = max(dist_proj, 0.000001f);
    let s_own_p = state[((owner_1 * 8u) + 4u)];
    let s_own_rho = state[((owner_1 * 8u) + 0u)];
    let s_own_rho_e = state[((owner_1 * 8u) + 3u)];
    let _cse_1450_ = state[((owner_1 * 8u) + 1u)];
    let _cse_1459_ = state[((owner_1 * 8u) + 2u)];
    let _e122 = neigh_idx;
    let _e129 = state[((_e122 * 8u) + 4u)];
    let _e136 = state[((owner_1 * 8u) + 4u)];
    let _e143 = bc_kind[((idx * 8u) + 6u)];
    let _e150 = bc_value[((idx * 8u) + 6u)];
    let _e151 = bc_neighbor_scalar(_e129, _e136, _e143, _e150, d_own_1, is_boundary_1);
    let _e152 = neigh_idx;
    let _e159 = state[((_e152 * 8u) + 0u)];
    let _e166 = state[((owner_1 * 8u) + 0u)];
    let _e173 = bc_kind[((idx * 8u) + 0u)];
    let _e180 = bc_value[((idx * 8u) + 0u)];
    let _e181 = bc_neighbor_scalar(_e159, _e166, _e173, _e180, d_own_1, is_boundary_1);
    let _e182 = neigh_idx;
    let _e189 = state[((_e182 * 8u) + 3u)];
    let _e196 = state[((owner_1 * 8u) + 3u)];
    let _e203 = bc_kind[((idx * 8u) + 3u)];
    let _e210 = bc_value[((idx * 8u) + 3u)];
    let _e211 = bc_neighbor_scalar(_e189, _e196, _e203, _e210, d_own_1, is_boundary_1);
    let _e212 = neigh_idx;
    let _e219 = state[((_e212 * 8u) + 1u)];
    let _e226 = state[((owner_1 * 8u) + 1u)];
    let _e233 = bc_kind[((idx * 8u) + 1u)];
    let _e240 = bc_value[((idx * 8u) + 1u)];
    let _e241 = bc_neighbor_scalar(_e219, _e226, _e233, _e240, d_own_1, is_boundary_1);
    let _e242 = neigh_idx;
    let _e249 = state[((_e242 * 8u) + 2u)];
    let _e256 = state[((owner_1 * 8u) + 2u)];
    let _e263 = bc_kind[((idx * 8u) + 2u)];
    let _e270 = bc_value[((idx * 8u) + 2u)];
    let _e271 = bc_neighbor_scalar(_e249, _e256, _e263, _e270, d_own_1, is_boundary_1);
    let _cse_2_ = vec2<f32>(_cse_1450_, _cse_1459_);
    let _cse_1_ = ((_cse_2_ * 1f) / vec2(s_own_rho));
    let _e277 = normal_vec;
    let _cse_0_ = dot(_cse_1_, _e277);
    let _e281 = low_mach_params.model;
    let _cse_12_ = (f32(_e281) - 2f);
    let _cse_11_ = abs(_cse_12_);
    let _cse_10_ = (1f - _cse_11_);
    let _cse_9_ = max(0f, _cse_10_);
    let _e292 = constants.eos_gamma;
    let _cse_14_ = ((_e292 * s_own_p) / s_own_rho);
    let _e297 = constants.eos_dp_drho;
    let _cse_13_ = (_cse_14_ + _e297);
    let _cse_8_ = (_cse_9_ * _cse_13_);
    let _e302 = low_mach_params.model;
    let _cse_19_ = f32(_e302);
    let _cse_18_ = abs(_cse_19_);
    let _cse_17_ = (1f - _cse_18_);
    let _cse_16_ = max(0f, _cse_17_);
    let _cse_21_ = (_cse_0_ * _cse_0_);
    let _cse_20_ = min(_cse_21_, _cse_13_);
    let _cse_15_ = (_cse_16_ * _cse_20_);
    let _cse_7_ = (_cse_8_ + _cse_15_);
    let _e315 = low_mach_params.model;
    let _cse_26_ = (f32(_e315) - 1f);
    let _cse_25_ = abs(_cse_26_);
    let _cse_24_ = (1f - _cse_25_);
    let _cse_23_ = max(0f, _cse_24_);
    let _e326 = low_mach_params.theta_floor;
    let _cse_29_ = (_e326 * _cse_13_);
    let _cse_28_ = max(_cse_21_, _cse_29_);
    let _cse_27_ = min(_cse_28_, _cse_13_);
    let _cse_22_ = (_cse_23_ * _cse_27_);
    let _cse_6_ = (_cse_7_ + _cse_22_);
    let _cse_5_ = sqrt(_cse_6_);
    let _cse_32_ = vec2<f32>(_e241, _e271);
    let _cse_31_ = ((_cse_32_ * 1f) / vec2(_e181));
    let _e338 = normal_vec;
    let _cse_30_ = dot(_cse_31_, _e338);
    let _e342 = constants.eos_gamma;
    let _cse_40_ = ((_e342 * _e151) / _e181);
    let _e347 = constants.eos_dp_drho;
    let _cse_39_ = (_cse_40_ + _e347);
    let _cse_38_ = (_cse_9_ * _cse_39_);
    let _cse_43_ = (_cse_30_ * _cse_30_);
    let _cse_42_ = min(_cse_43_, _cse_39_);
    let _cse_41_ = (_cse_16_ * _cse_42_);
    let _cse_37_ = (_cse_38_ + _cse_41_);
    let _e356 = low_mach_params.theta_floor;
    let _cse_47_ = (_e356 * _cse_39_);
    let _cse_46_ = max(_cse_43_, _cse_47_);
    let _cse_45_ = min(_cse_46_, _cse_39_);
    let _cse_44_ = (_cse_23_ * _cse_45_);
    let _cse_36_ = (_cse_37_ + _cse_44_);
    let _cse_35_ = sqrt(_cse_36_);
    a_plus = max(0f, max((_cse_0_ + _cse_5_), (_cse_30_ + _cse_35_)));
    a_minus = min(0f, min((_cse_0_ - _cse_5_), (_cse_30_ - _cse_35_)));
    let _e377 = constants.scheme;
    if ((_e377 == 1u) && !(is_boundary_1)) {
        let _cse_58_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_57_ = max(_cse_58_, 0.000000000001f);
        let _cse_55_ = ((_e241 - _cse_1450_) / _cse_57_);
        let _cse_54_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_55_);
        let _cse_53_ = dot(_cse_54_, (face_center_vec - c_owner_vec));
        let _cse_51_ = (_cse_1450_ + _cse_53_);
        let _cse_63_ = ((_e271 - _cse_1459_) / _cse_57_);
        let _cse_62_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_63_);
        let _cse_61_ = dot(_cse_62_, (face_center_vec - c_owner_vec));
        let _cse_59_ = (_cse_1459_ + _cse_61_);
        let _cse_50_ = vec2<f32>(_cse_51_, _cse_59_);
        let _cse_69_ = ((_e181 - s_own_rho) / _cse_57_);
        let _cse_68_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_69_);
        let _cse_67_ = dot(_cse_68_, (face_center_vec - c_owner_vec));
        let _cse_66_ = (s_own_rho + _cse_67_);
        let _cse_65_ = (1f / _cse_66_);
        let _cse_49_ = (_cse_50_ * _cse_65_);
        let _e412 = normal_vec;
        let _cse_48_ = dot(_cse_49_, _e412);
        let _e416 = constants.eos_gamma;
        let _cse_75_ = (_e416 * (s_own_p + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_57_)), (face_center_vec - c_owner_vec))));
        let _cse_74_ = (_cse_75_ / _cse_66_);
        let _e429 = constants.eos_dp_drho;
        let _cse_73_ = (_cse_74_ + _e429);
        let _cse_78_ = (_cse_48_ * _cse_48_);
        let _cse_77_ = min(_cse_78_, _cse_73_);
        let _e435 = low_mach_params.model;
        let _cse_76_ = (max(0f, (1f - abs(f32(_e435)))) * _cse_77_);
        let _e445 = low_mach_params.model;
        let _cse_72_ = ((max(0f, (1f - abs((f32(_e445) - 2f)))) * _cse_73_) + _cse_76_);
        let _e458 = low_mach_params.theta_floor;
        let _cse_81_ = max(_cse_78_, (_e458 * _cse_73_));
        let _cse_80_ = min(_cse_81_, _cse_73_);
        let _e464 = low_mach_params.model;
        let _cse_79_ = (max(0f, (1f - abs((f32(_e464) - 1f)))) * _cse_80_);
        let _cse_71_ = (_cse_72_ + _cse_79_);
        let _cse_70_ = sqrt(_cse_71_);
        let _cse_90_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_89_ = max(_cse_90_, 0.000000000001f);
        let _cse_88_ = ((_cse_1450_ - _e241) / _cse_89_);
        let _cse_87_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_88_);
        let _cse_86_ = dot(_cse_87_, (face_center_vec - c_neigh_cell_vec));
        let _cse_85_ = (_e241 + _cse_86_);
        let _cse_94_ = ((_cse_1459_ - _e271) / _cse_89_);
        let _cse_93_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_94_);
        let _cse_92_ = dot(_cse_93_, (face_center_vec - c_neigh_cell_vec));
        let _cse_91_ = (_e271 + _cse_92_);
        let _cse_84_ = vec2<f32>(_cse_85_, _cse_91_);
        let _cse_99_ = ((s_own_rho - _e181) / _cse_89_);
        let _cse_98_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_99_);
        let _cse_97_ = dot(_cse_98_, (face_center_vec - c_neigh_cell_vec));
        let _cse_96_ = (_e181 + _cse_97_);
        let _cse_95_ = (1f / _cse_96_);
        let _cse_83_ = (_cse_84_ * _cse_95_);
        let _e506 = normal_vec;
        let _cse_82_ = dot(_cse_83_, _e506);
        let _e510 = constants.eos_gamma;
        let _cse_105_ = (_e510 * (_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_89_)), (face_center_vec - c_neigh_cell_vec))));
        let _cse_104_ = (_cse_105_ / _cse_96_);
        let _e523 = constants.eos_dp_drho;
        let _cse_103_ = (_cse_104_ + _e523);
        let _cse_108_ = (_cse_82_ * _cse_82_);
        let _cse_107_ = min(_cse_108_, _cse_103_);
        let _e529 = low_mach_params.model;
        let _cse_106_ = (max(0f, (1f - abs(f32(_e529)))) * _cse_107_);
        let _e539 = low_mach_params.model;
        let _cse_102_ = ((max(0f, (1f - abs((f32(_e539) - 2f)))) * _cse_103_) + _cse_106_);
        let _e552 = low_mach_params.theta_floor;
        let _cse_111_ = max(_cse_108_, (_e552 * _cse_103_));
        let _cse_110_ = min(_cse_111_, _cse_103_);
        let _e558 = low_mach_params.model;
        let _cse_109_ = (max(0f, (1f - abs((f32(_e558) - 1f)))) * _cse_110_);
        let _cse_101_ = (_cse_102_ + _cse_109_);
        let _cse_100_ = sqrt(_cse_101_);
        a_plus = max(0f, max((_cse_48_ + _cse_70_), (_cse_82_ + _cse_100_)));
        a_minus = min(0f, min((_cse_48_ - _cse_70_), (_cse_82_ - _cse_100_)));
    }
    let _e582 = constants.scheme;
    if ((_e582 == 2u) && !(is_boundary_1)) {
        let _cse_122_ = max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f);
        let _cse_121_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_122_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_120_ = (_cse_121_ * 0.125f);
        let _cse_118_ = (((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + _cse_120_);
        let _cse_117_ = (_cse_118_ - _cse_1450_);
        let _cse_115_ = (_cse_1450_ + _cse_117_);
        let _cse_129_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_122_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_128_ = (_cse_129_ * 0.125f);
        let _cse_126_ = (((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + _cse_128_);
        let _cse_125_ = (_cse_126_ - _cse_1459_);
        let _cse_123_ = (_cse_1459_ + _cse_125_);
        let _cse_114_ = vec2<f32>(_cse_115_, _cse_123_);
        let _cse_134_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_122_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_133_ = (_cse_134_ * 0.125f);
        let _cse_132_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + _cse_133_);
        let _cse_131_ = (_cse_132_ - s_own_rho);
        let _cse_130_ = (s_own_rho + _cse_131_);
        let _cse_113_ = ((_cse_114_ * 1f) / vec2(_cse_130_));
        let _e648 = normal_vec;
        let _cse_112_ = dot(_cse_113_, _e648);
        let _e652 = constants.eos_gamma;
        let _cse_139_ = ((_e652 * ((((s_own_p + (s_own_p * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_122_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)) / _cse_130_);
        let _e674 = constants.eos_dp_drho;
        let _cse_138_ = (_cse_139_ + _e674);
        let _cse_142_ = (_cse_112_ * _cse_112_);
        let _cse_141_ = min(_cse_142_, _cse_138_);
        let _e680 = low_mach_params.model;
        let _cse_140_ = (max(0f, (1f - abs(f32(_e680)))) * _cse_141_);
        let _e690 = low_mach_params.model;
        let _cse_137_ = ((max(0f, (1f - abs((f32(_e690) - 2f)))) * _cse_138_) + _cse_140_);
        let _e703 = low_mach_params.theta_floor;
        let _cse_145_ = max(_cse_142_, (_e703 * _cse_138_));
        let _cse_144_ = min(_cse_145_, _cse_138_);
        let _e709 = low_mach_params.model;
        let _cse_143_ = (max(0f, (1f - abs((f32(_e709) - 1f)))) * _cse_144_);
        let _cse_136_ = (_cse_137_ + _cse_143_);
        let _cse_135_ = sqrt(_cse_136_);
        let _cse_154_ = max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f);
        let _cse_153_ = dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_154_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_152_ = (_cse_153_ * 0.125f);
        let _cse_151_ = (((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + _cse_152_);
        let _cse_150_ = (_cse_151_ - _e241);
        let _cse_149_ = (_e241 + _cse_150_);
        let _cse_159_ = dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_154_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_158_ = (_cse_159_ * 0.125f);
        let _cse_157_ = (((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + _cse_158_);
        let _cse_156_ = (_cse_157_ - _e271);
        let _cse_155_ = (_e271 + _cse_156_);
        let _cse_148_ = vec2<f32>(_cse_149_, _cse_155_);
        let _cse_164_ = dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_154_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_163_ = (_cse_164_ * 0.125f);
        let _cse_162_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + _cse_163_);
        let _cse_161_ = (_cse_162_ - _e181);
        let _cse_160_ = (_e181 + _cse_161_);
        let _cse_147_ = ((_cse_148_ * 1f) / vec2(_cse_160_));
        let _e782 = normal_vec;
        let _cse_146_ = dot(_cse_147_, _e782);
        let _e786 = constants.eos_gamma;
        let _cse_169_ = ((_e786 * ((((_e151 + (_e151 * 0.625f)) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_154_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) / _cse_160_);
        let _e808 = constants.eos_dp_drho;
        let _cse_168_ = (_cse_169_ + _e808);
        let _cse_172_ = (_cse_146_ * _cse_146_);
        let _cse_171_ = min(_cse_172_, _cse_168_);
        let _e814 = low_mach_params.model;
        let _cse_170_ = (max(0f, (1f - abs(f32(_e814)))) * _cse_171_);
        let _e824 = low_mach_params.model;
        let _cse_167_ = ((max(0f, (1f - abs((f32(_e824) - 2f)))) * _cse_168_) + _cse_170_);
        let _e837 = low_mach_params.theta_floor;
        let _cse_175_ = max(_cse_172_, (_e837 * _cse_168_));
        let _cse_174_ = min(_cse_175_, _cse_168_);
        let _e843 = low_mach_params.model;
        let _cse_173_ = (max(0f, (1f - abs((f32(_e843) - 1f)))) * _cse_174_);
        let _cse_166_ = (_cse_167_ + _cse_173_);
        let _cse_165_ = sqrt(_cse_166_);
        a_plus = max(0f, max((_cse_112_ + _cse_135_), (_cse_146_ + _cse_165_)));
        a_minus = min(0f, min((_cse_112_ - _cse_135_), (_cse_146_ - _cse_165_)));
    }
    let _e867 = constants.scheme;
    if ((_e867 == 3u) && !(is_boundary_1)) {
        let _cse_184_ = (_e241 - _cse_1450_);
        let _cse_186_ = max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f);
        let _cse_183_ = dot((((c_neigh_cell_vec - c_owner_vec) * _cse_184_) / vec2(_cse_186_)), (face_center_vec - c_owner_vec));
        let _cse_182_ = max(_cse_183_, min(_cse_184_, 0f));
        let _cse_181_ = min(_cse_182_, max(_cse_184_, 0f));
        let _cse_179_ = (_cse_1450_ + _cse_181_);
        let _cse_192_ = (_e271 - _cse_1459_);
        let _cse_191_ = dot((((c_neigh_cell_vec - c_owner_vec) * _cse_192_) / vec2(_cse_186_)), (face_center_vec - c_owner_vec));
        let _cse_190_ = max(_cse_191_, min(_cse_192_, 0f));
        let _cse_189_ = min(_cse_190_, max(_cse_192_, 0f));
        let _cse_187_ = (_cse_1459_ + _cse_189_);
        let _cse_178_ = vec2<f32>(_cse_179_, _cse_187_);
        let _cse_198_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_186_)), (face_center_vec - c_owner_vec));
        let _cse_197_ = max(_cse_198_, min((_e181 - s_own_rho), 0f));
        let _cse_196_ = min(_cse_197_, max((_e181 - s_own_rho), 0f));
        let _cse_195_ = (s_own_rho + _cse_196_);
        let _cse_194_ = (1f / _cse_195_);
        let _cse_177_ = (_cse_178_ * _cse_194_);
        let _e925 = normal_vec;
        let _cse_176_ = dot(_cse_177_, _e925);
        let _e929 = constants.eos_gamma;
        let _cse_203_ = ((_e929 * (s_own_p + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_186_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f)))) / _cse_195_);
        let _e950 = constants.eos_dp_drho;
        let _cse_202_ = (_cse_203_ + _e950);
        let _cse_206_ = (_cse_176_ * _cse_176_);
        let _cse_205_ = min(_cse_206_, _cse_202_);
        let _e956 = low_mach_params.model;
        let _cse_204_ = (max(0f, (1f - abs(f32(_e956)))) * _cse_205_);
        let _e966 = low_mach_params.model;
        let _cse_201_ = ((max(0f, (1f - abs((f32(_e966) - 2f)))) * _cse_202_) + _cse_204_);
        let _e979 = low_mach_params.theta_floor;
        let _cse_209_ = max(_cse_206_, (_e979 * _cse_202_));
        let _cse_208_ = min(_cse_209_, _cse_202_);
        let _e985 = low_mach_params.model;
        let _cse_207_ = (max(0f, (1f - abs((f32(_e985) - 1f)))) * _cse_208_);
        let _cse_200_ = (_cse_201_ + _cse_207_);
        let _cse_199_ = sqrt(_cse_200_);
        let _cse_217_ = (_cse_1450_ - _e241);
        let _cse_218_ = max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f);
        let _cse_216_ = dot((((c_owner_vec - c_neigh_cell_vec) * _cse_217_) / vec2(_cse_218_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_215_ = max(_cse_216_, min(_cse_217_, 0f));
        let _cse_214_ = min(_cse_215_, max(_cse_217_, 0f));
        let _cse_213_ = (_e241 + _cse_214_);
        let _cse_223_ = (_cse_1459_ - _e271);
        let _cse_222_ = dot((((c_owner_vec - c_neigh_cell_vec) * _cse_223_) / vec2(_cse_218_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_221_ = max(_cse_222_, min(_cse_223_, 0f));
        let _cse_220_ = min(_cse_221_, max(_cse_223_, 0f));
        let _cse_219_ = (_e271 + _cse_220_);
        let _cse_212_ = vec2<f32>(_cse_213_, _cse_219_);
        let _cse_228_ = dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_218_)), (face_center_vec - c_neigh_cell_vec));
        let _cse_227_ = max(_cse_228_, min((s_own_rho - _e181), 0f));
        let _cse_226_ = min(_cse_227_, max((s_own_rho - _e181), 0f));
        let _cse_225_ = (_e181 + _cse_226_);
        let _cse_224_ = (1f / _cse_225_);
        let _cse_211_ = (_cse_212_ * _cse_224_);
        let _e1050 = normal_vec;
        let _cse_210_ = dot(_cse_211_, _e1050);
        let _e1054 = constants.eos_gamma;
        let _cse_233_ = ((_e1054 * (_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_218_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f)))) / _cse_225_);
        let _e1075 = constants.eos_dp_drho;
        let _cse_232_ = (_cse_233_ + _e1075);
        let _cse_236_ = (_cse_210_ * _cse_210_);
        let _cse_235_ = min(_cse_236_, _cse_232_);
        let _e1081 = low_mach_params.model;
        let _cse_234_ = (max(0f, (1f - abs(f32(_e1081)))) * _cse_235_);
        let _e1091 = low_mach_params.model;
        let _cse_231_ = ((max(0f, (1f - abs((f32(_e1091) - 2f)))) * _cse_232_) + _cse_234_);
        let _e1104 = low_mach_params.theta_floor;
        let _cse_239_ = max(_cse_236_, (_e1104 * _cse_232_));
        let _cse_238_ = min(_cse_239_, _cse_232_);
        let _e1110 = low_mach_params.model;
        let _cse_237_ = (max(0f, (1f - abs((f32(_e1110) - 1f)))) * _cse_238_);
        let _cse_230_ = (_cse_231_ + _cse_237_);
        let _cse_229_ = sqrt(_cse_230_);
        a_plus = max(0f, max((_cse_176_ + _cse_199_), (_cse_210_ + _cse_229_)));
        a_minus = min(0f, min((_cse_176_ - _cse_199_), (_cse_210_ - _cse_229_)));
    }
    let _e1134 = constants.scheme;
    if ((_e1134 == 4u) && !(is_boundary_1)) {
        let _cse_248_ = (_e241 - _cse_1450_);
        let _cse_251_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_250_ = max(_cse_251_, 0.000000000001f);
        let _cse_247_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_248_) / vec2(_cse_250_));
        let _cse_246_ = dot(_cse_247_, (face_center_vec - c_owner_vec));
        let _cse_245_ = ((((_cse_246_ * abs(_cse_248_)) / max(abs(_cse_248_), (abs(_cse_246_) + 0.00000001f))) * max((_cse_248_ * _cse_246_), 0f)) / max(abs((_cse_248_ * _cse_246_)), 0.00000001f));
        let _cse_243_ = (_cse_1450_ + _cse_245_);
        let _cse_257_ = (_e271 - _cse_1459_);
        let _cse_256_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_257_) / vec2(_cse_250_));
        let _cse_255_ = dot(_cse_256_, (face_center_vec - c_owner_vec));
        let _cse_254_ = ((((_cse_255_ * abs(_cse_257_)) / max(abs(_cse_257_), (abs(_cse_255_) + 0.00000001f))) * max((_cse_257_ * _cse_255_), 0f)) / max(abs((_cse_257_ * _cse_255_)), 0.00000001f));
        let _cse_252_ = (_cse_1459_ + _cse_254_);
        let _cse_242_ = vec2<f32>(_cse_243_, _cse_252_);
        let _cse_262_ = (((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_250_));
        let _cse_261_ = dot(_cse_262_, (face_center_vec - c_owner_vec));
        let _cse_260_ = ((((_cse_261_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_261_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_261_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_261_)), 0.00000001f));
        let _cse_259_ = (s_own_rho + _cse_260_);
        let _cse_241_ = ((_cse_242_ * 1f) / vec2(_cse_259_));
        let _e1228 = normal_vec;
        let _cse_240_ = dot(_cse_241_, _e1228);
        let _e1232 = constants.eos_gamma;
        let _cse_267_ = ((_e1232 * (s_own_p + ((((dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_250_)), (face_center_vec - c_owner_vec)) * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_250_)), (face_center_vec - c_owner_vec))) + 0.00000001f))) * max(((_e151 - s_own_p) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_250_)), (face_center_vec - c_owner_vec))), 0f)) / max(abs(((_e151 - s_own_p) * dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_250_)), (face_center_vec - c_owner_vec)))), 0.00000001f)))) / _cse_259_);
        let _e1287 = constants.eos_dp_drho;
        let _cse_266_ = (_cse_267_ + _e1287);
        let _cse_270_ = (_cse_240_ * _cse_240_);
        let _cse_269_ = min(_cse_270_, _cse_266_);
        let _e1293 = low_mach_params.model;
        let _cse_268_ = (max(0f, (1f - abs(f32(_e1293)))) * _cse_269_);
        let _e1303 = low_mach_params.model;
        let _cse_265_ = ((max(0f, (1f - abs((f32(_e1303) - 2f)))) * _cse_266_) + _cse_268_);
        let _e1316 = low_mach_params.theta_floor;
        let _cse_273_ = max(_cse_270_, (_e1316 * _cse_266_));
        let _cse_272_ = min(_cse_273_, _cse_266_);
        let _e1322 = low_mach_params.model;
        let _cse_271_ = (max(0f, (1f - abs((f32(_e1322) - 1f)))) * _cse_272_);
        let _cse_264_ = (_cse_265_ + _cse_271_);
        let _cse_263_ = sqrt(_cse_264_);
        let _cse_281_ = (_cse_1450_ - _e241);
        let _cse_283_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_282_ = max(_cse_283_, 0.000000000001f);
        let _cse_280_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_281_) / vec2(_cse_282_));
        let _cse_279_ = dot(_cse_280_, (face_center_vec - c_neigh_cell_vec));
        let _cse_278_ = ((((_cse_279_ * abs(_cse_281_)) / max(abs(_cse_281_), (abs(_cse_279_) + 0.00000001f))) * max((_cse_281_ * _cse_279_), 0f)) / max(abs((_cse_281_ * _cse_279_)), 0.00000001f));
        let _cse_277_ = (_e241 + _cse_278_);
        let _cse_288_ = (_cse_1459_ - _e271);
        let _cse_287_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_288_) / vec2(_cse_282_));
        let _cse_286_ = dot(_cse_287_, (face_center_vec - c_neigh_cell_vec));
        let _cse_285_ = ((((_cse_286_ * abs(_cse_288_)) / max(abs(_cse_288_), (abs(_cse_286_) + 0.00000001f))) * max((_cse_288_ * _cse_286_), 0f)) / max(abs((_cse_288_ * _cse_286_)), 0.00000001f));
        let _cse_284_ = (_e271 + _cse_285_);
        let _cse_276_ = vec2<f32>(_cse_277_, _cse_284_);
        let _cse_292_ = (((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_282_));
        let _cse_291_ = dot(_cse_292_, (face_center_vec - c_neigh_cell_vec));
        let _cse_290_ = ((((_cse_291_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_291_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_291_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_291_)), 0.00000001f));
        let _cse_289_ = (_e181 + _cse_290_);
        let _cse_275_ = ((_cse_276_ * 1f) / vec2(_cse_289_));
        let _e1423 = normal_vec;
        let _cse_274_ = dot(_cse_275_, _e1423);
        let _e1427 = constants.eos_gamma;
        let _cse_297_ = ((_e1427 * (_e151 + ((((dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_282_)), (face_center_vec - c_neigh_cell_vec)) * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_282_)), (face_center_vec - c_neigh_cell_vec))) + 0.00000001f))) * max(((s_own_p - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_282_)), (face_center_vec - c_neigh_cell_vec))), 0f)) / max(abs(((s_own_p - _e151) * dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_282_)), (face_center_vec - c_neigh_cell_vec)))), 0.00000001f)))) / _cse_289_);
        let _e1482 = constants.eos_dp_drho;
        let _cse_296_ = (_cse_297_ + _e1482);
        let _cse_300_ = (_cse_274_ * _cse_274_);
        let _cse_299_ = min(_cse_300_, _cse_296_);
        let _e1488 = low_mach_params.model;
        let _cse_298_ = (max(0f, (1f - abs(f32(_e1488)))) * _cse_299_);
        let _e1498 = low_mach_params.model;
        let _cse_295_ = ((max(0f, (1f - abs((f32(_e1498) - 2f)))) * _cse_296_) + _cse_298_);
        let _e1511 = low_mach_params.theta_floor;
        let _cse_303_ = max(_cse_300_, (_e1511 * _cse_296_));
        let _cse_302_ = min(_cse_303_, _cse_296_);
        let _e1517 = low_mach_params.model;
        let _cse_301_ = (max(0f, (1f - abs((f32(_e1517) - 1f)))) * _cse_302_);
        let _cse_294_ = (_cse_295_ + _cse_301_);
        let _cse_293_ = sqrt(_cse_294_);
        a_plus = max(0f, max((_cse_240_ + _cse_263_), (_cse_274_ + _cse_293_)));
        a_minus = min(0f, min((_cse_240_ - _cse_263_), (_cse_274_ - _cse_293_)));
    }
    let _e1541 = constants.scheme;
    if ((_e1541 == 5u) && !(is_boundary_1)) {
        let _cse_314_ = (_e241 - _cse_1450_);
        let _cse_312_ = (((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_314_) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_311_ = (_cse_312_ - _cse_1450_);
        let _cse_310_ = max(_cse_311_, min(_cse_314_, 0f));
        let _cse_309_ = min(_cse_310_, max(_cse_314_, 0f));
        let _cse_307_ = (_cse_1450_ + _cse_309_);
        let _cse_322_ = (_e271 - _cse_1459_);
        let _cse_320_ = (((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_322_) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_319_ = (_cse_320_ - _cse_1459_);
        let _cse_318_ = max(_cse_319_, min(_cse_322_, 0f));
        let _cse_317_ = min(_cse_318_, max(_cse_322_, 0f));
        let _cse_315_ = (_cse_1459_ + _cse_317_);
        let _cse_306_ = vec2<f32>(_cse_307_, _cse_315_);
        let _cse_326_ = ((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho);
        let _cse_325_ = max(_cse_326_, min((_e181 - s_own_rho), 0f));
        let _cse_324_ = min(_cse_325_, max((_e181 - s_own_rho), 0f));
        let _cse_323_ = (s_own_rho + _cse_324_);
        let _cse_305_ = ((_cse_306_ * 1f) / vec2(_cse_323_));
        let _e1637 = normal_vec;
        let _cse_304_ = dot(_cse_305_, _e1637);
        let _e1641 = constants.eos_gamma;
        let _cse_331_ = ((_e1641 * (s_own_p + min(max(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f))), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f)))) / _cse_323_);
        let _e1676 = constants.eos_dp_drho;
        let _cse_330_ = (_cse_331_ + _e1676);
        let _cse_334_ = (_cse_304_ * _cse_304_);
        let _cse_333_ = min(_cse_334_, _cse_330_);
        let _e1682 = low_mach_params.model;
        let _cse_332_ = (max(0f, (1f - abs(f32(_e1682)))) * _cse_333_);
        let _e1692 = low_mach_params.model;
        let _cse_329_ = ((max(0f, (1f - abs((f32(_e1692) - 2f)))) * _cse_330_) + _cse_332_);
        let _e1705 = low_mach_params.theta_floor;
        let _cse_337_ = max(_cse_334_, (_e1705 * _cse_330_));
        let _cse_336_ = min(_cse_337_, _cse_330_);
        let _e1711 = low_mach_params.model;
        let _cse_335_ = (max(0f, (1f - abs((f32(_e1711) - 1f)))) * _cse_336_);
        let _cse_328_ = (_cse_329_ + _cse_335_);
        let _cse_327_ = sqrt(_cse_328_);
        let _cse_346_ = (_cse_1450_ - _e241);
        let _cse_345_ = (((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_346_) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_344_ = (_cse_345_ - _e241);
        let _cse_343_ = max(_cse_344_, min(_cse_346_, 0f));
        let _cse_342_ = min(_cse_343_, max(_cse_346_, 0f));
        let _cse_341_ = (_e241 + _cse_342_);
        let _cse_352_ = (_cse_1459_ - _e271);
        let _cse_351_ = (((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_352_) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_350_ = (_cse_351_ - _e271);
        let _cse_349_ = max(_cse_350_, min(_cse_352_, 0f));
        let _cse_348_ = min(_cse_349_, max(_cse_352_, 0f));
        let _cse_347_ = (_e271 + _cse_348_);
        let _cse_340_ = vec2<f32>(_cse_341_, _cse_347_);
        let _cse_356_ = ((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181);
        let _cse_355_ = max(_cse_356_, min((s_own_rho - _e181), 0f));
        let _cse_354_ = min(_cse_355_, max((s_own_rho - _e181), 0f));
        let _cse_353_ = (_e181 + _cse_354_);
        let _cse_339_ = ((_cse_340_ * 1f) / vec2(_cse_353_));
        let _e1814 = normal_vec;
        let _cse_338_ = dot(_cse_339_, _e1814);
        let _e1818 = constants.eos_gamma;
        let _cse_361_ = ((_e1818 * (_e151 + min(max(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f))), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f)))) / _cse_353_);
        let _e1853 = constants.eos_dp_drho;
        let _cse_360_ = (_cse_361_ + _e1853);
        let _cse_364_ = (_cse_338_ * _cse_338_);
        let _cse_363_ = min(_cse_364_, _cse_360_);
        let _e1859 = low_mach_params.model;
        let _cse_362_ = (max(0f, (1f - abs(f32(_e1859)))) * _cse_363_);
        let _e1869 = low_mach_params.model;
        let _cse_359_ = ((max(0f, (1f - abs((f32(_e1869) - 2f)))) * _cse_360_) + _cse_362_);
        let _e1882 = low_mach_params.theta_floor;
        let _cse_367_ = max(_cse_364_, (_e1882 * _cse_360_));
        let _cse_366_ = min(_cse_367_, _cse_360_);
        let _e1888 = low_mach_params.model;
        let _cse_365_ = (max(0f, (1f - abs((f32(_e1888) - 1f)))) * _cse_366_);
        let _cse_358_ = (_cse_359_ + _cse_365_);
        let _cse_357_ = sqrt(_cse_358_);
        a_plus = max(0f, max((_cse_304_ + _cse_327_), (_cse_338_ + _cse_357_)));
        a_minus = min(0f, min((_cse_304_ - _cse_327_), (_cse_338_ - _cse_357_)));
    }
    let _e1912 = constants.scheme;
    if ((_e1912 == 6u) && !(is_boundary_1)) {
        let _cse_378_ = max(dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec)), 0.000000000001f);
        let _cse_376_ = (((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_375_ = (_cse_376_ - _cse_1450_);
        let _cse_374_ = ((_cse_375_ * abs((_e241 - _cse_1450_))) / max(abs((_e241 - _cse_1450_)), (abs(_cse_375_) + 0.00000001f)));
        let _cse_379_ = ((_e241 - _cse_1450_) * _cse_375_);
        let _cse_373_ = ((_cse_374_ * max(_cse_379_, 0f)) / max(abs(_cse_379_), 0.00000001f));
        let _cse_371_ = (_cse_1450_ + _cse_373_);
        let _cse_385_ = (((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_384_ = (_cse_385_ - _cse_1459_);
        let _cse_383_ = ((_cse_384_ * abs((_e271 - _cse_1459_))) / max(abs((_e271 - _cse_1459_)), (abs(_cse_384_) + 0.00000001f)));
        let _cse_387_ = ((_e271 - _cse_1459_) * _cse_384_);
        let _cse_382_ = ((_cse_383_ * max(_cse_387_, 0f)) / max(abs(_cse_387_), 0.00000001f));
        let _cse_380_ = (_cse_1459_ + _cse_382_);
        let _cse_370_ = vec2<f32>(_cse_371_, _cse_380_);
        let _cse_391_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_390_ = (_cse_391_ - s_own_rho);
        let _cse_389_ = ((((_cse_390_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_390_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_390_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_390_)), 0.00000001f));
        let _cse_388_ = (s_own_rho + _cse_389_);
        let _cse_369_ = ((_cse_370_ * 1f) / vec2(_cse_388_));
        let _e2037 = normal_vec;
        let _cse_368_ = dot(_cse_369_, _e2037);
        let _e2041 = constants.eos_gamma;
        let _cse_396_ = ((_e2041 * (s_own_p + ((((((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p) * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)) + 0.00000001f))) * max(((_e151 - s_own_p) * ((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)), 0f)) / max(abs(((_e151 - s_own_p) * ((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_378_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p))), 0.00000001f)))) / _cse_388_);
        let _e2132 = constants.eos_dp_drho;
        let _cse_395_ = (_cse_396_ + _e2132);
        let _cse_399_ = (_cse_368_ * _cse_368_);
        let _cse_398_ = min(_cse_399_, _cse_395_);
        let _e2138 = low_mach_params.model;
        let _cse_397_ = (max(0f, (1f - abs(f32(_e2138)))) * _cse_398_);
        let _e2148 = low_mach_params.model;
        let _cse_394_ = ((max(0f, (1f - abs((f32(_e2148) - 2f)))) * _cse_395_) + _cse_397_);
        let _e2161 = low_mach_params.theta_floor;
        let _cse_402_ = max(_cse_399_, (_e2161 * _cse_395_));
        let _cse_401_ = min(_cse_402_, _cse_395_);
        let _e2167 = low_mach_params.model;
        let _cse_400_ = (max(0f, (1f - abs((f32(_e2167) - 1f)))) * _cse_401_);
        let _cse_393_ = (_cse_394_ + _cse_400_);
        let _cse_392_ = sqrt(_cse_393_);
        let _cse_410_ = max(dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec)), 0.000000000001f);
        let _cse_409_ = (((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_408_ = (_cse_409_ - _e241);
        let _cse_411_ = ((_cse_1450_ - _e241) * _cse_408_);
        let _cse_407_ = ((((_cse_408_ * abs((_cse_1450_ - _e241))) / max(abs((_cse_1450_ - _e241)), (abs(_cse_408_) + 0.00000001f))) * max(_cse_411_, 0f)) / max(abs(_cse_411_), 0.00000001f));
        let _cse_406_ = (_e241 + _cse_407_);
        let _cse_415_ = (((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_414_ = (_cse_415_ - _e271);
        let _cse_416_ = ((_cse_1459_ - _e271) * _cse_414_);
        let _cse_413_ = ((((_cse_414_ * abs((_cse_1459_ - _e271))) / max(abs((_cse_1459_ - _e271)), (abs(_cse_414_) + 0.00000001f))) * max(_cse_416_, 0f)) / max(abs(_cse_416_), 0.00000001f));
        let _cse_412_ = (_e271 + _cse_413_);
        let _cse_405_ = vec2<f32>(_cse_406_, _cse_412_);
        let _cse_420_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_419_ = (_cse_420_ - _e181);
        let _cse_418_ = ((((_cse_419_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_419_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_419_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_419_)), 0.00000001f));
        let _cse_417_ = (_e181 + _cse_418_);
        let _cse_404_ = ((_cse_405_ * 1f) / vec2(_cse_417_));
        let _e2299 = normal_vec;
        let _cse_403_ = dot(_cse_404_, _e2299);
        let _e2303 = constants.eos_gamma;
        let _cse_425_ = ((_e2303 * (_e151 + ((((((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) + 0.00000001f))) * max(((s_own_p - _e151) * ((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)), 0f)) / max(abs(((s_own_p - _e151) * ((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_410_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))), 0.00000001f)))) / _cse_417_);
        let _e2394 = constants.eos_dp_drho;
        let _cse_424_ = (_cse_425_ + _e2394);
        let _cse_428_ = (_cse_403_ * _cse_403_);
        let _cse_427_ = min(_cse_428_, _cse_424_);
        let _e2400 = low_mach_params.model;
        let _cse_426_ = (max(0f, (1f - abs(f32(_e2400)))) * _cse_427_);
        let _e2410 = low_mach_params.model;
        let _cse_423_ = ((max(0f, (1f - abs((f32(_e2410) - 2f)))) * _cse_424_) + _cse_426_);
        let _e2423 = low_mach_params.theta_floor;
        let _cse_431_ = max(_cse_428_, (_e2423 * _cse_424_));
        let _cse_430_ = min(_cse_431_, _cse_424_);
        let _e2429 = low_mach_params.model;
        let _cse_429_ = (max(0f, (1f - abs((f32(_e2429) - 1f)))) * _cse_430_);
        let _cse_422_ = (_cse_423_ + _cse_429_);
        let _cse_421_ = sqrt(_cse_422_);
        a_plus = max(0f, max((_cse_368_ + _cse_392_), (_cse_403_ + _cse_421_)));
        a_minus = min(0f, min((_cse_368_ - _cse_392_), (_cse_403_ - _cse_421_)));
    }
    let _e2451 = a_plus;
    let _e2452 = a_minus;
    let denom = max((_e2451 - _e2452), 0.000001f);
    let _e2458 = low_mach_params.model;
    let _cse_437_ = (f32(_e2458) - 2f);
    let _cse_436_ = abs(_cse_437_);
    let _cse_435_ = (1f - _cse_436_);
    let _cse_434_ = max(0f, _cse_435_);
    let _cse_433_ = (1f - _cse_434_);
    let _e2471 = low_mach_params.pressure_coupling_alpha;
    let _cse_432_ = (_cse_433_ * _e2471);
    let _e2475 = constants.eos_theta_ref;
    let _e2479 = constants.eos_dp_drho;
    let _e2484 = constants.eos_p_offset;
    let _e2490 = constants.eos_gamma;
    let _e2495 = constants.eos_dp_drho;
    u_l_0_ = (s_own_rho + ((_cse_432_ * (s_own_p - (((s_own_rho * _e2475) + (s_own_rho * _e2479)) - _e2484))) / max((((_e2490 * s_own_p) / s_own_rho) + _e2495), 0.000000000001f)));
    let _e2504 = constants.eos_theta_ref;
    let _e2508 = constants.eos_dp_drho;
    let _e2513 = constants.eos_p_offset;
    let _e2519 = constants.eos_gamma;
    let _e2524 = constants.eos_dp_drho;
    u_r_0_ = (_e181 + ((_cse_432_ * (_e151 - (((_e181 * _e2504) + (_e181 * _e2508)) - _e2513))) / max((((_e2519 * _e151) / _e181) + _e2524), 0.000000000001f)));
    let _e2536 = normal_vec;
    f_l_0_ = (s_own_rho * dot(((vec2<f32>(_cse_1450_, _cse_1459_) * 1f) / vec2(s_own_rho)), _e2536));
    let _e2545 = normal_vec;
    f_r_0_ = (_e181 * dot(((vec2<f32>(_e241, _e271) * 1f) / vec2(_e181)), _e2545));
    let _e2551 = constants.scheme;
    if ((_e2551 == 1u) && !(is_boundary_1)) {
        let _cse_443_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_442_ = max(_cse_443_, 0.000000000001f);
        let _cse_441_ = ((_e181 - s_own_rho) / _cse_442_);
        let _cse_440_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_441_);
        let _cse_439_ = dot(_cse_440_, (face_center_vec - c_owner_vec));
        let _cse_438_ = (s_own_rho + _cse_439_);
        let _e2570 = low_mach_params.model;
        let _cse_449_ = (f32(_e2570) - 2f);
        let _cse_448_ = abs(_cse_449_);
        let _cse_447_ = (1f - _cse_448_);
        let _cse_446_ = max(0f, _cse_447_);
        let _cse_445_ = (1f - _cse_446_);
        let _e2583 = low_mach_params.pressure_coupling_alpha;
        let _cse_444_ = (_cse_445_ * _e2583);
        let _cse_453_ = ((_e151 - s_own_p) / _cse_442_);
        let _cse_452_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_453_);
        let _cse_451_ = dot(_cse_452_, (face_center_vec - c_owner_vec));
        let _cse_450_ = (s_own_p + _cse_451_);
        let _cse_459_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_458_ = max(_cse_459_, 0.000000000001f);
        let _cse_457_ = ((s_own_rho - _e181) / _cse_458_);
        let _cse_456_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_457_);
        let _cse_455_ = dot(_cse_456_, (face_center_vec - c_neigh_cell_vec));
        let _cse_454_ = (_e181 + _cse_455_);
        let _cse_463_ = ((s_own_p - _e151) / _cse_458_);
        let _cse_462_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_463_);
        let _cse_461_ = dot(_cse_462_, (face_center_vec - c_neigh_cell_vec));
        let _cse_460_ = (_e151 + _cse_461_);
        let _e2613 = constants.eos_theta_ref;
        let _e2617 = constants.eos_dp_drho;
        let _e2622 = constants.eos_p_offset;
        let _e2628 = constants.eos_gamma;
        let _e2633 = constants.eos_dp_drho;
        u_l_0_ = (_cse_438_ + ((_cse_444_ * (_cse_450_ - (((_cse_438_ * _e2613) + (_cse_438_ * _e2617)) - _e2622))) / max((((_e2628 * _cse_450_) / _cse_438_) + _e2633), 0.000000000001f)));
        let _e2641 = constants.eos_theta_ref;
        let _e2645 = constants.eos_dp_drho;
        let _e2650 = constants.eos_p_offset;
        let _e2656 = constants.eos_gamma;
        let _e2661 = constants.eos_dp_drho;
        u_r_0_ = (_cse_454_ + ((_cse_444_ * (_cse_460_ - (((_cse_454_ * _e2641) + (_cse_454_ * _e2645)) - _e2650))) / max((((_e2656 * _cse_460_) / _cse_454_) + _e2661), 0.000000000001f)));
        let _e2688 = normal_vec;
        f_l_0_ = (_cse_438_ * dot(((vec2<f32>((_cse_1450_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_442_)), (face_center_vec - c_owner_vec))), (_cse_1459_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_442_)), (face_center_vec - c_owner_vec)))) * 1f) / vec2(_cse_438_)), _e2688));
        let _e2712 = normal_vec;
        f_r_0_ = (_cse_454_ * dot(((vec2<f32>((_e241 + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_458_)), (face_center_vec - c_neigh_cell_vec))), (_e271 + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_458_)), (face_center_vec - c_neigh_cell_vec)))) * 1f) / vec2(_cse_454_)), _e2712));
    }
    let _e2717 = constants.scheme;
    if ((_e2717 == 2u) && !(is_boundary_1)) {
        let _cse_471_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_477_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_476_ = max(_cse_477_, 0.000000000001f);
        let _cse_475_ = ((_e181 - s_own_rho) / _cse_476_);
        let _cse_474_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_475_);
        let _cse_473_ = dot(_cse_474_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_472_ = (_cse_473_ * 0.125f);
        let _cse_470_ = (_cse_471_ + _cse_472_);
        let _cse_469_ = (_cse_470_ - s_own_rho);
        let _cse_468_ = (s_own_rho + _cse_469_);
        let _e2745 = low_mach_params.model;
        let _cse_483_ = (f32(_e2745) - 2f);
        let _cse_482_ = abs(_cse_483_);
        let _cse_481_ = (1f - _cse_482_);
        let _cse_480_ = max(0f, _cse_481_);
        let _cse_479_ = (1f - _cse_480_);
        let _e2758 = low_mach_params.pressure_coupling_alpha;
        let _cse_478_ = (_cse_479_ * _e2758);
        let _cse_487_ = ((s_own_p * 0.625f) + (_e151 * 0.375f));
        let _cse_491_ = ((_e151 - s_own_p) / _cse_476_);
        let _cse_490_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_491_);
        let _cse_489_ = dot(_cse_490_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_488_ = (_cse_489_ * 0.125f);
        let _cse_486_ = (_cse_487_ + _cse_488_);
        let _cse_485_ = (_cse_486_ - s_own_p);
        let _cse_484_ = (s_own_p + _cse_485_);
        let _cse_495_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_501_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_500_ = max(_cse_501_, 0.000000000001f);
        let _cse_499_ = ((s_own_rho - _e181) / _cse_500_);
        let _cse_498_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_499_);
        let _cse_497_ = dot(_cse_498_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_496_ = (_cse_497_ * 0.125f);
        let _cse_494_ = (_cse_495_ + _cse_496_);
        let _cse_493_ = (_cse_494_ - _e181);
        let _cse_492_ = (_e181 + _cse_493_);
        let _cse_505_ = ((_e151 * 0.625f) + (s_own_p * 0.375f));
        let _cse_509_ = ((s_own_p - _e151) / _cse_500_);
        let _cse_508_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_509_);
        let _cse_507_ = dot(_cse_508_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_506_ = (_cse_507_ * 0.125f);
        let _cse_504_ = (_cse_505_ + _cse_506_);
        let _cse_503_ = (_cse_504_ - _e151);
        let _cse_502_ = (_e151 + _cse_503_);
        let _e2815 = constants.eos_theta_ref;
        let _e2819 = constants.eos_dp_drho;
        let _e2824 = constants.eos_p_offset;
        let _e2830 = constants.eos_gamma;
        let _e2835 = constants.eos_dp_drho;
        u_l_0_ = (_cse_468_ + ((_cse_478_ * (_cse_484_ - (((_cse_468_ * _e2815) + (_cse_468_ * _e2819)) - _e2824))) / max((((_e2830 * _cse_484_) / _cse_468_) + _e2835), 0.000000000001f)));
        let _e2843 = constants.eos_theta_ref;
        let _e2847 = constants.eos_dp_drho;
        let _e2852 = constants.eos_p_offset;
        let _e2858 = constants.eos_gamma;
        let _e2863 = constants.eos_dp_drho;
        u_r_0_ = (_cse_492_ + ((_cse_478_ * (_cse_502_ - (((_cse_492_ * _e2843) + (_cse_492_ * _e2847)) - _e2852))) / max((((_e2858 * _cse_502_) / _cse_492_) + _e2863), 0.000000000001f)));
        let _e2908 = normal_vec;
        f_l_0_ = (_cse_468_ * dot(((vec2<f32>(((((_cse_1450_ + (_cse_1450_ * 0.625f)) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_476_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1450_), ((((_cse_1459_ + (_cse_1459_ * 0.625f)) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_476_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1459_)) * 1f) / vec2(_cse_468_)), _e2908));
        let _e2950 = normal_vec;
        f_r_0_ = (_cse_492_ * dot(((vec2<f32>(((((_e241 + (_e241 * 0.625f)) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_500_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e241), ((((_e271 + (_e271 * 0.625f)) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_500_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e271)) * 1f) / vec2(_cse_492_)), _e2950));
    }
    let _e2955 = constants.scheme;
    if ((_e2955 == 3u) && !(is_boundary_1)) {
        let _cse_521_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_520_ = max(_cse_521_, 0.000000000001f);
        let _cse_519_ = ((_e181 - s_own_rho) / _cse_520_);
        let _cse_518_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_519_);
        let _cse_517_ = dot(_cse_518_, (face_center_vec - c_owner_vec));
        let _cse_522_ = min((_e181 - s_own_rho), 0f);
        let _cse_516_ = max(_cse_517_, _cse_522_);
        let _cse_523_ = max((_e181 - s_own_rho), 0f);
        let _cse_515_ = min(_cse_516_, _cse_523_);
        let _cse_514_ = (s_own_rho + _cse_515_);
        let _e2982 = low_mach_params.model;
        let _cse_529_ = (f32(_e2982) - 2f);
        let _cse_528_ = abs(_cse_529_);
        let _cse_527_ = (1f - _cse_528_);
        let _cse_526_ = max(0f, _cse_527_);
        let _cse_525_ = (1f - _cse_526_);
        let _e2995 = low_mach_params.pressure_coupling_alpha;
        let _cse_524_ = (_cse_525_ * _e2995);
        let _cse_535_ = ((_e151 - s_own_p) / _cse_520_);
        let _cse_534_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_535_);
        let _cse_533_ = dot(_cse_534_, (face_center_vec - c_owner_vec));
        let _cse_536_ = min((_e151 - s_own_p), 0f);
        let _cse_532_ = max(_cse_533_, _cse_536_);
        let _cse_537_ = max((_e151 - s_own_p), 0f);
        let _cse_531_ = min(_cse_532_, _cse_537_);
        let _cse_530_ = (s_own_p + _cse_531_);
        let _cse_545_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_544_ = max(_cse_545_, 0.000000000001f);
        let _cse_543_ = ((s_own_rho - _e181) / _cse_544_);
        let _cse_542_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_543_);
        let _cse_541_ = dot(_cse_542_, (face_center_vec - c_neigh_cell_vec));
        let _cse_546_ = min((s_own_rho - _e181), 0f);
        let _cse_540_ = max(_cse_541_, _cse_546_);
        let _cse_547_ = max((s_own_rho - _e181), 0f);
        let _cse_539_ = min(_cse_540_, _cse_547_);
        let _cse_538_ = (_e181 + _cse_539_);
        let _cse_553_ = ((s_own_p - _e151) / _cse_544_);
        let _cse_552_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_553_);
        let _cse_551_ = dot(_cse_552_, (face_center_vec - c_neigh_cell_vec));
        let _cse_554_ = min((s_own_p - _e151), 0f);
        let _cse_550_ = max(_cse_551_, _cse_554_);
        let _cse_555_ = max((s_own_p - _e151), 0f);
        let _cse_549_ = min(_cse_550_, _cse_555_);
        let _cse_548_ = (_e151 + _cse_549_);
        let _cse_557_ = (_e241 - _cse_1450_);
        let _cse_560_ = (_e271 - _cse_1459_);
        let _cse_562_ = (_cse_1450_ - _e241);
        let _cse_563_ = (_cse_1459_ - _e271);
        let _e3053 = constants.eos_theta_ref;
        let _e3057 = constants.eos_dp_drho;
        let _e3062 = constants.eos_p_offset;
        let _e3068 = constants.eos_gamma;
        let _e3073 = constants.eos_dp_drho;
        u_l_0_ = (_cse_514_ + ((_cse_524_ * (_cse_530_ - (((_cse_514_ * _e3053) + (_cse_514_ * _e3057)) - _e3062))) / max((((_e3068 * _cse_530_) / _cse_514_) + _e3073), 0.000000000001f)));
        let _e3081 = constants.eos_theta_ref;
        let _e3085 = constants.eos_dp_drho;
        let _e3090 = constants.eos_p_offset;
        let _e3096 = constants.eos_gamma;
        let _e3101 = constants.eos_dp_drho;
        u_r_0_ = (_cse_538_ + ((_cse_524_ * (_cse_548_ - (((_cse_538_ * _e3081) + (_cse_538_ * _e3085)) - _e3090))) / max((((_e3096 * _cse_548_) / _cse_538_) + _e3101), 0.000000000001f)));
        let _e3138 = normal_vec;
        f_l_0_ = (_cse_514_ * dot(((vec2<f32>((_cse_1450_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_557_) / vec2(_cse_520_)), (face_center_vec - c_owner_vec)), min(_cse_557_, 0f)), max(_cse_557_, 0f))), (_cse_1459_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_560_) / vec2(_cse_520_)), (face_center_vec - c_owner_vec)), min(_cse_560_, 0f)), max(_cse_560_, 0f)))) * 1f) / vec2(_cse_514_)), _e3138));
        let _e3172 = normal_vec;
        f_r_0_ = (_cse_538_ * dot(((vec2<f32>((_e241 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_562_) / vec2(_cse_544_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_562_, 0f)), max(_cse_562_, 0f))), (_e271 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_563_) / vec2(_cse_544_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_563_, 0f)), max(_cse_563_, 0f)))) * 1f) / vec2(_cse_538_)), _e3172));
    }
    let _e3177 = constants.scheme;
    if ((_e3177 == 4u) && !(is_boundary_1)) {
        let _cse_571_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_570_ = max(_cse_571_, 0.000000000001f);
        let _cse_569_ = ((_e181 - s_own_rho) / _cse_570_);
        let _cse_568_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_569_);
        let _cse_567_ = dot(_cse_568_, (face_center_vec - c_owner_vec));
        let _cse_575_ = abs(_cse_567_);
        let _cse_574_ = (_cse_575_ + 0.00000001f);
        let _cse_573_ = max(abs((_e181 - s_own_rho)), _cse_574_);
        let _cse_572_ = (abs((_e181 - s_own_rho)) / _cse_573_);
        let _cse_566_ = (_cse_567_ * _cse_572_);
        let _cse_578_ = ((_e181 - s_own_rho) * _cse_567_);
        let _cse_577_ = max(_cse_578_, 0f);
        let _cse_580_ = abs(_cse_578_);
        let _cse_579_ = max(_cse_580_, 0.00000001f);
        let _cse_576_ = (_cse_577_ / _cse_579_);
        let _cse_565_ = (_cse_566_ * _cse_576_);
        let _cse_564_ = (s_own_rho + _cse_565_);
        let _cse_585_ = ((_e151 - s_own_p) / _cse_570_);
        let _cse_584_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_585_);
        let _cse_583_ = dot(_cse_584_, (face_center_vec - c_owner_vec));
        let _cse_582_ = ((((_cse_583_ * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(_cse_583_) + 0.00000001f))) * max(((_e151 - s_own_p) * _cse_583_), 0f)) / max(abs(((_e151 - s_own_p) * _cse_583_)), 0.00000001f));
        let _cse_581_ = (s_own_p + _cse_582_);
        let _cse_593_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_592_ = max(_cse_593_, 0.000000000001f);
        let _cse_591_ = ((s_own_rho - _e181) / _cse_592_);
        let _cse_590_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_591_);
        let _cse_589_ = dot(_cse_590_, (face_center_vec - c_neigh_cell_vec));
        let _cse_597_ = abs(_cse_589_);
        let _cse_596_ = (_cse_597_ + 0.00000001f);
        let _cse_595_ = max(abs((s_own_rho - _e181)), _cse_596_);
        let _cse_594_ = (abs((s_own_rho - _e181)) / _cse_595_);
        let _cse_588_ = (_cse_589_ * _cse_594_);
        let _cse_600_ = ((s_own_rho - _e181) * _cse_589_);
        let _cse_599_ = max(_cse_600_, 0f);
        let _cse_602_ = abs(_cse_600_);
        let _cse_601_ = max(_cse_602_, 0.00000001f);
        let _cse_598_ = (_cse_599_ / _cse_601_);
        let _cse_587_ = (_cse_588_ * _cse_598_);
        let _cse_586_ = (_e181 + _cse_587_);
        let _cse_607_ = ((s_own_p - _e151) / _cse_592_);
        let _cse_606_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_607_);
        let _cse_605_ = dot(_cse_606_, (face_center_vec - c_neigh_cell_vec));
        let _cse_604_ = ((((_cse_605_ * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(_cse_605_) + 0.00000001f))) * max(((s_own_p - _e151) * _cse_605_), 0f)) / max(abs(((s_own_p - _e151) * _cse_605_)), 0.00000001f));
        let _cse_603_ = (_e151 + _cse_604_);
        let _cse_612_ = (_e241 - _cse_1450_);
        let _cse_611_ = (_cse_612_ / _cse_570_);
        let _cse_610_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_611_);
        let _cse_609_ = dot(_cse_610_, (face_center_vec - c_owner_vec));
        let _cse_618_ = (_e271 - _cse_1459_);
        let _cse_617_ = (_cse_618_ / _cse_570_);
        let _cse_616_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_617_);
        let _cse_615_ = dot(_cse_616_, (face_center_vec - c_owner_vec));
        let _cse_623_ = (_cse_1450_ - _e241);
        let _cse_622_ = (_cse_623_ / _cse_592_);
        let _cse_621_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_622_);
        let _cse_620_ = dot(_cse_621_, (face_center_vec - c_neigh_cell_vec));
        let _cse_627_ = (_cse_1459_ - _e271);
        let _cse_626_ = (_cse_627_ / _cse_592_);
        let _cse_625_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_626_);
        let _cse_624_ = dot(_cse_625_, (face_center_vec - c_neigh_cell_vec));
        let _e3326 = low_mach_params.model;
        let _e3339 = low_mach_params.pressure_coupling_alpha;
        let _e3343 = constants.eos_theta_ref;
        let _e3347 = constants.eos_dp_drho;
        let _e3352 = constants.eos_p_offset;
        let _e3358 = constants.eos_gamma;
        let _e3363 = constants.eos_dp_drho;
        u_l_0_ = (_cse_564_ + ((((1f - max(0f, (1f - abs((f32(_e3326) - 2f))))) * _e3339) * (_cse_581_ - (((_cse_564_ * _e3343) + (_cse_564_ * _e3347)) - _e3352))) / max((((_e3358 * _cse_581_) / _cse_564_) + _e3363), 0.000000000001f)));
        let _e3371 = low_mach_params.model;
        let _e3384 = low_mach_params.pressure_coupling_alpha;
        let _e3388 = constants.eos_theta_ref;
        let _e3392 = constants.eos_dp_drho;
        let _e3397 = constants.eos_p_offset;
        let _e3403 = constants.eos_gamma;
        let _e3408 = constants.eos_dp_drho;
        u_r_0_ = (_cse_586_ + ((((1f - max(0f, (1f - abs((f32(_e3371) - 2f))))) * _e3384) * (_cse_603_ - (((_cse_586_ * _e3388) + (_cse_586_ * _e3392)) - _e3397))) / max((((_e3403 * _cse_603_) / _cse_586_) + _e3408), 0.000000000001f)));
        let _e3455 = normal_vec;
        f_l_0_ = (_cse_564_ * dot(((vec2<f32>((_cse_1450_ + ((((_cse_609_ * abs(_cse_612_)) / max(abs(_cse_612_), (abs(_cse_609_) + 0.00000001f))) * max((_cse_612_ * _cse_609_), 0f)) / max(abs((_cse_612_ * _cse_609_)), 0.00000001f))), (_cse_1459_ + ((((_cse_615_ * abs(_cse_618_)) / max(abs(_cse_618_), (abs(_cse_615_) + 0.00000001f))) * max((_cse_618_ * _cse_615_), 0f)) / max(abs((_cse_618_ * _cse_615_)), 0.00000001f)))) * 1f) / vec2(_cse_564_)), _e3455));
        let _e3499 = normal_vec;
        f_r_0_ = (_cse_586_ * dot(((vec2<f32>((_e241 + ((((_cse_620_ * abs(_cse_623_)) / max(abs(_cse_623_), (abs(_cse_620_) + 0.00000001f))) * max((_cse_623_ * _cse_620_), 0f)) / max(abs((_cse_623_ * _cse_620_)), 0.00000001f))), (_e271 + ((((_cse_624_ * abs(_cse_627_)) / max(abs(_cse_627_), (abs(_cse_624_) + 0.00000001f))) * max((_cse_627_ * _cse_624_), 0f)) / max(abs((_cse_627_ * _cse_624_)), 0.00000001f)))) * 1f) / vec2(_cse_586_)), _e3499));
    }
    let _e3504 = constants.scheme;
    if ((_e3504 == 5u) && !(is_boundary_1)) {
        let _cse_633_ = ((s_own_rho * 0.625f) + (_e181 * 0.375f));
        let _cse_639_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_638_ = max(_cse_639_, 0.000000000001f);
        let _cse_637_ = ((_e181 - s_own_rho) / _cse_638_);
        let _cse_636_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_637_);
        let _cse_635_ = dot(_cse_636_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_634_ = (_cse_635_ * 0.125f);
        let _cse_632_ = (_cse_633_ + _cse_634_);
        let _cse_631_ = (_cse_632_ - s_own_rho);
        let _cse_640_ = min((_e181 - s_own_rho), 0f);
        let _cse_630_ = max(_cse_631_, _cse_640_);
        let _cse_641_ = max((_e181 - s_own_rho), 0f);
        let _cse_629_ = min(_cse_630_, _cse_641_);
        let _cse_628_ = (s_own_rho + _cse_629_);
        let _e3540 = low_mach_params.model;
        let _cse_646_ = abs((f32(_e3540) - 2f));
        let _cse_645_ = (1f - _cse_646_);
        let _cse_644_ = max(0f, _cse_645_);
        let _cse_643_ = (1f - _cse_644_);
        let _e3553 = low_mach_params.pressure_coupling_alpha;
        let _cse_642_ = (_cse_643_ * _e3553);
        let _cse_652_ = ((s_own_p * 0.625f) + (_e151 * 0.375f));
        let _cse_656_ = ((_e151 - s_own_p) / _cse_638_);
        let _cse_655_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_656_);
        let _cse_654_ = dot(_cse_655_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_653_ = (_cse_654_ * 0.125f);
        let _cse_651_ = (_cse_652_ + _cse_653_);
        let _cse_650_ = (_cse_651_ - s_own_p);
        let _cse_649_ = max(_cse_650_, min((_e151 - s_own_p), 0f));
        let _cse_657_ = max((_e151 - s_own_p), 0f);
        let _cse_648_ = min(_cse_649_, _cse_657_);
        let _cse_647_ = (s_own_p + _cse_648_);
        let _cse_663_ = ((_e181 * 0.625f) + (s_own_rho * 0.375f));
        let _cse_669_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_668_ = max(_cse_669_, 0.000000000001f);
        let _cse_667_ = ((s_own_rho - _e181) / _cse_668_);
        let _cse_666_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_667_);
        let _cse_665_ = dot(_cse_666_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_664_ = (_cse_665_ * 0.125f);
        let _cse_662_ = (_cse_663_ + _cse_664_);
        let _cse_661_ = (_cse_662_ - _e181);
        let _cse_670_ = min((s_own_rho - _e181), 0f);
        let _cse_660_ = max(_cse_661_, _cse_670_);
        let _cse_671_ = max((s_own_rho - _e181), 0f);
        let _cse_659_ = min(_cse_660_, _cse_671_);
        let _cse_658_ = (_e181 + _cse_659_);
        let _cse_677_ = ((_e151 * 0.625f) + (s_own_p * 0.375f));
        let _cse_681_ = ((s_own_p - _e151) / _cse_668_);
        let _cse_680_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_681_);
        let _cse_679_ = dot(_cse_680_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_678_ = (_cse_679_ * 0.125f);
        let _cse_676_ = (_cse_677_ + _cse_678_);
        let _cse_675_ = (_cse_676_ - _e151);
        let _cse_682_ = min((s_own_p - _e151), 0f);
        let _cse_674_ = max(_cse_675_, _cse_682_);
        let _cse_683_ = max((s_own_p - _e151), 0f);
        let _cse_673_ = min(_cse_674_, _cse_683_);
        let _cse_672_ = (_e151 + _cse_673_);
        let _cse_686_ = (_e241 - _cse_1450_);
        let _cse_689_ = (_e271 - _cse_1459_);
        let _cse_690_ = (_cse_1450_ - _e241);
        let _cse_691_ = (_cse_1459_ - _e271);
        let _e3638 = constants.eos_theta_ref;
        let _e3642 = constants.eos_dp_drho;
        let _e3647 = constants.eos_p_offset;
        let _e3653 = constants.eos_gamma;
        let _e3658 = constants.eos_dp_drho;
        u_l_0_ = (_cse_628_ + ((_cse_642_ * (_cse_647_ - (((_cse_628_ * _e3638) + (_cse_628_ * _e3642)) - _e3647))) / max((((_e3653 * _cse_647_) / _cse_628_) + _e3658), 0.000000000001f)));
        let _e3666 = constants.eos_theta_ref;
        let _e3670 = constants.eos_dp_drho;
        let _e3675 = constants.eos_p_offset;
        let _e3681 = constants.eos_gamma;
        let _e3686 = constants.eos_dp_drho;
        u_r_0_ = (_cse_658_ + ((_cse_642_ * (_cse_672_ - (((_cse_658_ * _e3666) + (_cse_658_ * _e3670)) - _e3675))) / max((((_e3681 * _cse_672_) / _cse_658_) + _e3686), 0.000000000001f)));
        let _e3741 = normal_vec;
        f_l_0_ = (_cse_628_ * dot(((vec2<f32>((_cse_1450_ + min(max(((((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_686_) / vec2(_cse_638_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1450_), min(_cse_686_, 0f)), max(_cse_686_, 0f))), (_cse_1459_ + min(max(((((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_689_) / vec2(_cse_638_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1459_), min(_cse_689_, 0f)), max(_cse_689_, 0f)))) * 1f) / vec2(_cse_628_)), _e3741));
        let _e3793 = normal_vec;
        f_r_0_ = (_cse_658_ * dot(((vec2<f32>((_e241 + min(max(((((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_690_) / vec2(_cse_668_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e241), min(_cse_690_, 0f)), max(_cse_690_, 0f))), (_e271 + min(max(((((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_691_) / vec2(_cse_668_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e271), min(_cse_691_, 0f)), max(_cse_691_, 0f)))) * 1f) / vec2(_cse_658_)), _e3793));
    }
    let _e3798 = constants.scheme;
    if ((_e3798 == 6u) && !(is_boundary_1)) {
        let _cse_702_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_701_ = max(_cse_702_, 0.000000000001f);
        let _cse_700_ = ((_e181 - s_own_rho) / _cse_701_);
        let _cse_699_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_700_);
        let _cse_698_ = dot(_cse_699_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_697_ = (_cse_698_ * 0.125f);
        let _cse_696_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + _cse_697_);
        let _cse_695_ = (_cse_696_ - s_own_rho);
        let _cse_706_ = abs(_cse_695_);
        let _cse_705_ = (_cse_706_ + 0.00000001f);
        let _cse_704_ = max(abs((_e181 - s_own_rho)), _cse_705_);
        let _cse_703_ = (abs((_e181 - s_own_rho)) / _cse_704_);
        let _cse_694_ = (_cse_695_ * _cse_703_);
        let _cse_709_ = ((_e181 - s_own_rho) * _cse_695_);
        let _cse_708_ = max(_cse_709_, 0f);
        let _cse_711_ = abs(_cse_709_);
        let _cse_710_ = max(_cse_711_, 0.00000001f);
        let _cse_707_ = (_cse_708_ / _cse_710_);
        let _cse_693_ = (_cse_694_ * _cse_707_);
        let _cse_692_ = (s_own_rho + _cse_693_);
        let _cse_717_ = dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_701_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_716_ = (_cse_717_ * 0.125f);
        let _cse_715_ = (((s_own_p * 0.625f) + (_e151 * 0.375f)) + _cse_716_);
        let _cse_714_ = (_cse_715_ - s_own_p);
        let _cse_713_ = ((((_cse_714_ * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(_cse_714_) + 0.00000001f))) * max(((_e151 - s_own_p) * _cse_714_), 0f)) / max(abs(((_e151 - s_own_p) * _cse_714_)), 0.00000001f));
        let _cse_712_ = (s_own_p + _cse_713_);
        let _cse_728_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_727_ = max(_cse_728_, 0.000000000001f);
        let _cse_726_ = ((s_own_rho - _e181) / _cse_727_);
        let _cse_725_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_726_);
        let _cse_724_ = dot(_cse_725_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_723_ = (_cse_724_ * 0.125f);
        let _cse_722_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + _cse_723_);
        let _cse_721_ = (_cse_722_ - _e181);
        let _cse_732_ = abs(_cse_721_);
        let _cse_731_ = (_cse_732_ + 0.00000001f);
        let _cse_730_ = max(abs((s_own_rho - _e181)), _cse_731_);
        let _cse_729_ = (abs((s_own_rho - _e181)) / _cse_730_);
        let _cse_720_ = (_cse_721_ * _cse_729_);
        let _cse_735_ = ((s_own_rho - _e181) * _cse_721_);
        let _cse_734_ = max(_cse_735_, 0f);
        let _cse_737_ = abs(_cse_735_);
        let _cse_736_ = max(_cse_737_, 0.00000001f);
        let _cse_733_ = (_cse_734_ / _cse_736_);
        let _cse_719_ = (_cse_720_ * _cse_733_);
        let _cse_718_ = (_e181 + _cse_719_);
        let _cse_743_ = dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_727_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_742_ = (_cse_743_ * 0.125f);
        let _cse_741_ = (((_e151 * 0.625f) + (s_own_p * 0.375f)) + _cse_742_);
        let _cse_740_ = (_cse_741_ - _e151);
        let _cse_739_ = ((((_cse_740_ * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(_cse_740_) + 0.00000001f))) * max(((s_own_p - _e151) * _cse_740_), 0f)) / max(abs(((s_own_p - _e151) * _cse_740_)), 0.00000001f));
        let _cse_738_ = (_e151 + _cse_739_);
        let _cse_746_ = (((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_701_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_745_ = (_cse_746_ - _cse_1450_);
        let _cse_750_ = (((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_701_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_749_ = (_cse_750_ - _cse_1459_);
        let _cse_753_ = (((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_727_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_752_ = (_cse_753_ - _e241);
        let _cse_755_ = (((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_727_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_754_ = (_cse_755_ - _e271);
        let _e4025 = low_mach_params.model;
        let _e4038 = low_mach_params.pressure_coupling_alpha;
        let _e4042 = constants.eos_theta_ref;
        let _e4046 = constants.eos_dp_drho;
        let _e4051 = constants.eos_p_offset;
        let _e4057 = constants.eos_gamma;
        let _e4062 = constants.eos_dp_drho;
        u_l_0_ = (_cse_692_ + ((((1f - max(0f, (1f - abs((f32(_e4025) - 2f))))) * _e4038) * (_cse_712_ - (((_cse_692_ * _e4042) + (_cse_692_ * _e4046)) - _e4051))) / max((((_e4057 * _cse_712_) / _cse_692_) + _e4062), 0.000000000001f)));
        let _e4070 = low_mach_params.model;
        let _e4083 = low_mach_params.pressure_coupling_alpha;
        let _e4087 = constants.eos_theta_ref;
        let _e4091 = constants.eos_dp_drho;
        let _e4096 = constants.eos_p_offset;
        let _e4102 = constants.eos_gamma;
        let _e4107 = constants.eos_dp_drho;
        u_r_0_ = (_cse_718_ + ((((1f - max(0f, (1f - abs((f32(_e4070) - 2f))))) * _e4083) * (_cse_738_ - (((_cse_718_ * _e4087) + (_cse_718_ * _e4091)) - _e4096))) / max((((_e4102 * _cse_738_) / _cse_718_) + _e4107), 0.000000000001f)));
        let _e4162 = normal_vec;
        f_l_0_ = (_cse_692_ * dot(((vec2<f32>((_cse_1450_ + ((((_cse_745_ * abs((_e241 - _cse_1450_))) / max(abs((_e241 - _cse_1450_)), (abs(_cse_745_) + 0.00000001f))) * max(((_e241 - _cse_1450_) * _cse_745_), 0f)) / max(abs(((_e241 - _cse_1450_) * _cse_745_)), 0.00000001f))), (_cse_1459_ + ((((_cse_749_ * abs((_e271 - _cse_1459_))) / max(abs((_e271 - _cse_1459_)), (abs(_cse_749_) + 0.00000001f))) * max(((_e271 - _cse_1459_) * _cse_749_), 0f)) / max(abs(((_e271 - _cse_1459_) * _cse_749_)), 0.00000001f)))) * 1f) / vec2(_cse_692_)), _e4162));
        let _e4214 = normal_vec;
        f_r_0_ = (_cse_718_ * dot(((vec2<f32>((_e241 + ((((_cse_752_ * abs((_cse_1450_ - _e241))) / max(abs((_cse_1450_ - _e241)), (abs(_cse_752_) + 0.00000001f))) * max(((_cse_1450_ - _e241) * _cse_752_), 0f)) / max(abs(((_cse_1450_ - _e241) * _cse_752_)), 0.00000001f))), (_e271 + ((((_cse_754_ * abs((_cse_1459_ - _e271))) / max(abs((_cse_1459_ - _e271)), (abs(_cse_754_) + 0.00000001f))) * max(((_cse_1459_ - _e271) * _cse_754_), 0f)) / max(abs(((_cse_1459_ - _e271) * _cse_754_)), 0.00000001f)))) * 1f) / vec2(_cse_718_)), _e4214));
    }
    let _e4223 = a_plus;
    let _e4224 = f_l_0_;
    let _e4226 = a_minus;
    let _e4227 = f_r_0_;
    let _e4230 = a_plus;
    let _e4231 = a_minus;
    let _e4233 = u_r_0_;
    let _e4234 = u_l_0_;
    fluxes[((idx * 8u) + 0u)] = (((((_e4223 * _e4224) - (_e4226 * _e4227)) + ((_e4230 * _e4231) * (_e4233 - _e4234))) / denom) * area);
    let _cse_758_ = normal_vec.x;
    u_l_1_ = _cse_1450_;
    u_r_1_ = _e241;
    let _e4249 = normal_vec;
    f_l_1_ = ((_cse_1450_ * dot(((vec2<f32>(_cse_1450_, _cse_1459_) * 1f) / vec2(s_own_rho)), _e4249)) + (s_own_p * _cse_758_));
    let _e4260 = normal_vec;
    f_r_1_ = ((_e241 * dot(((vec2<f32>(_e241, _e271) * 1f) / vec2(_e181)), _e4260)) + (_e151 * _cse_758_));
    let _e4268 = constants.scheme;
    if ((_e4268 == 1u) && !(is_boundary_1)) {
        let _cse_764_ = (_e241 - _cse_1450_);
        let _cse_767_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_766_ = max(_cse_767_, 0.000000000001f);
        let _cse_763_ = (_cse_764_ / _cse_766_);
        let _cse_762_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_763_);
        let _cse_761_ = dot(_cse_762_, (face_center_vec - c_owner_vec));
        let _cse_759_ = (_cse_1450_ + _cse_761_);
        let _cse_772_ = (_cse_1450_ - _e241);
        let _cse_774_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_773_ = max(_cse_774_, 0.000000000001f);
        let _cse_771_ = (_cse_772_ / _cse_773_);
        let _cse_770_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_771_);
        let _cse_769_ = dot(_cse_770_, (face_center_vec - c_neigh_cell_vec));
        let _cse_768_ = (_e241 + _cse_769_);
        let _cse_777_ = normal_vec.x;
        u_l_1_ = _cse_759_;
        u_r_1_ = _cse_768_;
        let _e4320 = normal_vec;
        f_l_1_ = ((_cse_759_ * dot(((vec2<f32>(_cse_759_, (_cse_1459_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_766_)), (face_center_vec - c_owner_vec)))) * 1f) / vec2((s_own_rho + dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_766_)), (face_center_vec - c_owner_vec))))), _e4320)) + ((s_own_p + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_766_)), (face_center_vec - c_owner_vec))) * _cse_777_));
        let _e4354 = normal_vec;
        f_r_1_ = ((_cse_768_ * dot(((vec2<f32>(_cse_768_, (_e271 + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_773_)), (face_center_vec - c_neigh_cell_vec)))) * 1f) / vec2((_e181 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_773_)), (face_center_vec - c_neigh_cell_vec))))), _e4354)) + ((_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_773_)), (face_center_vec - c_neigh_cell_vec))) * _cse_777_));
    }
    let _e4369 = constants.scheme;
    if ((_e4369 == 2u) && !(is_boundary_1)) {
        let _cse_783_ = (_cse_1450_ * 0.625f);
        let _cse_784_ = (_e241 * 0.375f);
        let _cse_782_ = (_cse_783_ + _cse_784_);
        let _cse_790_ = (_e241 - _cse_1450_);
        let _cse_792_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_791_ = max(_cse_792_, 0.000000000001f);
        let _cse_789_ = (_cse_790_ / _cse_791_);
        let _cse_788_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_789_);
        let _cse_787_ = dot(_cse_788_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_786_ = (_cse_787_ * 0.125f);
        let _cse_781_ = (_cse_782_ + _cse_786_);
        let _cse_780_ = (_cse_781_ - _cse_1450_);
        let _cse_778_ = (_cse_1450_ + _cse_780_);
        let _cse_797_ = (_e241 * 0.625f);
        let _cse_798_ = (_cse_1450_ * 0.375f);
        let _cse_796_ = (_cse_797_ + _cse_798_);
        let _cse_803_ = (_cse_1450_ - _e241);
        let _cse_805_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_804_ = max(_cse_805_, 0.000000000001f);
        let _cse_802_ = (_cse_803_ / _cse_804_);
        let _cse_801_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_802_);
        let _cse_800_ = dot(_cse_801_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_799_ = (_cse_800_ * 0.125f);
        let _cse_795_ = (_cse_796_ + _cse_799_);
        let _cse_794_ = (_cse_795_ - _e241);
        let _cse_793_ = (_e241 + _cse_794_);
        let _cse_808_ = normal_vec.x;
        u_l_1_ = _cse_778_;
        u_r_1_ = _cse_793_;
        let _e4457 = normal_vec;
        f_l_1_ = ((_cse_778_ * dot(((vec2<f32>(_cse_778_, ((((_cse_1459_ + (_cse_1459_ * 0.625f)) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_791_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1459_)) * 1f) / vec2(((((s_own_rho + (s_own_rho * 0.625f)) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_791_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho))), _e4457)) + (((((s_own_p + (s_own_p * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_791_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p) * _cse_808_));
        let _e4518 = normal_vec;
        f_r_1_ = ((_cse_793_ * dot(((vec2<f32>(_cse_793_, ((((_e271 + (_e271 * 0.625f)) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_804_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e271)) * 1f) / vec2(((((_e181 + (_e181 * 0.625f)) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_804_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181))), _e4518)) + (((((_e151 + (_e151 * 0.625f)) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_804_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * _cse_808_));
    }
    let _e4542 = constants.scheme;
    if ((_e4542 == 3u) && !(is_boundary_1)) {
        let _cse_816_ = (_e241 - _cse_1450_);
        let _cse_819_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_818_ = max(_cse_819_, 0.000000000001f);
        let _cse_815_ = (_cse_816_ / _cse_818_);
        let _cse_814_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_815_);
        let _cse_813_ = dot(_cse_814_, (face_center_vec - c_owner_vec));
        let _cse_820_ = min(_cse_816_, 0f);
        let _cse_812_ = max(_cse_813_, _cse_820_);
        let _cse_821_ = max(_cse_816_, 0f);
        let _cse_811_ = min(_cse_812_, _cse_821_);
        let _cse_809_ = (_cse_1450_ + _cse_811_);
        let _cse_828_ = (_cse_1450_ - _e241);
        let _cse_830_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_829_ = max(_cse_830_, 0.000000000001f);
        let _cse_827_ = (_cse_828_ / _cse_829_);
        let _cse_826_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_827_);
        let _cse_825_ = dot(_cse_826_, (face_center_vec - c_neigh_cell_vec));
        let _cse_831_ = min(_cse_828_, 0f);
        let _cse_824_ = max(_cse_825_, _cse_831_);
        let _cse_832_ = max(_cse_828_, 0f);
        let _cse_823_ = min(_cse_824_, _cse_832_);
        let _cse_822_ = (_e241 + _cse_823_);
        let _cse_834_ = (_e271 - _cse_1459_);
        let _cse_836_ = normal_vec.x;
        let _cse_837_ = (_cse_1459_ - _e271);
        u_l_1_ = _cse_809_;
        u_r_1_ = _cse_822_;
        let _e4621 = normal_vec;
        f_l_1_ = ((_cse_809_ * dot(((vec2<f32>(_cse_809_, (_cse_1459_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_834_) / vec2(_cse_818_)), (face_center_vec - c_owner_vec)), min(_cse_834_, 0f)), max(_cse_834_, 0f)))) * 1f) / vec2((s_own_rho + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_818_)), (face_center_vec - c_owner_vec)), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))))), _e4621)) + ((s_own_p + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_818_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f))) * _cse_836_));
        let _e4676 = normal_vec;
        f_r_1_ = ((_cse_822_ * dot(((vec2<f32>(_cse_822_, (_e271 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_837_) / vec2(_cse_829_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_837_, 0f)), max(_cse_837_, 0f)))) * 1f) / vec2((_e181 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_829_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))))), _e4676)) + ((_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_829_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f))) * _cse_836_));
    }
    let _e4699 = constants.scheme;
    if ((_e4699 == 4u) && !(is_boundary_1)) {
        let _cse_845_ = (_e241 - _cse_1450_);
        let _cse_848_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_847_ = max(_cse_848_, 0.000000000001f);
        let _cse_844_ = (_cse_845_ / _cse_847_);
        let _cse_843_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_844_);
        let _cse_842_ = dot(_cse_843_, (face_center_vec - c_owner_vec));
        let _cse_850_ = abs(_cse_845_);
        let _cse_853_ = abs(_cse_842_);
        let _cse_852_ = (_cse_853_ + 0.00000001f);
        let _cse_851_ = max(_cse_850_, _cse_852_);
        let _cse_849_ = (_cse_850_ / _cse_851_);
        let _cse_841_ = (_cse_842_ * _cse_849_);
        let _cse_856_ = (_cse_845_ * _cse_842_);
        let _cse_855_ = max(_cse_856_, 0f);
        let _cse_858_ = abs(_cse_856_);
        let _cse_857_ = max(_cse_858_, 0.00000001f);
        let _cse_854_ = (_cse_855_ / _cse_857_);
        let _cse_840_ = (_cse_841_ * _cse_854_);
        let _cse_838_ = (_cse_1450_ + _cse_840_);
        let _cse_865_ = (_cse_1450_ - _e241);
        let _cse_867_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_866_ = max(_cse_867_, 0.000000000001f);
        let _cse_864_ = (_cse_865_ / _cse_866_);
        let _cse_863_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_864_);
        let _cse_862_ = dot(_cse_863_, (face_center_vec - c_neigh_cell_vec));
        let _cse_869_ = abs(_cse_865_);
        let _cse_872_ = abs(_cse_862_);
        let _cse_871_ = (_cse_872_ + 0.00000001f);
        let _cse_870_ = max(_cse_869_, _cse_871_);
        let _cse_868_ = (_cse_869_ / _cse_870_);
        let _cse_861_ = (_cse_862_ * _cse_868_);
        let _cse_875_ = (_cse_865_ * _cse_862_);
        let _cse_874_ = max(_cse_875_, 0f);
        let _cse_877_ = abs(_cse_875_);
        let _cse_876_ = max(_cse_877_, 0.00000001f);
        let _cse_873_ = (_cse_874_ / _cse_876_);
        let _cse_860_ = (_cse_861_ * _cse_873_);
        let _cse_859_ = (_e241 + _cse_860_);
        let _cse_882_ = (_e271 - _cse_1459_);
        let _cse_881_ = (_cse_882_ / _cse_847_);
        let _cse_880_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_881_);
        let _cse_879_ = dot(_cse_880_, (face_center_vec - c_owner_vec));
        let _cse_884_ = (_cse_882_ * _cse_879_);
        let _cse_887_ = ((_e181 - s_own_rho) / _cse_847_);
        let _cse_886_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_887_);
        let _cse_885_ = dot(_cse_886_, (face_center_vec - c_owner_vec));
        let _cse_890_ = ((_e151 - s_own_p) / _cse_847_);
        let _cse_889_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_890_);
        let _cse_888_ = dot(_cse_889_, (face_center_vec - c_owner_vec));
        let _cse_894_ = (_cse_1459_ - _e271);
        let _cse_893_ = (_cse_894_ / _cse_866_);
        let _cse_892_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_893_);
        let _cse_891_ = dot(_cse_892_, (face_center_vec - c_neigh_cell_vec));
        let _cse_895_ = (_cse_894_ * _cse_891_);
        let _cse_898_ = ((s_own_rho - _e181) / _cse_866_);
        let _cse_897_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_898_);
        let _cse_896_ = dot(_cse_897_, (face_center_vec - c_neigh_cell_vec));
        let _cse_901_ = ((s_own_p - _e151) / _cse_866_);
        let _cse_900_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_901_);
        let _cse_899_ = dot(_cse_900_, (face_center_vec - c_neigh_cell_vec));
        u_l_1_ = _cse_838_;
        u_r_1_ = _cse_859_;
        let _e4839 = normal_vec;
        let _e4865 = normal_vec.x;
        f_l_1_ = ((_cse_838_ * dot(((vec2<f32>(_cse_838_, (_cse_1459_ + ((((_cse_879_ * abs(_cse_882_)) / max(abs(_cse_882_), (abs(_cse_879_) + 0.00000001f))) * max(_cse_884_, 0f)) / max(abs(_cse_884_), 0.00000001f)))) * 1f) / vec2((s_own_rho + ((((_cse_885_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_885_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_885_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_885_)), 0.00000001f))))), _e4839)) + ((s_own_p + ((((_cse_888_ * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(_cse_888_) + 0.00000001f))) * max(((_e151 - s_own_p) * _cse_888_), 0f)) / max(abs(((_e151 - s_own_p) * _cse_888_)), 0.00000001f))) * _e4865));
        let _e4911 = normal_vec;
        let _e4937 = normal_vec.x;
        f_r_1_ = ((_cse_859_ * dot(((vec2<f32>(_cse_859_, (_e271 + ((((_cse_891_ * abs(_cse_894_)) / max(abs(_cse_894_), (abs(_cse_891_) + 0.00000001f))) * max(_cse_895_, 0f)) / max(abs(_cse_895_), 0.00000001f)))) * 1f) / vec2((_e181 + ((((_cse_896_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_896_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_896_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_896_)), 0.00000001f))))), _e4911)) + ((_e151 + ((((_cse_899_ * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(_cse_899_) + 0.00000001f))) * max(((s_own_p - _e151) * _cse_899_), 0f)) / max(abs(((s_own_p - _e151) * _cse_899_)), 0.00000001f))) * _e4937));
    }
    let _e4942 = constants.scheme;
    if ((_e4942 == 5u) && !(is_boundary_1)) {
        let _cse_909_ = (_cse_1450_ * 0.625f);
        let _cse_910_ = (_e241 * 0.375f);
        let _cse_908_ = (_cse_909_ + _cse_910_);
        let _cse_916_ = (_e241 - _cse_1450_);
        let _cse_918_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_917_ = max(_cse_918_, 0.000000000001f);
        let _cse_915_ = (_cse_916_ / _cse_917_);
        let _cse_914_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_915_);
        let _cse_913_ = dot(_cse_914_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_912_ = (_cse_913_ * 0.125f);
        let _cse_907_ = (_cse_908_ + _cse_912_);
        let _cse_906_ = (_cse_907_ - _cse_1450_);
        let _cse_919_ = min(_cse_916_, 0f);
        let _cse_905_ = max(_cse_906_, _cse_919_);
        let _cse_920_ = max(_cse_916_, 0f);
        let _cse_904_ = min(_cse_905_, _cse_920_);
        let _cse_902_ = (_cse_1450_ + _cse_904_);
        let _cse_927_ = (_e241 * 0.625f);
        let _cse_928_ = (_cse_1450_ * 0.375f);
        let _cse_926_ = (_cse_927_ + _cse_928_);
        let _cse_933_ = (_cse_1450_ - _e241);
        let _cse_935_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_934_ = max(_cse_935_, 0.000000000001f);
        let _cse_932_ = (_cse_933_ / _cse_934_);
        let _cse_931_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_932_);
        let _cse_930_ = dot(_cse_931_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_929_ = (_cse_930_ * 0.125f);
        let _cse_925_ = (_cse_926_ + _cse_929_);
        let _cse_924_ = (_cse_925_ - _e241);
        let _cse_936_ = min(_cse_933_, 0f);
        let _cse_923_ = max(_cse_924_, _cse_936_);
        let _cse_937_ = max(_cse_933_, 0f);
        let _cse_922_ = min(_cse_923_, _cse_937_);
        let _cse_921_ = (_e241 + _cse_922_);
        let _cse_940_ = (_e271 - _cse_1459_);
        let _cse_941_ = normal_vec.x;
        let _cse_942_ = (_cse_1459_ - _e271);
        u_l_1_ = _cse_902_;
        u_r_1_ = _cse_921_;
        let _e5057 = normal_vec;
        f_l_1_ = ((_cse_902_ * dot(((vec2<f32>(_cse_902_, (_cse_1459_ + min(max(((((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_940_) / vec2(_cse_917_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1459_), min(_cse_940_, 0f)), max(_cse_940_, 0f)))) * 1f) / vec2((s_own_rho + min(max(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_917_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))))), _e5057)) + ((s_own_p + min(max(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_917_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f))) * _cse_941_));
        let _e5139 = normal_vec;
        f_r_1_ = ((_cse_921_ * dot(((vec2<f32>(_cse_921_, (_e271 + min(max(((((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_942_) / vec2(_cse_934_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e271), min(_cse_942_, 0f)), max(_cse_942_, 0f)))) * 1f) / vec2((_e181 + min(max(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_934_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))))), _e5139)) + ((_e151 + min(max(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_934_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f))) * _cse_941_));
    }
    let _e5171 = constants.scheme;
    if ((_e5171 == 6u) && !(is_boundary_1)) {
        let _cse_950_ = (_cse_1450_ * 0.625f);
        let _cse_951_ = (_e241 * 0.375f);
        let _cse_949_ = (_cse_950_ + _cse_951_);
        let _cse_957_ = (_e241 - _cse_1450_);
        let _cse_959_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_958_ = max(_cse_959_, 0.000000000001f);
        let _cse_956_ = (_cse_957_ / _cse_958_);
        let _cse_955_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_956_);
        let _cse_954_ = dot(_cse_955_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_953_ = (_cse_954_ * 0.125f);
        let _cse_948_ = (_cse_949_ + _cse_953_);
        let _cse_947_ = (_cse_948_ - _cse_1450_);
        let _cse_961_ = abs(_cse_957_);
        let _cse_964_ = abs(_cse_947_);
        let _cse_963_ = (_cse_964_ + 0.00000001f);
        let _cse_962_ = max(_cse_961_, _cse_963_);
        let _cse_960_ = (_cse_961_ / _cse_962_);
        let _cse_946_ = (_cse_947_ * _cse_960_);
        let _cse_967_ = (_cse_957_ * _cse_947_);
        let _cse_966_ = max(_cse_967_, 0f);
        let _cse_969_ = abs(_cse_967_);
        let _cse_968_ = max(_cse_969_, 0.00000001f);
        let _cse_965_ = (_cse_966_ / _cse_968_);
        let _cse_945_ = (_cse_946_ * _cse_965_);
        let _cse_943_ = (_cse_1450_ + _cse_945_);
        let _cse_976_ = (_e241 * 0.625f);
        let _cse_977_ = (_cse_1450_ * 0.375f);
        let _cse_975_ = (_cse_976_ + _cse_977_);
        let _cse_982_ = (_cse_1450_ - _e241);
        let _cse_984_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_983_ = max(_cse_984_, 0.000000000001f);
        let _cse_981_ = (_cse_982_ / _cse_983_);
        let _cse_980_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_981_);
        let _cse_979_ = dot(_cse_980_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_978_ = (_cse_979_ * 0.125f);
        let _cse_974_ = (_cse_975_ + _cse_978_);
        let _cse_973_ = (_cse_974_ - _e241);
        let _cse_986_ = abs(_cse_982_);
        let _cse_989_ = abs(_cse_973_);
        let _cse_988_ = (_cse_989_ + 0.00000001f);
        let _cse_987_ = max(_cse_986_, _cse_988_);
        let _cse_985_ = (_cse_986_ / _cse_987_);
        let _cse_972_ = (_cse_973_ * _cse_985_);
        let _cse_992_ = (_cse_982_ * _cse_973_);
        let _cse_991_ = max(_cse_992_, 0f);
        let _cse_994_ = abs(_cse_992_);
        let _cse_993_ = max(_cse_994_, 0.00000001f);
        let _cse_990_ = (_cse_991_ / _cse_993_);
        let _cse_971_ = (_cse_972_ * _cse_990_);
        let _cse_970_ = (_e241 + _cse_971_);
        let _cse_1001_ = (_e271 - _cse_1459_);
        let _cse_1000_ = dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1001_) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_999_ = (_cse_1000_ * 0.125f);
        let _cse_997_ = (((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + _cse_999_);
        let _cse_996_ = (_cse_997_ - _cse_1459_);
        let _cse_1006_ = (_cse_1459_ - _e271);
        let _cse_1005_ = dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1006_) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1004_ = (_cse_1005_ * 0.125f);
        let _cse_1003_ = (((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + _cse_1004_);
        let _cse_1002_ = (_cse_1003_ - _e271);
        u_l_1_ = _cse_943_;
        u_r_1_ = _cse_970_;
        let _e5389 = normal_vec;
        let _e5479 = normal_vec.x;
        f_l_1_ = ((_cse_943_ * dot(((vec2<f32>(_cse_943_, (_cse_1459_ + ((((_cse_996_ * abs(_cse_1001_)) / max(abs(_cse_1001_), (abs(_cse_996_) + 0.00000001f))) * max((_cse_1001_ * _cse_996_), 0f)) / max(abs((_cse_1001_ * _cse_996_)), 0.00000001f)))) * 1f) / vec2((s_own_rho + ((((((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho) * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho)) + 0.00000001f))) * max(((_e181 - s_own_rho) * ((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho)), 0f)) / max(abs(((_e181 - s_own_rho) * ((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho))), 0.00000001f))))), _e5389)) + ((s_own_p + ((((((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p) * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)) + 0.00000001f))) * max(((_e151 - s_own_p) * ((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)), 0f)) / max(abs(((_e151 - s_own_p) * ((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_958_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p))), 0.00000001f))) * _e5479));
        let _e5591 = normal_vec;
        let _e5681 = normal_vec.x;
        f_r_1_ = ((_cse_970_ * dot(((vec2<f32>(_cse_970_, (_e271 + ((((_cse_1002_ * abs(_cse_1006_)) / max(abs(_cse_1006_), (abs(_cse_1002_) + 0.00000001f))) * max((_cse_1006_ * _cse_1002_), 0f)) / max(abs((_cse_1006_ * _cse_1002_)), 0.00000001f)))) * 1f) / vec2((_e181 + ((((((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181) * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181)) + 0.00000001f))) * max(((s_own_rho - _e181) * ((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181)), 0f)) / max(abs(((s_own_rho - _e181) * ((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181))), 0.00000001f))))), _e5591)) + ((_e151 + ((((((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) + 0.00000001f))) * max(((s_own_p - _e151) * ((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)), 0f)) / max(abs(((s_own_p - _e151) * ((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_983_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))), 0.00000001f))) * _e5681));
    }
    let _e5690 = a_plus;
    let _e5691 = f_l_1_;
    let _e5693 = a_minus;
    let _e5694 = f_r_1_;
    let _e5697 = a_plus;
    let _e5698 = a_minus;
    let _e5700 = u_r_1_;
    let _e5701 = u_l_1_;
    fluxes[((idx * 8u) + 1u)] = (((((_e5690 * _e5691) - (_e5693 * _e5694)) + ((_e5697 * _e5698) * (_e5700 - _e5701))) / denom) * area);
    let _cse_1009_ = normal_vec.y;
    u_l_2_ = _cse_1459_;
    u_r_2_ = _e271;
    let _e5716 = normal_vec;
    f_l_2_ = ((_cse_1459_ * dot(((vec2<f32>(_cse_1450_, _cse_1459_) * 1f) / vec2(s_own_rho)), _e5716)) + (s_own_p * _cse_1009_));
    let _e5727 = normal_vec;
    f_r_2_ = ((_e271 * dot(((vec2<f32>(_e241, _e271) * 1f) / vec2(_e181)), _e5727)) + (_e151 * _cse_1009_));
    let _e5735 = constants.scheme;
    if ((_e5735 == 1u) && !(is_boundary_1)) {
        let _cse_1015_ = (_e271 - _cse_1459_);
        let _cse_1018_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1017_ = max(_cse_1018_, 0.000000000001f);
        let _cse_1014_ = (_cse_1015_ / _cse_1017_);
        let _cse_1013_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1014_);
        let _cse_1012_ = dot(_cse_1013_, (face_center_vec - c_owner_vec));
        let _cse_1010_ = (_cse_1459_ + _cse_1012_);
        let _cse_1023_ = (_cse_1459_ - _e271);
        let _cse_1025_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1024_ = max(_cse_1025_, 0.000000000001f);
        let _cse_1022_ = (_cse_1023_ / _cse_1024_);
        let _cse_1021_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1022_);
        let _cse_1020_ = dot(_cse_1021_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1019_ = (_e271 + _cse_1020_);
        let _cse_1028_ = normal_vec.y;
        u_l_2_ = _cse_1010_;
        u_r_2_ = _cse_1019_;
        let _e5787 = normal_vec;
        f_l_2_ = ((_cse_1010_ * dot(((vec2<f32>((_cse_1450_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_1017_)), (face_center_vec - c_owner_vec))), _cse_1010_) * 1f) / vec2((s_own_rho + dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1017_)), (face_center_vec - c_owner_vec))))), _e5787)) + ((s_own_p + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1017_)), (face_center_vec - c_owner_vec))) * _cse_1028_));
        let _e5821 = normal_vec;
        f_r_2_ = ((_cse_1019_ * dot(((vec2<f32>((_e241 + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_1024_)), (face_center_vec - c_neigh_cell_vec))), _cse_1019_) * 1f) / vec2((_e181 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1024_)), (face_center_vec - c_neigh_cell_vec))))), _e5821)) + ((_e151 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1024_)), (face_center_vec - c_neigh_cell_vec))) * _cse_1028_));
    }
    let _e5836 = constants.scheme;
    if ((_e5836 == 2u) && !(is_boundary_1)) {
        let _cse_1034_ = (_cse_1459_ * 0.625f);
        let _cse_1035_ = (_e271 * 0.375f);
        let _cse_1033_ = (_cse_1034_ + _cse_1035_);
        let _cse_1041_ = (_e271 - _cse_1459_);
        let _cse_1043_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1042_ = max(_cse_1043_, 0.000000000001f);
        let _cse_1040_ = (_cse_1041_ / _cse_1042_);
        let _cse_1039_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1040_);
        let _cse_1038_ = dot(_cse_1039_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1037_ = (_cse_1038_ * 0.125f);
        let _cse_1032_ = (_cse_1033_ + _cse_1037_);
        let _cse_1031_ = (_cse_1032_ - _cse_1459_);
        let _cse_1029_ = (_cse_1459_ + _cse_1031_);
        let _cse_1048_ = (_e271 * 0.625f);
        let _cse_1049_ = (_cse_1459_ * 0.375f);
        let _cse_1047_ = (_cse_1048_ + _cse_1049_);
        let _cse_1054_ = (_cse_1459_ - _e271);
        let _cse_1056_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1055_ = max(_cse_1056_, 0.000000000001f);
        let _cse_1053_ = (_cse_1054_ / _cse_1055_);
        let _cse_1052_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1053_);
        let _cse_1051_ = dot(_cse_1052_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1050_ = (_cse_1051_ * 0.125f);
        let _cse_1046_ = (_cse_1047_ + _cse_1050_);
        let _cse_1045_ = (_cse_1046_ - _e271);
        let _cse_1044_ = (_e271 + _cse_1045_);
        let _cse_1059_ = normal_vec.y;
        u_l_2_ = _cse_1029_;
        u_r_2_ = _cse_1044_;
        let _e5924 = normal_vec;
        f_l_2_ = ((_cse_1029_ * dot(((vec2<f32>(((((_cse_1450_ + (_cse_1450_ * 0.625f)) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_1042_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1450_), _cse_1029_) * 1f) / vec2(((((s_own_rho + (s_own_rho * 0.625f)) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1042_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho))), _e5924)) + (((((s_own_p + (s_own_p * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1042_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p) * _cse_1059_));
        let _e5985 = normal_vec;
        f_r_2_ = ((_cse_1044_ * dot(((vec2<f32>(((((_e241 + (_e241 * 0.625f)) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_1055_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e241), _cse_1044_) * 1f) / vec2(((((_e181 + (_e181 * 0.625f)) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1055_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181))), _e5985)) + (((((_e151 + (_e151 * 0.625f)) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1055_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * _cse_1059_));
    }
    let _e6009 = constants.scheme;
    if ((_e6009 == 3u) && !(is_boundary_1)) {
        let _cse_1067_ = (_e271 - _cse_1459_);
        let _cse_1070_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1069_ = max(_cse_1070_, 0.000000000001f);
        let _cse_1066_ = (_cse_1067_ / _cse_1069_);
        let _cse_1065_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1066_);
        let _cse_1064_ = dot(_cse_1065_, (face_center_vec - c_owner_vec));
        let _cse_1071_ = min(_cse_1067_, 0f);
        let _cse_1063_ = max(_cse_1064_, _cse_1071_);
        let _cse_1072_ = max(_cse_1067_, 0f);
        let _cse_1062_ = min(_cse_1063_, _cse_1072_);
        let _cse_1060_ = (_cse_1459_ + _cse_1062_);
        let _cse_1079_ = (_cse_1459_ - _e271);
        let _cse_1081_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1080_ = max(_cse_1081_, 0.000000000001f);
        let _cse_1078_ = (_cse_1079_ / _cse_1080_);
        let _cse_1077_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1078_);
        let _cse_1076_ = dot(_cse_1077_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1082_ = min(_cse_1079_, 0f);
        let _cse_1075_ = max(_cse_1076_, _cse_1082_);
        let _cse_1083_ = max(_cse_1079_, 0f);
        let _cse_1074_ = min(_cse_1075_, _cse_1083_);
        let _cse_1073_ = (_e271 + _cse_1074_);
        let _cse_1085_ = (_e241 - _cse_1450_);
        let _cse_1087_ = normal_vec.y;
        let _cse_1088_ = (_cse_1450_ - _e241);
        u_l_2_ = _cse_1060_;
        u_r_2_ = _cse_1073_;
        let _e6088 = normal_vec;
        f_l_2_ = ((_cse_1060_ * dot(((vec2<f32>((_cse_1450_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1085_) / vec2(_cse_1069_)), (face_center_vec - c_owner_vec)), min(_cse_1085_, 0f)), max(_cse_1085_, 0f))), _cse_1060_) * 1f) / vec2((s_own_rho + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1069_)), (face_center_vec - c_owner_vec)), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))))), _e6088)) + ((s_own_p + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1069_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f))) * _cse_1087_));
        let _e6143 = normal_vec;
        f_r_2_ = ((_cse_1073_ * dot(((vec2<f32>((_e241 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1088_) / vec2(_cse_1080_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_1088_, 0f)), max(_cse_1088_, 0f))), _cse_1073_) * 1f) / vec2((_e181 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1080_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))))), _e6143)) + ((_e151 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1080_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f))) * _cse_1087_));
    }
    let _e6166 = constants.scheme;
    if ((_e6166 == 4u) && !(is_boundary_1)) {
        let _cse_1096_ = (_e271 - _cse_1459_);
        let _cse_1099_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1098_ = max(_cse_1099_, 0.000000000001f);
        let _cse_1095_ = (_cse_1096_ / _cse_1098_);
        let _cse_1094_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1095_);
        let _cse_1093_ = dot(_cse_1094_, (face_center_vec - c_owner_vec));
        let _cse_1101_ = abs(_cse_1096_);
        let _cse_1104_ = abs(_cse_1093_);
        let _cse_1103_ = (_cse_1104_ + 0.00000001f);
        let _cse_1102_ = max(_cse_1101_, _cse_1103_);
        let _cse_1100_ = (_cse_1101_ / _cse_1102_);
        let _cse_1092_ = (_cse_1093_ * _cse_1100_);
        let _cse_1107_ = (_cse_1096_ * _cse_1093_);
        let _cse_1106_ = max(_cse_1107_, 0f);
        let _cse_1109_ = abs(_cse_1107_);
        let _cse_1108_ = max(_cse_1109_, 0.00000001f);
        let _cse_1105_ = (_cse_1106_ / _cse_1108_);
        let _cse_1091_ = (_cse_1092_ * _cse_1105_);
        let _cse_1089_ = (_cse_1459_ + _cse_1091_);
        let _cse_1116_ = (_cse_1459_ - _e271);
        let _cse_1118_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1117_ = max(_cse_1118_, 0.000000000001f);
        let _cse_1115_ = (_cse_1116_ / _cse_1117_);
        let _cse_1114_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1115_);
        let _cse_1113_ = dot(_cse_1114_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1120_ = abs(_cse_1116_);
        let _cse_1123_ = abs(_cse_1113_);
        let _cse_1122_ = (_cse_1123_ + 0.00000001f);
        let _cse_1121_ = max(_cse_1120_, _cse_1122_);
        let _cse_1119_ = (_cse_1120_ / _cse_1121_);
        let _cse_1112_ = (_cse_1113_ * _cse_1119_);
        let _cse_1126_ = (_cse_1116_ * _cse_1113_);
        let _cse_1125_ = max(_cse_1126_, 0f);
        let _cse_1128_ = abs(_cse_1126_);
        let _cse_1127_ = max(_cse_1128_, 0.00000001f);
        let _cse_1124_ = (_cse_1125_ / _cse_1127_);
        let _cse_1111_ = (_cse_1112_ * _cse_1124_);
        let _cse_1110_ = (_e271 + _cse_1111_);
        let _cse_1133_ = (_e241 - _cse_1450_);
        let _cse_1132_ = (_cse_1133_ / _cse_1098_);
        let _cse_1131_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1132_);
        let _cse_1130_ = dot(_cse_1131_, (face_center_vec - c_owner_vec));
        let _cse_1135_ = (_cse_1133_ * _cse_1130_);
        let _cse_1138_ = ((_e181 - s_own_rho) / _cse_1098_);
        let _cse_1137_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1138_);
        let _cse_1136_ = dot(_cse_1137_, (face_center_vec - c_owner_vec));
        let _cse_1141_ = ((_e151 - s_own_p) / _cse_1098_);
        let _cse_1140_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1141_);
        let _cse_1139_ = dot(_cse_1140_, (face_center_vec - c_owner_vec));
        let _cse_1145_ = (_cse_1450_ - _e241);
        let _cse_1144_ = (_cse_1145_ / _cse_1117_);
        let _cse_1143_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1144_);
        let _cse_1142_ = dot(_cse_1143_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1146_ = (_cse_1145_ * _cse_1142_);
        let _cse_1149_ = ((s_own_rho - _e181) / _cse_1117_);
        let _cse_1148_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1149_);
        let _cse_1147_ = dot(_cse_1148_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1152_ = ((s_own_p - _e151) / _cse_1117_);
        let _cse_1151_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1152_);
        let _cse_1150_ = dot(_cse_1151_, (face_center_vec - c_neigh_cell_vec));
        u_l_2_ = _cse_1089_;
        u_r_2_ = _cse_1110_;
        let _e6306 = normal_vec;
        let _e6332 = normal_vec.y;
        f_l_2_ = ((_cse_1089_ * dot(((vec2<f32>((_cse_1450_ + ((((_cse_1130_ * abs(_cse_1133_)) / max(abs(_cse_1133_), (abs(_cse_1130_) + 0.00000001f))) * max(_cse_1135_, 0f)) / max(abs(_cse_1135_), 0.00000001f))), _cse_1089_) * 1f) / vec2((s_own_rho + ((((_cse_1136_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1136_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1136_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1136_)), 0.00000001f))))), _e6306)) + ((s_own_p + ((((_cse_1139_ * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(_cse_1139_) + 0.00000001f))) * max(((_e151 - s_own_p) * _cse_1139_), 0f)) / max(abs(((_e151 - s_own_p) * _cse_1139_)), 0.00000001f))) * _e6332));
        let _e6378 = normal_vec;
        let _e6404 = normal_vec.y;
        f_r_2_ = ((_cse_1110_ * dot(((vec2<f32>((_e241 + ((((_cse_1142_ * abs(_cse_1145_)) / max(abs(_cse_1145_), (abs(_cse_1142_) + 0.00000001f))) * max(_cse_1146_, 0f)) / max(abs(_cse_1146_), 0.00000001f))), _cse_1110_) * 1f) / vec2((_e181 + ((((_cse_1147_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1147_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1147_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1147_)), 0.00000001f))))), _e6378)) + ((_e151 + ((((_cse_1150_ * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(_cse_1150_) + 0.00000001f))) * max(((s_own_p - _e151) * _cse_1150_), 0f)) / max(abs(((s_own_p - _e151) * _cse_1150_)), 0.00000001f))) * _e6404));
    }
    let _e6409 = constants.scheme;
    if ((_e6409 == 5u) && !(is_boundary_1)) {
        let _cse_1160_ = (_cse_1459_ * 0.625f);
        let _cse_1161_ = (_e271 * 0.375f);
        let _cse_1159_ = (_cse_1160_ + _cse_1161_);
        let _cse_1167_ = (_e271 - _cse_1459_);
        let _cse_1169_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1168_ = max(_cse_1169_, 0.000000000001f);
        let _cse_1166_ = (_cse_1167_ / _cse_1168_);
        let _cse_1165_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1166_);
        let _cse_1164_ = dot(_cse_1165_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1163_ = (_cse_1164_ * 0.125f);
        let _cse_1158_ = (_cse_1159_ + _cse_1163_);
        let _cse_1157_ = (_cse_1158_ - _cse_1459_);
        let _cse_1170_ = min(_cse_1167_, 0f);
        let _cse_1156_ = max(_cse_1157_, _cse_1170_);
        let _cse_1171_ = max(_cse_1167_, 0f);
        let _cse_1155_ = min(_cse_1156_, _cse_1171_);
        let _cse_1153_ = (_cse_1459_ + _cse_1155_);
        let _cse_1178_ = (_e271 * 0.625f);
        let _cse_1179_ = (_cse_1459_ * 0.375f);
        let _cse_1177_ = (_cse_1178_ + _cse_1179_);
        let _cse_1184_ = (_cse_1459_ - _e271);
        let _cse_1186_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1185_ = max(_cse_1186_, 0.000000000001f);
        let _cse_1183_ = (_cse_1184_ / _cse_1185_);
        let _cse_1182_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1183_);
        let _cse_1181_ = dot(_cse_1182_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1180_ = (_cse_1181_ * 0.125f);
        let _cse_1176_ = (_cse_1177_ + _cse_1180_);
        let _cse_1175_ = (_cse_1176_ - _e271);
        let _cse_1187_ = min(_cse_1184_, 0f);
        let _cse_1174_ = max(_cse_1175_, _cse_1187_);
        let _cse_1188_ = max(_cse_1184_, 0f);
        let _cse_1173_ = min(_cse_1174_, _cse_1188_);
        let _cse_1172_ = (_e271 + _cse_1173_);
        let _cse_1191_ = (_e241 - _cse_1450_);
        let _cse_1192_ = normal_vec.y;
        let _cse_1193_ = (_cse_1450_ - _e241);
        u_l_2_ = _cse_1153_;
        u_r_2_ = _cse_1172_;
        let _e6524 = normal_vec;
        f_l_2_ = ((_cse_1153_ * dot(((vec2<f32>((_cse_1450_ + min(max(((((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1191_) / vec2(_cse_1168_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1450_), min(_cse_1191_, 0f)), max(_cse_1191_, 0f))), _cse_1153_) * 1f) / vec2((s_own_rho + min(max(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1168_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))))), _e6524)) + ((s_own_p + min(max(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1168_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f))) * _cse_1192_));
        let _e6606 = normal_vec;
        f_r_2_ = ((_cse_1172_ * dot(((vec2<f32>((_e241 + min(max(((((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1193_) / vec2(_cse_1185_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e241), min(_cse_1193_, 0f)), max(_cse_1193_, 0f))), _cse_1172_) * 1f) / vec2((_e181 + min(max(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1185_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))))), _e6606)) + ((_e151 + min(max(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1185_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f))) * _cse_1192_));
    }
    let _e6638 = constants.scheme;
    if ((_e6638 == 6u) && !(is_boundary_1)) {
        let _cse_1201_ = (_cse_1459_ * 0.625f);
        let _cse_1202_ = (_e271 * 0.375f);
        let _cse_1200_ = (_cse_1201_ + _cse_1202_);
        let _cse_1208_ = (_e271 - _cse_1459_);
        let _cse_1210_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1209_ = max(_cse_1210_, 0.000000000001f);
        let _cse_1207_ = (_cse_1208_ / _cse_1209_);
        let _cse_1206_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1207_);
        let _cse_1205_ = dot(_cse_1206_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1204_ = (_cse_1205_ * 0.125f);
        let _cse_1199_ = (_cse_1200_ + _cse_1204_);
        let _cse_1198_ = (_cse_1199_ - _cse_1459_);
        let _cse_1212_ = abs(_cse_1208_);
        let _cse_1215_ = abs(_cse_1198_);
        let _cse_1214_ = (_cse_1215_ + 0.00000001f);
        let _cse_1213_ = max(_cse_1212_, _cse_1214_);
        let _cse_1211_ = (_cse_1212_ / _cse_1213_);
        let _cse_1197_ = (_cse_1198_ * _cse_1211_);
        let _cse_1218_ = (_cse_1208_ * _cse_1198_);
        let _cse_1217_ = max(_cse_1218_, 0f);
        let _cse_1220_ = abs(_cse_1218_);
        let _cse_1219_ = max(_cse_1220_, 0.00000001f);
        let _cse_1216_ = (_cse_1217_ / _cse_1219_);
        let _cse_1196_ = (_cse_1197_ * _cse_1216_);
        let _cse_1194_ = (_cse_1459_ + _cse_1196_);
        let _cse_1227_ = (_e271 * 0.625f);
        let _cse_1228_ = (_cse_1459_ * 0.375f);
        let _cse_1226_ = (_cse_1227_ + _cse_1228_);
        let _cse_1233_ = (_cse_1459_ - _e271);
        let _cse_1235_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1234_ = max(_cse_1235_, 0.000000000001f);
        let _cse_1232_ = (_cse_1233_ / _cse_1234_);
        let _cse_1231_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1232_);
        let _cse_1230_ = dot(_cse_1231_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1229_ = (_cse_1230_ * 0.125f);
        let _cse_1225_ = (_cse_1226_ + _cse_1229_);
        let _cse_1224_ = (_cse_1225_ - _e271);
        let _cse_1237_ = abs(_cse_1233_);
        let _cse_1240_ = abs(_cse_1224_);
        let _cse_1239_ = (_cse_1240_ + 0.00000001f);
        let _cse_1238_ = max(_cse_1237_, _cse_1239_);
        let _cse_1236_ = (_cse_1237_ / _cse_1238_);
        let _cse_1223_ = (_cse_1224_ * _cse_1236_);
        let _cse_1243_ = (_cse_1233_ * _cse_1224_);
        let _cse_1242_ = max(_cse_1243_, 0f);
        let _cse_1245_ = abs(_cse_1243_);
        let _cse_1244_ = max(_cse_1245_, 0.00000001f);
        let _cse_1241_ = (_cse_1242_ / _cse_1244_);
        let _cse_1222_ = (_cse_1223_ * _cse_1241_);
        let _cse_1221_ = (_e271 + _cse_1222_);
        let _cse_1252_ = (_e241 - _cse_1450_);
        let _cse_1251_ = dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1252_) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1250_ = (_cse_1251_ * 0.125f);
        let _cse_1248_ = (((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + _cse_1250_);
        let _cse_1247_ = (_cse_1248_ - _cse_1450_);
        let _cse_1257_ = (_cse_1450_ - _e241);
        let _cse_1256_ = dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1257_) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1255_ = (_cse_1256_ * 0.125f);
        let _cse_1254_ = (((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + _cse_1255_);
        let _cse_1253_ = (_cse_1254_ - _e241);
        u_l_2_ = _cse_1194_;
        u_r_2_ = _cse_1221_;
        let _e6856 = normal_vec;
        let _e6946 = normal_vec.y;
        f_l_2_ = ((_cse_1194_ * dot(((vec2<f32>((_cse_1450_ + ((((_cse_1247_ * abs(_cse_1252_)) / max(abs(_cse_1252_), (abs(_cse_1247_) + 0.00000001f))) * max((_cse_1252_ * _cse_1247_), 0f)) / max(abs((_cse_1252_ * _cse_1247_)), 0.00000001f))), _cse_1194_) * 1f) / vec2((s_own_rho + ((((((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho) * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho)) + 0.00000001f))) * max(((_e181 - s_own_rho) * ((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho)), 0f)) / max(abs(((_e181 - s_own_rho) * ((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho))), 0.00000001f))))), _e6856)) + ((s_own_p + ((((((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p) * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)) + 0.00000001f))) * max(((_e151 - s_own_p) * ((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p)), 0f)) / max(abs(((_e151 - s_own_p) * ((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1209_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p))), 0.00000001f))) * _e6946));
        let _e7058 = normal_vec;
        let _e7148 = normal_vec.y;
        f_r_2_ = ((_cse_1221_ * dot(((vec2<f32>((_e241 + ((((_cse_1253_ * abs(_cse_1257_)) / max(abs(_cse_1257_), (abs(_cse_1253_) + 0.00000001f))) * max((_cse_1257_ * _cse_1253_), 0f)) / max(abs((_cse_1257_ * _cse_1253_)), 0.00000001f))), _cse_1221_) * 1f) / vec2((_e181 + ((((((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181) * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181)) + 0.00000001f))) * max(((s_own_rho - _e181) * ((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181)), 0f)) / max(abs(((s_own_rho - _e181) * ((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181))), 0.00000001f))))), _e7058)) + ((_e151 + ((((((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)) + 0.00000001f))) * max(((s_own_p - _e151) * ((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151)), 0f)) / max(abs(((s_own_p - _e151) * ((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1234_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151))), 0.00000001f))) * _e7148));
    }
    let _e7157 = a_plus;
    let _e7158 = f_l_2_;
    let _e7160 = a_minus;
    let _e7161 = f_r_2_;
    let _e7164 = a_plus;
    let _e7165 = a_minus;
    let _e7167 = u_r_2_;
    let _e7168 = u_l_2_;
    fluxes[((idx * 8u) + 2u)] = (((((_e7157 * _e7158) - (_e7160 * _e7161)) + ((_e7164 * _e7165) * (_e7167 - _e7168))) / denom) * area);
    u_l_3_ = s_own_rho_e;
    u_r_3_ = _e211;
    let _e7182 = normal_vec;
    f_l_3_ = ((s_own_rho_e + s_own_p) * dot(((vec2<f32>(_cse_1450_, _cse_1459_) * 1f) / vec2(s_own_rho)), _e7182));
    let _e7192 = normal_vec;
    f_r_3_ = ((_e211 + _e151) * dot(((vec2<f32>(_e241, _e271) * 1f) / vec2(_e181)), _e7192));
    let _e7198 = constants.scheme;
    if ((_e7198 == 1u) && !(is_boundary_1)) {
        let _cse_1263_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1262_ = max(_cse_1263_, 0.000000000001f);
        let _cse_1261_ = ((_e211 - s_own_rho_e) / _cse_1262_);
        let _cse_1260_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1261_);
        let _cse_1259_ = dot(_cse_1260_, (face_center_vec - c_owner_vec));
        let _cse_1258_ = (s_own_rho_e + _cse_1259_);
        let _cse_1269_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1268_ = max(_cse_1269_, 0.000000000001f);
        let _cse_1267_ = ((s_own_rho_e - _e211) / _cse_1268_);
        let _cse_1266_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1267_);
        let _cse_1265_ = dot(_cse_1266_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1264_ = (_e211 + _cse_1265_);
        u_l_3_ = _cse_1258_;
        u_r_3_ = _cse_1264_;
        let _e7265 = normal_vec;
        f_l_3_ = (((_cse_1258_ + s_own_p) + dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1262_)), (face_center_vec - c_owner_vec))) * dot(((vec2<f32>((_cse_1450_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_1262_)), (face_center_vec - c_owner_vec))), (_cse_1459_ + dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_1262_)), (face_center_vec - c_owner_vec)))) * 1f) / vec2((s_own_rho + dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1262_)), (face_center_vec - c_owner_vec))))), _e7265));
        let _e7306 = normal_vec;
        f_r_3_ = (((_cse_1264_ + _e151) + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1268_)), (face_center_vec - c_neigh_cell_vec))) * dot(((vec2<f32>((_e241 + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_1268_)), (face_center_vec - c_neigh_cell_vec))), (_e271 + dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_1268_)), (face_center_vec - c_neigh_cell_vec)))) * 1f) / vec2((_e181 + dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1268_)), (face_center_vec - c_neigh_cell_vec))))), _e7306));
    }
    let _e7311 = constants.scheme;
    if ((_e7311 == 2u) && !(is_boundary_1)) {
        let _cse_1277_ = ((s_own_rho_e * 0.625f) + (_e211 * 0.375f));
        let _cse_1283_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1282_ = max(_cse_1283_, 0.000000000001f);
        let _cse_1281_ = ((_e211 - s_own_rho_e) / _cse_1282_);
        let _cse_1280_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1281_);
        let _cse_1279_ = dot(_cse_1280_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1278_ = (_cse_1279_ * 0.125f);
        let _cse_1276_ = (_cse_1277_ + _cse_1278_);
        let _cse_1275_ = (_cse_1276_ - s_own_rho_e);
        let _cse_1274_ = (s_own_rho_e + _cse_1275_);
        let _cse_1287_ = ((_e211 * 0.625f) + (s_own_rho_e * 0.375f));
        let _cse_1293_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1292_ = max(_cse_1293_, 0.000000000001f);
        let _cse_1291_ = ((s_own_rho_e - _e211) / _cse_1292_);
        let _cse_1290_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1291_);
        let _cse_1289_ = dot(_cse_1290_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1288_ = (_cse_1289_ * 0.125f);
        let _cse_1286_ = (_cse_1287_ + _cse_1288_);
        let _cse_1285_ = (_cse_1286_ - _e211);
        let _cse_1284_ = (_e211 + _cse_1285_);
        u_l_3_ = _cse_1274_;
        u_r_3_ = _cse_1284_;
        let _e7432 = normal_vec;
        f_l_3_ = ((((((_cse_1274_ + s_own_p) + (s_own_p * 0.625f)) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1282_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p) * dot(((vec2<f32>(((((_cse_1450_ + (_cse_1450_ * 0.625f)) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e241 - _cse_1450_)) / vec2(_cse_1282_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1450_), ((((_cse_1459_ + (_cse_1459_ * 0.625f)) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e271 - _cse_1459_)) / vec2(_cse_1282_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1459_)) * 1f) / vec2(((((s_own_rho + (s_own_rho * 0.625f)) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1282_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho))), _e7432));
        let _e7509 = normal_vec;
        f_r_3_ = ((((((_cse_1284_ + _e151) + (_e151 * 0.625f)) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1292_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151) * dot(((vec2<f32>(((((_e241 + (_e241 * 0.625f)) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1450_ - _e241)) / vec2(_cse_1292_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e241), ((((_e271 + (_e271 * 0.625f)) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (_cse_1459_ - _e271)) / vec2(_cse_1292_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e271)) * 1f) / vec2(((((_e181 + (_e181 * 0.625f)) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1292_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181))), _e7509));
    }
    let _e7514 = constants.scheme;
    if ((_e7514 == 3u) && !(is_boundary_1)) {
        let _cse_1305_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1304_ = max(_cse_1305_, 0.000000000001f);
        let _cse_1303_ = ((_e211 - s_own_rho_e) / _cse_1304_);
        let _cse_1302_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1303_);
        let _cse_1301_ = dot(_cse_1302_, (face_center_vec - c_owner_vec));
        let _cse_1306_ = min((_e211 - s_own_rho_e), 0f);
        let _cse_1300_ = max(_cse_1301_, _cse_1306_);
        let _cse_1307_ = max((_e211 - s_own_rho_e), 0f);
        let _cse_1299_ = min(_cse_1300_, _cse_1307_);
        let _cse_1298_ = (s_own_rho_e + _cse_1299_);
        let _cse_1315_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1314_ = max(_cse_1315_, 0.000000000001f);
        let _cse_1313_ = ((s_own_rho_e - _e211) / _cse_1314_);
        let _cse_1312_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1313_);
        let _cse_1311_ = dot(_cse_1312_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1316_ = min((s_own_rho_e - _e211), 0f);
        let _cse_1310_ = max(_cse_1311_, _cse_1316_);
        let _cse_1317_ = max((s_own_rho_e - _e211), 0f);
        let _cse_1309_ = min(_cse_1310_, _cse_1317_);
        let _cse_1308_ = (_e211 + _cse_1309_);
        let _cse_1319_ = (_e241 - _cse_1450_);
        let _cse_1322_ = (_e271 - _cse_1459_);
        let _cse_1324_ = (_cse_1450_ - _e241);
        let _cse_1325_ = (_cse_1459_ - _e271);
        u_l_3_ = _cse_1298_;
        u_r_3_ = _cse_1308_;
        let _e7627 = normal_vec;
        f_l_3_ = (((_cse_1298_ + s_own_p) + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1304_)), (face_center_vec - c_owner_vec)), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f))) * dot(((vec2<f32>((_cse_1450_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1319_) / vec2(_cse_1304_)), (face_center_vec - c_owner_vec)), min(_cse_1319_, 0f)), max(_cse_1319_, 0f))), (_cse_1459_ + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1322_) / vec2(_cse_1304_)), (face_center_vec - c_owner_vec)), min(_cse_1322_, 0f)), max(_cse_1322_, 0f)))) * 1f) / vec2((s_own_rho + min(max(dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1304_)), (face_center_vec - c_owner_vec)), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))))), _e7627));
        let _e7694 = normal_vec;
        f_r_3_ = (((_cse_1308_ + _e151) + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1314_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f))) * dot(((vec2<f32>((_e241 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1324_) / vec2(_cse_1314_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_1324_, 0f)), max(_cse_1324_, 0f))), (_e271 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1325_) / vec2(_cse_1314_)), (face_center_vec - c_neigh_cell_vec)), min(_cse_1325_, 0f)), max(_cse_1325_, 0f)))) * 1f) / vec2((_e181 + min(max(dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1314_)), (face_center_vec - c_neigh_cell_vec)), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))))), _e7694));
    }
    let _e7699 = constants.scheme;
    if ((_e7699 == 4u) && !(is_boundary_1)) {
        let _cse_1333_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1332_ = max(_cse_1333_, 0.000000000001f);
        let _cse_1331_ = ((_e211 - s_own_rho_e) / _cse_1332_);
        let _cse_1330_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1331_);
        let _cse_1329_ = dot(_cse_1330_, (face_center_vec - c_owner_vec));
        let _cse_1335_ = max(abs((_e211 - s_own_rho_e)), (abs(_cse_1329_) + 0.00000001f));
        let _cse_1334_ = (abs((_e211 - s_own_rho_e)) / _cse_1335_);
        let _cse_1328_ = (_cse_1329_ * _cse_1334_);
        let _cse_1338_ = ((_e211 - s_own_rho_e) * _cse_1329_);
        let _cse_1337_ = max(_cse_1338_, 0f);
        let _cse_1339_ = max(abs(_cse_1338_), 0.00000001f);
        let _cse_1336_ = (_cse_1337_ / _cse_1339_);
        let _cse_1327_ = (_cse_1328_ * _cse_1336_);
        let _cse_1326_ = (s_own_rho_e + _cse_1327_);
        let _cse_1347_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1346_ = max(_cse_1347_, 0.000000000001f);
        let _cse_1345_ = ((s_own_rho_e - _e211) / _cse_1346_);
        let _cse_1344_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1345_);
        let _cse_1343_ = dot(_cse_1344_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1349_ = max(abs((s_own_rho_e - _e211)), (abs(_cse_1343_) + 0.00000001f));
        let _cse_1348_ = (abs((s_own_rho_e - _e211)) / _cse_1349_);
        let _cse_1342_ = (_cse_1343_ * _cse_1348_);
        let _cse_1352_ = ((s_own_rho_e - _e211) * _cse_1343_);
        let _cse_1351_ = max(_cse_1352_, 0f);
        let _cse_1353_ = max(abs(_cse_1352_), 0.00000001f);
        let _cse_1350_ = (_cse_1351_ / _cse_1353_);
        let _cse_1341_ = (_cse_1342_ * _cse_1350_);
        let _cse_1340_ = (_e211 + _cse_1341_);
        let _cse_1356_ = ((_e151 - s_own_p) / _cse_1332_);
        let _cse_1355_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1356_);
        let _cse_1354_ = dot(_cse_1355_, (face_center_vec - c_owner_vec));
        let _cse_1361_ = (_e241 - _cse_1450_);
        let _cse_1360_ = (_cse_1361_ / _cse_1332_);
        let _cse_1359_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1360_);
        let _cse_1358_ = dot(_cse_1359_, (face_center_vec - c_owner_vec));
        let _cse_1363_ = (_cse_1361_ * _cse_1358_);
        let _cse_1368_ = (_e271 - _cse_1459_);
        let _cse_1367_ = (_cse_1368_ / _cse_1332_);
        let _cse_1366_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1367_);
        let _cse_1365_ = dot(_cse_1366_, (face_center_vec - c_owner_vec));
        let _cse_1370_ = (_cse_1368_ * _cse_1365_);
        let _cse_1373_ = ((_e181 - s_own_rho) / _cse_1332_);
        let _cse_1372_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1373_);
        let _cse_1371_ = dot(_cse_1372_, (face_center_vec - c_owner_vec));
        let _cse_1376_ = ((s_own_p - _e151) / _cse_1346_);
        let _cse_1375_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1376_);
        let _cse_1374_ = dot(_cse_1375_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1380_ = (_cse_1450_ - _e241);
        let _cse_1379_ = (_cse_1380_ / _cse_1346_);
        let _cse_1378_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1379_);
        let _cse_1377_ = dot(_cse_1378_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1381_ = (_cse_1380_ * _cse_1377_);
        let _cse_1385_ = (_cse_1459_ - _e271);
        let _cse_1384_ = (_cse_1385_ / _cse_1346_);
        let _cse_1383_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1384_);
        let _cse_1382_ = dot(_cse_1383_, (face_center_vec - c_neigh_cell_vec));
        let _cse_1386_ = (_cse_1385_ * _cse_1382_);
        let _cse_1389_ = ((s_own_rho - _e181) / _cse_1346_);
        let _cse_1388_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1389_);
        let _cse_1387_ = dot(_cse_1388_, (face_center_vec - c_neigh_cell_vec));
        u_l_3_ = _cse_1326_;
        u_r_3_ = _cse_1340_;
        let _e7900 = normal_vec;
        f_l_3_ = (((_cse_1326_ + s_own_p) + ((((_cse_1354_ * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(_cse_1354_) + 0.00000001f))) * max(((_e151 - s_own_p) * _cse_1354_), 0f)) / max(abs(((_e151 - s_own_p) * _cse_1354_)), 0.00000001f))) * dot(((vec2<f32>((_cse_1450_ + ((((_cse_1358_ * abs(_cse_1361_)) / max(abs(_cse_1361_), (abs(_cse_1358_) + 0.00000001f))) * max(_cse_1363_, 0f)) / max(abs(_cse_1363_), 0.00000001f))), (_cse_1459_ + ((((_cse_1365_ * abs(_cse_1368_)) / max(abs(_cse_1368_), (abs(_cse_1365_) + 0.00000001f))) * max(_cse_1370_, 0f)) / max(abs(_cse_1370_), 0.00000001f)))) * 1f) / vec2((s_own_rho + ((((_cse_1371_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1371_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1371_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1371_)), 0.00000001f))))), _e7900));
        let _e7985 = normal_vec;
        f_r_3_ = (((_cse_1340_ + _e151) + ((((_cse_1374_ * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(_cse_1374_) + 0.00000001f))) * max(((s_own_p - _e151) * _cse_1374_), 0f)) / max(abs(((s_own_p - _e151) * _cse_1374_)), 0.00000001f))) * dot(((vec2<f32>((_e241 + ((((_cse_1377_ * abs(_cse_1380_)) / max(abs(_cse_1380_), (abs(_cse_1377_) + 0.00000001f))) * max(_cse_1381_, 0f)) / max(abs(_cse_1381_), 0.00000001f))), (_e271 + ((((_cse_1382_ * abs(_cse_1385_)) / max(abs(_cse_1385_), (abs(_cse_1382_) + 0.00000001f))) * max(_cse_1386_, 0f)) / max(abs(_cse_1386_), 0.00000001f)))) * 1f) / vec2((_e181 + ((((_cse_1387_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1387_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1387_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1387_)), 0.00000001f))))), _e7985));
    }
    let _e7990 = constants.scheme;
    if ((_e7990 == 5u) && !(is_boundary_1)) {
        let _cse_1395_ = ((s_own_rho_e * 0.625f) + (_e211 * 0.375f));
        let _cse_1401_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1400_ = max(_cse_1401_, 0.000000000001f);
        let _cse_1399_ = ((_e211 - s_own_rho_e) / _cse_1400_);
        let _cse_1398_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1399_);
        let _cse_1397_ = dot(_cse_1398_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1396_ = (_cse_1397_ * 0.125f);
        let _cse_1394_ = (_cse_1395_ + _cse_1396_);
        let _cse_1393_ = (_cse_1394_ - s_own_rho_e);
        let _cse_1402_ = min((_e211 - s_own_rho_e), 0f);
        let _cse_1392_ = max(_cse_1393_, _cse_1402_);
        let _cse_1403_ = max((_e211 - s_own_rho_e), 0f);
        let _cse_1391_ = min(_cse_1392_, _cse_1403_);
        let _cse_1390_ = (s_own_rho_e + _cse_1391_);
        let _cse_1409_ = ((_e211 * 0.625f) + (s_own_rho_e * 0.375f));
        let _cse_1415_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1414_ = max(_cse_1415_, 0.000000000001f);
        let _cse_1413_ = ((s_own_rho_e - _e211) / _cse_1414_);
        let _cse_1412_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1413_);
        let _cse_1411_ = dot(_cse_1412_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1410_ = (_cse_1411_ * 0.125f);
        let _cse_1408_ = (_cse_1409_ + _cse_1410_);
        let _cse_1407_ = (_cse_1408_ - _e211);
        let _cse_1416_ = min((s_own_rho_e - _e211), 0f);
        let _cse_1406_ = max(_cse_1407_, _cse_1416_);
        let _cse_1417_ = max((s_own_rho_e - _e211), 0f);
        let _cse_1405_ = min(_cse_1406_, _cse_1417_);
        let _cse_1404_ = (_e211 + _cse_1405_);
        let _cse_1420_ = (_e241 - _cse_1450_);
        let _cse_1423_ = (_e271 - _cse_1459_);
        let _cse_1424_ = (_cse_1450_ - _e241);
        let _cse_1425_ = (_cse_1459_ - _e271);
        u_l_3_ = _cse_1390_;
        u_r_3_ = _cse_1404_;
        let _e8157 = normal_vec;
        f_l_3_ = (((_cse_1390_ + s_own_p) + min(max(((((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1400_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_p), min((_e151 - s_own_p), 0f)), max((_e151 - s_own_p), 0f))) * dot(((vec2<f32>((_cse_1450_ + min(max(((((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1420_) / vec2(_cse_1400_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1450_), min(_cse_1420_, 0f)), max(_cse_1420_, 0f))), (_cse_1459_ + min(max(((((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * _cse_1423_) / vec2(_cse_1400_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - _cse_1459_), min(_cse_1423_, 0f)), max(_cse_1423_, 0f)))) * 1f) / vec2((s_own_rho + min(max(((((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1400_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f)) - s_own_rho), min((_e181 - s_own_rho), 0f)), max((_e181 - s_own_rho), 0f))))), _e8157));
        let _e8260 = normal_vec;
        f_r_3_ = (((_cse_1404_ + _e151) + min(max(((((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1414_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e151), min((s_own_p - _e151), 0f)), max((s_own_p - _e151), 0f))) * dot(((vec2<f32>((_e241 + min(max(((((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1424_) / vec2(_cse_1414_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e241), min(_cse_1424_, 0f)), max(_cse_1424_, 0f))), (_e271 + min(max(((((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * _cse_1425_) / vec2(_cse_1414_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e271), min(_cse_1425_, 0f)), max(_cse_1425_, 0f)))) * 1f) / vec2((_e181 + min(max(((((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1414_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f)) - _e181), min((s_own_rho - _e181), 0f)), max((s_own_rho - _e181), 0f))))), _e8260));
    }
    let _e8265 = constants.scheme;
    if ((_e8265 == 6u) && !(is_boundary_1)) {
        let _cse_1435_ = dot((c_neigh_cell_vec - c_owner_vec), (c_neigh_cell_vec - c_owner_vec));
        let _cse_1434_ = max(_cse_1435_, 0.000000000001f);
        let _cse_1433_ = ((_e211 - s_own_rho_e) / _cse_1434_);
        let _cse_1432_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1433_);
        let _cse_1431_ = dot(_cse_1432_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1430_ = (_cse_1431_ * 0.125f);
        let _cse_1429_ = (((s_own_rho_e * 0.625f) + (_e211 * 0.375f)) + _cse_1430_);
        let _cse_1428_ = (_cse_1429_ - s_own_rho_e);
        let _cse_1436_ = ((_e211 - s_own_rho_e) * _cse_1428_);
        let _cse_1427_ = ((((_cse_1428_ * abs((_e211 - s_own_rho_e))) / max(abs((_e211 - s_own_rho_e)), (abs(_cse_1428_) + 0.00000001f))) * max(_cse_1436_, 0f)) / max(abs(_cse_1436_), 0.00000001f));
        let _cse_1426_ = (s_own_rho_e + _cse_1427_);
        let _cse_1446_ = dot((c_owner_vec - c_neigh_cell_vec), (c_owner_vec - c_neigh_cell_vec));
        let _cse_1445_ = max(_cse_1446_, 0.000000000001f);
        let _cse_1444_ = ((s_own_rho_e - _e211) / _cse_1445_);
        let _cse_1443_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1444_);
        let _cse_1442_ = dot(_cse_1443_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1441_ = (_cse_1442_ * 0.125f);
        let _cse_1440_ = (((_e211 * 0.625f) + (s_own_rho_e * 0.375f)) + _cse_1441_);
        let _cse_1439_ = (_cse_1440_ - _e211);
        let _cse_1447_ = ((s_own_rho_e - _e211) * _cse_1439_);
        let _cse_1438_ = ((((_cse_1439_ * abs((s_own_rho_e - _e211))) / max(abs((s_own_rho_e - _e211)), (abs(_cse_1439_) + 0.00000001f))) * max(_cse_1447_, 0f)) / max(abs(_cse_1447_), 0.00000001f));
        let _cse_1437_ = (_e211 + _cse_1438_);
        let _cse_1449_ = (((s_own_p * 0.625f) + (_e151 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e151 - s_own_p)) / vec2(_cse_1434_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1448_ = (_cse_1449_ - s_own_p);
        let _cse_1457_ = (_e241 - _cse_1450_);
        let _cse_1456_ = (((c_neigh_cell_vec - c_owner_vec) * _cse_1457_) / vec2(_cse_1434_));
        let _cse_1455_ = dot(_cse_1456_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1454_ = (_cse_1455_ * 0.125f);
        let _cse_1452_ = (((_cse_1450_ * 0.625f) + (_e241 * 0.375f)) + _cse_1454_);
        let _cse_1451_ = (_cse_1452_ - _cse_1450_);
        let _cse_1458_ = (_cse_1457_ * _cse_1451_);
        let _cse_1467_ = (_e271 - _cse_1459_);
        let _cse_1466_ = (_cse_1467_ / _cse_1434_);
        let _cse_1465_ = ((c_neigh_cell_vec - c_owner_vec) * _cse_1466_);
        let _cse_1464_ = dot(_cse_1465_, (c_neigh_cell_vec - c_owner_vec));
        let _cse_1463_ = (_cse_1464_ * 0.125f);
        let _cse_1461_ = (((_cse_1459_ * 0.625f) + (_e271 * 0.375f)) + _cse_1463_);
        let _cse_1460_ = (_cse_1461_ - _cse_1459_);
        let _cse_1468_ = (_cse_1467_ * _cse_1460_);
        let _cse_1470_ = (((s_own_rho * 0.625f) + (_e181 * 0.375f)) + (dot((((c_neigh_cell_vec - c_owner_vec) * (_e181 - s_own_rho)) / vec2(_cse_1434_)), (c_neigh_cell_vec - c_owner_vec)) * 0.125f));
        let _cse_1469_ = (_cse_1470_ - s_own_rho);
        let _cse_1472_ = (((_e151 * 0.625f) + (s_own_p * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_p - _e151)) / vec2(_cse_1445_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1471_ = (_cse_1472_ - _e151);
        let _cse_1478_ = (_cse_1450_ - _e241);
        let _cse_1477_ = (((c_owner_vec - c_neigh_cell_vec) * _cse_1478_) / vec2(_cse_1445_));
        let _cse_1476_ = dot(_cse_1477_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1475_ = (_cse_1476_ * 0.125f);
        let _cse_1474_ = (((_e241 * 0.625f) + (_cse_1450_ * 0.375f)) + _cse_1475_);
        let _cse_1473_ = (_cse_1474_ - _e241);
        let _cse_1479_ = (_cse_1478_ * _cse_1473_);
        let _cse_1486_ = (_cse_1459_ - _e271);
        let _cse_1485_ = (_cse_1486_ / _cse_1445_);
        let _cse_1484_ = ((c_owner_vec - c_neigh_cell_vec) * _cse_1485_);
        let _cse_1483_ = dot(_cse_1484_, (c_owner_vec - c_neigh_cell_vec));
        let _cse_1482_ = (_cse_1483_ * 0.125f);
        let _cse_1481_ = (((_e271 * 0.625f) + (_cse_1459_ * 0.375f)) + _cse_1482_);
        let _cse_1480_ = (_cse_1481_ - _e271);
        let _cse_1487_ = (_cse_1486_ * _cse_1480_);
        let _cse_1489_ = (((_e181 * 0.625f) + (s_own_rho * 0.375f)) + (dot((((c_owner_vec - c_neigh_cell_vec) * (s_own_rho - _e181)) / vec2(_cse_1445_)), (c_owner_vec - c_neigh_cell_vec)) * 0.125f));
        let _cse_1488_ = (_cse_1489_ - _e181);
        u_l_3_ = _cse_1426_;
        u_r_3_ = _cse_1437_;
        let _e8562 = normal_vec;
        f_l_3_ = (((_cse_1426_ + s_own_p) + ((((_cse_1448_ * abs((_e151 - s_own_p))) / max(abs((_e151 - s_own_p)), (abs(_cse_1448_) + 0.00000001f))) * max(((_e151 - s_own_p) * _cse_1448_), 0f)) / max(abs(((_e151 - s_own_p) * _cse_1448_)), 0.00000001f))) * dot(((vec2<f32>((_cse_1450_ + ((((_cse_1451_ * abs(_cse_1457_)) / max(abs(_cse_1457_), (abs(_cse_1451_) + 0.00000001f))) * max(_cse_1458_, 0f)) / max(abs(_cse_1458_), 0.00000001f))), (_cse_1459_ + ((((_cse_1460_ * abs(_cse_1467_)) / max(abs(_cse_1467_), (abs(_cse_1460_) + 0.00000001f))) * max(_cse_1468_, 0f)) / max(abs(_cse_1468_), 0.00000001f)))) * 1f) / vec2((s_own_rho + ((((_cse_1469_ * abs((_e181 - s_own_rho))) / max(abs((_e181 - s_own_rho)), (abs(_cse_1469_) + 0.00000001f))) * max(((_e181 - s_own_rho) * _cse_1469_), 0f)) / max(abs(((_e181 - s_own_rho) * _cse_1469_)), 0.00000001f))))), _e8562));
        let _e8647 = normal_vec;
        f_r_3_ = (((_cse_1437_ + _e151) + ((((_cse_1471_ * abs((s_own_p - _e151))) / max(abs((s_own_p - _e151)), (abs(_cse_1471_) + 0.00000001f))) * max(((s_own_p - _e151) * _cse_1471_), 0f)) / max(abs(((s_own_p - _e151) * _cse_1471_)), 0.00000001f))) * dot(((vec2<f32>((_e241 + ((((_cse_1473_ * abs(_cse_1478_)) / max(abs(_cse_1478_), (abs(_cse_1473_) + 0.00000001f))) * max(_cse_1479_, 0f)) / max(abs(_cse_1479_), 0.00000001f))), (_e271 + ((((_cse_1480_ * abs(_cse_1486_)) / max(abs(_cse_1486_), (abs(_cse_1480_) + 0.00000001f))) * max(_cse_1487_, 0f)) / max(abs(_cse_1487_), 0.00000001f)))) * 1f) / vec2((_e181 + ((((_cse_1488_ * abs((s_own_rho - _e181))) / max(abs((s_own_rho - _e181)), (abs(_cse_1488_) + 0.00000001f))) * max(((s_own_rho - _e181) * _cse_1488_), 0f)) / max(abs(((s_own_rho - _e181) * _cse_1488_)), 0.00000001f))))), _e8647));
    }
    let _e8656 = a_plus;
    let _e8657 = f_l_3_;
    let _e8659 = a_minus;
    let _e8660 = f_r_3_;
    let _e8663 = a_plus;
    let _e8664 = a_minus;
    let _e8666 = u_r_3_;
    let _e8667 = u_l_3_;
    fluxes[((idx * 8u) + 3u)] = (((((_e8656 * _e8657) - (_e8659 * _e8660)) + ((_e8663 * _e8664) * (_e8666 - _e8667))) / denom) * area);
    let _e8675 = constants.scheme;
    if ((_e8675 == 1u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8690 = constants.scheme;
    if ((_e8690 == 2u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8701 = constants.scheme;
    if ((_e8701 == 3u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8712 = constants.scheme;
    if ((_e8712 == 4u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8723 = constants.scheme;
    if ((_e8723 == 5u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8734 = constants.scheme;
    if ((_e8734 == 6u) && !(is_boundary_1)) {
        u_l_4_ = 0f;
        u_r_4_ = 0f;
        f_l_4_ = 0f;
        f_r_4_ = 0f;
    }
    let _e8749 = a_plus;
    let _e8750 = f_l_4_;
    let _e8752 = a_minus;
    let _e8753 = f_r_4_;
    let _e8756 = a_plus;
    let _e8757 = a_minus;
    let _e8759 = u_r_4_;
    let _e8760 = u_l_4_;
    fluxes[((idx * 8u) + 4u)] = (((((_e8749 * _e8750) - (_e8752 * _e8753)) + ((_e8756 * _e8757) * (_e8759 - _e8760))) / denom) * area);
    let _e8768 = constants.scheme;
    if ((_e8768 == 1u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8783 = constants.scheme;
    if ((_e8783 == 2u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8794 = constants.scheme;
    if ((_e8794 == 3u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8805 = constants.scheme;
    if ((_e8805 == 4u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8816 = constants.scheme;
    if ((_e8816 == 5u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8827 = constants.scheme;
    if ((_e8827 == 6u) && !(is_boundary_1)) {
        u_l_5_ = 0f;
        u_r_5_ = 0f;
        f_l_5_ = 0f;
        f_r_5_ = 0f;
    }
    let _e8842 = a_plus;
    let _e8843 = f_l_5_;
    let _e8845 = a_minus;
    let _e8846 = f_r_5_;
    let _e8849 = a_plus;
    let _e8850 = a_minus;
    let _e8852 = u_r_5_;
    let _e8853 = u_l_5_;
    fluxes[((idx * 8u) + 5u)] = (((((_e8842 * _e8843) - (_e8845 * _e8846)) + ((_e8849 * _e8850) * (_e8852 - _e8853))) / denom) * area);
    let _e8861 = constants.scheme;
    if ((_e8861 == 1u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8876 = constants.scheme;
    if ((_e8876 == 2u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8887 = constants.scheme;
    if ((_e8887 == 3u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8898 = constants.scheme;
    if ((_e8898 == 4u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8909 = constants.scheme;
    if ((_e8909 == 5u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8920 = constants.scheme;
    if ((_e8920 == 6u) && !(is_boundary_1)) {
        u_l_6_ = 0f;
        u_r_6_ = 0f;
        f_l_6_ = 0f;
        f_r_6_ = 0f;
    }
    let _e8935 = a_plus;
    let _e8936 = f_l_6_;
    let _e8938 = a_minus;
    let _e8939 = f_r_6_;
    let _e8942 = a_plus;
    let _e8943 = a_minus;
    let _e8945 = u_r_6_;
    let _e8946 = u_l_6_;
    fluxes[((idx * 8u) + 6u)] = (((((_e8935 * _e8936) - (_e8938 * _e8939)) + ((_e8942 * _e8943) * (_e8945 - _e8946))) / denom) * area);
    let _e8954 = constants.scheme;
    if ((_e8954 == 1u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8969 = constants.scheme;
    if ((_e8969 == 2u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8980 = constants.scheme;
    if ((_e8980 == 3u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e8991 = constants.scheme;
    if ((_e8991 == 4u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e9002 = constants.scheme;
    if ((_e9002 == 5u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e9013 = constants.scheme;
    if ((_e9013 == 6u) && !(is_boundary_1)) {
        u_l_7_ = 0f;
        u_r_7_ = 0f;
        f_l_7_ = 0f;
        f_r_7_ = 0f;
    }
    let _e9028 = a_plus;
    let _e9029 = f_l_7_;
    let _e9031 = a_minus;
    let _e9032 = f_r_7_;
    let _e9035 = a_plus;
    let _e9036 = a_minus;
    let _e9038 = u_r_7_;
    let _e9039 = u_l_7_;
    fluxes[((idx * 8u) + 7u)] = (((((_e9028 * _e9029) - (_e9031 * _e9032)) + ((_e9035 * _e9036) * (_e9038 - _e9039))) / denom) * area);
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e31 = k;
        if (_e31 < end) {
        } else {
            break;
        }
        {
            let _e34 = k;
            let face_idx = cell_faces[_e34];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e60 = face_normals[face_idx].x;
            let _e64 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e60, _e64);
            let _e68 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e68) < 0f) {
                let _e72 = normal_vec;
                normal_vec = -(_e72);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e81 = other_idx;
                let other_center = cell_centers[_e81];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e88 = other_center_vec;
            let d_neigh = distance(_e88, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e96 = lambda;
            let lambda_other = (1f - _e96);
            let _e99 = normal_vec;
            let _e106 = state[((idx * 8u) + 2u)];
            let _e107 = lambda;
            let _e109 = other_idx;
            let _e116 = state[((_e109 * 8u) + 2u)];
            let _e123 = state[((idx * 8u) + 2u)];
            let _e130 = bc_value[((face_idx * 3u) + 2u)];
            let _e137 = bc_kind[((face_idx * 3u) + 2u)];
            let _e147 = state[((idx * 8u) + 2u)];
            let _e154 = bc_value[((face_idx * 3u) + 2u)];
            let _e163 = bc_kind[((face_idx * 3u) + 2u)];
            let _e173 = grad_acc_p;
            grad_acc_p = (_e173 + ((_e99 * ((_e106 * _e107) + (select(_e116, select(select(_e123, _e130, (_e137 == 1u)), (_e147 + (_e154 * d_own)), (_e163 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e176 = k;
            k = (_e176 + 1u);
        }
    }
    let _e178 = grad_acc_p;
    let grad_out_p = ((_e178 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32;

    boundary = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = (owner + (value * d_own));
    }
    let _e13 = boundary;
    return select(interior, _e13, is_boundary);
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var phi: f32;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner_1 = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary_1 = (neighbor == -1i);
    neigh_idx = owner_1;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner_1];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary_1 {
        c_neigh_vec = face_center_vec;
    }
    let d_own_1 = distance(c_owner_vec, face_center_vec);
    let _e69 = c_neigh_vec;
    let d_neigh = distance(_e69, face_center_vec);
    let total_dist = (d_own_1 + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e76 = lambda;
    let lambda_other = (1f - _e76);
    let _e79 = c_neigh_vec;
    let d_vec = (_e79 - c_owner_vec);
    let _e81 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e81));
    let dist = max(dist_proj, 0.000001f);
    let s_own_U_x = state[((owner_1 * 8u) + 0u)];
    let s_own_U_y = state[((owner_1 * 8u) + 1u)];
    let s_own_d_p = state[((owner_1 * 8u) + 3u)];
    let s_own_p = state[((owner_1 * 8u) + 2u)];
    let _e114 = neigh_idx;
    let _e121 = state[((_e114 * 8u) + 0u)];
    let _e128 = state[((owner_1 * 8u) + 0u)];
    let _e135 = bc_kind[((idx * 3u) + 0u)];
    let _e142 = bc_value[((idx * 3u) + 0u)];
    let _e143 = bc_neighbor_scalar(_e121, _e128, _e135, _e142, d_own_1, is_boundary_1);
    let _e144 = neigh_idx;
    let _e151 = state[((_e144 * 8u) + 1u)];
    let _e158 = state[((owner_1 * 8u) + 1u)];
    let _e165 = bc_kind[((idx * 3u) + 1u)];
    let _e172 = bc_value[((idx * 3u) + 1u)];
    let _e173 = bc_neighbor_scalar(_e151, _e158, _e165, _e172, d_own_1, is_boundary_1);
    let _e174 = neigh_idx;
    let _e181 = state[((_e174 * 8u) + 3u)];
    let _e188 = state[((owner_1 * 8u) + 3u)];
    let s_neigh_d_p = select(_e181, _e188, is_boundary_1);
    let _e190 = neigh_idx;
    let _e197 = state[((_e190 * 8u) + 2u)];
    let _e204 = state[((owner_1 * 8u) + 2u)];
    let _e211 = bc_kind[((idx * 3u) + 2u)];
    let _e218 = bc_value[((idx * 3u) + 2u)];
    let _e219 = bc_neighbor_scalar(_e197, _e204, _e211, _e218, d_own_1, is_boundary_1);
    let _e222 = constants.density;
    let _e224 = lambda;
    let _e229 = normal_vec;
    let _e235 = constants.density;
    let _e236 = lambda;
    phi = (((_e222 * dot(((vec2<f32>(s_own_U_x, s_own_U_y) * _e224) + (vec2<f32>(_e143, _e173) * lambda_other)), _e229)) * area) - ((((_e235 * ((s_own_d_p * _e236) + (s_neigh_d_p * lambda_other))) * (_e219 - s_own_p)) / dist) * area));
    let _e253 = phi;
    fluxes[((idx * 3u) + 0u)] = _e253;
    let _e260 = phi;
    fluxes[((idx * 3u) + 1u)] = _e260;
    let _e267 = phi;
    fluxes[((idx * 3u) + 2u)] = _e267;
    return;
}
"#;
    }
    pub mod generic_coupled_apply {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub row_offsets: wgpu::BufferBinding<'a>,
            pub col_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub row_offsets: wgpu::BindGroupEntry<'a>,
            pub col_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.row_offsets),
                    },
                    col_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.col_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.row_offsets, self.col_indices, self.matrix_values]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"col_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub y: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub y: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    y: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.y),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.x, self.y, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::generic_coupled_apply::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> y: array<f32>;
@group(1) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e5 = constants.stride_x;
    let row = ((global_id.y * _e5) + global_id.x);
    let n = (arrayLength((&row_offsets)) - 1u);
    if (row >= n) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e23 = k;
        if (_e23 < end) {
        } else {
            break;
        }
        {
            let _e26 = k;
            let col = col_indices[_e26];
            let _e30 = k;
            let _e32 = matrix_values[_e30];
            let _e36 = x[col];
            let _e38 = sum;
            sum = (_e38 + (_e32 * _e36));
        }
        continuing {
            let _e41 = k;
            k = (_e41 + 1u);
        }
    }
    let _e45 = sum;
    y[row] = _e45;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup3::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 8u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 8u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 8u) + 0u)];
        let _e750 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 8u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 8u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 8u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 8u) + 1u)];
        let _e871 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 8u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 8u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 8u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 8u) + 2u)];
        let _e992 = state_old_old[((idx * 8u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 8u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 8u) + 3u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 8u) + 3u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 8u) + 3u)];
        let _e1113 = state_old_old[((idx * 8u) + 3u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 8u) + 3u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 8u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 8u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 8u) + 6u)];
    let _e1332 = state[((idx * 8u) + 6u)];
    let _e1340 = state[((idx * 8u) + 7u)];
    let _e1347 = state[((idx * 8u) + 7u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 8u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1560 = dist;
            let diff_coeff_rho_u = ((_e1558 * area) / _e1560);
            let _e1562 = is_boundary;
            if !(_e1562) {
                let _e1571 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1571 + diff_coeff_rho_u);
                let _e1580 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1580 - diff_coeff_rho_u);
            } else {
                let _e1588 = bc_kind[((face_idx * 8u) + 4u)];
                if (_e1588 == 1u) {
                    let _e1598 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1598 + diff_coeff_rho_u);
                    let _e1606 = bc_value[((face_idx * 8u) + 4u)];
                    let _e1608 = rhs_1_;
                    rhs_1_ = (_e1608 + (diff_coeff_rho_u * _e1606));
                } else {
                    let _e1616 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1616 == 2u) {
                        let _e1621 = constants.viscosity;
                        let _e1629 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1632 = rhs_1_;
                        rhs_1_ = (_e1632 + -(((_e1621 * area) * _e1629)));
                    }
                }
            }
            let _e1634 = is_boundary;
            if !(_e1634) {
                let _e1643 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1643 + diff_coeff_rho_u);
                let _e1652 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1652 - diff_coeff_rho_u);
            } else {
                let _e1660 = bc_kind[((face_idx * 8u) + 5u)];
                if (_e1660 == 1u) {
                    let _e1670 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1670 + diff_coeff_rho_u);
                    let _e1678 = bc_value[((face_idx * 8u) + 5u)];
                    let _e1680 = rhs_2_;
                    rhs_2_ = (_e1680 + (diff_coeff_rho_u * _e1678));
                } else {
                    let _e1688 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1688 == 2u) {
                        let _e1693 = constants.viscosity;
                        let _e1701 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1704 = rhs_2_;
                        rhs_2_ = (_e1704 + -(((_e1693 * area) * _e1701)));
                    }
                }
            }
            let _e1712 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1712;
            if (owner != idx) {
                let _e1715 = phi_1_;
                let _e1718 = phi_1_;
                phi_1_ = (_e1718 - (_e1715 * 2f));
            }
            let _e1720 = phi_1_;
            let _e1721 = rhs_1_;
            rhs_1_ = (_e1721 - _e1720);
            let _e1729 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1729;
            if (owner != idx) {
                let _e1732 = phi_2_;
                let _e1735 = phi_2_;
                phi_2_ = (_e1735 - (_e1732 * 2f));
            }
            let _e1737 = phi_2_;
            let _e1738 = rhs_2_;
            rhs_2_ = (_e1738 - _e1737);
            let _e1746 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1746;
            if (owner != idx) {
                let _e1749 = phi_3_;
                let _e1752 = phi_3_;
                phi_3_ = (_e1752 - (_e1749 * 2f));
            }
            let _e1754 = phi_3_;
            let _e1755 = rhs_3_;
            rhs_3_ = (_e1755 - _e1754);
        }
        continuing {
            let _e1758 = k;
            k = (_e1758 + 1u);
        }
    }
    let _e1767 = diag_0_;
    let _e1768 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1768 + _e1767);
    let _e1776 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1776;
    let _e1784 = diag_1_;
    let _e1785 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1785 + _e1784);
    let _e1793 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1793;
    let _e1801 = diag_2_;
    let _e1802 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1802 + _e1801);
    let _e1810 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1810;
    let _e1818 = diag_3_;
    let _e1819 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1819 + _e1818);
    let _e1827 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1827;
    let _e1835 = diag_4_;
    let _e1836 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1836 + _e1835);
    let _e1845 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1845;
    let _e1853 = diag_5_;
    let _e1854 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1854 + _e1853);
    let _e1863 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1863;
    let _e1871 = diag_6_;
    let _e1872 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e1872 + _e1871);
    let _e1880 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e1880;
    let _e1888 = diag_7_;
    let _e1889 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e1889 + _e1888);
    let _e1898 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e1898;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGradStateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e78 = rank;
        if (_e78 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e80 = rank;
            matrix_values[((start_row_0_ + (_e80 * 8u)) + 0u)] = 0f;
            let _e89 = rank;
            matrix_values[((start_row_0_ + (_e89 * 8u)) + 1u)] = 0f;
            let _e98 = rank;
            matrix_values[((start_row_0_ + (_e98 * 8u)) + 2u)] = 0f;
            let _e107 = rank;
            matrix_values[((start_row_0_ + (_e107 * 8u)) + 3u)] = 0f;
            let _e116 = rank;
            matrix_values[((start_row_0_ + (_e116 * 8u)) + 4u)] = 0f;
            let _e125 = rank;
            matrix_values[((start_row_0_ + (_e125 * 8u)) + 5u)] = 0f;
            let _e134 = rank;
            matrix_values[((start_row_0_ + (_e134 * 8u)) + 6u)] = 0f;
            let _e143 = rank;
            matrix_values[((start_row_0_ + (_e143 * 8u)) + 7u)] = 0f;
            let _e152 = rank;
            matrix_values[((start_row_1_ + (_e152 * 8u)) + 0u)] = 0f;
            let _e161 = rank;
            matrix_values[((start_row_1_ + (_e161 * 8u)) + 1u)] = 0f;
            let _e170 = rank;
            matrix_values[((start_row_1_ + (_e170 * 8u)) + 2u)] = 0f;
            let _e179 = rank;
            matrix_values[((start_row_1_ + (_e179 * 8u)) + 3u)] = 0f;
            let _e188 = rank;
            matrix_values[((start_row_1_ + (_e188 * 8u)) + 4u)] = 0f;
            let _e197 = rank;
            matrix_values[((start_row_1_ + (_e197 * 8u)) + 5u)] = 0f;
            let _e206 = rank;
            matrix_values[((start_row_1_ + (_e206 * 8u)) + 6u)] = 0f;
            let _e215 = rank;
            matrix_values[((start_row_1_ + (_e215 * 8u)) + 7u)] = 0f;
            let _e224 = rank;
            matrix_values[((start_row_2_ + (_e224 * 8u)) + 0u)] = 0f;
            let _e233 = rank;
            matrix_values[((start_row_2_ + (_e233 * 8u)) + 1u)] = 0f;
            let _e242 = rank;
            matrix_values[((start_row_2_ + (_e242 * 8u)) + 2u)] = 0f;
            let _e251 = rank;
            matrix_values[((start_row_2_ + (_e251 * 8u)) + 3u)] = 0f;
            let _e260 = rank;
            matrix_values[((start_row_2_ + (_e260 * 8u)) + 4u)] = 0f;
            let _e269 = rank;
            matrix_values[((start_row_2_ + (_e269 * 8u)) + 5u)] = 0f;
            let _e278 = rank;
            matrix_values[((start_row_2_ + (_e278 * 8u)) + 6u)] = 0f;
            let _e287 = rank;
            matrix_values[((start_row_2_ + (_e287 * 8u)) + 7u)] = 0f;
            let _e296 = rank;
            matrix_values[((start_row_3_ + (_e296 * 8u)) + 0u)] = 0f;
            let _e305 = rank;
            matrix_values[((start_row_3_ + (_e305 * 8u)) + 1u)] = 0f;
            let _e314 = rank;
            matrix_values[((start_row_3_ + (_e314 * 8u)) + 2u)] = 0f;
            let _e323 = rank;
            matrix_values[((start_row_3_ + (_e323 * 8u)) + 3u)] = 0f;
            let _e332 = rank;
            matrix_values[((start_row_3_ + (_e332 * 8u)) + 4u)] = 0f;
            let _e341 = rank;
            matrix_values[((start_row_3_ + (_e341 * 8u)) + 5u)] = 0f;
            let _e350 = rank;
            matrix_values[((start_row_3_ + (_e350 * 8u)) + 6u)] = 0f;
            let _e359 = rank;
            matrix_values[((start_row_3_ + (_e359 * 8u)) + 7u)] = 0f;
            let _e368 = rank;
            matrix_values[((start_row_4_ + (_e368 * 8u)) + 0u)] = 0f;
            let _e377 = rank;
            matrix_values[((start_row_4_ + (_e377 * 8u)) + 1u)] = 0f;
            let _e386 = rank;
            matrix_values[((start_row_4_ + (_e386 * 8u)) + 2u)] = 0f;
            let _e395 = rank;
            matrix_values[((start_row_4_ + (_e395 * 8u)) + 3u)] = 0f;
            let _e404 = rank;
            matrix_values[((start_row_4_ + (_e404 * 8u)) + 4u)] = 0f;
            let _e413 = rank;
            matrix_values[((start_row_4_ + (_e413 * 8u)) + 5u)] = 0f;
            let _e422 = rank;
            matrix_values[((start_row_4_ + (_e422 * 8u)) + 6u)] = 0f;
            let _e431 = rank;
            matrix_values[((start_row_4_ + (_e431 * 8u)) + 7u)] = 0f;
            let _e440 = rank;
            matrix_values[((start_row_5_ + (_e440 * 8u)) + 0u)] = 0f;
            let _e449 = rank;
            matrix_values[((start_row_5_ + (_e449 * 8u)) + 1u)] = 0f;
            let _e458 = rank;
            matrix_values[((start_row_5_ + (_e458 * 8u)) + 2u)] = 0f;
            let _e467 = rank;
            matrix_values[((start_row_5_ + (_e467 * 8u)) + 3u)] = 0f;
            let _e476 = rank;
            matrix_values[((start_row_5_ + (_e476 * 8u)) + 4u)] = 0f;
            let _e485 = rank;
            matrix_values[((start_row_5_ + (_e485 * 8u)) + 5u)] = 0f;
            let _e494 = rank;
            matrix_values[((start_row_5_ + (_e494 * 8u)) + 6u)] = 0f;
            let _e503 = rank;
            matrix_values[((start_row_5_ + (_e503 * 8u)) + 7u)] = 0f;
            let _e512 = rank;
            matrix_values[((start_row_6_ + (_e512 * 8u)) + 0u)] = 0f;
            let _e521 = rank;
            matrix_values[((start_row_6_ + (_e521 * 8u)) + 1u)] = 0f;
            let _e530 = rank;
            matrix_values[((start_row_6_ + (_e530 * 8u)) + 2u)] = 0f;
            let _e539 = rank;
            matrix_values[((start_row_6_ + (_e539 * 8u)) + 3u)] = 0f;
            let _e548 = rank;
            matrix_values[((start_row_6_ + (_e548 * 8u)) + 4u)] = 0f;
            let _e557 = rank;
            matrix_values[((start_row_6_ + (_e557 * 8u)) + 5u)] = 0f;
            let _e566 = rank;
            matrix_values[((start_row_6_ + (_e566 * 8u)) + 6u)] = 0f;
            let _e575 = rank;
            matrix_values[((start_row_6_ + (_e575 * 8u)) + 7u)] = 0f;
            let _e584 = rank;
            matrix_values[((start_row_7_ + (_e584 * 8u)) + 0u)] = 0f;
            let _e593 = rank;
            matrix_values[((start_row_7_ + (_e593 * 8u)) + 1u)] = 0f;
            let _e602 = rank;
            matrix_values[((start_row_7_ + (_e602 * 8u)) + 2u)] = 0f;
            let _e611 = rank;
            matrix_values[((start_row_7_ + (_e611 * 8u)) + 3u)] = 0f;
            let _e620 = rank;
            matrix_values[((start_row_7_ + (_e620 * 8u)) + 4u)] = 0f;
            let _e629 = rank;
            matrix_values[((start_row_7_ + (_e629 * 8u)) + 5u)] = 0f;
            let _e638 = rank;
            matrix_values[((start_row_7_ + (_e638 * 8u)) + 6u)] = 0f;
            let _e647 = rank;
            matrix_values[((start_row_7_ + (_e647 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e657 = rank;
            rank = (_e657 + 1u);
        }
    }
    let _e662 = constants.dt;
    let _e664 = diag_0_;
    diag_0_ = (_e664 + (vol / _e662));
    let _e668 = constants.dt;
    let _e677 = state_old[((idx * 8u) + 0u)];
    let _e679 = rhs_0_;
    rhs_0_ = (_e679 + ((vol / _e668) * _e677));
    let _e683 = constants.time_scheme;
    if (_e683 == 1u) {
        let _e688 = constants.dt;
        let _e691 = constants.dt_old;
        let r = (_e688 / _e691);
        let _e695 = constants.dt;
        let diag_bdf2_ = (((vol / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e714 = constants.dt;
        diag_0_ = ((_e711 - (vol / _e714)) + diag_bdf2_);
        let _e718 = rhs_0_;
        let _e721 = constants.dt;
        let _e729 = state_old[((idx * 8u) + 0u)];
        let _e734 = constants.dt;
        let _e742 = state_old[((idx * 8u) + 0u)];
        let _e750 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e718 - ((vol / _e721) * _e729)) + ((vol / _e734) * ((factor_n * _e742) - (factor_nm1_ * _e750))));
    }
    let _e757 = constants.dtau;
    if (_e757 > 0f) {
        let _e762 = constants.dtau;
        let _e764 = diag_0_;
        diag_0_ = (_e764 + (vol / _e762));
        let _e768 = constants.dtau;
        let _e776 = state_iter[((idx * 8u) + 0u)];
        let _e778 = rhs_0_;
        rhs_0_ = (_e778 + ((vol / _e768) * _e776));
    }
    let _e783 = constants.dt;
    let _e785 = diag_1_;
    diag_1_ = (_e785 + (vol / _e783));
    let _e789 = constants.dt;
    let _e798 = state_old[((idx * 8u) + 1u)];
    let _e800 = rhs_1_;
    rhs_1_ = (_e800 + ((vol / _e789) * _e798));
    let _e804 = constants.time_scheme;
    if (_e804 == 1u) {
        let _e809 = constants.dt;
        let _e812 = constants.dt_old;
        let r_1 = (_e809 / _e812);
        let _e816 = constants.dt;
        let diag_bdf2_1 = (((vol / _e816) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e832 = diag_1_;
        let _e835 = constants.dt;
        diag_1_ = ((_e832 - (vol / _e835)) + diag_bdf2_1);
        let _e839 = rhs_1_;
        let _e842 = constants.dt;
        let _e850 = state_old[((idx * 8u) + 1u)];
        let _e855 = constants.dt;
        let _e863 = state_old[((idx * 8u) + 1u)];
        let _e871 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e839 - ((vol / _e842) * _e850)) + ((vol / _e855) * ((factor_n_1 * _e863) - (factor_nm1_1 * _e871))));
    }
    let _e878 = constants.dtau;
    if (_e878 > 0f) {
        let _e883 = constants.dtau;
        let _e885 = diag_1_;
        diag_1_ = (_e885 + (vol / _e883));
        let _e889 = constants.dtau;
        let _e897 = state_iter[((idx * 8u) + 1u)];
        let _e899 = rhs_1_;
        rhs_1_ = (_e899 + ((vol / _e889) * _e897));
    }
    let _e904 = constants.dt;
    let _e906 = diag_2_;
    diag_2_ = (_e906 + (vol / _e904));
    let _e910 = constants.dt;
    let _e919 = state_old[((idx * 8u) + 2u)];
    let _e921 = rhs_2_;
    rhs_2_ = (_e921 + ((vol / _e910) * _e919));
    let _e925 = constants.time_scheme;
    if (_e925 == 1u) {
        let _e930 = constants.dt;
        let _e933 = constants.dt_old;
        let r_2 = (_e930 / _e933);
        let _e937 = constants.dt;
        let diag_bdf2_2 = (((vol / _e937) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e953 = diag_2_;
        let _e956 = constants.dt;
        diag_2_ = ((_e953 - (vol / _e956)) + diag_bdf2_2);
        let _e960 = rhs_2_;
        let _e963 = constants.dt;
        let _e971 = state_old[((idx * 8u) + 2u)];
        let _e976 = constants.dt;
        let _e984 = state_old[((idx * 8u) + 2u)];
        let _e992 = state_old_old[((idx * 8u) + 2u)];
        rhs_2_ = ((_e960 - ((vol / _e963) * _e971)) + ((vol / _e976) * ((factor_n_2 * _e984) - (factor_nm1_2 * _e992))));
    }
    let _e999 = constants.dtau;
    if (_e999 > 0f) {
        let _e1004 = constants.dtau;
        let _e1006 = diag_2_;
        diag_2_ = (_e1006 + (vol / _e1004));
        let _e1010 = constants.dtau;
        let _e1018 = state_iter[((idx * 8u) + 2u)];
        let _e1020 = rhs_2_;
        rhs_2_ = (_e1020 + ((vol / _e1010) * _e1018));
    }
    let _e1025 = constants.dt;
    let _e1027 = diag_3_;
    diag_3_ = (_e1027 + (vol / _e1025));
    let _e1031 = constants.dt;
    let _e1040 = state_old[((idx * 8u) + 3u)];
    let _e1042 = rhs_3_;
    rhs_3_ = (_e1042 + ((vol / _e1031) * _e1040));
    let _e1046 = constants.time_scheme;
    if (_e1046 == 1u) {
        let _e1051 = constants.dt;
        let _e1054 = constants.dt_old;
        let r_3 = (_e1051 / _e1054);
        let _e1058 = constants.dt;
        let diag_bdf2_3 = (((vol / _e1058) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1074 = diag_3_;
        let _e1077 = constants.dt;
        diag_3_ = ((_e1074 - (vol / _e1077)) + diag_bdf2_3);
        let _e1081 = rhs_3_;
        let _e1084 = constants.dt;
        let _e1092 = state_old[((idx * 8u) + 3u)];
        let _e1097 = constants.dt;
        let _e1105 = state_old[((idx * 8u) + 3u)];
        let _e1113 = state_old_old[((idx * 8u) + 3u)];
        rhs_3_ = ((_e1081 - ((vol / _e1084) * _e1092)) + ((vol / _e1097) * ((factor_n_3 * _e1105) - (factor_nm1_3 * _e1113))));
    }
    let _e1120 = constants.dtau;
    if (_e1120 > 0f) {
        let _e1125 = constants.dtau;
        let _e1127 = diag_3_;
        diag_3_ = (_e1127 + (vol / _e1125));
        let _e1131 = constants.dtau;
        let _e1139 = state_iter[((idx * 8u) + 3u)];
        let _e1141 = rhs_3_;
        rhs_3_ = (_e1141 + ((vol / _e1131) * _e1139));
    }
    let _e1149 = state[((idx * 8u) + 0u)];
    let _e1154 = constants.dt;
    let _e1157 = constants.dtau;
    let _e1160 = constants.dtau;
    let _e1168 = diag_4_;
    diag_4_ = (_e1168 - (-(((_e1149 * 1f) / select(_e1154, _e1157, (_e1160 > 0f)))) * vol));
    let _e1176 = state[((idx * 8u) + 0u)];
    let _e1181 = constants.dt;
    let _e1184 = constants.dtau;
    let _e1187 = constants.dtau;
    let _e1195 = diag_5_;
    diag_5_ = (_e1195 - (-(((_e1176 * 1f) / select(_e1181, _e1184, (_e1187 > 0f)))) * vol));
    let _e1206 = constants.dt;
    let _e1209 = constants.dtau;
    let _e1212 = constants.dtau;
    let _e1219 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1219 - ((1f / select(_e1206, _e1209, (_e1212 > 0f))) * vol));
    let _e1230 = constants.dt;
    let _e1233 = constants.dtau;
    let _e1236 = constants.dtau;
    let _e1243 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1243 - ((1f / select(_e1230, _e1233, (_e1236 > 0f))) * vol));
    let _e1247 = constants.dt;
    let _e1250 = constants.dtau;
    let _e1253 = constants.dtau;
    let _e1261 = diag_6_;
    diag_6_ = (_e1261 - ((1f / select(_e1247, _e1250, (_e1253 > 0f))) * vol));
    let _e1272 = constants.eos_gm1_;
    let _e1278 = constants.dt;
    let _e1281 = constants.dtau;
    let _e1284 = constants.dtau;
    let _e1290 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1290 - (((-(_e1272) * 1f) / select(_e1278, _e1281, (_e1284 > 0f))) * vol));
    let _e1301 = constants.eos_gm1_;
    let _e1308 = constants.dt;
    let _e1311 = constants.dtau;
    let _e1314 = constants.dtau;
    let _e1325 = state[((idx * 8u) + 6u)];
    let _e1332 = state[((idx * 8u) + 6u)];
    let _e1340 = state[((idx * 8u) + 7u)];
    let _e1347 = state[((idx * 8u) + 7u)];
    let _e1352 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1352 - (((((0.5f * _e1301) * 1f) / select(_e1308, _e1311, (_e1314 > 0f))) * ((_e1325 * _e1332) + (_e1340 * _e1347))) * vol));
    let _e1363 = constants.eos_dp_drho;
    let _e1369 = constants.dt;
    let _e1372 = constants.dtau;
    let _e1375 = constants.dtau;
    let _e1381 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1381 - (((-(_e1363) * 1f) / select(_e1369, _e1372, (_e1375 > 0f))) * vol));
    let _e1385 = constants.eos_p_offset;
    let _e1391 = constants.dt;
    let _e1394 = constants.dtau;
    let _e1397 = constants.dtau;
    let _e1404 = rhs_6_;
    rhs_6_ = (_e1404 + (((-(_e1385) * 1f) / select(_e1391, _e1394, (_e1397 > 0f))) * vol));
    let _e1412 = state[((idx * 8u) + 0u)];
    let _e1415 = constants.eos_r;
    let _e1421 = constants.dt;
    let _e1424 = constants.dtau;
    let _e1427 = constants.dtau;
    let _e1434 = diag_7_;
    diag_7_ = (_e1434 - ((((_e1412 * _e1415) * 1f) / select(_e1421, _e1424, (_e1427 > 0f))) * vol));
    let _e1445 = constants.dt;
    let _e1448 = constants.dtau;
    let _e1451 = constants.dtau;
    let _e1459 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1459 - (-((1f / select(_e1445, _e1448, (_e1451 > 0f)))) * vol));
    k = start;
    loop {
        let _e1462 = k;
        if (_e1462 < end) {
        } else {
            break;
        }
        {
            let _e1465 = k;
            let face_idx = cell_faces[_e1465];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1485 = face_normals[face_idx];
            normal = _e1485;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1493 = normal.x;
                normal.x = -(_e1493);
                let _e1497 = normal.y;
                normal.y = -(_e1497);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1504 = other_idx;
                let _e1506 = cell_centers[_e1504];
                other_center = _e1506;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1510 = other_center.x;
            let dx = (_e1510 - center.x);
            let _e1514 = other_center.y;
            let dy = (_e1514 - center.y);
            let _e1518 = normal.x;
            let _e1521 = normal.y;
            let dist_proj = abs(((dx * _e1518) + (dy * _e1521)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1535 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1535];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1545 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1545;
            if (owner != idx) {
                let _e1548 = phi_0_;
                let _e1551 = phi_0_;
                phi_0_ = (_e1551 - (_e1548 * 2f));
            }
            let _e1553 = phi_0_;
            let _e1554 = rhs_0_;
            rhs_0_ = (_e1554 - _e1553);
            let _e1558 = constants.viscosity;
            let _e1560 = dist;
            let diff_coeff_rho_u = ((_e1558 * area) / _e1560);
            let _e1562 = is_boundary;
            if !(_e1562) {
                let _e1571 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1571 + diff_coeff_rho_u);
                let _e1580 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1580 - diff_coeff_rho_u);
            } else {
                let _e1588 = bc_kind[((face_idx * 8u) + 4u)];
                if (_e1588 == 1u) {
                    let _e1598 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1598 + diff_coeff_rho_u);
                    let _e1606 = bc_value[((face_idx * 8u) + 4u)];
                    let _e1608 = rhs_1_;
                    rhs_1_ = (_e1608 + (diff_coeff_rho_u * _e1606));
                } else {
                    let _e1616 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1616 == 2u) {
                        let _e1621 = constants.viscosity;
                        let _e1629 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1632 = rhs_1_;
                        rhs_1_ = (_e1632 + -(((_e1621 * area) * _e1629)));
                    }
                }
            }
            let _e1634 = is_boundary;
            if !(_e1634) {
                let _e1643 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1643 + diff_coeff_rho_u);
                let _e1652 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1652 - diff_coeff_rho_u);
            } else {
                let _e1660 = bc_kind[((face_idx * 8u) + 5u)];
                if (_e1660 == 1u) {
                    let _e1670 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1670 + diff_coeff_rho_u);
                    let _e1678 = bc_value[((face_idx * 8u) + 5u)];
                    let _e1680 = rhs_2_;
                    rhs_2_ = (_e1680 + (diff_coeff_rho_u * _e1678));
                } else {
                    let _e1688 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1688 == 2u) {
                        let _e1693 = constants.viscosity;
                        let _e1701 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1704 = rhs_2_;
                        rhs_2_ = (_e1704 + -(((_e1693 * area) * _e1701)));
                    }
                }
            }
            let _e1712 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1712;
            if (owner != idx) {
                let _e1715 = phi_1_;
                let _e1718 = phi_1_;
                phi_1_ = (_e1718 - (_e1715 * 2f));
            }
            let _e1720 = phi_1_;
            let _e1721 = rhs_1_;
            rhs_1_ = (_e1721 - _e1720);
            let _e1729 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1729;
            if (owner != idx) {
                let _e1732 = phi_2_;
                let _e1735 = phi_2_;
                phi_2_ = (_e1735 - (_e1732 * 2f));
            }
            let _e1737 = phi_2_;
            let _e1738 = rhs_2_;
            rhs_2_ = (_e1738 - _e1737);
            let _e1746 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1746;
            if (owner != idx) {
                let _e1749 = phi_3_;
                let _e1752 = phi_3_;
                phi_3_ = (_e1752 - (_e1749 * 2f));
            }
            let _e1754 = phi_3_;
            let _e1755 = rhs_3_;
            rhs_3_ = (_e1755 - _e1754);
        }
        continuing {
            let _e1758 = k;
            k = (_e1758 + 1u);
        }
    }
    let _e1767 = diag_0_;
    let _e1768 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1768 + _e1767);
    let _e1776 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1776;
    let _e1784 = diag_1_;
    let _e1785 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1785 + _e1784);
    let _e1793 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1793;
    let _e1801 = diag_2_;
    let _e1802 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1802 + _e1801);
    let _e1810 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1810;
    let _e1818 = diag_3_;
    let _e1819 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1819 + _e1818);
    let _e1827 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1827;
    let _e1835 = diag_4_;
    let _e1836 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1836 + _e1835);
    let _e1845 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1845;
    let _e1853 = diag_5_;
    let _e1854 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1854 + _e1853);
    let _e1863 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1863;
    let _e1871 = diag_6_;
    let _e1872 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e1872 + _e1871);
    let _e1880 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e1880;
    let _e1888 = diag_7_;
    let _e1889 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e1889 + _e1888);
    let _e1898 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e1898;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemo::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateGenericDiffusionDemoNeumann::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some(
                    "generic_coupled_assembly_grad_state_generic_diffusion_demo_neumann.wgsl",
                ),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e43 = rank;
        if (_e43 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e45 = rank;
            matrix_values[((start_row_0_ + (_e45 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e55 = rank;
            rank = (_e55 + 1u);
        }
    }
    let _e60 = constants.dt;
    let _e62 = diag_0_;
    diag_0_ = (_e62 + (vol / _e60));
    let _e66 = constants.dt;
    let _e75 = state_old[((idx * 1u) + 0u)];
    let _e77 = rhs_0_;
    rhs_0_ = (_e77 + ((vol / _e66) * _e75));
    let _e81 = constants.time_scheme;
    if (_e81 == 1u) {
        let _e86 = constants.dt;
        let _e89 = constants.dt_old;
        let r = (_e86 / _e89);
        let _e93 = constants.dt;
        let diag_bdf2_ = (((vol / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e112 = constants.dt;
        diag_0_ = ((_e109 - (vol / _e112)) + diag_bdf2_);
        let _e116 = rhs_0_;
        let _e119 = constants.dt;
        let _e127 = state_old[((idx * 1u) + 0u)];
        let _e132 = constants.dt;
        let _e140 = state_old[((idx * 1u) + 0u)];
        let _e148 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e116 - ((vol / _e119) * _e127)) + ((vol / _e132) * ((factor_n * _e140) - (factor_nm1_ * _e148))));
    }
    let _e155 = constants.dtau;
    if (_e155 > 0f) {
        let _e160 = constants.dtau;
        let _e162 = diag_0_;
        diag_0_ = (_e162 + (vol / _e160));
        let _e166 = constants.dtau;
        let _e174 = state_iter[((idx * 1u) + 0u)];
        let _e176 = rhs_0_;
        rhs_0_ = (_e176 + ((vol / _e166) * _e174));
    }
    k = start;
    loop {
        let _e179 = k;
        if (_e179 < end) {
        } else {
            break;
        }
        {
            let _e182 = k;
            let face_idx = cell_faces[_e182];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e202 = face_normals[face_idx];
            normal = _e202;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e210 = normal.x;
                normal.x = -(_e210);
                let _e214 = normal.y;
                normal.y = -(_e214);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e221 = other_idx;
                let _e223 = cell_centers[_e221];
                other_center = _e223;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e227 = other_center.x;
            let dx = (_e227 - center.x);
            let _e231 = other_center.y;
            let dy = (_e231 - center.y);
            let _e235 = normal.x;
            let _e238 = normal.y;
            let dist_proj = abs(((dx * _e235) + (dy * _e238)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e252 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e252];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e256 = dist;
            let diff_coeff_phi = (area / _e256);
            let _e258 = is_boundary;
            if !(_e258) {
                let _e260 = diag_0_;
                diag_0_ = (_e260 + diff_coeff_phi);
                let _e269 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e269 - diff_coeff_phi);
            } else {
                let _e277 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e277 == 1u) {
                    let _e280 = diag_0_;
                    diag_0_ = (_e280 + diff_coeff_phi);
                    let _e288 = bc_value[((face_idx * 1u) + 0u)];
                    let _e290 = rhs_0_;
                    rhs_0_ = (_e290 + (diff_coeff_phi * _e288));
                } else {
                    let _e298 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e298 == 2u) {
                        let _e307 = bc_value[((face_idx * 1u) + 0u)];
                        let _e310 = rhs_0_;
                        rhs_0_ = (_e310 + -((area * _e307)));
                    }
                }
            }
        }
        continuing {
            let _e313 = k;
            k = (_e313 + 1u);
        }
    }
    let _e322 = diag_0_;
    let _e323 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e323 + _e322);
    let _e331 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e331;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_grad_state_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup0") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.grad_state,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_grad_state_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup1") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup2") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device . create_bind_group (& wgpu :: BindGroupDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::BindGroup3") , layout : & bind_group_layout , entries : & entries , }) ;
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device . create_pipeline_layout (& wgpu :: PipelineLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGradStateIncompressibleMomentum::PipelineLayout") , bind_group_layouts : & [& WgpuBindGroup0 :: get_bind_group_layout (device) , & WgpuBindGroup1 :: get_bind_group_layout (device) , & WgpuBindGroup2 :: get_bind_group_layout (device) , & WgpuBindGroup3 :: get_bind_group_layout (device)] , push_constant_ranges : & [] , })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_grad_state_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(5) 
var<storage> grad_state: array<Vector2_>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e527 = dist;
            let diff_coeff_U = ((_e525 * area) / _e527);
            let _e529 = is_boundary;
            if !(_e529) {
                let _e531 = diag_0_;
                diag_0_ = (_e531 + diff_coeff_U);
                let _e540 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e540 - diff_coeff_U);
            } else {
                let _e548 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e548 == 1u) {
                    let _e551 = diag_0_;
                    diag_0_ = (_e551 + diff_coeff_U);
                    let _e559 = bc_value[((face_idx * 3u) + 0u)];
                    let _e561 = rhs_0_;
                    rhs_0_ = (_e561 + (diff_coeff_U * _e559));
                } else {
                    let _e569 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e569 == 2u) {
                        let _e574 = constants.viscosity;
                        let _e582 = bc_value[((face_idx * 3u) + 0u)];
                        let _e585 = rhs_0_;
                        rhs_0_ = (_e585 + -(((_e574 * area) * _e582)));
                    }
                }
            }
            let _e587 = is_boundary;
            if !(_e587) {
                let _e589 = diag_1_;
                diag_1_ = (_e589 + diff_coeff_U);
                let _e598 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e598 - diff_coeff_U);
            } else {
                let _e606 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e606 == 1u) {
                    let _e609 = diag_1_;
                    diag_1_ = (_e609 + diff_coeff_U);
                    let _e617 = bc_value[((face_idx * 3u) + 1u)];
                    let _e619 = rhs_1_;
                    rhs_1_ = (_e619 + (diff_coeff_U * _e617));
                } else {
                    let _e627 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e627 == 2u) {
                        let _e632 = constants.viscosity;
                        let _e640 = bc_value[((face_idx * 3u) + 1u)];
                        let _e643 = rhs_1_;
                        rhs_1_ = (_e643 + -(((_e632 * area) * _e640)));
                    }
                }
            }
            let _e651 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e651;
            if (owner != idx) {
                let _e654 = phi_0_;
                let _e657 = phi_0_;
                phi_0_ = (_e657 - (_e654 * 2f));
            }
            let _e659 = is_boundary;
            if !(_e659) {
                let _e661 = phi_0_;
                let _e664 = diag_0_;
                diag_0_ = (_e664 + max(_e661, 0f));
                let _e673 = phi_0_;
                let _e676 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e676 + min(_e673, 0f));
                let _e678 = phi_0_;
                let _e685 = state[((idx * 8u) + 0u)];
                let _e686 = other_idx;
                let _e693 = state[((_e686 * 8u) + 0u)];
                let _e694 = phi_0_;
                let _e698 = other_idx;
                let _e705 = state[((_e698 * 8u) + 0u)];
                let _e706 = other_idx;
                let _e714 = grad_state[((_e706 * 8u) + 0u)].x;
                let _e715 = other_idx;
                let _e723 = grad_state[((_e715 * 8u) + 0u)].y;
                let _e729 = other_center.x;
                let _e731 = other_center.y;
                let _e742 = state[((idx * 8u) + 0u)];
                let _e750 = grad_state[((idx * 8u) + 0u)].x;
                let _e758 = grad_state[((idx * 8u) + 0u)].y;
                let _e769 = phi_0_;
                let _e775 = constants.scheme;
                let _e779 = other_idx;
                let _e786 = state[((_e779 * 8u) + 0u)];
                let _e787 = other_idx;
                let _e794 = state[((_e787 * 8u) + 0u)];
                let _e804 = state[((idx * 8u) + 0u)];
                let _e808 = other_idx;
                let _e816 = grad_state[((_e808 * 8u) + 0u)].x;
                let _e817 = other_idx;
                let _e825 = grad_state[((_e817 * 8u) + 0u)].y;
                let _e831 = other_center.x;
                let _e833 = other_center.y;
                let _e840 = other_idx;
                let _e847 = state[((_e840 * 8u) + 0u)];
                let _e855 = state[((idx * 8u) + 0u)];
                let _e862 = state[((idx * 8u) + 0u)];
                let _e866 = other_idx;
                let _e873 = state[((_e866 * 8u) + 0u)];
                let _e884 = grad_state[((idx * 8u) + 0u)].x;
                let _e892 = grad_state[((idx * 8u) + 0u)].y;
                let _e895 = other_center.x;
                let _e897 = other_center.y;
                let _e913 = state[((idx * 8u) + 0u)];
                let _e915 = phi_0_;
                let _e921 = constants.scheme;
                let _e925 = other_idx;
                let _e932 = state[((_e925 * 8u) + 0u)];
                let _e933 = other_idx;
                let _e941 = grad_state[((_e933 * 8u) + 0u)].x;
                let _e942 = other_idx;
                let _e950 = grad_state[((_e942 * 8u) + 0u)].y;
                let _e956 = other_center.x;
                let _e958 = other_center.y;
                let _e968 = state[((idx * 8u) + 0u)];
                let _e969 = other_idx;
                let _e976 = state[((_e969 * 8u) + 0u)];
                let _e987 = state[((idx * 8u) + 0u)];
                let _e988 = other_idx;
                let _e995 = state[((_e988 * 8u) + 0u)];
                let _e1007 = state[((idx * 8u) + 0u)];
                let _e1015 = grad_state[((idx * 8u) + 0u)].x;
                let _e1023 = grad_state[((idx * 8u) + 0u)].y;
                let _e1033 = other_idx;
                let _e1040 = state[((_e1033 * 8u) + 0u)];
                let _e1047 = state[((idx * 8u) + 0u)];
                let _e1052 = other_idx;
                let _e1059 = state[((_e1052 * 8u) + 0u)];
                let _e1066 = state[((idx * 8u) + 0u)];
                let _e1072 = phi_0_;
                let _e1078 = constants.scheme;
                let _e1082 = other_idx;
                let _e1089 = state[((_e1082 * 8u) + 0u)];
                let _e1090 = other_idx;
                let _e1098 = grad_state[((_e1090 * 8u) + 0u)].x;
                let _e1099 = other_idx;
                let _e1107 = grad_state[((_e1099 * 8u) + 0u)].y;
                let _e1113 = other_center.x;
                let _e1115 = other_center.y;
                let _e1125 = state[((idx * 8u) + 0u)];
                let _e1126 = other_idx;
                let _e1133 = state[((_e1126 * 8u) + 0u)];
                let _e1143 = state[((idx * 8u) + 0u)];
                let _e1144 = other_idx;
                let _e1151 = state[((_e1144 * 8u) + 0u)];
                let _e1154 = other_idx;
                let _e1162 = grad_state[((_e1154 * 8u) + 0u)].x;
                let _e1163 = other_idx;
                let _e1171 = grad_state[((_e1163 * 8u) + 0u)].y;
                let _e1177 = other_center.x;
                let _e1179 = other_center.y;
                let _e1194 = state[((idx * 8u) + 0u)];
                let _e1195 = other_idx;
                let _e1202 = state[((_e1195 * 8u) + 0u)];
                let _e1204 = other_idx;
                let _e1212 = grad_state[((_e1204 * 8u) + 0u)].x;
                let _e1213 = other_idx;
                let _e1221 = grad_state[((_e1213 * 8u) + 0u)].y;
                let _e1227 = other_center.x;
                let _e1229 = other_center.y;
                let _e1243 = state[((idx * 8u) + 0u)];
                let _e1244 = other_idx;
                let _e1251 = state[((_e1244 * 8u) + 0u)];
                let _e1253 = other_idx;
                let _e1261 = grad_state[((_e1253 * 8u) + 0u)].x;
                let _e1262 = other_idx;
                let _e1270 = grad_state[((_e1262 * 8u) + 0u)].y;
                let _e1276 = other_center.x;
                let _e1278 = other_center.y;
                let _e1294 = state[((idx * 8u) + 0u)];
                let _e1302 = grad_state[((idx * 8u) + 0u)].x;
                let _e1310 = grad_state[((idx * 8u) + 0u)].y;
                let _e1320 = other_idx;
                let _e1327 = state[((_e1320 * 8u) + 0u)];
                let _e1334 = state[((idx * 8u) + 0u)];
                let _e1338 = other_idx;
                let _e1345 = state[((_e1338 * 8u) + 0u)];
                let _e1352 = state[((idx * 8u) + 0u)];
                let _e1362 = grad_state[((idx * 8u) + 0u)].x;
                let _e1370 = grad_state[((idx * 8u) + 0u)].y;
                let _e1385 = other_idx;
                let _e1392 = state[((_e1385 * 8u) + 0u)];
                let _e1399 = state[((idx * 8u) + 0u)];
                let _e1408 = grad_state[((idx * 8u) + 0u)].x;
                let _e1416 = grad_state[((idx * 8u) + 0u)].y;
                let _e1430 = other_idx;
                let _e1437 = state[((_e1430 * 8u) + 0u)];
                let _e1444 = state[((idx * 8u) + 0u)];
                let _e1453 = grad_state[((idx * 8u) + 0u)].x;
                let _e1461 = grad_state[((idx * 8u) + 0u)].y;
                let _e1477 = phi_0_;
                let _e1483 = constants.scheme;
                let _e1487 = other_idx;
                let _e1494 = state[((_e1487 * 8u) + 0u)];
                let _e1495 = other_idx;
                let _e1502 = state[((_e1495 * 8u) + 0u)];
                let _e1511 = state[((idx * 8u) + 0u)];
                let _e1515 = other_idx;
                let _e1523 = grad_state[((_e1515 * 8u) + 0u)].x;
                let _e1524 = other_idx;
                let _e1532 = grad_state[((_e1524 * 8u) + 0u)].y;
                let _e1538 = other_center.x;
                let _e1540 = other_center.y;
                let _e1547 = other_idx;
                let _e1554 = state[((_e1547 * 8u) + 0u)];
                let _e1562 = state[((idx * 8u) + 0u)];
                let _e1563 = other_idx;
                let _e1570 = state[((_e1563 * 8u) + 0u)];
                let _e1581 = state[((idx * 8u) + 0u)];
                let _e1582 = other_idx;
                let _e1589 = state[((_e1582 * 8u) + 0u)];
                let _e1601 = state[((idx * 8u) + 0u)];
                let _e1608 = state[((idx * 8u) + 0u)];
                let _e1611 = other_idx;
                let _e1618 = state[((_e1611 * 8u) + 0u)];
                let _e1629 = grad_state[((idx * 8u) + 0u)].x;
                let _e1637 = grad_state[((idx * 8u) + 0u)].y;
                let _e1640 = other_center.x;
                let _e1642 = other_center.y;
                let _e1658 = state[((idx * 8u) + 0u)];
                let _e1660 = other_idx;
                let _e1667 = state[((_e1660 * 8u) + 0u)];
                let _e1674 = state[((idx * 8u) + 0u)];
                let _e1679 = other_idx;
                let _e1686 = state[((_e1679 * 8u) + 0u)];
                let _e1693 = state[((idx * 8u) + 0u)];
                let _e1699 = phi_0_;
                let _e1705 = constants.scheme;
                let _e1709 = other_idx;
                let _e1716 = state[((_e1709 * 8u) + 0u)];
                let _e1717 = other_idx;
                let _e1724 = state[((_e1717 * 8u) + 0u)];
                let _e1733 = state[((idx * 8u) + 0u)];
                let _e1737 = other_idx;
                let _e1745 = grad_state[((_e1737 * 8u) + 0u)].x;
                let _e1746 = other_idx;
                let _e1754 = grad_state[((_e1746 * 8u) + 0u)].y;
                let _e1760 = other_center.x;
                let _e1762 = other_center.y;
                let _e1769 = other_idx;
                let _e1776 = state[((_e1769 * 8u) + 0u)];
                let _e1784 = state[((idx * 8u) + 0u)];
                let _e1785 = other_idx;
                let _e1792 = state[((_e1785 * 8u) + 0u)];
                let _e1802 = state[((idx * 8u) + 0u)];
                let _e1803 = other_idx;
                let _e1810 = state[((_e1803 * 8u) + 0u)];
                let _e1813 = other_idx;
                let _e1820 = state[((_e1813 * 8u) + 0u)];
                let _e1829 = state[((idx * 8u) + 0u)];
                let _e1833 = other_idx;
                let _e1841 = grad_state[((_e1833 * 8u) + 0u)].x;
                let _e1842 = other_idx;
                let _e1850 = grad_state[((_e1842 * 8u) + 0u)].y;
                let _e1856 = other_center.x;
                let _e1858 = other_center.y;
                let _e1865 = other_idx;
                let _e1872 = state[((_e1865 * 8u) + 0u)];
                let _e1885 = state[((idx * 8u) + 0u)];
                let _e1886 = other_idx;
                let _e1893 = state[((_e1886 * 8u) + 0u)];
                let _e1895 = other_idx;
                let _e1902 = state[((_e1895 * 8u) + 0u)];
                let _e1911 = state[((idx * 8u) + 0u)];
                let _e1915 = other_idx;
                let _e1923 = grad_state[((_e1915 * 8u) + 0u)].x;
                let _e1924 = other_idx;
                let _e1932 = grad_state[((_e1924 * 8u) + 0u)].y;
                let _e1938 = other_center.x;
                let _e1940 = other_center.y;
                let _e1947 = other_idx;
                let _e1954 = state[((_e1947 * 8u) + 0u)];
                let _e1966 = state[((idx * 8u) + 0u)];
                let _e1967 = other_idx;
                let _e1974 = state[((_e1967 * 8u) + 0u)];
                let _e1976 = other_idx;
                let _e1983 = state[((_e1976 * 8u) + 0u)];
                let _e1992 = state[((idx * 8u) + 0u)];
                let _e1996 = other_idx;
                let _e2004 = grad_state[((_e1996 * 8u) + 0u)].x;
                let _e2005 = other_idx;
                let _e2013 = grad_state[((_e2005 * 8u) + 0u)].y;
                let _e2019 = other_center.x;
                let _e2021 = other_center.y;
                let _e2028 = other_idx;
                let _e2035 = state[((_e2028 * 8u) + 0u)];
                let _e2049 = state[((idx * 8u) + 0u)];
                let _e2056 = state[((idx * 8u) + 0u)];
                let _e2059 = other_idx;
                let _e2066 = state[((_e2059 * 8u) + 0u)];
                let _e2077 = grad_state[((idx * 8u) + 0u)].x;
                let _e2085 = grad_state[((idx * 8u) + 0u)].y;
                let _e2088 = other_center.x;
                let _e2090 = other_center.y;
                let _e2106 = state[((idx * 8u) + 0u)];
                let _e2108 = other_idx;
                let _e2115 = state[((_e2108 * 8u) + 0u)];
                let _e2122 = state[((idx * 8u) + 0u)];
                let _e2126 = other_idx;
                let _e2133 = state[((_e2126 * 8u) + 0u)];
                let _e2140 = state[((idx * 8u) + 0u)];
                let _e2149 = state[((idx * 8u) + 0u)];
                let _e2152 = other_idx;
                let _e2159 = state[((_e2152 * 8u) + 0u)];
                let _e2170 = grad_state[((idx * 8u) + 0u)].x;
                let _e2178 = grad_state[((idx * 8u) + 0u)].y;
                let _e2181 = other_center.x;
                let _e2183 = other_center.y;
                let _e2199 = state[((idx * 8u) + 0u)];
                let _e2206 = other_idx;
                let _e2213 = state[((_e2206 * 8u) + 0u)];
                let _e2220 = state[((idx * 8u) + 0u)];
                let _e2228 = state[((idx * 8u) + 0u)];
                let _e2231 = other_idx;
                let _e2238 = state[((_e2231 * 8u) + 0u)];
                let _e2249 = grad_state[((idx * 8u) + 0u)].x;
                let _e2257 = grad_state[((idx * 8u) + 0u)].y;
                let _e2260 = other_center.x;
                let _e2262 = other_center.y;
                let _e2278 = state[((idx * 8u) + 0u)];
                let _e2284 = other_idx;
                let _e2291 = state[((_e2284 * 8u) + 0u)];
                let _e2298 = state[((idx * 8u) + 0u)];
                let _e2306 = state[((idx * 8u) + 0u)];
                let _e2309 = other_idx;
                let _e2316 = state[((_e2309 * 8u) + 0u)];
                let _e2327 = grad_state[((idx * 8u) + 0u)].x;
                let _e2335 = grad_state[((idx * 8u) + 0u)].y;
                let _e2338 = other_center.x;
                let _e2340 = other_center.y;
                let _e2356 = state[((idx * 8u) + 0u)];
                let _e2364 = phi_0_;
                let _e2370 = constants.scheme;
                let _e2380 = state[((idx * 8u) + 0u)];
                let _e2381 = other_idx;
                let _e2388 = state[((_e2381 * 8u) + 0u)];
                let _e2389 = phi_0_;
                let _e2395 = rhs_0_;
                rhs_0_ = (_e2395 - (_e678 * (select(select(select(select(select(select(select(_e685, _e693, (_e694 < 0f)), select((_e705 + dot(vec2<f32>(_e714, _e723), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e729, _e731)))), (_e742 + dot(vec2<f32>(_e750, _e758), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e769 > 0f)), (_e775 == 1u)), select(((((_e786 + (_e794 * 0.625f)) + (_e804 * 0.375f)) + (dot(vec2<f32>(_e816, _e825), (vec2<f32>(center.x, center.y) - vec2<f32>(_e831, _e833))) * 0.125f)) - _e847), ((((_e855 + (_e862 * 0.625f)) + (_e873 * 0.375f)) + (dot(vec2<f32>(_e884, _e892), (vec2<f32>(_e895, _e897) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e913), (_e915 > 0f)), (_e921 == 2u)), select((_e932 + min(max(dot(vec2<f32>(_e941, _e950), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e956, _e958))), min((_e968 - _e976), 0f)), max((_e987 - _e995), 0f))), (_e1007 + min(max(dot(vec2<f32>(_e1015, _e1023), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1040 - _e1047), 0f)), max((_e1059 - _e1066), 0f))), (_e1072 > 0f)), (_e1078 == 3u)), select((_e1089 + ((((dot(vec2<f32>(_e1098, _e1107), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1113, _e1115))) * abs((_e1125 - _e1133))) / max(abs((_e1143 - _e1151)), (abs(dot(vec2<f32>(_e1162, _e1171), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1177, _e1179)))) + 0.00000001f))) * max(((_e1194 - _e1202) * dot(vec2<f32>(_e1212, _e1221), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1227, _e1229)))), 0f)) / max(abs(((_e1243 - _e1251) * dot(vec2<f32>(_e1261, _e1270), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1276, _e1278))))), 0.00000001f))), (_e1294 + ((((dot(vec2<f32>(_e1302, _e1310), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1327 - _e1334))) / max(abs((_e1345 - _e1352)), (abs(dot(vec2<f32>(_e1362, _e1370), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1392 - _e1399) * dot(vec2<f32>(_e1408, _e1416), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1437 - _e1444) * dot(vec2<f32>(_e1453, _e1461), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1477 > 0f)), (_e1483 == 4u)), select((_e1494 + min(max(((((_e1502 * 0.625f) + (_e1511 * 0.375f)) + (dot(vec2<f32>(_e1523, _e1532), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1538, _e1540))) * 0.125f)) - _e1554), min((_e1562 - _e1570), 0f)), max((_e1581 - _e1589), 0f))), (_e1601 + min(max(((((_e1608 * 0.625f) + (_e1618 * 0.375f)) + (dot(vec2<f32>(_e1629, _e1637), (vec2<f32>(_e1640, _e1642) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1658), min((_e1667 - _e1674), 0f)), max((_e1686 - _e1693), 0f))), (_e1699 > 0f)), (_e1705 == 5u)), select((_e1716 + ((((((((_e1724 * 0.625f) + (_e1733 * 0.375f)) + (dot(vec2<f32>(_e1745, _e1754), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1760, _e1762))) * 0.125f)) - _e1776) * abs((_e1784 - _e1792))) / max(abs((_e1802 - _e1810)), (abs(((((_e1820 * 0.625f) + (_e1829 * 0.375f)) + (dot(vec2<f32>(_e1841, _e1850), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1856, _e1858))) * 0.125f)) - _e1872)) + 0.00000001f))) * max(((_e1885 - _e1893) * ((((_e1902 * 0.625f) + (_e1911 * 0.375f)) + (dot(vec2<f32>(_e1923, _e1932), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1938, _e1940))) * 0.125f)) - _e1954)), 0f)) / max(abs(((_e1966 - _e1974) * ((((_e1983 * 0.625f) + (_e1992 * 0.375f)) + (dot(vec2<f32>(_e2004, _e2013), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2019, _e2021))) * 0.125f)) - _e2035))), 0.00000001f))), (_e2049 + ((((((((_e2056 * 0.625f) + (_e2066 * 0.375f)) + (dot(vec2<f32>(_e2077, _e2085), (vec2<f32>(_e2088, _e2090) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2106) * abs((_e2115 - _e2122))) / max(abs((_e2133 - _e2140)), (abs(((((_e2149 * 0.625f) + (_e2159 * 0.375f)) + (dot(vec2<f32>(_e2170, _e2178), (vec2<f32>(_e2181, _e2183) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2199)) + 0.00000001f))) * max(((_e2213 - _e2220) * ((((_e2228 * 0.625f) + (_e2238 * 0.375f)) + (dot(vec2<f32>(_e2249, _e2257), (vec2<f32>(_e2260, _e2262) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2278)), 0f)) / max(abs(((_e2291 - _e2298) * ((((_e2306 * 0.625f) + (_e2316 * 0.375f)) + (dot(vec2<f32>(_e2327, _e2335), (vec2<f32>(_e2338, _e2340) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2356))), 0.00000001f))), (_e2364 > 0f)), (_e2370 == 6u)) - select(_e2380, _e2388, (_e2389 < 0f)))));
            } else {
                let _e2403 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e2403 == 1u) {
                    let _e2406 = phi_0_;
                    let _e2409 = diag_0_;
                    diag_0_ = (_e2409 + max(_e2406, 0f));
                    let _e2411 = phi_0_;
                    let _e2420 = bc_value[((face_idx * 3u) + 0u)];
                    let _e2422 = rhs_0_;
                    rhs_0_ = (_e2422 - (min(_e2411, 0f) * _e2420));
                } else {
                    let _e2424 = phi_0_;
                    let _e2425 = diag_0_;
                    diag_0_ = (_e2425 + _e2424);
                }
            }
            let _e2433 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e2433;
            if (owner != idx) {
                let _e2436 = phi_1_;
                let _e2439 = phi_1_;
                phi_1_ = (_e2439 - (_e2436 * 2f));
            }
            let _e2441 = is_boundary;
            if !(_e2441) {
                let _e2443 = phi_1_;
                let _e2446 = diag_1_;
                diag_1_ = (_e2446 + max(_e2443, 0f));
                let _e2455 = phi_1_;
                let _e2458 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e2458 + min(_e2455, 0f));
                let _e2460 = phi_1_;
                let _e2467 = state[((idx * 8u) + 1u)];
                let _e2468 = other_idx;
                let _e2475 = state[((_e2468 * 8u) + 1u)];
                let _e2476 = phi_1_;
                let _e2480 = other_idx;
                let _e2487 = state[((_e2480 * 8u) + 1u)];
                let _e2488 = other_idx;
                let _e2496 = grad_state[((_e2488 * 8u) + 1u)].x;
                let _e2497 = other_idx;
                let _e2505 = grad_state[((_e2497 * 8u) + 1u)].y;
                let _e2511 = other_center.x;
                let _e2513 = other_center.y;
                let _e2524 = state[((idx * 8u) + 1u)];
                let _e2532 = grad_state[((idx * 8u) + 1u)].x;
                let _e2540 = grad_state[((idx * 8u) + 1u)].y;
                let _e2551 = phi_1_;
                let _e2557 = constants.scheme;
                let _e2561 = other_idx;
                let _e2568 = state[((_e2561 * 8u) + 1u)];
                let _e2569 = other_idx;
                let _e2576 = state[((_e2569 * 8u) + 1u)];
                let _e2586 = state[((idx * 8u) + 1u)];
                let _e2590 = other_idx;
                let _e2598 = grad_state[((_e2590 * 8u) + 1u)].x;
                let _e2599 = other_idx;
                let _e2607 = grad_state[((_e2599 * 8u) + 1u)].y;
                let _e2613 = other_center.x;
                let _e2615 = other_center.y;
                let _e2622 = other_idx;
                let _e2629 = state[((_e2622 * 8u) + 1u)];
                let _e2637 = state[((idx * 8u) + 1u)];
                let _e2644 = state[((idx * 8u) + 1u)];
                let _e2648 = other_idx;
                let _e2655 = state[((_e2648 * 8u) + 1u)];
                let _e2666 = grad_state[((idx * 8u) + 1u)].x;
                let _e2674 = grad_state[((idx * 8u) + 1u)].y;
                let _e2677 = other_center.x;
                let _e2679 = other_center.y;
                let _e2695 = state[((idx * 8u) + 1u)];
                let _e2697 = phi_1_;
                let _e2703 = constants.scheme;
                let _e2707 = other_idx;
                let _e2714 = state[((_e2707 * 8u) + 1u)];
                let _e2715 = other_idx;
                let _e2723 = grad_state[((_e2715 * 8u) + 1u)].x;
                let _e2724 = other_idx;
                let _e2732 = grad_state[((_e2724 * 8u) + 1u)].y;
                let _e2738 = other_center.x;
                let _e2740 = other_center.y;
                let _e2750 = state[((idx * 8u) + 1u)];
                let _e2751 = other_idx;
                let _e2758 = state[((_e2751 * 8u) + 1u)];
                let _e2769 = state[((idx * 8u) + 1u)];
                let _e2770 = other_idx;
                let _e2777 = state[((_e2770 * 8u) + 1u)];
                let _e2789 = state[((idx * 8u) + 1u)];
                let _e2797 = grad_state[((idx * 8u) + 1u)].x;
                let _e2805 = grad_state[((idx * 8u) + 1u)].y;
                let _e2815 = other_idx;
                let _e2822 = state[((_e2815 * 8u) + 1u)];
                let _e2829 = state[((idx * 8u) + 1u)];
                let _e2834 = other_idx;
                let _e2841 = state[((_e2834 * 8u) + 1u)];
                let _e2848 = state[((idx * 8u) + 1u)];
                let _e2854 = phi_1_;
                let _e2860 = constants.scheme;
                let _e2864 = other_idx;
                let _e2871 = state[((_e2864 * 8u) + 1u)];
                let _e2872 = other_idx;
                let _e2880 = grad_state[((_e2872 * 8u) + 1u)].x;
                let _e2881 = other_idx;
                let _e2889 = grad_state[((_e2881 * 8u) + 1u)].y;
                let _e2895 = other_center.x;
                let _e2897 = other_center.y;
                let _e2907 = state[((idx * 8u) + 1u)];
                let _e2908 = other_idx;
                let _e2915 = state[((_e2908 * 8u) + 1u)];
                let _e2925 = state[((idx * 8u) + 1u)];
                let _e2926 = other_idx;
                let _e2933 = state[((_e2926 * 8u) + 1u)];
                let _e2936 = other_idx;
                let _e2944 = grad_state[((_e2936 * 8u) + 1u)].x;
                let _e2945 = other_idx;
                let _e2953 = grad_state[((_e2945 * 8u) + 1u)].y;
                let _e2959 = other_center.x;
                let _e2961 = other_center.y;
                let _e2976 = state[((idx * 8u) + 1u)];
                let _e2977 = other_idx;
                let _e2984 = state[((_e2977 * 8u) + 1u)];
                let _e2986 = other_idx;
                let _e2994 = grad_state[((_e2986 * 8u) + 1u)].x;
                let _e2995 = other_idx;
                let _e3003 = grad_state[((_e2995 * 8u) + 1u)].y;
                let _e3009 = other_center.x;
                let _e3011 = other_center.y;
                let _e3025 = state[((idx * 8u) + 1u)];
                let _e3026 = other_idx;
                let _e3033 = state[((_e3026 * 8u) + 1u)];
                let _e3035 = other_idx;
                let _e3043 = grad_state[((_e3035 * 8u) + 1u)].x;
                let _e3044 = other_idx;
                let _e3052 = grad_state[((_e3044 * 8u) + 1u)].y;
                let _e3058 = other_center.x;
                let _e3060 = other_center.y;
                let _e3076 = state[((idx * 8u) + 1u)];
                let _e3084 = grad_state[((idx * 8u) + 1u)].x;
                let _e3092 = grad_state[((idx * 8u) + 1u)].y;
                let _e3102 = other_idx;
                let _e3109 = state[((_e3102 * 8u) + 1u)];
                let _e3116 = state[((idx * 8u) + 1u)];
                let _e3120 = other_idx;
                let _e3127 = state[((_e3120 * 8u) + 1u)];
                let _e3134 = state[((idx * 8u) + 1u)];
                let _e3144 = grad_state[((idx * 8u) + 1u)].x;
                let _e3152 = grad_state[((idx * 8u) + 1u)].y;
                let _e3167 = other_idx;
                let _e3174 = state[((_e3167 * 8u) + 1u)];
                let _e3181 = state[((idx * 8u) + 1u)];
                let _e3190 = grad_state[((idx * 8u) + 1u)].x;
                let _e3198 = grad_state[((idx * 8u) + 1u)].y;
                let _e3212 = other_idx;
                let _e3219 = state[((_e3212 * 8u) + 1u)];
                let _e3226 = state[((idx * 8u) + 1u)];
                let _e3235 = grad_state[((idx * 8u) + 1u)].x;
                let _e3243 = grad_state[((idx * 8u) + 1u)].y;
                let _e3259 = phi_1_;
                let _e3265 = constants.scheme;
                let _e3269 = other_idx;
                let _e3276 = state[((_e3269 * 8u) + 1u)];
                let _e3277 = other_idx;
                let _e3284 = state[((_e3277 * 8u) + 1u)];
                let _e3293 = state[((idx * 8u) + 1u)];
                let _e3297 = other_idx;
                let _e3305 = grad_state[((_e3297 * 8u) + 1u)].x;
                let _e3306 = other_idx;
                let _e3314 = grad_state[((_e3306 * 8u) + 1u)].y;
                let _e3320 = other_center.x;
                let _e3322 = other_center.y;
                let _e3329 = other_idx;
                let _e3336 = state[((_e3329 * 8u) + 1u)];
                let _e3344 = state[((idx * 8u) + 1u)];
                let _e3345 = other_idx;
                let _e3352 = state[((_e3345 * 8u) + 1u)];
                let _e3363 = state[((idx * 8u) + 1u)];
                let _e3364 = other_idx;
                let _e3371 = state[((_e3364 * 8u) + 1u)];
                let _e3383 = state[((idx * 8u) + 1u)];
                let _e3390 = state[((idx * 8u) + 1u)];
                let _e3393 = other_idx;
                let _e3400 = state[((_e3393 * 8u) + 1u)];
                let _e3411 = grad_state[((idx * 8u) + 1u)].x;
                let _e3419 = grad_state[((idx * 8u) + 1u)].y;
                let _e3422 = other_center.x;
                let _e3424 = other_center.y;
                let _e3440 = state[((idx * 8u) + 1u)];
                let _e3442 = other_idx;
                let _e3449 = state[((_e3442 * 8u) + 1u)];
                let _e3456 = state[((idx * 8u) + 1u)];
                let _e3461 = other_idx;
                let _e3468 = state[((_e3461 * 8u) + 1u)];
                let _e3475 = state[((idx * 8u) + 1u)];
                let _e3481 = phi_1_;
                let _e3487 = constants.scheme;
                let _e3491 = other_idx;
                let _e3498 = state[((_e3491 * 8u) + 1u)];
                let _e3499 = other_idx;
                let _e3506 = state[((_e3499 * 8u) + 1u)];
                let _e3515 = state[((idx * 8u) + 1u)];
                let _e3519 = other_idx;
                let _e3527 = grad_state[((_e3519 * 8u) + 1u)].x;
                let _e3528 = other_idx;
                let _e3536 = grad_state[((_e3528 * 8u) + 1u)].y;
                let _e3542 = other_center.x;
                let _e3544 = other_center.y;
                let _e3551 = other_idx;
                let _e3558 = state[((_e3551 * 8u) + 1u)];
                let _e3566 = state[((idx * 8u) + 1u)];
                let _e3567 = other_idx;
                let _e3574 = state[((_e3567 * 8u) + 1u)];
                let _e3584 = state[((idx * 8u) + 1u)];
                let _e3585 = other_idx;
                let _e3592 = state[((_e3585 * 8u) + 1u)];
                let _e3595 = other_idx;
                let _e3602 = state[((_e3595 * 8u) + 1u)];
                let _e3611 = state[((idx * 8u) + 1u)];
                let _e3615 = other_idx;
                let _e3623 = grad_state[((_e3615 * 8u) + 1u)].x;
                let _e3624 = other_idx;
                let _e3632 = grad_state[((_e3624 * 8u) + 1u)].y;
                let _e3638 = other_center.x;
                let _e3640 = other_center.y;
                let _e3647 = other_idx;
                let _e3654 = state[((_e3647 * 8u) + 1u)];
                let _e3667 = state[((idx * 8u) + 1u)];
                let _e3668 = other_idx;
                let _e3675 = state[((_e3668 * 8u) + 1u)];
                let _e3677 = other_idx;
                let _e3684 = state[((_e3677 * 8u) + 1u)];
                let _e3693 = state[((idx * 8u) + 1u)];
                let _e3697 = other_idx;
                let _e3705 = grad_state[((_e3697 * 8u) + 1u)].x;
                let _e3706 = other_idx;
                let _e3714 = grad_state[((_e3706 * 8u) + 1u)].y;
                let _e3720 = other_center.x;
                let _e3722 = other_center.y;
                let _e3729 = other_idx;
                let _e3736 = state[((_e3729 * 8u) + 1u)];
                let _e3748 = state[((idx * 8u) + 1u)];
                let _e3749 = other_idx;
                let _e3756 = state[((_e3749 * 8u) + 1u)];
                let _e3758 = other_idx;
                let _e3765 = state[((_e3758 * 8u) + 1u)];
                let _e3774 = state[((idx * 8u) + 1u)];
                let _e3778 = other_idx;
                let _e3786 = grad_state[((_e3778 * 8u) + 1u)].x;
                let _e3787 = other_idx;
                let _e3795 = grad_state[((_e3787 * 8u) + 1u)].y;
                let _e3801 = other_center.x;
                let _e3803 = other_center.y;
                let _e3810 = other_idx;
                let _e3817 = state[((_e3810 * 8u) + 1u)];
                let _e3831 = state[((idx * 8u) + 1u)];
                let _e3838 = state[((idx * 8u) + 1u)];
                let _e3841 = other_idx;
                let _e3848 = state[((_e3841 * 8u) + 1u)];
                let _e3859 = grad_state[((idx * 8u) + 1u)].x;
                let _e3867 = grad_state[((idx * 8u) + 1u)].y;
                let _e3870 = other_center.x;
                let _e3872 = other_center.y;
                let _e3888 = state[((idx * 8u) + 1u)];
                let _e3890 = other_idx;
                let _e3897 = state[((_e3890 * 8u) + 1u)];
                let _e3904 = state[((idx * 8u) + 1u)];
                let _e3908 = other_idx;
                let _e3915 = state[((_e3908 * 8u) + 1u)];
                let _e3922 = state[((idx * 8u) + 1u)];
                let _e3931 = state[((idx * 8u) + 1u)];
                let _e3934 = other_idx;
                let _e3941 = state[((_e3934 * 8u) + 1u)];
                let _e3952 = grad_state[((idx * 8u) + 1u)].x;
                let _e3960 = grad_state[((idx * 8u) + 1u)].y;
                let _e3963 = other_center.x;
                let _e3965 = other_center.y;
                let _e3981 = state[((idx * 8u) + 1u)];
                let _e3988 = other_idx;
                let _e3995 = state[((_e3988 * 8u) + 1u)];
                let _e4002 = state[((idx * 8u) + 1u)];
                let _e4010 = state[((idx * 8u) + 1u)];
                let _e4013 = other_idx;
                let _e4020 = state[((_e4013 * 8u) + 1u)];
                let _e4031 = grad_state[((idx * 8u) + 1u)].x;
                let _e4039 = grad_state[((idx * 8u) + 1u)].y;
                let _e4042 = other_center.x;
                let _e4044 = other_center.y;
                let _e4060 = state[((idx * 8u) + 1u)];
                let _e4066 = other_idx;
                let _e4073 = state[((_e4066 * 8u) + 1u)];
                let _e4080 = state[((idx * 8u) + 1u)];
                let _e4088 = state[((idx * 8u) + 1u)];
                let _e4091 = other_idx;
                let _e4098 = state[((_e4091 * 8u) + 1u)];
                let _e4109 = grad_state[((idx * 8u) + 1u)].x;
                let _e4117 = grad_state[((idx * 8u) + 1u)].y;
                let _e4120 = other_center.x;
                let _e4122 = other_center.y;
                let _e4138 = state[((idx * 8u) + 1u)];
                let _e4146 = phi_1_;
                let _e4152 = constants.scheme;
                let _e4162 = state[((idx * 8u) + 1u)];
                let _e4163 = other_idx;
                let _e4170 = state[((_e4163 * 8u) + 1u)];
                let _e4171 = phi_1_;
                let _e4177 = rhs_1_;
                rhs_1_ = (_e4177 - (_e2460 * (select(select(select(select(select(select(select(_e2467, _e2475, (_e2476 < 0f)), select((_e2487 + dot(vec2<f32>(_e2496, _e2505), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2511, _e2513)))), (_e2524 + dot(vec2<f32>(_e2532, _e2540), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e2551 > 0f)), (_e2557 == 1u)), select(((((_e2568 + (_e2576 * 0.625f)) + (_e2586 * 0.375f)) + (dot(vec2<f32>(_e2598, _e2607), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2613, _e2615))) * 0.125f)) - _e2629), ((((_e2637 + (_e2644 * 0.625f)) + (_e2655 * 0.375f)) + (dot(vec2<f32>(_e2666, _e2674), (vec2<f32>(_e2677, _e2679) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2695), (_e2697 > 0f)), (_e2703 == 2u)), select((_e2714 + min(max(dot(vec2<f32>(_e2723, _e2732), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2738, _e2740))), min((_e2750 - _e2758), 0f)), max((_e2769 - _e2777), 0f))), (_e2789 + min(max(dot(vec2<f32>(_e2797, _e2805), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e2822 - _e2829), 0f)), max((_e2841 - _e2848), 0f))), (_e2854 > 0f)), (_e2860 == 3u)), select((_e2871 + ((((dot(vec2<f32>(_e2880, _e2889), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2895, _e2897))) * abs((_e2907 - _e2915))) / max(abs((_e2925 - _e2933)), (abs(dot(vec2<f32>(_e2944, _e2953), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e2959, _e2961)))) + 0.00000001f))) * max(((_e2976 - _e2984) * dot(vec2<f32>(_e2994, _e3003), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3009, _e3011)))), 0f)) / max(abs(((_e3025 - _e3033) * dot(vec2<f32>(_e3043, _e3052), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3058, _e3060))))), 0.00000001f))), (_e3076 + ((((dot(vec2<f32>(_e3084, _e3092), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e3109 - _e3116))) / max(abs((_e3127 - _e3134)), (abs(dot(vec2<f32>(_e3144, _e3152), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e3174 - _e3181) * dot(vec2<f32>(_e3190, _e3198), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e3219 - _e3226) * dot(vec2<f32>(_e3235, _e3243), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e3259 > 0f)), (_e3265 == 4u)), select((_e3276 + min(max(((((_e3284 * 0.625f) + (_e3293 * 0.375f)) + (dot(vec2<f32>(_e3305, _e3314), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3320, _e3322))) * 0.125f)) - _e3336), min((_e3344 - _e3352), 0f)), max((_e3363 - _e3371), 0f))), (_e3383 + min(max(((((_e3390 * 0.625f) + (_e3400 * 0.375f)) + (dot(vec2<f32>(_e3411, _e3419), (vec2<f32>(_e3422, _e3424) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3440), min((_e3449 - _e3456), 0f)), max((_e3468 - _e3475), 0f))), (_e3481 > 0f)), (_e3487 == 5u)), select((_e3498 + ((((((((_e3506 * 0.625f) + (_e3515 * 0.375f)) + (dot(vec2<f32>(_e3527, _e3536), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3542, _e3544))) * 0.125f)) - _e3558) * abs((_e3566 - _e3574))) / max(abs((_e3584 - _e3592)), (abs(((((_e3602 * 0.625f) + (_e3611 * 0.375f)) + (dot(vec2<f32>(_e3623, _e3632), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3638, _e3640))) * 0.125f)) - _e3654)) + 0.00000001f))) * max(((_e3667 - _e3675) * ((((_e3684 * 0.625f) + (_e3693 * 0.375f)) + (dot(vec2<f32>(_e3705, _e3714), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3720, _e3722))) * 0.125f)) - _e3736)), 0f)) / max(abs(((_e3748 - _e3756) * ((((_e3765 * 0.625f) + (_e3774 * 0.375f)) + (dot(vec2<f32>(_e3786, _e3795), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3801, _e3803))) * 0.125f)) - _e3817))), 0.00000001f))), (_e3831 + ((((((((_e3838 * 0.625f) + (_e3848 * 0.375f)) + (dot(vec2<f32>(_e3859, _e3867), (vec2<f32>(_e3870, _e3872) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3888) * abs((_e3897 - _e3904))) / max(abs((_e3915 - _e3922)), (abs(((((_e3931 * 0.625f) + (_e3941 * 0.375f)) + (dot(vec2<f32>(_e3952, _e3960), (vec2<f32>(_e3963, _e3965) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3981)) + 0.00000001f))) * max(((_e3995 - _e4002) * ((((_e4010 * 0.625f) + (_e4020 * 0.375f)) + (dot(vec2<f32>(_e4031, _e4039), (vec2<f32>(_e4042, _e4044) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4060)), 0f)) / max(abs(((_e4073 - _e4080) * ((((_e4088 * 0.625f) + (_e4098 * 0.375f)) + (dot(vec2<f32>(_e4109, _e4117), (vec2<f32>(_e4120, _e4122) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4138))), 0.00000001f))), (_e4146 > 0f)), (_e4152 == 6u)) - select(_e4162, _e4170, (_e4171 < 0f)))));
            } else {
                let _e4185 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e4185 == 1u) {
                    let _e4188 = phi_1_;
                    let _e4191 = diag_1_;
                    diag_1_ = (_e4191 + max(_e4188, 0f));
                    let _e4193 = phi_1_;
                    let _e4202 = bc_value[((face_idx * 3u) + 1u)];
                    let _e4204 = rhs_1_;
                    rhs_1_ = (_e4204 - (min(_e4193, 0f) * _e4202));
                } else {
                    let _e4206 = phi_1_;
                    let _e4207 = diag_1_;
                    diag_1_ = (_e4207 + _e4206);
                }
            }
            let _e4219 = normal.x;
            let _e4221 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)] = (_e4221 + ((0.5f * area) * _e4219));
            let _e4233 = normal.x;
            let _e4235 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)] = (_e4235 + ((0.5f * area) * _e4233));
            let _e4247 = normal.y;
            let _e4249 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)] = (_e4249 + ((0.5f * area) * _e4247));
            let _e4261 = normal.y;
            let _e4263 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)] = (_e4263 + ((0.5f * area) * _e4261));
            let _e4267 = constants.density;
            let _e4274 = state[((idx * 8u) + 3u)];
            let _e4277 = dist;
            let diff_coeff_p = (((_e4267 * _e4274) * area) / _e4277);
            let _e4279 = is_boundary;
            if !(_e4279) {
                let _e4282 = diag_2_;
                diag_2_ = (_e4282 + diff_coeff_p);
                let _e4291 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e4291 - diff_coeff_p);
            } else {
                let _e4299 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e4299 == 1u) {
                    let _e4302 = diag_2_;
                    diag_2_ = (_e4302 + diff_coeff_p);
                    let _e4311 = bc_value[((face_idx * 3u) + 2u)];
                    let _e4313 = rhs_2_;
                    rhs_2_ = (_e4313 + (diff_coeff_p * _e4311));
                } else {
                    let _e4321 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e4321 == 2u) {
                        let _e4326 = constants.density;
                        let _e4333 = state[((idx * 8u) + 3u)];
                        let _e4342 = bc_value[((face_idx * 3u) + 2u)];
                        let _e4345 = rhs_2_;
                        rhs_2_ = (_e4345 + -((((_e4326 * _e4333) * area) * _e4342)));
                    }
                }
            }
            let _e4353 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e4353;
            if (owner != idx) {
                let _e4356 = phi_2_;
                let _e4359 = phi_2_;
                phi_2_ = (_e4359 - (_e4356 * 2f));
            }
            let _e4361 = phi_2_;
            let _e4362 = rhs_2_;
            rhs_2_ = (_e4362 - _e4361);
        }
        continuing {
            let _e4365 = k;
            k = (_e4365 + 1u);
        }
    }
    let _e4374 = diag_0_;
    let _e4375 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e4375 + _e4374);
    let _e4383 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e4383;
    let _e4391 = diag_1_;
    let _e4392 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e4392 + _e4391);
    let _e4400 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e4400;
    let _e4408 = diag_2_;
    let _e4409 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e4409 + _e4408);
    let _e4417 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e4417;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub state_iter: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub state_iter: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    state_iter: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.state_iter),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.state_iter,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"state_iter\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage> state_iter: array<f32>;
@group(1) @binding(6) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e32 = diagonal_indices[idx];
    let diag_rank = (_e32 - scalar_offset);
    let _e38 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e38 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e53 = rank;
        if (_e53 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e55 = rank;
            matrix_values[((start_row_0_ + (_e55 * 3u)) + 0u)] = 0f;
            let _e64 = rank;
            matrix_values[((start_row_0_ + (_e64 * 3u)) + 1u)] = 0f;
            let _e73 = rank;
            matrix_values[((start_row_0_ + (_e73 * 3u)) + 2u)] = 0f;
            let _e82 = rank;
            matrix_values[((start_row_1_ + (_e82 * 3u)) + 0u)] = 0f;
            let _e91 = rank;
            matrix_values[((start_row_1_ + (_e91 * 3u)) + 1u)] = 0f;
            let _e100 = rank;
            matrix_values[((start_row_1_ + (_e100 * 3u)) + 2u)] = 0f;
            let _e109 = rank;
            matrix_values[((start_row_2_ + (_e109 * 3u)) + 0u)] = 0f;
            let _e118 = rank;
            matrix_values[((start_row_2_ + (_e118 * 3u)) + 1u)] = 0f;
            let _e127 = rank;
            matrix_values[((start_row_2_ + (_e127 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e137 = rank;
            rank = (_e137 + 1u);
        }
    }
    let _e141 = constants.density;
    let _e146 = constants.dt;
    let _e148 = diag_0_;
    diag_0_ = (_e148 + ((vol * _e141) / _e146));
    let _e152 = constants.density;
    let _e156 = constants.dt;
    let _e165 = state_old[((idx * 8u) + 0u)];
    let _e167 = rhs_0_;
    rhs_0_ = (_e167 + (((vol * _e152) / _e156) * _e165));
    let _e171 = constants.time_scheme;
    if (_e171 == 1u) {
        let _e176 = constants.dt;
        let _e179 = constants.dt_old;
        let r = (_e176 / _e179);
        let _e183 = constants.density;
        let _e187 = constants.dt;
        let diag_bdf2_ = ((((vol * _e183) / _e187) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e203 = diag_0_;
        let _e206 = constants.density;
        let _e210 = constants.dt;
        diag_0_ = ((_e203 - ((vol * _e206) / _e210)) + diag_bdf2_);
        let _e214 = rhs_0_;
        let _e217 = constants.density;
        let _e221 = constants.dt;
        let _e229 = state_old[((idx * 8u) + 0u)];
        let _e234 = constants.density;
        let _e238 = constants.dt;
        let _e246 = state_old[((idx * 8u) + 0u)];
        let _e254 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e214 - (((vol * _e217) / _e221) * _e229)) + (((vol * _e234) / _e238) * ((factor_n * _e246) - (factor_nm1_ * _e254))));
    }
    let _e261 = constants.dtau;
    if (_e261 > 0f) {
        let _e266 = constants.density;
        let _e270 = constants.dtau;
        let _e272 = diag_0_;
        diag_0_ = (_e272 + ((vol * _e266) / _e270));
        let _e276 = constants.density;
        let _e280 = constants.dtau;
        let _e288 = state_iter[((idx * 8u) + 0u)];
        let _e290 = rhs_0_;
        rhs_0_ = (_e290 + (((vol * _e276) / _e280) * _e288));
    }
    let _e294 = constants.density;
    let _e299 = constants.dt;
    let _e301 = diag_1_;
    diag_1_ = (_e301 + ((vol * _e294) / _e299));
    let _e305 = constants.density;
    let _e309 = constants.dt;
    let _e318 = state_old[((idx * 8u) + 1u)];
    let _e320 = rhs_1_;
    rhs_1_ = (_e320 + (((vol * _e305) / _e309) * _e318));
    let _e324 = constants.time_scheme;
    if (_e324 == 1u) {
        let _e329 = constants.dt;
        let _e332 = constants.dt_old;
        let r_1 = (_e329 / _e332);
        let _e336 = constants.density;
        let _e340 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e336) / _e340) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e356 = diag_1_;
        let _e359 = constants.density;
        let _e363 = constants.dt;
        diag_1_ = ((_e356 - ((vol * _e359) / _e363)) + diag_bdf2_1);
        let _e367 = rhs_1_;
        let _e370 = constants.density;
        let _e374 = constants.dt;
        let _e382 = state_old[((idx * 8u) + 1u)];
        let _e387 = constants.density;
        let _e391 = constants.dt;
        let _e399 = state_old[((idx * 8u) + 1u)];
        let _e407 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e367 - (((vol * _e370) / _e374) * _e382)) + (((vol * _e387) / _e391) * ((factor_n_1 * _e399) - (factor_nm1_1 * _e407))));
    }
    let _e414 = constants.dtau;
    if (_e414 > 0f) {
        let _e419 = constants.density;
        let _e423 = constants.dtau;
        let _e425 = diag_1_;
        diag_1_ = (_e425 + ((vol * _e419) / _e423));
        let _e429 = constants.density;
        let _e433 = constants.dtau;
        let _e441 = state_iter[((idx * 8u) + 1u)];
        let _e443 = rhs_1_;
        rhs_1_ = (_e443 + (((vol * _e429) / _e433) * _e441));
    }
    k = start;
    loop {
        let _e446 = k;
        if (_e446 < end) {
        } else {
            break;
        }
        {
            let _e449 = k;
            let face_idx = cell_faces[_e449];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e469 = face_normals[face_idx];
            normal = _e469;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e477 = normal.x;
                normal.x = -(_e477);
                let _e481 = normal.y;
                normal.y = -(_e481);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e488 = other_idx;
                let _e490 = cell_centers[_e488];
                other_center = _e490;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e494 = other_center.x;
            let dx = (_e494 - center.x);
            let _e498 = other_center.y;
            let dy = (_e498 - center.y);
            let _e502 = normal.x;
            let _e505 = normal.y;
            let dist_proj = abs(((dx * _e502) + (dy * _e505)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e519 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e519];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e525 = constants.viscosity;
            let _e527 = dist;
            let diff_coeff_U = ((_e525 * area) / _e527);
            let _e529 = is_boundary;
            if !(_e529) {
                let _e531 = diag_0_;
                diag_0_ = (_e531 + diff_coeff_U);
                let _e540 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e540 - diff_coeff_U);
            } else {
                let _e548 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e548 == 1u) {
                    let _e551 = diag_0_;
                    diag_0_ = (_e551 + diff_coeff_U);
                    let _e559 = bc_value[((face_idx * 3u) + 0u)];
                    let _e561 = rhs_0_;
                    rhs_0_ = (_e561 + (diff_coeff_U * _e559));
                } else {
                    let _e569 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e569 == 2u) {
                        let _e574 = constants.viscosity;
                        let _e582 = bc_value[((face_idx * 3u) + 0u)];
                        let _e585 = rhs_0_;
                        rhs_0_ = (_e585 + -(((_e574 * area) * _e582)));
                    }
                }
            }
            let _e587 = is_boundary;
            if !(_e587) {
                let _e589 = diag_1_;
                diag_1_ = (_e589 + diff_coeff_U);
                let _e598 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e598 - diff_coeff_U);
            } else {
                let _e606 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e606 == 1u) {
                    let _e609 = diag_1_;
                    diag_1_ = (_e609 + diff_coeff_U);
                    let _e617 = bc_value[((face_idx * 3u) + 1u)];
                    let _e619 = rhs_1_;
                    rhs_1_ = (_e619 + (diff_coeff_U * _e617));
                } else {
                    let _e627 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e627 == 2u) {
                        let _e632 = constants.viscosity;
                        let _e640 = bc_value[((face_idx * 3u) + 1u)];
                        let _e643 = rhs_1_;
                        rhs_1_ = (_e643 + -(((_e632 * area) * _e640)));
                    }
                }
            }
            let _e651 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e651;
            if (owner != idx) {
                let _e654 = phi_0_;
                let _e657 = phi_0_;
                phi_0_ = (_e657 - (_e654 * 2f));
            }
            let _e659 = is_boundary;
            if !(_e659) {
                let _e661 = phi_0_;
                let _e664 = diag_0_;
                diag_0_ = (_e664 + max(_e661, 0f));
                let _e673 = phi_0_;
                let _e676 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e676 + min(_e673, 0f));
                let _e678 = phi_0_;
                let _e685 = state[((idx * 8u) + 0u)];
                let _e686 = other_idx;
                let _e693 = state[((_e686 * 8u) + 0u)];
                let _e694 = phi_0_;
                let _e698 = other_idx;
                let _e705 = state[((_e698 * 8u) + 0u)];
                let _e706 = other_idx;
                let _e713 = state[((_e706 * 8u) + 0u)];
                let _e720 = state[((idx * 8u) + 0u)];
                let _e729 = other_idx;
                let _e736 = state[((_e729 * 8u) + 0u)];
                let _e743 = state[((idx * 8u) + 0u)];
                let _e757 = other_center.x;
                let _e759 = other_center.y;
                let _e770 = state[((idx * 8u) + 0u)];
                let _e771 = other_idx;
                let _e778 = state[((_e771 * 8u) + 0u)];
                let _e785 = state[((idx * 8u) + 0u)];
                let _e794 = other_idx;
                let _e801 = state[((_e794 * 8u) + 0u)];
                let _e808 = state[((idx * 8u) + 0u)];
                let _e827 = phi_0_;
                let _e833 = constants.scheme;
                let _e837 = other_idx;
                let _e844 = state[((_e837 * 8u) + 0u)];
                let _e845 = other_idx;
                let _e852 = state[((_e845 * 8u) + 0u)];
                let _e862 = state[((idx * 8u) + 0u)];
                let _e866 = other_idx;
                let _e873 = state[((_e866 * 8u) + 0u)];
                let _e880 = state[((idx * 8u) + 0u)];
                let _e889 = other_idx;
                let _e896 = state[((_e889 * 8u) + 0u)];
                let _e903 = state[((idx * 8u) + 0u)];
                let _e917 = other_center.x;
                let _e919 = other_center.y;
                let _e926 = other_idx;
                let _e933 = state[((_e926 * 8u) + 0u)];
                let _e941 = state[((idx * 8u) + 0u)];
                let _e948 = state[((idx * 8u) + 0u)];
                let _e952 = other_idx;
                let _e959 = state[((_e952 * 8u) + 0u)];
                let _e963 = other_idx;
                let _e970 = state[((_e963 * 8u) + 0u)];
                let _e977 = state[((idx * 8u) + 0u)];
                let _e986 = other_idx;
                let _e993 = state[((_e986 * 8u) + 0u)];
                let _e1000 = state[((idx * 8u) + 0u)];
                let _e1011 = other_center.x;
                let _e1013 = other_center.y;
                let _e1029 = state[((idx * 8u) + 0u)];
                let _e1031 = phi_0_;
                let _e1037 = constants.scheme;
                let _e1041 = other_idx;
                let _e1048 = state[((_e1041 * 8u) + 0u)];
                let _e1049 = other_idx;
                let _e1056 = state[((_e1049 * 8u) + 0u)];
                let _e1063 = state[((idx * 8u) + 0u)];
                let _e1072 = other_idx;
                let _e1079 = state[((_e1072 * 8u) + 0u)];
                let _e1086 = state[((idx * 8u) + 0u)];
                let _e1100 = other_center.x;
                let _e1102 = other_center.y;
                let _e1112 = state[((idx * 8u) + 0u)];
                let _e1113 = other_idx;
                let _e1120 = state[((_e1113 * 8u) + 0u)];
                let _e1131 = state[((idx * 8u) + 0u)];
                let _e1132 = other_idx;
                let _e1139 = state[((_e1132 * 8u) + 0u)];
                let _e1151 = state[((idx * 8u) + 0u)];
                let _e1152 = other_idx;
                let _e1159 = state[((_e1152 * 8u) + 0u)];
                let _e1166 = state[((idx * 8u) + 0u)];
                let _e1175 = other_idx;
                let _e1182 = state[((_e1175 * 8u) + 0u)];
                let _e1189 = state[((idx * 8u) + 0u)];
                let _e1207 = other_idx;
                let _e1214 = state[((_e1207 * 8u) + 0u)];
                let _e1221 = state[((idx * 8u) + 0u)];
                let _e1226 = other_idx;
                let _e1233 = state[((_e1226 * 8u) + 0u)];
                let _e1240 = state[((idx * 8u) + 0u)];
                let _e1246 = phi_0_;
                let _e1252 = constants.scheme;
                let _e1256 = other_idx;
                let _e1263 = state[((_e1256 * 8u) + 0u)];
                let _e1264 = other_idx;
                let _e1271 = state[((_e1264 * 8u) + 0u)];
                let _e1278 = state[((idx * 8u) + 0u)];
                let _e1287 = other_idx;
                let _e1294 = state[((_e1287 * 8u) + 0u)];
                let _e1301 = state[((idx * 8u) + 0u)];
                let _e1315 = other_center.x;
                let _e1317 = other_center.y;
                let _e1327 = state[((idx * 8u) + 0u)];
                let _e1328 = other_idx;
                let _e1335 = state[((_e1328 * 8u) + 0u)];
                let _e1345 = state[((idx * 8u) + 0u)];
                let _e1346 = other_idx;
                let _e1353 = state[((_e1346 * 8u) + 0u)];
                let _e1356 = other_idx;
                let _e1363 = state[((_e1356 * 8u) + 0u)];
                let _e1370 = state[((idx * 8u) + 0u)];
                let _e1379 = other_idx;
                let _e1386 = state[((_e1379 * 8u) + 0u)];
                let _e1393 = state[((idx * 8u) + 0u)];
                let _e1407 = other_center.x;
                let _e1409 = other_center.y;
                let _e1424 = state[((idx * 8u) + 0u)];
                let _e1425 = other_idx;
                let _e1432 = state[((_e1425 * 8u) + 0u)];
                let _e1434 = other_idx;
                let _e1441 = state[((_e1434 * 8u) + 0u)];
                let _e1448 = state[((idx * 8u) + 0u)];
                let _e1457 = other_idx;
                let _e1464 = state[((_e1457 * 8u) + 0u)];
                let _e1471 = state[((idx * 8u) + 0u)];
                let _e1485 = other_center.x;
                let _e1487 = other_center.y;
                let _e1501 = state[((idx * 8u) + 0u)];
                let _e1502 = other_idx;
                let _e1509 = state[((_e1502 * 8u) + 0u)];
                let _e1511 = other_idx;
                let _e1518 = state[((_e1511 * 8u) + 0u)];
                let _e1525 = state[((idx * 8u) + 0u)];
                let _e1534 = other_idx;
                let _e1541 = state[((_e1534 * 8u) + 0u)];
                let _e1548 = state[((idx * 8u) + 0u)];
                let _e1562 = other_center.x;
                let _e1564 = other_center.y;
                let _e1580 = state[((idx * 8u) + 0u)];
                let _e1581 = other_idx;
                let _e1588 = state[((_e1581 * 8u) + 0u)];
                let _e1595 = state[((idx * 8u) + 0u)];
                let _e1604 = other_idx;
                let _e1611 = state[((_e1604 * 8u) + 0u)];
                let _e1618 = state[((idx * 8u) + 0u)];
                let _e1636 = other_idx;
                let _e1643 = state[((_e1636 * 8u) + 0u)];
                let _e1650 = state[((idx * 8u) + 0u)];
                let _e1654 = other_idx;
                let _e1661 = state[((_e1654 * 8u) + 0u)];
                let _e1668 = state[((idx * 8u) + 0u)];
                let _e1671 = other_idx;
                let _e1678 = state[((_e1671 * 8u) + 0u)];
                let _e1685 = state[((idx * 8u) + 0u)];
                let _e1694 = other_idx;
                let _e1701 = state[((_e1694 * 8u) + 0u)];
                let _e1708 = state[((idx * 8u) + 0u)];
                let _e1731 = other_idx;
                let _e1738 = state[((_e1731 * 8u) + 0u)];
                let _e1745 = state[((idx * 8u) + 0u)];
                let _e1747 = other_idx;
                let _e1754 = state[((_e1747 * 8u) + 0u)];
                let _e1761 = state[((idx * 8u) + 0u)];
                let _e1770 = other_idx;
                let _e1777 = state[((_e1770 * 8u) + 0u)];
                let _e1784 = state[((idx * 8u) + 0u)];
                let _e1806 = other_idx;
                let _e1813 = state[((_e1806 * 8u) + 0u)];
                let _e1820 = state[((idx * 8u) + 0u)];
                let _e1822 = other_idx;
                let _e1829 = state[((_e1822 * 8u) + 0u)];
                let _e1836 = state[((idx * 8u) + 0u)];
                let _e1845 = other_idx;
                let _e1852 = state[((_e1845 * 8u) + 0u)];
                let _e1859 = state[((idx * 8u) + 0u)];
                let _e1883 = phi_0_;
                let _e1889 = constants.scheme;
                let _e1893 = other_idx;
                let _e1900 = state[((_e1893 * 8u) + 0u)];
                let _e1901 = other_idx;
                let _e1908 = state[((_e1901 * 8u) + 0u)];
                let _e1917 = state[((idx * 8u) + 0u)];
                let _e1921 = other_idx;
                let _e1928 = state[((_e1921 * 8u) + 0u)];
                let _e1935 = state[((idx * 8u) + 0u)];
                let _e1944 = other_idx;
                let _e1951 = state[((_e1944 * 8u) + 0u)];
                let _e1958 = state[((idx * 8u) + 0u)];
                let _e1972 = other_center.x;
                let _e1974 = other_center.y;
                let _e1981 = other_idx;
                let _e1988 = state[((_e1981 * 8u) + 0u)];
                let _e1996 = state[((idx * 8u) + 0u)];
                let _e1997 = other_idx;
                let _e2004 = state[((_e1997 * 8u) + 0u)];
                let _e2015 = state[((idx * 8u) + 0u)];
                let _e2016 = other_idx;
                let _e2023 = state[((_e2016 * 8u) + 0u)];
                let _e2035 = state[((idx * 8u) + 0u)];
                let _e2042 = state[((idx * 8u) + 0u)];
                let _e2045 = other_idx;
                let _e2052 = state[((_e2045 * 8u) + 0u)];
                let _e2056 = other_idx;
                let _e2063 = state[((_e2056 * 8u) + 0u)];
                let _e2070 = state[((idx * 8u) + 0u)];
                let _e2079 = other_idx;
                let _e2086 = state[((_e2079 * 8u) + 0u)];
                let _e2093 = state[((idx * 8u) + 0u)];
                let _e2104 = other_center.x;
                let _e2106 = other_center.y;
                let _e2122 = state[((idx * 8u) + 0u)];
                let _e2124 = other_idx;
                let _e2131 = state[((_e2124 * 8u) + 0u)];
                let _e2138 = state[((idx * 8u) + 0u)];
                let _e2143 = other_idx;
                let _e2150 = state[((_e2143 * 8u) + 0u)];
                let _e2157 = state[((idx * 8u) + 0u)];
                let _e2163 = phi_0_;
                let _e2169 = constants.scheme;
                let _e2173 = other_idx;
                let _e2180 = state[((_e2173 * 8u) + 0u)];
                let _e2181 = other_idx;
                let _e2188 = state[((_e2181 * 8u) + 0u)];
                let _e2197 = state[((idx * 8u) + 0u)];
                let _e2201 = other_idx;
                let _e2208 = state[((_e2201 * 8u) + 0u)];
                let _e2215 = state[((idx * 8u) + 0u)];
                let _e2224 = other_idx;
                let _e2231 = state[((_e2224 * 8u) + 0u)];
                let _e2238 = state[((idx * 8u) + 0u)];
                let _e2252 = other_center.x;
                let _e2254 = other_center.y;
                let _e2261 = other_idx;
                let _e2268 = state[((_e2261 * 8u) + 0u)];
                let _e2276 = state[((idx * 8u) + 0u)];
                let _e2277 = other_idx;
                let _e2284 = state[((_e2277 * 8u) + 0u)];
                let _e2294 = state[((idx * 8u) + 0u)];
                let _e2295 = other_idx;
                let _e2302 = state[((_e2295 * 8u) + 0u)];
                let _e2305 = other_idx;
                let _e2312 = state[((_e2305 * 8u) + 0u)];
                let _e2321 = state[((idx * 8u) + 0u)];
                let _e2325 = other_idx;
                let _e2332 = state[((_e2325 * 8u) + 0u)];
                let _e2339 = state[((idx * 8u) + 0u)];
                let _e2348 = other_idx;
                let _e2355 = state[((_e2348 * 8u) + 0u)];
                let _e2362 = state[((idx * 8u) + 0u)];
                let _e2376 = other_center.x;
                let _e2378 = other_center.y;
                let _e2385 = other_idx;
                let _e2392 = state[((_e2385 * 8u) + 0u)];
                let _e2405 = state[((idx * 8u) + 0u)];
                let _e2406 = other_idx;
                let _e2413 = state[((_e2406 * 8u) + 0u)];
                let _e2415 = other_idx;
                let _e2422 = state[((_e2415 * 8u) + 0u)];
                let _e2431 = state[((idx * 8u) + 0u)];
                let _e2435 = other_idx;
                let _e2442 = state[((_e2435 * 8u) + 0u)];
                let _e2449 = state[((idx * 8u) + 0u)];
                let _e2458 = other_idx;
                let _e2465 = state[((_e2458 * 8u) + 0u)];
                let _e2472 = state[((idx * 8u) + 0u)];
                let _e2486 = other_center.x;
                let _e2488 = other_center.y;
                let _e2495 = other_idx;
                let _e2502 = state[((_e2495 * 8u) + 0u)];
                let _e2514 = state[((idx * 8u) + 0u)];
                let _e2515 = other_idx;
                let _e2522 = state[((_e2515 * 8u) + 0u)];
                let _e2524 = other_idx;
                let _e2531 = state[((_e2524 * 8u) + 0u)];
                let _e2540 = state[((idx * 8u) + 0u)];
                let _e2544 = other_idx;
                let _e2551 = state[((_e2544 * 8u) + 0u)];
                let _e2558 = state[((idx * 8u) + 0u)];
                let _e2567 = other_idx;
                let _e2574 = state[((_e2567 * 8u) + 0u)];
                let _e2581 = state[((idx * 8u) + 0u)];
                let _e2595 = other_center.x;
                let _e2597 = other_center.y;
                let _e2604 = other_idx;
                let _e2611 = state[((_e2604 * 8u) + 0u)];
                let _e2625 = state[((idx * 8u) + 0u)];
                let _e2632 = state[((idx * 8u) + 0u)];
                let _e2635 = other_idx;
                let _e2642 = state[((_e2635 * 8u) + 0u)];
                let _e2646 = other_idx;
                let _e2653 = state[((_e2646 * 8u) + 0u)];
                let _e2660 = state[((idx * 8u) + 0u)];
                let _e2669 = other_idx;
                let _e2676 = state[((_e2669 * 8u) + 0u)];
                let _e2683 = state[((idx * 8u) + 0u)];
                let _e2694 = other_center.x;
                let _e2696 = other_center.y;
                let _e2712 = state[((idx * 8u) + 0u)];
                let _e2714 = other_idx;
                let _e2721 = state[((_e2714 * 8u) + 0u)];
                let _e2728 = state[((idx * 8u) + 0u)];
                let _e2732 = other_idx;
                let _e2739 = state[((_e2732 * 8u) + 0u)];
                let _e2746 = state[((idx * 8u) + 0u)];
                let _e2755 = state[((idx * 8u) + 0u)];
                let _e2758 = other_idx;
                let _e2765 = state[((_e2758 * 8u) + 0u)];
                let _e2769 = other_idx;
                let _e2776 = state[((_e2769 * 8u) + 0u)];
                let _e2783 = state[((idx * 8u) + 0u)];
                let _e2792 = other_idx;
                let _e2799 = state[((_e2792 * 8u) + 0u)];
                let _e2806 = state[((idx * 8u) + 0u)];
                let _e2817 = other_center.x;
                let _e2819 = other_center.y;
                let _e2835 = state[((idx * 8u) + 0u)];
                let _e2842 = other_idx;
                let _e2849 = state[((_e2842 * 8u) + 0u)];
                let _e2856 = state[((idx * 8u) + 0u)];
                let _e2864 = state[((idx * 8u) + 0u)];
                let _e2867 = other_idx;
                let _e2874 = state[((_e2867 * 8u) + 0u)];
                let _e2878 = other_idx;
                let _e2885 = state[((_e2878 * 8u) + 0u)];
                let _e2892 = state[((idx * 8u) + 0u)];
                let _e2901 = other_idx;
                let _e2908 = state[((_e2901 * 8u) + 0u)];
                let _e2915 = state[((idx * 8u) + 0u)];
                let _e2926 = other_center.x;
                let _e2928 = other_center.y;
                let _e2944 = state[((idx * 8u) + 0u)];
                let _e2950 = other_idx;
                let _e2957 = state[((_e2950 * 8u) + 0u)];
                let _e2964 = state[((idx * 8u) + 0u)];
                let _e2972 = state[((idx * 8u) + 0u)];
                let _e2975 = other_idx;
                let _e2982 = state[((_e2975 * 8u) + 0u)];
                let _e2986 = other_idx;
                let _e2993 = state[((_e2986 * 8u) + 0u)];
                let _e3000 = state[((idx * 8u) + 0u)];
                let _e3009 = other_idx;
                let _e3016 = state[((_e3009 * 8u) + 0u)];
                let _e3023 = state[((idx * 8u) + 0u)];
                let _e3034 = other_center.x;
                let _e3036 = other_center.y;
                let _e3052 = state[((idx * 8u) + 0u)];
                let _e3060 = phi_0_;
                let _e3066 = constants.scheme;
                let _e3076 = state[((idx * 8u) + 0u)];
                let _e3077 = other_idx;
                let _e3084 = state[((_e3077 * 8u) + 0u)];
                let _e3085 = phi_0_;
                let _e3091 = rhs_0_;
                rhs_0_ = (_e3091 - (_e678 * (select(select(select(select(select(select(select(_e685, _e693, (_e694 < 0f)), select((_e705 + dot(vec2<f32>((((_e713 - _e720) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e736 - _e743) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e757, _e759)))), (_e770 + dot(vec2<f32>((((_e778 - _e785) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e801 - _e808) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e827 > 0f)), (_e833 == 1u)), select(((((_e844 + (_e852 * 0.625f)) + (_e862 * 0.375f)) + (dot(vec2<f32>((((_e873 - _e880) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e896 - _e903) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e917, _e919))) * 0.125f)) - _e933), ((((_e941 + (_e948 * 0.625f)) + (_e959 * 0.375f)) + (dot(vec2<f32>((((_e970 - _e977) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e993 - _e1000) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e1011, _e1013) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e1029), (_e1031 > 0f)), (_e1037 == 2u)), select((_e1048 + min(max(dot(vec2<f32>((((_e1056 - _e1063) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1079 - _e1086) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1100, _e1102))), min((_e1112 - _e1120), 0f)), max((_e1131 - _e1139), 0f))), (_e1151 + min(max(dot(vec2<f32>((((_e1159 - _e1166) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1182 - _e1189) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1214 - _e1221), 0f)), max((_e1233 - _e1240), 0f))), (_e1246 > 0f)), (_e1252 == 3u)), select((_e1263 + ((((dot(vec2<f32>((((_e1271 - _e1278) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1294 - _e1301) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1315, _e1317))) * abs((_e1327 - _e1335))) / max(abs((_e1345 - _e1353)), (abs(dot(vec2<f32>((((_e1363 - _e1370) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1386 - _e1393) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1407, _e1409)))) + 0.00000001f))) * max(((_e1424 - _e1432) * dot(vec2<f32>((((_e1441 - _e1448) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1464 - _e1471) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1485, _e1487)))), 0f)) / max(abs(((_e1501 - _e1509) * dot(vec2<f32>((((_e1518 - _e1525) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1541 - _e1548) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1562, _e1564))))), 0.00000001f))), (_e1580 + ((((dot(vec2<f32>((((_e1588 - _e1595) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1611 - _e1618) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1643 - _e1650))) / max(abs((_e1661 - _e1668)), (abs(dot(vec2<f32>((((_e1678 - _e1685) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1701 - _e1708) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e1738 - _e1745) * dot(vec2<f32>((((_e1754 - _e1761) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1777 - _e1784) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e1813 - _e1820) * dot(vec2<f32>((((_e1829 - _e1836) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1852 - _e1859) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e1883 > 0f)), (_e1889 == 4u)), select((_e1900 + min(max(((((_e1908 * 0.625f) + (_e1917 * 0.375f)) + (dot(vec2<f32>((((_e1928 - _e1935) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1951 - _e1958) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e1972, _e1974))) * 0.125f)) - _e1988), min((_e1996 - _e2004), 0f)), max((_e2015 - _e2023), 0f))), (_e2035 + min(max(((((_e2042 * 0.625f) + (_e2052 * 0.375f)) + (dot(vec2<f32>((((_e2063 - _e2070) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2086 - _e2093) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2104, _e2106) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2122), min((_e2131 - _e2138), 0f)), max((_e2150 - _e2157), 0f))), (_e2163 > 0f)), (_e2169 == 5u)), select((_e2180 + ((((((((_e2188 * 0.625f) + (_e2197 * 0.375f)) + (dot(vec2<f32>((((_e2208 - _e2215) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2231 - _e2238) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2252, _e2254))) * 0.125f)) - _e2268) * abs((_e2276 - _e2284))) / max(abs((_e2294 - _e2302)), (abs(((((_e2312 * 0.625f) + (_e2321 * 0.375f)) + (dot(vec2<f32>((((_e2332 - _e2339) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2355 - _e2362) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2376, _e2378))) * 0.125f)) - _e2392)) + 0.00000001f))) * max(((_e2405 - _e2413) * ((((_e2422 * 0.625f) + (_e2431 * 0.375f)) + (dot(vec2<f32>((((_e2442 - _e2449) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2465 - _e2472) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2486, _e2488))) * 0.125f)) - _e2502)), 0f)) / max(abs(((_e2514 - _e2522) * ((((_e2531 * 0.625f) + (_e2540 * 0.375f)) + (dot(vec2<f32>((((_e2551 - _e2558) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2574 - _e2581) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2595, _e2597))) * 0.125f)) - _e2611))), 0.00000001f))), (_e2625 + ((((((((_e2632 * 0.625f) + (_e2642 * 0.375f)) + (dot(vec2<f32>((((_e2653 - _e2660) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2676 - _e2683) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2694, _e2696) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2712) * abs((_e2721 - _e2728))) / max(abs((_e2739 - _e2746)), (abs(((((_e2755 * 0.625f) + (_e2765 * 0.375f)) + (dot(vec2<f32>((((_e2776 - _e2783) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2799 - _e2806) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2817, _e2819) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2835)) + 0.00000001f))) * max(((_e2849 - _e2856) * ((((_e2864 * 0.625f) + (_e2874 * 0.375f)) + (dot(vec2<f32>((((_e2885 - _e2892) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2908 - _e2915) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e2926, _e2928) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2944)), 0f)) / max(abs(((_e2957 - _e2964) * ((((_e2972 * 0.625f) + (_e2982 * 0.375f)) + (dot(vec2<f32>((((_e2993 - _e3000) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3016 - _e3023) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3034, _e3036) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3052))), 0.00000001f))), (_e3060 > 0f)), (_e3066 == 6u)) - select(_e3076, _e3084, (_e3085 < 0f)))));
            } else {
                let _e3099 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3099 == 1u) {
                    let _e3102 = phi_0_;
                    let _e3105 = diag_0_;
                    diag_0_ = (_e3105 + max(_e3102, 0f));
                    let _e3107 = phi_0_;
                    let _e3116 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3118 = rhs_0_;
                    rhs_0_ = (_e3118 - (min(_e3107, 0f) * _e3116));
                } else {
                    let _e3120 = phi_0_;
                    let _e3121 = diag_0_;
                    diag_0_ = (_e3121 + _e3120);
                }
            }
            let _e3129 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3129;
            if (owner != idx) {
                let _e3132 = phi_1_;
                let _e3135 = phi_1_;
                phi_1_ = (_e3135 - (_e3132 * 2f));
            }
            let _e3137 = is_boundary;
            if !(_e3137) {
                let _e3139 = phi_1_;
                let _e3142 = diag_1_;
                diag_1_ = (_e3142 + max(_e3139, 0f));
                let _e3151 = phi_1_;
                let _e3154 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3154 + min(_e3151, 0f));
                let _e3156 = phi_1_;
                let _e3163 = state[((idx * 8u) + 1u)];
                let _e3164 = other_idx;
                let _e3171 = state[((_e3164 * 8u) + 1u)];
                let _e3172 = phi_1_;
                let _e3176 = other_idx;
                let _e3183 = state[((_e3176 * 8u) + 1u)];
                let _e3184 = other_idx;
                let _e3191 = state[((_e3184 * 8u) + 1u)];
                let _e3198 = state[((idx * 8u) + 1u)];
                let _e3207 = other_idx;
                let _e3214 = state[((_e3207 * 8u) + 1u)];
                let _e3221 = state[((idx * 8u) + 1u)];
                let _e3235 = other_center.x;
                let _e3237 = other_center.y;
                let _e3248 = state[((idx * 8u) + 1u)];
                let _e3249 = other_idx;
                let _e3256 = state[((_e3249 * 8u) + 1u)];
                let _e3263 = state[((idx * 8u) + 1u)];
                let _e3272 = other_idx;
                let _e3279 = state[((_e3272 * 8u) + 1u)];
                let _e3286 = state[((idx * 8u) + 1u)];
                let _e3305 = phi_1_;
                let _e3311 = constants.scheme;
                let _e3315 = other_idx;
                let _e3322 = state[((_e3315 * 8u) + 1u)];
                let _e3323 = other_idx;
                let _e3330 = state[((_e3323 * 8u) + 1u)];
                let _e3340 = state[((idx * 8u) + 1u)];
                let _e3344 = other_idx;
                let _e3351 = state[((_e3344 * 8u) + 1u)];
                let _e3358 = state[((idx * 8u) + 1u)];
                let _e3367 = other_idx;
                let _e3374 = state[((_e3367 * 8u) + 1u)];
                let _e3381 = state[((idx * 8u) + 1u)];
                let _e3395 = other_center.x;
                let _e3397 = other_center.y;
                let _e3404 = other_idx;
                let _e3411 = state[((_e3404 * 8u) + 1u)];
                let _e3419 = state[((idx * 8u) + 1u)];
                let _e3426 = state[((idx * 8u) + 1u)];
                let _e3430 = other_idx;
                let _e3437 = state[((_e3430 * 8u) + 1u)];
                let _e3441 = other_idx;
                let _e3448 = state[((_e3441 * 8u) + 1u)];
                let _e3455 = state[((idx * 8u) + 1u)];
                let _e3464 = other_idx;
                let _e3471 = state[((_e3464 * 8u) + 1u)];
                let _e3478 = state[((idx * 8u) + 1u)];
                let _e3489 = other_center.x;
                let _e3491 = other_center.y;
                let _e3507 = state[((idx * 8u) + 1u)];
                let _e3509 = phi_1_;
                let _e3515 = constants.scheme;
                let _e3519 = other_idx;
                let _e3526 = state[((_e3519 * 8u) + 1u)];
                let _e3527 = other_idx;
                let _e3534 = state[((_e3527 * 8u) + 1u)];
                let _e3541 = state[((idx * 8u) + 1u)];
                let _e3550 = other_idx;
                let _e3557 = state[((_e3550 * 8u) + 1u)];
                let _e3564 = state[((idx * 8u) + 1u)];
                let _e3578 = other_center.x;
                let _e3580 = other_center.y;
                let _e3590 = state[((idx * 8u) + 1u)];
                let _e3591 = other_idx;
                let _e3598 = state[((_e3591 * 8u) + 1u)];
                let _e3609 = state[((idx * 8u) + 1u)];
                let _e3610 = other_idx;
                let _e3617 = state[((_e3610 * 8u) + 1u)];
                let _e3629 = state[((idx * 8u) + 1u)];
                let _e3630 = other_idx;
                let _e3637 = state[((_e3630 * 8u) + 1u)];
                let _e3644 = state[((idx * 8u) + 1u)];
                let _e3653 = other_idx;
                let _e3660 = state[((_e3653 * 8u) + 1u)];
                let _e3667 = state[((idx * 8u) + 1u)];
                let _e3685 = other_idx;
                let _e3692 = state[((_e3685 * 8u) + 1u)];
                let _e3699 = state[((idx * 8u) + 1u)];
                let _e3704 = other_idx;
                let _e3711 = state[((_e3704 * 8u) + 1u)];
                let _e3718 = state[((idx * 8u) + 1u)];
                let _e3724 = phi_1_;
                let _e3730 = constants.scheme;
                let _e3734 = other_idx;
                let _e3741 = state[((_e3734 * 8u) + 1u)];
                let _e3742 = other_idx;
                let _e3749 = state[((_e3742 * 8u) + 1u)];
                let _e3756 = state[((idx * 8u) + 1u)];
                let _e3765 = other_idx;
                let _e3772 = state[((_e3765 * 8u) + 1u)];
                let _e3779 = state[((idx * 8u) + 1u)];
                let _e3793 = other_center.x;
                let _e3795 = other_center.y;
                let _e3805 = state[((idx * 8u) + 1u)];
                let _e3806 = other_idx;
                let _e3813 = state[((_e3806 * 8u) + 1u)];
                let _e3823 = state[((idx * 8u) + 1u)];
                let _e3824 = other_idx;
                let _e3831 = state[((_e3824 * 8u) + 1u)];
                let _e3834 = other_idx;
                let _e3841 = state[((_e3834 * 8u) + 1u)];
                let _e3848 = state[((idx * 8u) + 1u)];
                let _e3857 = other_idx;
                let _e3864 = state[((_e3857 * 8u) + 1u)];
                let _e3871 = state[((idx * 8u) + 1u)];
                let _e3885 = other_center.x;
                let _e3887 = other_center.y;
                let _e3902 = state[((idx * 8u) + 1u)];
                let _e3903 = other_idx;
                let _e3910 = state[((_e3903 * 8u) + 1u)];
                let _e3912 = other_idx;
                let _e3919 = state[((_e3912 * 8u) + 1u)];
                let _e3926 = state[((idx * 8u) + 1u)];
                let _e3935 = other_idx;
                let _e3942 = state[((_e3935 * 8u) + 1u)];
                let _e3949 = state[((idx * 8u) + 1u)];
                let _e3963 = other_center.x;
                let _e3965 = other_center.y;
                let _e3979 = state[((idx * 8u) + 1u)];
                let _e3980 = other_idx;
                let _e3987 = state[((_e3980 * 8u) + 1u)];
                let _e3989 = other_idx;
                let _e3996 = state[((_e3989 * 8u) + 1u)];
                let _e4003 = state[((idx * 8u) + 1u)];
                let _e4012 = other_idx;
                let _e4019 = state[((_e4012 * 8u) + 1u)];
                let _e4026 = state[((idx * 8u) + 1u)];
                let _e4040 = other_center.x;
                let _e4042 = other_center.y;
                let _e4058 = state[((idx * 8u) + 1u)];
                let _e4059 = other_idx;
                let _e4066 = state[((_e4059 * 8u) + 1u)];
                let _e4073 = state[((idx * 8u) + 1u)];
                let _e4082 = other_idx;
                let _e4089 = state[((_e4082 * 8u) + 1u)];
                let _e4096 = state[((idx * 8u) + 1u)];
                let _e4114 = other_idx;
                let _e4121 = state[((_e4114 * 8u) + 1u)];
                let _e4128 = state[((idx * 8u) + 1u)];
                let _e4132 = other_idx;
                let _e4139 = state[((_e4132 * 8u) + 1u)];
                let _e4146 = state[((idx * 8u) + 1u)];
                let _e4149 = other_idx;
                let _e4156 = state[((_e4149 * 8u) + 1u)];
                let _e4163 = state[((idx * 8u) + 1u)];
                let _e4172 = other_idx;
                let _e4179 = state[((_e4172 * 8u) + 1u)];
                let _e4186 = state[((idx * 8u) + 1u)];
                let _e4209 = other_idx;
                let _e4216 = state[((_e4209 * 8u) + 1u)];
                let _e4223 = state[((idx * 8u) + 1u)];
                let _e4225 = other_idx;
                let _e4232 = state[((_e4225 * 8u) + 1u)];
                let _e4239 = state[((idx * 8u) + 1u)];
                let _e4248 = other_idx;
                let _e4255 = state[((_e4248 * 8u) + 1u)];
                let _e4262 = state[((idx * 8u) + 1u)];
                let _e4284 = other_idx;
                let _e4291 = state[((_e4284 * 8u) + 1u)];
                let _e4298 = state[((idx * 8u) + 1u)];
                let _e4300 = other_idx;
                let _e4307 = state[((_e4300 * 8u) + 1u)];
                let _e4314 = state[((idx * 8u) + 1u)];
                let _e4323 = other_idx;
                let _e4330 = state[((_e4323 * 8u) + 1u)];
                let _e4337 = state[((idx * 8u) + 1u)];
                let _e4361 = phi_1_;
                let _e4367 = constants.scheme;
                let _e4371 = other_idx;
                let _e4378 = state[((_e4371 * 8u) + 1u)];
                let _e4379 = other_idx;
                let _e4386 = state[((_e4379 * 8u) + 1u)];
                let _e4395 = state[((idx * 8u) + 1u)];
                let _e4399 = other_idx;
                let _e4406 = state[((_e4399 * 8u) + 1u)];
                let _e4413 = state[((idx * 8u) + 1u)];
                let _e4422 = other_idx;
                let _e4429 = state[((_e4422 * 8u) + 1u)];
                let _e4436 = state[((idx * 8u) + 1u)];
                let _e4450 = other_center.x;
                let _e4452 = other_center.y;
                let _e4459 = other_idx;
                let _e4466 = state[((_e4459 * 8u) + 1u)];
                let _e4474 = state[((idx * 8u) + 1u)];
                let _e4475 = other_idx;
                let _e4482 = state[((_e4475 * 8u) + 1u)];
                let _e4493 = state[((idx * 8u) + 1u)];
                let _e4494 = other_idx;
                let _e4501 = state[((_e4494 * 8u) + 1u)];
                let _e4513 = state[((idx * 8u) + 1u)];
                let _e4520 = state[((idx * 8u) + 1u)];
                let _e4523 = other_idx;
                let _e4530 = state[((_e4523 * 8u) + 1u)];
                let _e4534 = other_idx;
                let _e4541 = state[((_e4534 * 8u) + 1u)];
                let _e4548 = state[((idx * 8u) + 1u)];
                let _e4557 = other_idx;
                let _e4564 = state[((_e4557 * 8u) + 1u)];
                let _e4571 = state[((idx * 8u) + 1u)];
                let _e4582 = other_center.x;
                let _e4584 = other_center.y;
                let _e4600 = state[((idx * 8u) + 1u)];
                let _e4602 = other_idx;
                let _e4609 = state[((_e4602 * 8u) + 1u)];
                let _e4616 = state[((idx * 8u) + 1u)];
                let _e4621 = other_idx;
                let _e4628 = state[((_e4621 * 8u) + 1u)];
                let _e4635 = state[((idx * 8u) + 1u)];
                let _e4641 = phi_1_;
                let _e4647 = constants.scheme;
                let _e4651 = other_idx;
                let _e4658 = state[((_e4651 * 8u) + 1u)];
                let _e4659 = other_idx;
                let _e4666 = state[((_e4659 * 8u) + 1u)];
                let _e4675 = state[((idx * 8u) + 1u)];
                let _e4679 = other_idx;
                let _e4686 = state[((_e4679 * 8u) + 1u)];
                let _e4693 = state[((idx * 8u) + 1u)];
                let _e4702 = other_idx;
                let _e4709 = state[((_e4702 * 8u) + 1u)];
                let _e4716 = state[((idx * 8u) + 1u)];
                let _e4730 = other_center.x;
                let _e4732 = other_center.y;
                let _e4739 = other_idx;
                let _e4746 = state[((_e4739 * 8u) + 1u)];
                let _e4754 = state[((idx * 8u) + 1u)];
                let _e4755 = other_idx;
                let _e4762 = state[((_e4755 * 8u) + 1u)];
                let _e4772 = state[((idx * 8u) + 1u)];
                let _e4773 = other_idx;
                let _e4780 = state[((_e4773 * 8u) + 1u)];
                let _e4783 = other_idx;
                let _e4790 = state[((_e4783 * 8u) + 1u)];
                let _e4799 = state[((idx * 8u) + 1u)];
                let _e4803 = other_idx;
                let _e4810 = state[((_e4803 * 8u) + 1u)];
                let _e4817 = state[((idx * 8u) + 1u)];
                let _e4826 = other_idx;
                let _e4833 = state[((_e4826 * 8u) + 1u)];
                let _e4840 = state[((idx * 8u) + 1u)];
                let _e4854 = other_center.x;
                let _e4856 = other_center.y;
                let _e4863 = other_idx;
                let _e4870 = state[((_e4863 * 8u) + 1u)];
                let _e4883 = state[((idx * 8u) + 1u)];
                let _e4884 = other_idx;
                let _e4891 = state[((_e4884 * 8u) + 1u)];
                let _e4893 = other_idx;
                let _e4900 = state[((_e4893 * 8u) + 1u)];
                let _e4909 = state[((idx * 8u) + 1u)];
                let _e4913 = other_idx;
                let _e4920 = state[((_e4913 * 8u) + 1u)];
                let _e4927 = state[((idx * 8u) + 1u)];
                let _e4936 = other_idx;
                let _e4943 = state[((_e4936 * 8u) + 1u)];
                let _e4950 = state[((idx * 8u) + 1u)];
                let _e4964 = other_center.x;
                let _e4966 = other_center.y;
                let _e4973 = other_idx;
                let _e4980 = state[((_e4973 * 8u) + 1u)];
                let _e4992 = state[((idx * 8u) + 1u)];
                let _e4993 = other_idx;
                let _e5000 = state[((_e4993 * 8u) + 1u)];
                let _e5002 = other_idx;
                let _e5009 = state[((_e5002 * 8u) + 1u)];
                let _e5018 = state[((idx * 8u) + 1u)];
                let _e5022 = other_idx;
                let _e5029 = state[((_e5022 * 8u) + 1u)];
                let _e5036 = state[((idx * 8u) + 1u)];
                let _e5045 = other_idx;
                let _e5052 = state[((_e5045 * 8u) + 1u)];
                let _e5059 = state[((idx * 8u) + 1u)];
                let _e5073 = other_center.x;
                let _e5075 = other_center.y;
                let _e5082 = other_idx;
                let _e5089 = state[((_e5082 * 8u) + 1u)];
                let _e5103 = state[((idx * 8u) + 1u)];
                let _e5110 = state[((idx * 8u) + 1u)];
                let _e5113 = other_idx;
                let _e5120 = state[((_e5113 * 8u) + 1u)];
                let _e5124 = other_idx;
                let _e5131 = state[((_e5124 * 8u) + 1u)];
                let _e5138 = state[((idx * 8u) + 1u)];
                let _e5147 = other_idx;
                let _e5154 = state[((_e5147 * 8u) + 1u)];
                let _e5161 = state[((idx * 8u) + 1u)];
                let _e5172 = other_center.x;
                let _e5174 = other_center.y;
                let _e5190 = state[((idx * 8u) + 1u)];
                let _e5192 = other_idx;
                let _e5199 = state[((_e5192 * 8u) + 1u)];
                let _e5206 = state[((idx * 8u) + 1u)];
                let _e5210 = other_idx;
                let _e5217 = state[((_e5210 * 8u) + 1u)];
                let _e5224 = state[((idx * 8u) + 1u)];
                let _e5233 = state[((idx * 8u) + 1u)];
                let _e5236 = other_idx;
                let _e5243 = state[((_e5236 * 8u) + 1u)];
                let _e5247 = other_idx;
                let _e5254 = state[((_e5247 * 8u) + 1u)];
                let _e5261 = state[((idx * 8u) + 1u)];
                let _e5270 = other_idx;
                let _e5277 = state[((_e5270 * 8u) + 1u)];
                let _e5284 = state[((idx * 8u) + 1u)];
                let _e5295 = other_center.x;
                let _e5297 = other_center.y;
                let _e5313 = state[((idx * 8u) + 1u)];
                let _e5320 = other_idx;
                let _e5327 = state[((_e5320 * 8u) + 1u)];
                let _e5334 = state[((idx * 8u) + 1u)];
                let _e5342 = state[((idx * 8u) + 1u)];
                let _e5345 = other_idx;
                let _e5352 = state[((_e5345 * 8u) + 1u)];
                let _e5356 = other_idx;
                let _e5363 = state[((_e5356 * 8u) + 1u)];
                let _e5370 = state[((idx * 8u) + 1u)];
                let _e5379 = other_idx;
                let _e5386 = state[((_e5379 * 8u) + 1u)];
                let _e5393 = state[((idx * 8u) + 1u)];
                let _e5404 = other_center.x;
                let _e5406 = other_center.y;
                let _e5422 = state[((idx * 8u) + 1u)];
                let _e5428 = other_idx;
                let _e5435 = state[((_e5428 * 8u) + 1u)];
                let _e5442 = state[((idx * 8u) + 1u)];
                let _e5450 = state[((idx * 8u) + 1u)];
                let _e5453 = other_idx;
                let _e5460 = state[((_e5453 * 8u) + 1u)];
                let _e5464 = other_idx;
                let _e5471 = state[((_e5464 * 8u) + 1u)];
                let _e5478 = state[((idx * 8u) + 1u)];
                let _e5487 = other_idx;
                let _e5494 = state[((_e5487 * 8u) + 1u)];
                let _e5501 = state[((idx * 8u) + 1u)];
                let _e5512 = other_center.x;
                let _e5514 = other_center.y;
                let _e5530 = state[((idx * 8u) + 1u)];
                let _e5538 = phi_1_;
                let _e5544 = constants.scheme;
                let _e5554 = state[((idx * 8u) + 1u)];
                let _e5555 = other_idx;
                let _e5562 = state[((_e5555 * 8u) + 1u)];
                let _e5563 = phi_1_;
                let _e5569 = rhs_1_;
                rhs_1_ = (_e5569 - (_e3156 * (select(select(select(select(select(select(select(_e3163, _e3171, (_e3172 < 0f)), select((_e3183 + dot(vec2<f32>((((_e3191 - _e3198) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3214 - _e3221) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3235, _e3237)))), (_e3248 + dot(vec2<f32>((((_e3256 - _e3263) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3279 - _e3286) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3305 > 0f)), (_e3311 == 1u)), select(((((_e3322 + (_e3330 * 0.625f)) + (_e3340 * 0.375f)) + (dot(vec2<f32>((((_e3351 - _e3358) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3374 - _e3381) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3395, _e3397))) * 0.125f)) - _e3411), ((((_e3419 + (_e3426 * 0.625f)) + (_e3437 * 0.375f)) + (dot(vec2<f32>((((_e3448 - _e3455) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3471 - _e3478) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e3489, _e3491) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3507), (_e3509 > 0f)), (_e3515 == 2u)), select((_e3526 + min(max(dot(vec2<f32>((((_e3534 - _e3541) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3557 - _e3564) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3578, _e3580))), min((_e3590 - _e3598), 0f)), max((_e3609 - _e3617), 0f))), (_e3629 + min(max(dot(vec2<f32>((((_e3637 - _e3644) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3660 - _e3667) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e3692 - _e3699), 0f)), max((_e3711 - _e3718), 0f))), (_e3724 > 0f)), (_e3730 == 3u)), select((_e3741 + ((((dot(vec2<f32>((((_e3749 - _e3756) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3772 - _e3779) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3793, _e3795))) * abs((_e3805 - _e3813))) / max(abs((_e3823 - _e3831)), (abs(dot(vec2<f32>((((_e3841 - _e3848) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3864 - _e3871) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3885, _e3887)))) + 0.00000001f))) * max(((_e3902 - _e3910) * dot(vec2<f32>((((_e3919 - _e3926) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3942 - _e3949) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3963, _e3965)))), 0f)) / max(abs(((_e3979 - _e3987) * dot(vec2<f32>((((_e3996 - _e4003) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4019 - _e4026) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4040, _e4042))))), 0.00000001f))), (_e4058 + ((((dot(vec2<f32>((((_e4066 - _e4073) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4089 - _e4096) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e4121 - _e4128))) / max(abs((_e4139 - _e4146)), (abs(dot(vec2<f32>((((_e4156 - _e4163) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4179 - _e4186) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))) * max(((_e4216 - _e4223) * dot(vec2<f32>((((_e4232 - _e4239) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4255 - _e4262) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), 0f)) / max(abs(((_e4291 - _e4298) * dot(vec2<f32>((((_e4307 - _e4314) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4330 - _e4337) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))))), 0.00000001f))), (_e4361 > 0f)), (_e4367 == 4u)), select((_e4378 + min(max(((((_e4386 * 0.625f) + (_e4395 * 0.375f)) + (dot(vec2<f32>((((_e4406 - _e4413) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4429 - _e4436) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4450, _e4452))) * 0.125f)) - _e4466), min((_e4474 - _e4482), 0f)), max((_e4493 - _e4501), 0f))), (_e4513 + min(max(((((_e4520 * 0.625f) + (_e4530 * 0.375f)) + (dot(vec2<f32>((((_e4541 - _e4548) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4564 - _e4571) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e4582, _e4584) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e4600), min((_e4609 - _e4616), 0f)), max((_e4628 - _e4635), 0f))), (_e4641 > 0f)), (_e4647 == 5u)), select((_e4658 + ((((((((_e4666 * 0.625f) + (_e4675 * 0.375f)) + (dot(vec2<f32>((((_e4686 - _e4693) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4709 - _e4716) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4730, _e4732))) * 0.125f)) - _e4746) * abs((_e4754 - _e4762))) / max(abs((_e4772 - _e4780)), (abs(((((_e4790 * 0.625f) + (_e4799 * 0.375f)) + (dot(vec2<f32>((((_e4810 - _e4817) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4833 - _e4840) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4854, _e4856))) * 0.125f)) - _e4870)) + 0.00000001f))) * max(((_e4883 - _e4891) * ((((_e4900 * 0.625f) + (_e4909 * 0.375f)) + (dot(vec2<f32>((((_e4920 - _e4927) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4943 - _e4950) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4964, _e4966))) * 0.125f)) - _e4980)), 0f)) / max(abs(((_e4992 - _e5000) * ((((_e5009 * 0.625f) + (_e5018 * 0.375f)) + (dot(vec2<f32>((((_e5029 - _e5036) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5052 - _e5059) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5073, _e5075))) * 0.125f)) - _e5089))), 0.00000001f))), (_e5103 + ((((((((_e5110 * 0.625f) + (_e5120 * 0.375f)) + (dot(vec2<f32>((((_e5131 - _e5138) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5154 - _e5161) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5172, _e5174) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5190) * abs((_e5199 - _e5206))) / max(abs((_e5217 - _e5224)), (abs(((((_e5233 * 0.625f) + (_e5243 * 0.375f)) + (dot(vec2<f32>((((_e5254 - _e5261) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5277 - _e5284) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5295, _e5297) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5313)) + 0.00000001f))) * max(((_e5327 - _e5334) * ((((_e5342 * 0.625f) + (_e5352 * 0.375f)) + (dot(vec2<f32>((((_e5363 - _e5370) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5386 - _e5393) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5404, _e5406) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5422)), 0f)) / max(abs(((_e5435 - _e5442) * ((((_e5450 * 0.625f) + (_e5460 * 0.375f)) + (dot(vec2<f32>((((_e5471 - _e5478) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5494 - _e5501) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))), (vec2<f32>(_e5512, _e5514) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5530))), 0.00000001f))), (_e5538 > 0f)), (_e5544 == 6u)) - select(_e5554, _e5562, (_e5563 < 0f)))));
            } else {
                let _e5577 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e5577 == 1u) {
                    let _e5580 = phi_1_;
                    let _e5583 = diag_1_;
                    diag_1_ = (_e5583 + max(_e5580, 0f));
                    let _e5585 = phi_1_;
                    let _e5594 = bc_value[((face_idx * 3u) + 1u)];
                    let _e5596 = rhs_1_;
                    rhs_1_ = (_e5596 - (min(_e5585, 0f) * _e5594));
                } else {
                    let _e5598 = phi_1_;
                    let _e5599 = diag_1_;
                    diag_1_ = (_e5599 + _e5598);
                }
            }
            let _e5611 = normal.x;
            let _e5613 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)] = (_e5613 + ((0.5f * area) * _e5611));
            let _e5625 = normal.x;
            let _e5627 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)] = (_e5627 + ((0.5f * area) * _e5625));
            let _e5639 = normal.y;
            let _e5641 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)] = (_e5641 + ((0.5f * area) * _e5639));
            let _e5653 = normal.y;
            let _e5655 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)] = (_e5655 + ((0.5f * area) * _e5653));
            let _e5659 = constants.density;
            let _e5666 = state[((idx * 8u) + 3u)];
            let _e5669 = dist;
            let diff_coeff_p = (((_e5659 * _e5666) * area) / _e5669);
            let _e5671 = is_boundary;
            if !(_e5671) {
                let _e5674 = diag_2_;
                diag_2_ = (_e5674 + diff_coeff_p);
                let _e5683 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e5683 - diff_coeff_p);
            } else {
                let _e5691 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e5691 == 1u) {
                    let _e5694 = diag_2_;
                    diag_2_ = (_e5694 + diff_coeff_p);
                    let _e5703 = bc_value[((face_idx * 3u) + 2u)];
                    let _e5705 = rhs_2_;
                    rhs_2_ = (_e5705 + (diff_coeff_p * _e5703));
                } else {
                    let _e5713 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e5713 == 2u) {
                        let _e5718 = constants.density;
                        let _e5725 = state[((idx * 8u) + 3u)];
                        let _e5734 = bc_value[((face_idx * 3u) + 2u)];
                        let _e5737 = rhs_2_;
                        rhs_2_ = (_e5737 + -((((_e5718 * _e5725) * area) * _e5734)));
                    }
                }
            }
            let _e5745 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e5745;
            if (owner != idx) {
                let _e5748 = phi_2_;
                let _e5751 = phi_2_;
                phi_2_ = (_e5751 - (_e5748 * 2f));
            }
            let _e5753 = phi_2_;
            let _e5754 = rhs_2_;
            rhs_2_ = (_e5754 - _e5753);
        }
        continuing {
            let _e5757 = k;
            k = (_e5757 + 1u);
        }
    }
    let _e5766 = diag_0_;
    let _e5767 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e5767 + _e5766);
    let _e5775 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e5775;
    let _e5783 = diag_1_;
    let _e5784 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e5784 + _e5783);
    let _e5792 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e5792;
    let _e5800 = diag_2_;
    let _e5801 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e5801 + _e5800);
    let _e5809 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e5809;
    return;
}
"#;
    }
    pub mod generic_coupled_update_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_compressible :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 8u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 8u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e52 = constants.dtau;
    let _e64 = state[((idx * 8u) + 0u)];
    let _e71 = state[((idx * 8u) + 0u)];
    let _e79 = state[((idx * 8u) + 0u)];
    let _e91 = x[((idx * 8u) + 0u)];
    let _e98 = x[((idx * 8u) + 0u)];
    let _e106 = x[((idx * 8u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, select(1f, _e49, (_e52 > 0f))), ((_e64 == _e71) && (abs(_e79) < 340000000000000000000000000000000000000f))), ((_e91 == _e98) && (abs(_e106) < 340000000000000000000000000000000000000f)));
    let _e124 = state[((idx * 8u) + 0u)];
    let _e131 = x[((idx * 8u) + 0u)];
    let _e138 = state[((idx * 8u) + 0u)];
    let _e145 = x[((idx * 8u) + 0u)];
    let _e148 = constants.alpha_u;
    let _e151 = constants.dtau;
    let _e163 = state[((idx * 8u) + 0u)];
    let _e170 = state[((idx * 8u) + 0u)];
    let _e178 = state[((idx * 8u) + 0u)];
    let _e190 = x[((idx * 8u) + 0u)];
    let _e197 = x[((idx * 8u) + 0u)];
    let _e205 = x[((idx * 8u) + 0u)];
    x[((idx * 8u) + 0u)] = select(_e124, select(_e131, mix(_e138, _e145, select(1f, _e148, (_e151 > 0f))), ((_e163 == _e170) && (abs(_e178) < 340000000000000000000000000000000000000f))), ((_e190 == _e197) && (abs(_e205) < 340000000000000000000000000000000000000f)));
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 8u) + 1u)];
    let _e237 = state[((idx * 8u) + 1u)];
    let _e244 = x[((idx * 8u) + 1u)];
    let _e247 = constants.alpha_u;
    let _e250 = constants.dtau;
    let _e262 = state[((idx * 8u) + 1u)];
    let _e269 = state[((idx * 8u) + 1u)];
    let _e277 = state[((idx * 8u) + 1u)];
    let _e289 = x[((idx * 8u) + 1u)];
    let _e296 = x[((idx * 8u) + 1u)];
    let _e304 = x[((idx * 8u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e223, select(_e230, mix(_e237, _e244, select(1f, _e247, (_e250 > 0f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f))), ((_e289 == _e296) && (abs(_e304) < 340000000000000000000000000000000000000f)));
    let _e322 = state[((idx * 8u) + 1u)];
    let _e329 = x[((idx * 8u) + 1u)];
    let _e336 = state[((idx * 8u) + 1u)];
    let _e343 = x[((idx * 8u) + 1u)];
    let _e346 = constants.alpha_u;
    let _e349 = constants.dtau;
    let _e361 = state[((idx * 8u) + 1u)];
    let _e368 = state[((idx * 8u) + 1u)];
    let _e376 = state[((idx * 8u) + 1u)];
    let _e388 = x[((idx * 8u) + 1u)];
    let _e395 = x[((idx * 8u) + 1u)];
    let _e403 = x[((idx * 8u) + 1u)];
    x[((idx * 8u) + 1u)] = select(_e322, select(_e329, mix(_e336, _e343, select(1f, _e346, (_e349 > 0f))), ((_e361 == _e368) && (abs(_e376) < 340000000000000000000000000000000000000f))), ((_e388 == _e395) && (abs(_e403) < 340000000000000000000000000000000000000f)));
    let _e421 = state[((idx * 8u) + 2u)];
    let _e428 = x[((idx * 8u) + 2u)];
    let _e435 = state[((idx * 8u) + 2u)];
    let _e442 = x[((idx * 8u) + 2u)];
    let _e445 = constants.alpha_u;
    let _e448 = constants.dtau;
    let _e460 = state[((idx * 8u) + 2u)];
    let _e467 = state[((idx * 8u) + 2u)];
    let _e475 = state[((idx * 8u) + 2u)];
    let _e487 = x[((idx * 8u) + 2u)];
    let _e494 = x[((idx * 8u) + 2u)];
    let _e502 = x[((idx * 8u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e421, select(_e428, mix(_e435, _e442, select(1f, _e445, (_e448 > 0f))), ((_e460 == _e467) && (abs(_e475) < 340000000000000000000000000000000000000f))), ((_e487 == _e494) && (abs(_e502) < 340000000000000000000000000000000000000f)));
    let _e520 = state[((idx * 8u) + 2u)];
    let _e527 = x[((idx * 8u) + 2u)];
    let _e534 = state[((idx * 8u) + 2u)];
    let _e541 = x[((idx * 8u) + 2u)];
    let _e544 = constants.alpha_u;
    let _e547 = constants.dtau;
    let _e559 = state[((idx * 8u) + 2u)];
    let _e566 = state[((idx * 8u) + 2u)];
    let _e574 = state[((idx * 8u) + 2u)];
    let _e586 = x[((idx * 8u) + 2u)];
    let _e593 = x[((idx * 8u) + 2u)];
    let _e601 = x[((idx * 8u) + 2u)];
    x[((idx * 8u) + 2u)] = select(_e520, select(_e527, mix(_e534, _e541, select(1f, _e544, (_e547 > 0f))), ((_e559 == _e566) && (abs(_e574) < 340000000000000000000000000000000000000f))), ((_e586 == _e593) && (abs(_e601) < 340000000000000000000000000000000000000f)));
    let _e619 = state[((idx * 8u) + 3u)];
    let _e626 = x[((idx * 8u) + 3u)];
    let _e633 = state[((idx * 8u) + 3u)];
    let _e640 = x[((idx * 8u) + 3u)];
    let _e643 = constants.alpha_u;
    let _e646 = constants.dtau;
    let _e658 = state[((idx * 8u) + 3u)];
    let _e665 = state[((idx * 8u) + 3u)];
    let _e673 = state[((idx * 8u) + 3u)];
    let _e685 = x[((idx * 8u) + 3u)];
    let _e692 = x[((idx * 8u) + 3u)];
    let _e700 = x[((idx * 8u) + 3u)];
    state[((idx * 8u) + 3u)] = select(_e619, select(_e626, mix(_e633, _e640, select(1f, _e643, (_e646 > 0f))), ((_e658 == _e665) && (abs(_e673) < 340000000000000000000000000000000000000f))), ((_e685 == _e692) && (abs(_e700) < 340000000000000000000000000000000000000f)));
    let _e718 = state[((idx * 8u) + 3u)];
    let _e725 = x[((idx * 8u) + 3u)];
    let _e732 = state[((idx * 8u) + 3u)];
    let _e739 = x[((idx * 8u) + 3u)];
    let _e742 = constants.alpha_u;
    let _e745 = constants.dtau;
    let _e757 = state[((idx * 8u) + 3u)];
    let _e764 = state[((idx * 8u) + 3u)];
    let _e772 = state[((idx * 8u) + 3u)];
    let _e784 = x[((idx * 8u) + 3u)];
    let _e791 = x[((idx * 8u) + 3u)];
    let _e799 = x[((idx * 8u) + 3u)];
    x[((idx * 8u) + 3u)] = select(_e718, select(_e725, mix(_e732, _e739, select(1f, _e742, (_e745 > 0f))), ((_e757 == _e764) && (abs(_e772) < 340000000000000000000000000000000000000f))), ((_e784 == _e791) && (abs(_e799) < 340000000000000000000000000000000000000f)));
    let _e817 = state[((idx * 8u) + 6u)];
    let _e824 = x[((idx * 8u) + 4u)];
    let _e831 = state[((idx * 8u) + 6u)];
    let _e838 = x[((idx * 8u) + 4u)];
    let _e841 = constants.alpha_u;
    let _e844 = constants.dtau;
    let _e856 = state[((idx * 8u) + 6u)];
    let _e863 = state[((idx * 8u) + 6u)];
    let _e871 = state[((idx * 8u) + 6u)];
    let _e883 = x[((idx * 8u) + 4u)];
    let _e890 = x[((idx * 8u) + 4u)];
    let _e898 = x[((idx * 8u) + 4u)];
    state[((idx * 8u) + 6u)] = select(_e817, select(_e824, mix(_e831, _e838, select(1f, _e841, (_e844 > 0f))), ((_e856 == _e863) && (abs(_e871) < 340000000000000000000000000000000000000f))), ((_e883 == _e890) && (abs(_e898) < 340000000000000000000000000000000000000f)));
    let _e916 = state[((idx * 8u) + 6u)];
    let _e923 = x[((idx * 8u) + 4u)];
    let _e930 = state[((idx * 8u) + 6u)];
    let _e937 = x[((idx * 8u) + 4u)];
    let _e940 = constants.alpha_u;
    let _e943 = constants.dtau;
    let _e955 = state[((idx * 8u) + 6u)];
    let _e962 = state[((idx * 8u) + 6u)];
    let _e970 = state[((idx * 8u) + 6u)];
    let _e982 = x[((idx * 8u) + 4u)];
    let _e989 = x[((idx * 8u) + 4u)];
    let _e997 = x[((idx * 8u) + 4u)];
    x[((idx * 8u) + 4u)] = select(_e916, select(_e923, mix(_e930, _e937, select(1f, _e940, (_e943 > 0f))), ((_e955 == _e962) && (abs(_e970) < 340000000000000000000000000000000000000f))), ((_e982 == _e989) && (abs(_e997) < 340000000000000000000000000000000000000f)));
    let _e1015 = state[((idx * 8u) + 7u)];
    let _e1022 = x[((idx * 8u) + 5u)];
    let _e1029 = state[((idx * 8u) + 7u)];
    let _e1036 = x[((idx * 8u) + 5u)];
    let _e1039 = constants.alpha_u;
    let _e1042 = constants.dtau;
    let _e1054 = state[((idx * 8u) + 7u)];
    let _e1061 = state[((idx * 8u) + 7u)];
    let _e1069 = state[((idx * 8u) + 7u)];
    let _e1081 = x[((idx * 8u) + 5u)];
    let _e1088 = x[((idx * 8u) + 5u)];
    let _e1096 = x[((idx * 8u) + 5u)];
    state[((idx * 8u) + 7u)] = select(_e1015, select(_e1022, mix(_e1029, _e1036, select(1f, _e1039, (_e1042 > 0f))), ((_e1054 == _e1061) && (abs(_e1069) < 340000000000000000000000000000000000000f))), ((_e1081 == _e1088) && (abs(_e1096) < 340000000000000000000000000000000000000f)));
    let _e1114 = state[((idx * 8u) + 7u)];
    let _e1121 = x[((idx * 8u) + 5u)];
    let _e1128 = state[((idx * 8u) + 7u)];
    let _e1135 = x[((idx * 8u) + 5u)];
    let _e1138 = constants.alpha_u;
    let _e1141 = constants.dtau;
    let _e1153 = state[((idx * 8u) + 7u)];
    let _e1160 = state[((idx * 8u) + 7u)];
    let _e1168 = state[((idx * 8u) + 7u)];
    let _e1180 = x[((idx * 8u) + 5u)];
    let _e1187 = x[((idx * 8u) + 5u)];
    let _e1195 = x[((idx * 8u) + 5u)];
    x[((idx * 8u) + 5u)] = select(_e1114, select(_e1121, mix(_e1128, _e1135, select(1f, _e1138, (_e1141 > 0f))), ((_e1153 == _e1160) && (abs(_e1168) < 340000000000000000000000000000000000000f))), ((_e1180 == _e1187) && (abs(_e1195) < 340000000000000000000000000000000000000f)));
    let _e1213 = state[((idx * 8u) + 4u)];
    let _e1220 = x[((idx * 8u) + 6u)];
    let _e1227 = state[((idx * 8u) + 4u)];
    let _e1234 = x[((idx * 8u) + 6u)];
    let _e1237 = constants.alpha_p;
    let _e1240 = constants.dtau;
    let _e1252 = state[((idx * 8u) + 4u)];
    let _e1259 = state[((idx * 8u) + 4u)];
    let _e1267 = state[((idx * 8u) + 4u)];
    let _e1279 = x[((idx * 8u) + 6u)];
    let _e1286 = x[((idx * 8u) + 6u)];
    let _e1294 = x[((idx * 8u) + 6u)];
    state[((idx * 8u) + 4u)] = select(_e1213, select(_e1220, mix(_e1227, _e1234, select(1f, _e1237, (_e1240 > 0f))), ((_e1252 == _e1259) && (abs(_e1267) < 340000000000000000000000000000000000000f))), ((_e1279 == _e1286) && (abs(_e1294) < 340000000000000000000000000000000000000f)));
    let _e1312 = state[((idx * 8u) + 4u)];
    let _e1319 = x[((idx * 8u) + 6u)];
    let _e1326 = state[((idx * 8u) + 4u)];
    let _e1333 = x[((idx * 8u) + 6u)];
    let _e1336 = constants.alpha_p;
    let _e1339 = constants.dtau;
    let _e1351 = state[((idx * 8u) + 4u)];
    let _e1358 = state[((idx * 8u) + 4u)];
    let _e1366 = state[((idx * 8u) + 4u)];
    let _e1378 = x[((idx * 8u) + 6u)];
    let _e1385 = x[((idx * 8u) + 6u)];
    let _e1393 = x[((idx * 8u) + 6u)];
    x[((idx * 8u) + 6u)] = select(_e1312, select(_e1319, mix(_e1326, _e1333, select(1f, _e1336, (_e1339 > 0f))), ((_e1351 == _e1358) && (abs(_e1366) < 340000000000000000000000000000000000000f))), ((_e1378 == _e1385) && (abs(_e1393) < 340000000000000000000000000000000000000f)));
    let _e1411 = state[((idx * 8u) + 5u)];
    let _e1418 = x[((idx * 8u) + 7u)];
    let _e1425 = state[((idx * 8u) + 5u)];
    let _e1432 = x[((idx * 8u) + 7u)];
    let _e1435 = constants.alpha_u;
    let _e1438 = constants.dtau;
    let _e1450 = state[((idx * 8u) + 5u)];
    let _e1457 = state[((idx * 8u) + 5u)];
    let _e1465 = state[((idx * 8u) + 5u)];
    let _e1477 = x[((idx * 8u) + 7u)];
    let _e1484 = x[((idx * 8u) + 7u)];
    let _e1492 = x[((idx * 8u) + 7u)];
    state[((idx * 8u) + 5u)] = select(_e1411, select(_e1418, mix(_e1425, _e1432, select(1f, _e1435, (_e1438 > 0f))), ((_e1450 == _e1457) && (abs(_e1465) < 340000000000000000000000000000000000000f))), ((_e1477 == _e1484) && (abs(_e1492) < 340000000000000000000000000000000000000f)));
    let _e1510 = state[((idx * 8u) + 5u)];
    let _e1517 = x[((idx * 8u) + 7u)];
    let _e1524 = state[((idx * 8u) + 5u)];
    let _e1531 = x[((idx * 8u) + 7u)];
    let _e1534 = constants.alpha_u;
    let _e1537 = constants.dtau;
    let _e1549 = state[((idx * 8u) + 5u)];
    let _e1556 = state[((idx * 8u) + 5u)];
    let _e1564 = state[((idx * 8u) + 5u)];
    let _e1576 = x[((idx * 8u) + 7u)];
    let _e1583 = x[((idx * 8u) + 7u)];
    let _e1591 = x[((idx * 8u) + 7u)];
    x[((idx * 8u) + 7u)] = select(_e1510, select(_e1517, mix(_e1524, _e1531, select(1f, _e1534, (_e1537 > 0f))), ((_e1549 == _e1556) && (abs(_e1564) < 340000000000000000000000000000000000000f))), ((_e1576 == _e1583) && (abs(_e1591) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 1u) + 0u)];
    let _e32 = x[((idx * 1u) + 0u)];
    let _e39 = state[((idx * 1u) + 0u)];
    let _e46 = x[((idx * 1u) + 0u)];
    let _e55 = state[((idx * 1u) + 0u)];
    let _e62 = state[((idx * 1u) + 0u)];
    let _e70 = state[((idx * 1u) + 0u)];
    let _e82 = x[((idx * 1u) + 0u)];
    let _e89 = x[((idx * 1u) + 0u)];
    let _e97 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, 1f), ((_e55 == _e62) && (abs(_e70) < 340000000000000000000000000000000000000f))), ((_e82 == _e89) && (abs(_e97) < 340000000000000000000000000000000000000f)));
    let _e115 = state[((idx * 1u) + 0u)];
    let _e122 = x[((idx * 1u) + 0u)];
    let _e129 = state[((idx * 1u) + 0u)];
    let _e136 = x[((idx * 1u) + 0u)];
    let _e145 = state[((idx * 1u) + 0u)];
    let _e152 = state[((idx * 1u) + 0u)];
    let _e160 = state[((idx * 1u) + 0u)];
    let _e172 = x[((idx * 1u) + 0u)];
    let _e179 = x[((idx * 1u) + 0u)];
    let _e187 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e115, select(_e122, mix(_e129, _e136, 1f), ((_e145 == _e152) && (abs(_e160) < 340000000000000000000000000000000000000f))), ((_e172 == _e179) && (abs(_e187) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e25 = state[((idx * 8u) + 0u)];
    let _e32 = x[((idx * 3u) + 0u)];
    let _e39 = state[((idx * 8u) + 0u)];
    let _e46 = x[((idx * 3u) + 0u)];
    let _e49 = constants.alpha_u;
    let _e57 = state[((idx * 8u) + 0u)];
    let _e64 = state[((idx * 8u) + 0u)];
    let _e72 = state[((idx * 8u) + 0u)];
    let _e84 = x[((idx * 3u) + 0u)];
    let _e91 = x[((idx * 3u) + 0u)];
    let _e99 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e25, select(_e32, mix(_e39, _e46, _e49), ((_e57 == _e64) && (abs(_e72) < 340000000000000000000000000000000000000f))), ((_e84 == _e91) && (abs(_e99) < 340000000000000000000000000000000000000f)));
    let _e117 = state[((idx * 8u) + 0u)];
    let _e124 = x[((idx * 3u) + 0u)];
    let _e131 = state[((idx * 8u) + 0u)];
    let _e138 = x[((idx * 3u) + 0u)];
    let _e141 = constants.alpha_u;
    let _e149 = state[((idx * 8u) + 0u)];
    let _e156 = state[((idx * 8u) + 0u)];
    let _e164 = state[((idx * 8u) + 0u)];
    let _e176 = x[((idx * 3u) + 0u)];
    let _e183 = x[((idx * 3u) + 0u)];
    let _e191 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e117, select(_e124, mix(_e131, _e138, _e141), ((_e149 == _e156) && (abs(_e164) < 340000000000000000000000000000000000000f))), ((_e176 == _e183) && (abs(_e191) < 340000000000000000000000000000000000000f)));
    let _e209 = state[((idx * 8u) + 1u)];
    let _e216 = x[((idx * 3u) + 1u)];
    let _e223 = state[((idx * 8u) + 1u)];
    let _e230 = x[((idx * 3u) + 1u)];
    let _e233 = constants.alpha_u;
    let _e241 = state[((idx * 8u) + 1u)];
    let _e248 = state[((idx * 8u) + 1u)];
    let _e256 = state[((idx * 8u) + 1u)];
    let _e268 = x[((idx * 3u) + 1u)];
    let _e275 = x[((idx * 3u) + 1u)];
    let _e283 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e209, select(_e216, mix(_e223, _e230, _e233), ((_e241 == _e248) && (abs(_e256) < 340000000000000000000000000000000000000f))), ((_e268 == _e275) && (abs(_e283) < 340000000000000000000000000000000000000f)));
    let _e301 = state[((idx * 8u) + 1u)];
    let _e308 = x[((idx * 3u) + 1u)];
    let _e315 = state[((idx * 8u) + 1u)];
    let _e322 = x[((idx * 3u) + 1u)];
    let _e325 = constants.alpha_u;
    let _e333 = state[((idx * 8u) + 1u)];
    let _e340 = state[((idx * 8u) + 1u)];
    let _e348 = state[((idx * 8u) + 1u)];
    let _e360 = x[((idx * 3u) + 1u)];
    let _e367 = x[((idx * 3u) + 1u)];
    let _e375 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e301, select(_e308, mix(_e315, _e322, _e325), ((_e333 == _e340) && (abs(_e348) < 340000000000000000000000000000000000000f))), ((_e360 == _e367) && (abs(_e375) < 340000000000000000000000000000000000000f)));
    let _e393 = state[((idx * 8u) + 2u)];
    let _e400 = x[((idx * 3u) + 2u)];
    let _e407 = state[((idx * 8u) + 2u)];
    let _e414 = x[((idx * 3u) + 2u)];
    let _e417 = constants.alpha_p;
    let _e425 = state[((idx * 8u) + 2u)];
    let _e432 = state[((idx * 8u) + 2u)];
    let _e440 = state[((idx * 8u) + 2u)];
    let _e452 = x[((idx * 3u) + 2u)];
    let _e459 = x[((idx * 3u) + 2u)];
    let _e467 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e393, select(_e400, mix(_e407, _e414, _e417), ((_e425 == _e432) && (abs(_e440) < 340000000000000000000000000000000000000f))), ((_e452 == _e459) && (abs(_e467) < 340000000000000000000000000000000000000f)));
    let _e485 = state[((idx * 8u) + 2u)];
    let _e492 = x[((idx * 3u) + 2u)];
    let _e499 = state[((idx * 8u) + 2u)];
    let _e506 = x[((idx * 3u) + 2u)];
    let _e509 = constants.alpha_p;
    let _e517 = state[((idx * 8u) + 2u)];
    let _e524 = state[((idx * 8u) + 2u)];
    let _e532 = state[((idx * 8u) + 2u)];
    let _e544 = x[((idx * 3u) + 2u)];
    let _e551 = x[((idx * 3u) + 2u)];
    let _e559 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e485, select(_e492, mix(_e499, _e506, _e509), ((_e517 == _e524) && (abs(_e532) < 340000000000000000000000000000000000000f))), ((_e544 == _e551) && (abs(_e559) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod packed_state_gradients_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_3_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_4_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_5_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_6_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_7_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 8u) + 0u)];
            let _e139 = bc_kind[((face_idx * 8u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 8u) + 0u)];
            let _e165 = bc_kind[((face_idx * 8u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 8u) + 1u)];
            let _e215 = bc_kind[((face_idx * 8u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 8u) + 1u)];
            let _e241 = bc_kind[((face_idx * 8u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 8u) + 2u)];
            let _e291 = bc_kind[((face_idx * 8u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 8u) + 2u)];
            let _e317 = bc_kind[((face_idx * 8u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
            let _e329 = normal_vec;
            let _e336 = state[((idx * 8u) + 3u)];
            let _e337 = lambda;
            let _e339 = other_idx;
            let _e346 = state[((_e339 * 8u) + 3u)];
            let _e353 = state[((idx * 8u) + 3u)];
            let _e360 = bc_value[((face_idx * 8u) + 3u)];
            let _e367 = bc_kind[((face_idx * 8u) + 3u)];
            let _e377 = state[((idx * 8u) + 3u)];
            let _e384 = bc_value[((face_idx * 8u) + 3u)];
            let _e393 = bc_kind[((face_idx * 8u) + 3u)];
            let _e403 = grad_acc_3_;
            grad_acc_3_ = (_e403 + ((_e329 * ((_e336 * _e337) + (select(_e346, select(select(_e353, _e360, (_e367 == 1u)), (_e377 + (_e384 * d_own)), (_e393 == 2u)), is_boundary) * lambda_other))) * area));
            let _e405 = normal_vec;
            let _e412 = state[((idx * 8u) + 4u)];
            let _e413 = lambda;
            let _e415 = other_idx;
            let _e422 = state[((_e415 * 8u) + 4u)];
            let _e429 = state[((idx * 8u) + 4u)];
            let _e436 = bc_value[((face_idx * 8u) + 4u)];
            let _e443 = bc_kind[((face_idx * 8u) + 4u)];
            let _e453 = state[((idx * 8u) + 4u)];
            let _e460 = bc_value[((face_idx * 8u) + 4u)];
            let _e469 = bc_kind[((face_idx * 8u) + 4u)];
            let _e479 = grad_acc_4_;
            grad_acc_4_ = (_e479 + ((_e405 * ((_e412 * _e413) + (select(_e422, select(select(_e429, _e436, (_e443 == 1u)), (_e453 + (_e460 * d_own)), (_e469 == 2u)), is_boundary) * lambda_other))) * area));
            let _e481 = normal_vec;
            let _e488 = state[((idx * 8u) + 5u)];
            let _e489 = lambda;
            let _e491 = other_idx;
            let _e498 = state[((_e491 * 8u) + 5u)];
            let _e505 = state[((idx * 8u) + 5u)];
            let _e512 = bc_value[((face_idx * 8u) + 5u)];
            let _e519 = bc_kind[((face_idx * 8u) + 5u)];
            let _e529 = state[((idx * 8u) + 5u)];
            let _e536 = bc_value[((face_idx * 8u) + 5u)];
            let _e545 = bc_kind[((face_idx * 8u) + 5u)];
            let _e555 = grad_acc_5_;
            grad_acc_5_ = (_e555 + ((_e481 * ((_e488 * _e489) + (select(_e498, select(select(_e505, _e512, (_e519 == 1u)), (_e529 + (_e536 * d_own)), (_e545 == 2u)), is_boundary) * lambda_other))) * area));
            let _e557 = normal_vec;
            let _e564 = state[((idx * 8u) + 6u)];
            let _e565 = lambda;
            let _e567 = other_idx;
            let _e574 = state[((_e567 * 8u) + 6u)];
            let _e581 = state[((idx * 8u) + 6u)];
            let _e588 = bc_value[((face_idx * 8u) + 6u)];
            let _e595 = bc_kind[((face_idx * 8u) + 6u)];
            let _e605 = state[((idx * 8u) + 6u)];
            let _e612 = bc_value[((face_idx * 8u) + 6u)];
            let _e621 = bc_kind[((face_idx * 8u) + 6u)];
            let _e631 = grad_acc_6_;
            grad_acc_6_ = (_e631 + ((_e557 * ((_e564 * _e565) + (select(_e574, select(select(_e581, _e588, (_e595 == 1u)), (_e605 + (_e612 * d_own)), (_e621 == 2u)), is_boundary) * lambda_other))) * area));
            let _e633 = normal_vec;
            let _e640 = state[((idx * 8u) + 7u)];
            let _e641 = lambda;
            let _e643 = other_idx;
            let _e650 = state[((_e643 * 8u) + 7u)];
            let _e657 = state[((idx * 8u) + 7u)];
            let _e664 = bc_value[((face_idx * 8u) + 7u)];
            let _e671 = bc_kind[((face_idx * 8u) + 7u)];
            let _e681 = state[((idx * 8u) + 7u)];
            let _e688 = bc_value[((face_idx * 8u) + 7u)];
            let _e697 = bc_kind[((face_idx * 8u) + 7u)];
            let _e707 = grad_acc_7_;
            grad_acc_7_ = (_e707 + ((_e633 * ((_e640 * _e641) + (select(_e650, select(select(_e657, _e664, (_e671 == 1u)), (_e681 + (_e688 * d_own)), (_e697 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e710 = k;
            k = (_e710 + 1u);
        }
    }
    let _e712 = grad_acc_0_;
    let grad_out_0_ = ((_e712 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e735 = grad_acc_1_;
    let grad_out_1_ = ((_e735 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e758 = grad_acc_2_;
    let grad_out_2_ = ((_e758 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    let _e781 = grad_acc_3_;
    let grad_out_3_ = ((_e781 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 3u)].x = grad_out_3_.x;
    grad_state[((idx * 8u) + 3u)].y = grad_out_3_.y;
    let _e804 = grad_acc_4_;
    let grad_out_4_ = ((_e804 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 4u)].x = grad_out_4_.x;
    grad_state[((idx * 8u) + 4u)].y = grad_out_4_.y;
    let _e827 = grad_acc_5_;
    let grad_out_5_ = ((_e827 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 5u)].x = grad_out_5_.x;
    grad_state[((idx * 8u) + 5u)].y = grad_out_5_.y;
    let _e850 = grad_acc_6_;
    let grad_out_6_ = ((_e850 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 6u)].x = grad_out_6_.x;
    grad_state[((idx * 8u) + 6u)].y = grad_out_6_.y;
    let _e873 = grad_acc_7_;
    let grad_out_7_ = ((_e873 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 7u)].x = grad_out_7_.x;
    grad_state[((idx * 8u) + 7u)].y = grad_out_7_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedPackedStateGradientsGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 1u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 1u) + 0u)];
            let _e125 = state[((idx * 1u) + 0u)];
            let _e132 = bc_value[((face_idx * 1u) + 0u)];
            let _e139 = bc_kind[((face_idx * 1u) + 0u)];
            let _e149 = state[((idx * 1u) + 0u)];
            let _e156 = bc_value[((face_idx * 1u) + 0u)];
            let _e165 = bc_kind[((face_idx * 1u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e178 = k;
            k = (_e178 + 1u);
        }
    }
    let _e180 = grad_acc_0_;
    let grad_out_0_ = ((_e180 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 1u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 1u) + 0u)].y = grad_out_0_.y;
    return;
}
"#;
    }
    pub mod packed_state_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub grad_state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub grad_state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    grad_state: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.grad_state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.state, self.constants, self.grad_state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: packed_state_gradients_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(4): \"grad_state\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedPackedStateGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("packed_state_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(1) @binding(0) 
var<storage> state: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(4) 
var<storage, read_write> grad_state: array<Vector2_>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_0_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_1_: vec2<f32> = vec2<f32>(0f, 0f);
    var grad_acc_2_: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let _e6 = constants.stride_x;
    let idx = ((global_id.y * _e6) + global_id.x);
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let _e15 = constants.scheme;
    if (_e15 == 0u) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e36 = k;
        if (_e36 < end) {
        } else {
            break;
        }
        {
            let _e39 = k;
            let face_idx = cell_faces[_e39];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e62 = face_normals[face_idx].x;
            let _e66 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e62, _e66);
            let _e70 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e70) < 0f) {
                let _e74 = normal_vec;
                normal_vec = -(_e74);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e83 = other_idx;
                let other_center = cell_centers[_e83];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e90 = other_center_vec;
            let d_neigh = distance(_e90, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e98 = lambda;
            let lambda_other = (1f - _e98);
            let _e101 = normal_vec;
            let _e108 = state[((idx * 8u) + 0u)];
            let _e109 = lambda;
            let _e111 = other_idx;
            let _e118 = state[((_e111 * 8u) + 0u)];
            let _e125 = state[((idx * 8u) + 0u)];
            let _e132 = bc_value[((face_idx * 3u) + 0u)];
            let _e139 = bc_kind[((face_idx * 3u) + 0u)];
            let _e149 = state[((idx * 8u) + 0u)];
            let _e156 = bc_value[((face_idx * 3u) + 0u)];
            let _e165 = bc_kind[((face_idx * 3u) + 0u)];
            let _e175 = grad_acc_0_;
            grad_acc_0_ = (_e175 + ((_e101 * ((_e108 * _e109) + (select(_e118, select(select(_e125, _e132, (_e139 == 1u)), (_e149 + (_e156 * d_own)), (_e165 == 2u)), is_boundary) * lambda_other))) * area));
            let _e177 = normal_vec;
            let _e184 = state[((idx * 8u) + 1u)];
            let _e185 = lambda;
            let _e187 = other_idx;
            let _e194 = state[((_e187 * 8u) + 1u)];
            let _e201 = state[((idx * 8u) + 1u)];
            let _e208 = bc_value[((face_idx * 3u) + 1u)];
            let _e215 = bc_kind[((face_idx * 3u) + 1u)];
            let _e225 = state[((idx * 8u) + 1u)];
            let _e232 = bc_value[((face_idx * 3u) + 1u)];
            let _e241 = bc_kind[((face_idx * 3u) + 1u)];
            let _e251 = grad_acc_1_;
            grad_acc_1_ = (_e251 + ((_e177 * ((_e184 * _e185) + (select(_e194, select(select(_e201, _e208, (_e215 == 1u)), (_e225 + (_e232 * d_own)), (_e241 == 2u)), is_boundary) * lambda_other))) * area));
            let _e253 = normal_vec;
            let _e260 = state[((idx * 8u) + 2u)];
            let _e261 = lambda;
            let _e263 = other_idx;
            let _e270 = state[((_e263 * 8u) + 2u)];
            let _e277 = state[((idx * 8u) + 2u)];
            let _e284 = bc_value[((face_idx * 3u) + 2u)];
            let _e291 = bc_kind[((face_idx * 3u) + 2u)];
            let _e301 = state[((idx * 8u) + 2u)];
            let _e308 = bc_value[((face_idx * 3u) + 2u)];
            let _e317 = bc_kind[((face_idx * 3u) + 2u)];
            let _e327 = grad_acc_2_;
            grad_acc_2_ = (_e327 + ((_e253 * ((_e260 * _e261) + (select(_e270, select(select(_e277, _e284, (_e291 == 1u)), (_e301 + (_e308 * d_own)), (_e317 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e330 = k;
            k = (_e330 + 1u);
        }
    }
    let _e332 = grad_acc_0_;
    let grad_out_0_ = ((_e332 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 0u)].x = grad_out_0_.x;
    grad_state[((idx * 8u) + 0u)].y = grad_out_0_.y;
    let _e355 = grad_acc_1_;
    let grad_out_1_ = ((_e355 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 1u)].x = grad_out_1_.x;
    grad_state[((idx * 8u) + 1u)].y = grad_out_1_.y;
    let _e378 = grad_acc_2_;
    let grad_out_2_ = ((_e378 * 1f) / vec2(max(vol, 0.000000000001f)));
    grad_state[((idx * 8u) + 2u)].x = grad_out_2_.x;
    grad_state[((idx * 8u) + 2u)].y = grad_out_2_.y;
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const U_X_OFFSET: u32 = 0u32;
        pub const U_Y_OFFSET: u32 = 1u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const GRAD_P_X_OFFSET: u32 = 4u32;
        pub const GRAD_P_Y_OFFSET: u32 = 5u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: rhie_chow_correct_velocity_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const U_X_OFFSET: u32 = 0u;
const U_Y_OFFSET: u32 = 1u;
const D_P_OFFSET: u32 = 3u;
const GRAD_P_X_OFFSET: u32 = 4u;
const GRAD_P_Y_OFFSET: u32 = 5u;

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let _e4 = constants.stride_x;
    let idx = ((global_id.y * _e4) + global_id.x);
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * STATE_STRIDE);
    let d_p = state[(base + D_P_OFFSET)];
    let grad_px = state[(base + GRAD_P_X_OFFSET)];
    let grad_py = state[(base + GRAD_P_Y_OFFSET)];
    let _e38 = state[(base + U_X_OFFSET)];
    state[(base + U_X_OFFSET)] = (_e38 - (d_p * grad_px));
    let _e49 = state[(base + U_Y_OFFSET)];
    state[(base + U_Y_OFFSET)] = (_e49 - (d_p * grad_py));
    return;
}
"#;
    }
}
pub mod generic_coupled_schur_setup {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 16, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl SetupParams {
        pub const fn new(
            num_cells: u32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                num_cells,
                unknowns_per_cell,
                p,
                u_len,
                u0123,
                u4567,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_DIAG_AND_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_diag_and_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_diag_and_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_diag_and_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_DIAG_AND_PRESSURE: &str = "build_diag_and_pressure";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        pub diagonal_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        pub diagonal_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalar_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                },
                diagonal_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
                params: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
            [
                self.scalar_row_offsets,
                self.diagonal_indices,
                self.matrix_values,
                self.diag_u_inv,
                self.diag_p_inv,
                self.p_matrix_values,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalar_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diagonal_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(6): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::generic_coupled_schur_setup::SetupParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GenericCoupledSchurSetup::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("generic_coupled_schur_setup.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SetupParams {
    num_cells: u32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> p_matrix_values: array<f32>;
@group(0) @binding(6) 
var<uniform> params: SetupParams;

fn u_index(i_1: u32) -> u32 {
    if (i_1 < 4u) {
        let _e6 = params.u0123_[i_1];
        return _e6;
    }
    let _e12 = params.u4567_[(i_1 - 4u)];
    return _e12;
}

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_diag_and_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var i: u32 = 0u;
    var rank: u32 = 0u;

    let cell = ((global_id.y * (num_workgroups.x * 64u)) + global_id.x);
    let _e12 = params.num_cells;
    if (cell >= _e12) {
        return;
    }
    let scalar_offset = scalar_row_offsets[cell];
    let scalar_end = scalar_row_offsets[(cell + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e25 = diagonal_indices[cell];
    let diag_rank = (_e25 - scalar_offset);
    let _e29 = params.unknowns_per_cell;
    let _e32 = params.unknowns_per_cell;
    let block_stride = (_e29 * _e32);
    let start_row_0_ = (scalar_offset * block_stride);
    let _e37 = params.unknowns_per_cell;
    let row_stride = (num_neighbors * _e37);
    let _e41 = params.p;
    let start_row_p = (start_row_0_ + (_e41 * row_stride));
    let _e46 = params.unknowns_per_cell;
    let _e52 = params.p;
    let diag_p = matrix_values[((start_row_p + (diag_rank * _e46)) + _e52)];
    loop {
        let _e57 = i;
        let _e60 = params.u_len;
        if (_e57 < _e60) {
        } else {
            break;
        }
        {
            let _e62 = i;
            let _e63 = u_index(_e62);
            let start_row_u = (start_row_0_ + (_e63 * row_stride));
            let _e69 = params.unknowns_per_cell;
            let diag_u = matrix_values[((start_row_u + (diag_rank * _e69)) + _e63)];
            let _e75 = safe_inverse(diag_u);
            let _e79 = params.u_len;
            let _e81 = i;
            diag_u_inv[((cell * _e79) + _e81)] = _e75;
        }
        continuing {
            let _e85 = i;
            i = (_e85 + 1u);
        }
    }
    let _e89 = safe_inverse(diag_p);
    diag_p_inv[cell] = _e89;
    loop {
        let _e91 = rank;
        if (_e91 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e94 = rank;
            let _e97 = rank;
            let _e100 = params.unknowns_per_cell;
            let _e106 = params.p;
            let _e109 = matrix_values[((start_row_p + (_e97 * _e100)) + _e106)];
            p_matrix_values[(scalar_offset + _e94)] = _e109;
        }
        continuing {
            let _e111 = rank;
            rank = (_e111 + 1u);
        }
    }
    return;
}
"#;
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let j = params.num_iters;
    let n = params.n;
    let num_groups_n = ((n + 63u) / WORKGROUP_SIZE);
    let stride_x = (num_workgroups.x * WORKGROUP_SIZE);
    let idx = ((global_id.y * stride_x) + global_id.x);
    let group_flat = ((group_id.y * num_workgroups.x) + group_id.x);
    if (group_flat >= num_groups_n) {
        return;
    }
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e39 = b_w[idx];
        w_val = _e39;
    }
    loop {
        let _e42 = i;
        if (_e42 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e48 = i;
                if (_e48 <= j) {
                    let _e52 = i;
                    let _e56 = b_basis[((_e52 * stride_words) + idx)];
                    v.x = _e56;
                }
                let _e57 = i;
                if ((_e57 + 1u) <= j) {
                    let _e62 = i;
                    let _e69 = b_basis[(((_e62 + 1u) * stride_words) + idx)];
                    v.y = _e69;
                }
                let _e70 = i;
                if ((_e70 + 2u) <= j) {
                    let _e75 = i;
                    let _e82 = b_basis[(((_e75 + 2u) * stride_words) + idx)];
                    v.z = _e82;
                }
                let _e83 = i;
                if ((_e83 + 3u) <= j) {
                    let _e88 = i;
                    let _e95 = b_basis[(((_e88 + 3u) * stride_words) + idx)];
                    v.w = _e95;
                }
            }
            let _e96 = v;
            let _e97 = w_val;
            let prod = (_e96 * _e97);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e114 = sdata_vec4_[(local_id.x + 32u)];
                let _e115 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e115 + _e114);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e128 = sdata_vec4_[(local_id.x + 16u)];
                let _e129 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e129 + _e128);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e142 = sdata_vec4_[(local_id.x + 8u)];
                let _e143 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e143 + _e142);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e156 = sdata_vec4_[(local_id.x + 4u)];
                let _e157 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e157 + _e156);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e170 = sdata_vec4_[(local_id.x + 2u)];
                let _e171 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e171 + _e170);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e184 = sdata_vec4_[(local_id.x + 1u)];
                let _e185 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e185 + _e184);
                let sum_1 = sdata_vec4_[0];
                let _e190 = i;
                if (_e190 <= j) {
                    let _e193 = i;
                    b_dot_partial[((_e193 * num_groups_n) + group_flat)] = sum_1.x;
                }
                let _e198 = i;
                if ((_e198 + 1u) <= j) {
                    let _e202 = i;
                    b_dot_partial[(((_e202 + 1u) * num_groups_n) + group_flat)] = sum_1.y;
                }
                let _e210 = i;
                if ((_e210 + 2u) <= j) {
                    let _e214 = i;
                    b_dot_partial[(((_e214 + 2u) * num_groups_n) + group_flat)] = sum_1.z;
                }
                let _e222 = i;
                if ((_e222 + 3u) <= j) {
                    let _e226 = i;
                    b_dot_partial[(((_e226 + 3u) * num_groups_n) + group_flat)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e235 = i;
            i = (_e235 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e8 = params.n;
    let num_groups_n_1 = ((_e8 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e16 = k;
        if (_e16 < num_groups_n_1) {
        } else {
            break;
        }
        {
            let _e21 = k;
            let _e24 = b_dot_partial[((i_2 * num_groups_n_1) + _e21)];
            let _e25 = sum;
            sum = (_e25 + _e24);
        }
        continuing {
            let _e28 = k;
            k = (_e28 + 64u);
        }
    }
    let _e33 = sum;
    sdata[local_id_1.x] = _e33;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e45 = sdata[(local_id_1.x + 32u)];
        let _e46 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e46 + _e45);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e59 = sdata[(local_id_1.x + 16u)];
        let _e60 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e60 + _e59);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e73 = sdata[(local_id_1.x + 8u)];
        let _e74 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e74 + _e73);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e87 = sdata[(local_id_1.x + 4u)];
        let _e88 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e88 + _e87);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e101 = sdata[(local_id_1.x + 2u)];
        let _e102 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e102 + _e101);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e115 = sdata[(local_id_1.x + 1u)];
        let _e116 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e116 + _e115);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e129 = sdata[0];
        b_hessenberg[h_idx] = _e129;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let stride_x_1 = (num_workgroups_1.x * WORKGROUP_SIZE);
    let idx_1 = ((global_id_2.y * stride_x_1) + global_id_2.x);
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e30 = i_1;
        if (_e30 <= j_2) {
        } else {
            break;
        }
        {
            let _e32 = i_1;
            if (_e32 <= j_2) {
                let _e38 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e38)];
                let _e43 = i_1;
                let v_val = b_basis[((_e43 * stride_words_1) + idx_1)];
                let _e50 = correction;
                correction = (_e50 + (h_val * v_val));
            }
            let _e52 = i_1;
            if ((_e52 + 1u) <= j_2) {
                let _e59 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e59 + 1u))];
                let _e66 = i_1;
                let v_val_1 = b_basis[(((_e66 + 1u) * stride_words_1) + idx_1)];
                let _e75 = correction;
                correction = (_e75 + (h_val_1 * v_val_1));
            }
            let _e77 = i_1;
            if ((_e77 + 2u) <= j_2) {
                let _e84 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e84 + 2u))];
                let _e91 = i_1;
                let v_val_2 = b_basis[(((_e91 + 2u) * stride_words_1) + idx_1)];
                let _e100 = correction;
                correction = (_e100 + (h_val_2 * v_val_2));
            }
            let _e102 = i_1;
            if ((_e102 + 3u) <= j_2) {
                let _e109 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e109 + 3u))];
                let _e116 = i_1;
                let v_val_3 = b_basis[(((_e116 + 3u) * stride_words_1) + idx_1)];
                let _e125 = correction;
                correction = (_e125 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e128 = i_1;
            i_1 = (_e128 + 4u);
        }
    }
    let _e134 = b_w[idx_1];
    let _e135 = correction;
    b_w[idx_1] = (_e134 - _e135);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.iter_params, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let j_1 = iter_params.current_idx;
    loop {
        let _e7 = i;
        if (_e7 < j_1) {
        } else {
            break;
        }
        {
            let _e9 = i;
            let _e10 = h_idx(_e9, j_1);
            let _e11 = i;
            let _e14 = h_idx((_e11 + 1u), j_1);
            let h_ij = hessenberg[_e10];
            let h_i1j = hessenberg[_e14];
            let _e22 = i;
            let cs = givens[_e22];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e10] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e14] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e39 = i;
            i = (_e39 + 1u);
        }
    }
    let _e41 = h_idx(j_1, j_1);
    let _e44 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e41];
    let h_j1j = hessenberg[_e44];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e56 = rho;
    if (abs(_e56) > 0.00000000000000000001f) {
        let _e60 = rho;
        c = (h_jj / _e60);
        let _e63 = rho;
        s = (h_j1j / _e63);
    }
    let _e68 = c;
    let _e69 = s;
    givens[j_1] = vec2<f32>(_e68, _e69);
    let _e73 = rho;
    hessenberg[_e41] = _e73;
    hessenberg[_e44] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e87 = c;
    let _e89 = s;
    g_rhs[j_1] = ((_e87 * g_j) + (_e89 * g_j1_));
    let _e96 = s;
    let _e99 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e96) * g_j) + (_e99 * g_j1_));
    let _e108 = g_rhs[(j_1 + 1u)];
    scalars[0] = abs(_e108);
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let k = iter_params.current_idx;
    loop {
        let _e5 = loop_i;
        if (_e5 < k) {
        } else {
            break;
        }
        {
            let _e9 = loop_i;
            let i_1 = ((k - 1u) - _e9);
            let _e13 = g_rhs[i_1];
            sum = _e13;
            j = (i_1 + 1u);
            loop {
                let _e18 = j;
                if (_e18 < k) {
                } else {
                    break;
                }
                {
                    let _e20 = j;
                    let _e21 = h_idx(i_1, _e20);
                    let _e24 = hessenberg[_e21];
                    let _e26 = j;
                    let _e28 = y_sol[_e26];
                    let _e30 = sum;
                    sum = (_e30 - (_e24 * _e28));
                }
                continuing {
                    let _e33 = j;
                    j = (_e33 + 1u);
                }
            }
            let _e35 = h_idx(i_1, i_1);
            let diag = hessenberg[_e35];
            if (abs(diag) > 0.000000000001f) {
                let _e44 = sum;
                y_sol[i_1] = (_e44 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e50 = loop_i;
            loop_i = (_e50 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const EXTRACT_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_extract_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline extract_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("extract_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_DIAG_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_diag_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_diag_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_diag_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    pub const ENTRY_EXTRACT_DIAG_INV: &str = "extract_diag_inv";
    pub const ENTRY_APPLY_DIAG_INV: &str = "apply_diag_inv";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn global_index(global_id_14: vec3<u32>, num_workgroups_12: vec3<u32>) -> u32 {
    return ((global_id_14.y * (num_workgroups_12.x * WORKGROUP_SIZE)) + global_id_14.x);
}

fn workgroup_index(group_id_2: vec3<u32>, num_workgroups_13: vec3<u32>) -> u32 {
    return ((group_id_2.y * num_workgroups_13.x) + group_id_2.x);
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val_1 = matrix_values[_e24];
            let _e30 = vec_x[col];
            let _e32 = sum;
            sum = (_e32 + (val_1 * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    vec_y[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    let _e2 = global_index(global_id_1, num_workgroups_1);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha = scalars[0];
    let _e14 = vec_x[_e2];
    let _e18 = vec_y[_e2];
    vec_y[_e2] = ((alpha * _e14) + _e18);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    let _e2 = global_index(global_id_2, num_workgroups_2);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e10 = iter_params.current_idx;
    let alpha_1 = y_sol[_e10];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_y[_e2] = ((alpha_1 * _e17) + _e21);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>, @builtin(num_workgroups) num_workgroups_3: vec3<u32>) {
    let _e2 = global_index(global_id_3, num_workgroups_3);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e17 = vec_x[_e2];
    let _e21 = vec_y[_e2];
    vec_z[_e2] = ((alpha_2 * _e17) + (beta * _e21));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>, @builtin(num_workgroups) num_workgroups_4: vec3<u32>) {
    let _e2 = global_index(global_id_4, num_workgroups_4);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (alpha_3 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>, @builtin(num_workgroups) num_workgroups_5: vec3<u32>) {
    let _e2 = global_index(global_id_5, num_workgroups_5);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e14 = vec_y[_e2];
    vec_y[_e2] = (alpha_4 * _e14);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>, @builtin(num_workgroups) num_workgroups_6: vec3<u32>) {
    let _e2 = global_index(global_id_6, num_workgroups_6);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = vec_x[_e2];
    vec_y[_e2] = _e11;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_workgroups_7: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e4 = global_index(global_id_7, num_workgroups_7);
    let lid = local_id.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let _e13 = vec_x[_e4];
        let _e16 = vec_y[_e4];
        local_sum = (_e13 * _e16);
    }
    let _e21 = local_sum;
    partial_sums[lid] = _e21;
    workgroupBarrier();
    loop {
        let _e23 = stride;
        if (_e23 > 0u) {
        } else {
            break;
        }
        {
            let _e26 = stride;
            if (lid < _e26) {
                let _e31 = stride;
                let _e34 = partial_sums[(lid + _e31)];
                let _e35 = partial_sums[lid];
                partial_sums[lid] = (_e35 + _e34);
            }
            workgroupBarrier();
        }
        continuing {
            let _e38 = stride;
            stride = (_e38 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e43 = workgroup_index(group_id, num_workgroups_7);
        let _e46 = params.n;
        let num_groups_n = ((_e46 + 63u) / WORKGROUP_SIZE);
        if (_e43 < num_groups_n) {
            let _e56 = partial_sums[0];
            vec_z[_e43] = _e56;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_8: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e4 = global_index(global_id_8, num_workgroups_8);
    let lid_1 = local_id_1.x;
    let _e9 = params.n;
    if (_e4 < _e9) {
        let val_2 = vec_x[_e4];
        local_sum_1 = (val_2 * val_2);
    }
    let _e18 = local_sum_1;
    partial_sums[lid_1] = _e18;
    workgroupBarrier();
    loop {
        let _e20 = stride_1;
        if (_e20 > 0u) {
        } else {
            break;
        }
        {
            let _e23 = stride_1;
            if (lid_1 < _e23) {
                let _e28 = stride_1;
                let _e31 = partial_sums[(lid_1 + _e28)];
                let _e32 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e32 + _e31);
            }
            workgroupBarrier();
        }
        continuing {
            let _e35 = stride_1;
            stride_1 = (_e35 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e40 = workgroup_index(group_id_1, num_workgroups_8);
        let _e43 = params.n;
        let num_groups_n_1 = ((_e43 + 63u) / WORKGROUP_SIZE);
        if (_e40 < num_groups_n_1) {
            let _e53 = partial_sums[0];
            vec_z[_e40] = _e53;
            return;
        } else {
            return;
        }
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>, @builtin(num_workgroups) num_workgroups_9: vec3<u32>) {
    let _e2 = global_index(global_id_9, num_workgroups_9);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let h = scalars[0];
    let _e14 = vec_y[_e2];
    let _e17 = vec_x[_e2];
    vec_y[_e2] = (_e14 - (h * _e17));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let num_partials_1 = params.n;
    loop {
        let _e6 = i_1;
        if (_e6 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e10 = i_1;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum_1;
            total_sum_1 = (_e13 + _e12);
        }
        continuing {
            let _e16 = i_1;
            i_1 = (_e16 + 1u);
        }
    }
    let _e18 = total_sum_1;
    let norm = sqrt(_e18);
    let _e23 = iter_params.current_idx;
    hessenberg[_e23] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn extract_diag_inv(@builtin(global_invocation_id) global_id_12: vec3<u32>, @builtin(num_workgroups) num_workgroups_10: vec3<u32>) {
    var diag: f32 = 1f;
    var k_1: u32;

    let _e3 = global_index(global_id_12, num_workgroups_10);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start_1 = row_offsets[_e3];
    let end_1 = row_offsets[(_e3 + 1u)];
    k_1 = start_1;
    loop {
        let _e17 = k_1;
        if (_e17 < end_1) {
        } else {
            break;
        }
        {
            let _e20 = k_1;
            let _e22 = col_indices[_e20];
            if (_e22 == _e3) {
                let _e25 = k_1;
                let _e27 = matrix_values[_e25];
                diag = _e27;
                break;
            }
        }
        continuing {
            let _e29 = k_1;
            k_1 = (_e29 + 1u);
        }
    }
    let _e32 = diag;
    let _e33 = safe_inverse(_e32);
    diag_u[_e3] = _e33;
    diag_v[_e3] = _e33;
    diag_p[_e3] = _e33;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_diag_inv(@builtin(global_invocation_id) global_id_13: vec3<u32>, @builtin(num_workgroups) num_workgroups_11: vec3<u32>) {
    let _e2 = global_index(global_id_13, num_workgroups_11);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let _e11 = diag_u[_e2];
    let _e14 = vec_x[_e2];
    vec_y[_e2] = (_e11 * _e14);
    return;
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.x, self.r, self.p, self.v]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

fn global_index(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e3 = global_index(global_id, num_workgroups);
    let _e6 = params.n;
    if (_e3 >= _e6) {
        return;
    }
    let start = row_offsets[_e3];
    let end = row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = matrix_values[_e24];
            let _e30 = p[col];
            let _e32 = sum;
            sum = (_e32 + (val * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    v[_e3] = _e39;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var alpha: f32 = 0f;

    let _e3 = global_index(global_id_1, num_workgroups_1);
    let _e6 = scalars.r0_v;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_old;
        let _e15 = scalars.r0_v;
        alpha = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (_e3 >= _e25) {
        return;
    }
    let _e29 = alpha;
    let _e32 = p[_e3];
    let _e34 = x[_e3];
    x[_e3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha;
    let _e41 = v[_e3];
    let _e43 = r[_e3];
    r[_e3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var beta: f32 = 0f;

    let _e3 = global_index(global_id_2, num_workgroups_2);
    let _e6 = scalars.rho_old;
    if (abs(_e6) >= 0.00000000000000000001f) {
        let _e12 = scalars.rho_new;
        let _e15 = scalars.rho_old;
        beta = (_e12 / _e15);
    }
    if (_e3 == 0u) {
        let _e22 = beta;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (_e3 >= _e30) {
        return;
    }
    let _e36 = r[_e3];
    let _e37 = beta;
    let _e40 = p[_e3];
    p[_e3] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod outer_convergence {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub stride: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_targets: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl Params {
        pub const fn new(num_cells: u32, stride: u32, num_targets: u32, _pad0: u32) -> Self {
            Self {
                num_cells,
                stride,
                num_targets,
                _pad0,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct TargetDesc {
        #[doc = "offset: 0, size: 16, type: `array<u32, 4>`"]
        pub offsets: [u32; 4],
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub num_comps: u32,
        #[doc = "offset: 20, size: 12, type: `array<u32, 3>`"]
        pub _pad0: [u32; 3],
    }
    impl TargetDesc {
        pub const fn new(offsets: [u32; 4], num_comps: u32, _pad0: [u32; 3]) -> Self {
            Self {
                offsets,
                num_comps,
                _pad0,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input: wgpu::BufferBinding<'a>,
        pub targets: wgpu::BufferBinding<'a>,
        pub out_bits: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input: wgpu::BindGroupEntry<'a>,
        pub targets: wgpu::BindGroupEntry<'a>,
        pub out_bits: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input),
                },
                targets: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.targets),
                },
                out_bits: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.out_bits),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.input, self.targets, self.out_bits, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("OuterConvergence::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"targets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"out_bits\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::outer_convergence::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("OuterConvergence::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("OuterConvergence::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("outer_convergence.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    num_cells: u32,
    stride: u32,
    num_targets: u32,
    _pad0_: u32,
}

struct TargetDesc {
    offsets: array<u32, 4>,
    num_comps: u32,
    _pad0_: array<u32, 3>,
}

@group(0) @binding(0) 
var<storage> input: array<f32>;
@group(0) @binding(1) 
var<storage> targets: array<TargetDesc>;
@group(0) @binding(2) 
var<storage, read_write> out_bits: array<atomic<u32>>;
@group(0) @binding(3) 
var<uniform> params: Params;

@compute @workgroup_size(256, 1, 1) 
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
    var t: u32 = 0u;
    var mag2_: f32;
    var c: u32;

    let cell = gid.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let _e9 = params.stride;
    let base = (cell * _e9);
    loop {
        let _e12 = t;
        let _e15 = params.num_targets;
        if (_e12 < _e15) {
        } else {
            break;
        }
        {
            let _e18 = t;
            let desc = targets[_e18];
            mag2_ = 0f;
            c = 0u;
            loop {
                let _e25 = c;
                if (_e25 < desc.num_comps) {
                } else {
                    break;
                }
                {
                    let _e29 = c;
                    let off = desc.offsets[_e29];
                    let v = input[(base + off)];
                    let _e35 = mag2_;
                    mag2_ = (_e35 + (v * v));
                }
                continuing {
                    let _e38 = c;
                    c = (_e38 + 1u);
                }
            }
            let _e41 = mag2_;
            let mag = sqrt(_e41);
            let bits = bitcast<u32>(mag);
            let _e45 = t;
            let _e47 = atomicMax((&out_bits[_e45]), bits);
        }
        continuing {
            let _e48 = t;
            t = (_e48 + 1u);
        }
    }
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            r0_v: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                r0_v,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    r0_v: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_4;
            i_4 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_2] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_5;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_5;
            if (lid_2 < _e27) {
                let _e32 = i_5;
                let _e35 = scratch1_[(lid_2 + _e32)];
                let _e36 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_5;
            i_5 = (_e39 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u0: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            u0: u32,
            u1: u32,
            p: u32,
            _pad0: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                u0,
                u1,
                p,
                _pad0,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    u0_: u32,
    u1_: u32,
    p: u32,
    _pad0_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u = (base + _e14);
    let _e18 = params.u1_;
    let row_v = (base + _e18);
    let p_val = p_sol[_e3];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e32 = k_1;
        if (_e32 < end_u) {
        } else {
            break;
        }
        {
            let _e35 = k_1;
            let col = col_indices[_e35];
            let _e40 = params.unknowns_per_cell;
            let _e44 = params.p;
            if ((col % _e40) == _e44) {
                let _e48 = params.unknowns_per_cell;
                let p_cell = (col / _e48);
                let _e51 = k_1;
                let _e53 = matrix_values[_e51];
                let _e57 = p_sol[p_cell];
                let _e59 = correction_u;
                correction_u = (_e59 + (_e53 * _e57));
            }
        }
        continuing {
            let _e62 = k_1;
            k_1 = (_e62 + 1u);
        }
    }
    let _e68 = diag_u_inv[_e3];
    let _e69 = correction_u;
    let _e71 = z_out[row_u];
    z_out[row_u] = (_e71 - (_e68 * _e69));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e82 = k_2;
        if (_e82 < end_v) {
        } else {
            break;
        }
        {
            let _e85 = k_2;
            let col_1 = col_indices[_e85];
            let _e90 = params.unknowns_per_cell;
            let _e94 = params.p;
            if ((col_1 % _e90) == _e94) {
                let _e98 = params.unknowns_per_cell;
                let p_cell_1 = (col_1 / _e98);
                let _e101 = k_2;
                let _e103 = matrix_values[_e101];
                let _e107 = p_sol[p_cell_1];
                let _e109 = correction_v;
                correction_v = (_e109 + (_e103 * _e107));
            }
        }
        continuing {
            let _e112 = k_2;
            k_2 = (_e112 + 1u);
        }
    }
    let _e118 = diag_v_inv[_e3];
    let _e119 = correction_v;
    let _e121 = z_out[row_v];
    z_out[row_v] = (_e121 - (_e118 * _e119));
    let _e126 = params.p;
    z_out[(base + _e126)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.u0_;
    let row_u_1 = (base_1 + _e14);
    let _e18 = params.u1_;
    let row_v_1 = (base_1 + _e18);
    let _e22 = params.p;
    let row_p = (base_1 + _e22);
    loop {
        let _e25 = c;
        let _e28 = params.unknowns_per_cell;
        if (_e25 < _e28) {
        } else {
            break;
        }
        {
            let _e31 = c;
            let _e35 = c;
            let _e38 = r_in[(base_1 + _e35)];
            z_out[(base_1 + _e31)] = _e38;
        }
        continuing {
            let _e40 = c;
            c = (_e40 + 1u);
        }
    }
    let r_u = r_in[row_u_1];
    let r_v = r_in[row_v_1];
    let _e52 = diag_u_inv[_e3];
    z_out[row_u_1] = (_e52 * r_u);
    let _e58 = diag_v_inv[_e3];
    z_out[row_v_1] = (_e58 * r_v);
    z_out[row_p] = 0f;
    let _e65 = r_in[row_p];
    rhs_p = _e65;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e76 = k_3;
        if (_e76 < end_1) {
        } else {
            break;
        }
        {
            let _e79 = k_3;
            let col_2 = col_indices[_e79];
            let _e84 = params.unknowns_per_cell;
            let rem = (col_2 % _e84);
            z_val = 0f;
            let _e90 = params.u0_;
            if (rem == _e90) {
                let _e94 = params.unknowns_per_cell;
                let c_1 = (col_2 / _e94);
                let _e98 = r_in[col_2];
                let _e101 = diag_u_inv[c_1];
                z_val = (_e98 * _e101);
            } else {
                let _e105 = params.u1_;
                if (rem == _e105) {
                    let _e109 = params.unknowns_per_cell;
                    let c_2 = (col_2 / _e109);
                    let _e113 = r_in[col_2];
                    let _e116 = diag_v_inv[c_2];
                    z_val = (_e113 * _e116);
                }
            }
            let _e119 = k_3;
            let _e121 = matrix_values[_e119];
            let _e122 = z_val;
            let _e124 = rhs_p;
            rhs_p = (_e124 - (_e121 * _e122));
        }
        continuing {
            let _e127 = k_3;
            k_3 = (_e127 + 1u);
        }
    }
    let _e131 = rhs_p;
    temp_p[_e3] = _e131;
    let _e136 = diag_p_inv[_e3];
    let _e137 = rhs_p;
    p_sol[_e3] = (_e136 * _e137);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
pub mod schur_precond_generic {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            _pad0: u32,
            _pad1: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                p,
                u_len,
                _pad0,
                _pad1,
                u0123,
                u4567,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u_inv, self.diag_p_inv, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond_generic::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecondGeneric::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond_generic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    _pad0_: u32,
    _pad1_: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(2) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn u_index(i_3: u32) -> u32 {
    if (i_3 < 4u) {
        let _e6 = params.u0123_[i_3];
        return _e6;
    }
    let _e12 = params.u4567_[(i_3 - 4u)];
    return _e12;
}

fn global_cell(global_id_3: vec3<u32>, num_workgroups_3: vec3<u32>) -> u32 {
    return ((global_id_3.y * (num_workgroups_3.x * WORKGROUP_SIZE)) + global_id_3.x);
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(num_workgroups) num_workgroups: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let _e3 = global_cell(global_id, num_workgroups);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let start = p_row_offsets[_e3];
    let end = p_row_offsets[(_e3 + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col_cell = p_col_indices[_e20];
            if (col_cell != _e3) {
                let _e25 = k;
                let _e27 = p_matrix_values[_e25];
                let _e31 = p_sol[col_cell];
                let _e33 = sigma;
                sigma = (_e33 + (_e27 * _e31));
            }
        }
        continuing {
            let _e36 = k;
            k = (_e36 + 1u);
        }
    }
    let d_inv = diag_p_inv[_e3];
    let rhs = temp_p[_e3];
    let _e44 = sigma;
    let hat_x = (d_inv * (rhs - _e44));
    let x_prev = p_prev[_e3];
    let _e52 = params.omega;
    let x_new = mix(x_prev, hat_x, _e52);
    p_prev[_e3] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(num_workgroups) num_workgroups_1: vec3<u32>) {
    var i: u32 = 0u;
    var correction_u: f32;
    var k_1: u32;

    let _e3 = global_cell(global_id_1, num_workgroups_1);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base = (_e3 * _e10);
    let p_val = p_sol[_e3];
    loop {
        let _e16 = i;
        let _e19 = params.u_len;
        if (_e16 < _e19) {
        } else {
            break;
        }
        {
            let _e21 = i;
            let _e22 = u_index(_e21);
            let row_u = (base + _e22);
            let start_u = row_offsets[row_u];
            let end_u = row_offsets[(row_u + 1u)];
            correction_u = 0f;
            k_1 = start_u;
            loop {
                let _e35 = k_1;
                if (_e35 < end_u) {
                } else {
                    break;
                }
                {
                    let _e38 = k_1;
                    let col = col_indices[_e38];
                    let _e43 = params.unknowns_per_cell;
                    let _e47 = params.p;
                    if ((col % _e43) == _e47) {
                        let _e51 = params.unknowns_per_cell;
                        let p_cell = (col / _e51);
                        let _e54 = k_1;
                        let _e56 = matrix_values[_e54];
                        let _e59 = p_sol[p_cell];
                        let _e61 = correction_u;
                        correction_u = (_e61 + (_e56 * _e59));
                    }
                }
                continuing {
                    let _e64 = k_1;
                    k_1 = (_e64 + 1u);
                }
            }
            let _e71 = params.u_len;
            let _e73 = i;
            let _e76 = diag_u_inv[((_e3 * _e71) + _e73)];
            let _e77 = correction_u;
            let _e79 = z_out[row_u];
            z_out[row_u] = (_e79 - (_e76 * _e77));
        }
        continuing {
            let _e82 = i;
            i = (_e82 + 1u);
        }
    }
    let _e87 = params.p;
    z_out[(base + _e87)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>, @builtin(num_workgroups) num_workgroups_2: vec3<u32>) {
    var c: u32 = 0u;
    var i_1: u32 = 0u;
    var rhs_p: f32;
    var k_2: u32;
    var z_val: f32;
    var i_2: u32;

    let _e3 = global_cell(global_id_2, num_workgroups_2);
    let _e6 = params.num_cells;
    if (_e3 >= _e6) {
        return;
    }
    let _e10 = params.unknowns_per_cell;
    let base_1 = (_e3 * _e10);
    let _e14 = params.p;
    let row_p = (base_1 + _e14);
    loop {
        let _e17 = c;
        let _e20 = params.unknowns_per_cell;
        if (_e17 < _e20) {
        } else {
            break;
        }
        {
            let _e23 = c;
            let _e27 = c;
            let _e30 = r_in[(base_1 + _e27)];
            z_out[(base_1 + _e23)] = _e30;
        }
        continuing {
            let _e32 = c;
            c = (_e32 + 1u);
        }
    }
    loop {
        let _e35 = i_1;
        let _e38 = params.u_len;
        if (_e35 < _e38) {
        } else {
            break;
        }
        {
            let _e40 = i_1;
            let _e41 = u_index(_e40);
            let row_u_1 = (base_1 + _e41);
            let _e48 = params.u_len;
            let _e50 = i_1;
            let _e53 = diag_u_inv[((_e3 * _e48) + _e50)];
            let _e56 = r_in[row_u_1];
            z_out[row_u_1] = (_e53 * _e56);
        }
        continuing {
            let _e59 = i_1;
            i_1 = (_e59 + 1u);
        }
    }
    z_out[row_p] = 0f;
    let _e66 = r_in[row_p];
    rhs_p = _e66;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_2 = start_1;
    loop {
        let _e77 = k_2;
        if (_e77 < end_1) {
        } else {
            break;
        }
        {
            let _e80 = k_2;
            let col_1 = col_indices[_e80];
            let _e85 = params.unknowns_per_cell;
            let rem = (col_1 % _e85);
            z_val = 0f;
            i_2 = 0u;
            loop {
                let _e91 = i_2;
                let _e94 = params.u_len;
                if (_e91 < _e94) {
                } else {
                    break;
                }
                {
                    let _e96 = i_2;
                    let _e97 = u_index(_e96);
                    if (rem == _e97) {
                        let _e101 = params.unknowns_per_cell;
                        let c_1 = (col_1 / _e101);
                        let _e105 = r_in[col_1];
                        let _e109 = params.u_len;
                        let _e111 = i_2;
                        let _e114 = diag_u_inv[((c_1 * _e109) + _e111)];
                        z_val = (_e105 * _e114);
                        break;
                    }
                }
                continuing {
                    let _e117 = i_2;
                    i_2 = (_e117 + 1u);
                }
            }
            let _e120 = k_2;
            let _e122 = matrix_values[_e120];
            let _e123 = z_val;
            let _e125 = rhs_p;
            rhs_p = (_e125 - (_e122 * _e123));
        }
        continuing {
            let _e128 = k_2;
            k_2 = (_e128 + 1u);
        }
    }
    let _e132 = rhs_p;
    temp_p[_e3] = _e132;
    let _e137 = diag_p_inv[_e3];
    let _e138 = rhs_p;
    p_sol[_e3] = (_e137 * _e138);
    p_prev[_e3] = 0f;
    return;
}
"#;
}
