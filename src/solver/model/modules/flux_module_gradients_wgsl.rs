use crate::solver::ir::FluxLayout;
use crate::solver::model::modules::flux_module::ResolvedGradientTarget;
use cfd2_codegen::solver::codegen::dsl as typed;
use cfd2_codegen::solver::codegen::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use cfd2_codegen::solver::codegen::wgsl_dsl as dsl;
use cfd2_codegen::solver::codegen::KernelWgsl;

/// Generate flux module gradients WGSL kernel from pre-resolved gradient targets.
///
/// This function no longer scans StateLayout; all offsets and metadata must be
/// pre-resolved into `targets` via `resolve_flux_module_gradients_targets()`.
pub fn generate_flux_module_gradients_wgsl(
    stride: u32,
    flux_layout: &FluxLayout,
    targets: &[ResolvedGradientTarget],
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module_gradients)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(stride, flux_layout, targets)));
    KernelWgsl::from(module)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::ir::{vol_scalar, vol_vector, FluxComponent, StateLayout};
    use crate::solver::model::modules::flux_module::resolve_flux_module_gradients_targets;
    use crate::solver::units::si;

    #[test]
    fn flux_module_gradients_wgsl_matches_committed_incompressible_momentum() {
        use crate::solver::model::kernel::{generate_kernel_wgsl_for_model_by_id, KernelId};
        use crate::solver::model::incompressible_momentum_model;
        use crate::solver::ir::SchemeRegistry;

        let model = incompressible_momentum_model();
        let schemes = SchemeRegistry::default();
        let generated = generate_kernel_wgsl_for_model_by_id(
            &model,
            &schemes,
            KernelId::FLUX_MODULE_GRADIENTS,
        )
        .expect("should generate flux_module_gradients WGSL");

        let committed = include_str!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/src/solver/gpu/shaders/generated/flux_module_gradients_incompressible_momentum.wgsl"
        ));

        assert_eq!(
            generated.trim_end(),
            committed.trim_end(),
            "generated flux_module_gradients WGSL for incompressible_momentum does not match committed file"
        );
    }

    #[test]
    fn flux_module_gradients_wgsl_matches_committed_compressible() {
        use crate::solver::model::kernel::{generate_kernel_wgsl_for_model_by_id, KernelId};
        use crate::solver::model::compressible_model;
        use crate::solver::ir::SchemeRegistry;

        let model = compressible_model();
        let schemes = SchemeRegistry::default();
        let generated = generate_kernel_wgsl_for_model_by_id(
            &model,
            &schemes,
            KernelId::FLUX_MODULE_GRADIENTS,
        )
        .expect("should generate flux_module_gradients WGSL");

        let committed = include_str!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/src/solver/gpu/shaders/generated/flux_module_gradients_compressible.wgsl"
        ));

        assert_eq!(
            generated.trim_end(),
            committed.trim_end(),
            "generated flux_module_gradients WGSL for compressible does not match committed file"
        );
    }

    #[test]
    fn flux_module_gradients_accepts_vector_component_gradients() {
        let rho_u = vol_vector("rho_u", si::MOMENTUM_DENSITY);
        let grad_rho_u_x = vol_vector("grad_rho_u_x", si::MOMENTUM_DENSITY / si::LENGTH);
        let grad_rho_u_y = vol_vector("grad_rho_u_y", si::MOMENTUM_DENSITY / si::LENGTH);
        let rho = vol_scalar("rho", si::DENSITY);
        let grad_rho = vol_vector("grad_rho", si::DENSITY / si::LENGTH);

        let layout = StateLayout::new(vec![rho_u, grad_rho_u_x, grad_rho_u_y, rho, grad_rho]);

        let flux_layout = FluxLayout {
            stride: 3,
            components: vec![
                FluxComponent {
                    name: "rho".to_string(),
                    offset: 0,
                },
                FluxComponent {
                    name: "rho_u_x".to_string(),
                    offset: 1,
                },
                FluxComponent {
                    name: "rho_u_y".to_string(),
                    offset: 2,
                },
            ],
        };

        // Use resolver -> generator pattern
        let targets = resolve_flux_module_gradients_targets(&layout, &flux_layout)
            .expect("should resolve gradient targets");
        let wgsl =
            generate_flux_module_gradients_wgsl(layout.stride(), &flux_layout, &targets).to_wgsl();
        assert!(wgsl.contains("grad_acc_rho"));
        assert!(wgsl.contains("grad_acc_rho_u_x"));
        assert!(wgsl.contains("grad_acc_rho_u_y"));
    }

    #[test]
    fn missing_grad_field_component_returns_clear_error() {
        // Regression test: when a grad_<field> exists and base field exists,
        // but the base field component is missing (e.g., trying to access component 5 of a vec2),
        // the resolver should return a clear error containing the field name.
        let rho = vol_scalar("rho", si::DENSITY);
        let grad_rho = vol_vector("grad_rho", si::DENSITY / si::LENGTH);

        let layout = StateLayout::new(vec![rho, grad_rho]);

        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "rho".to_string(),
                offset: 0,
            }],
        };

        // This should succeed since rho is a scalar (component 0)
        let result = resolve_flux_module_gradients_targets(&layout, &flux_layout);
        assert!(
            result.is_ok(),
            "should succeed for scalar field: {:?}",
            result.err()
        );

        // Now test with a vector component selector that exceeds the field's component count
        let rho_u = vol_vector("rho_u", si::MOMENTUM_DENSITY);
        let grad_rho_u_z = vol_vector("grad_rho_u_z", si::MOMENTUM_DENSITY / si::LENGTH);
        // Note: rho_u only has x,y components (0,1), but we're requesting z (component 2)

        let layout2 = StateLayout::new(vec![rho_u, grad_rho_u_z]);
        let flux_layout2 = FluxLayout {
            stride: 2,
            components: vec![
                FluxComponent {
                    name: "rho_u_x".to_string(),
                    offset: 0,
                },
                FluxComponent {
                    name: "rho_u_y".to_string(),
                    offset: 1,
                },
            ],
        };

        let result2 = resolve_flux_module_gradients_targets(&layout2, &flux_layout2);
        let err = result2.expect_err("should fail when requesting component z of vec2 field");
        assert!(
            err.contains("rho_u_z") || err.contains("rho_u") || err.contains("component"),
            "error should contain field name or component info: {err}"
        );
    }
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 1),
    ]
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(stride: u32, flux_layout: &FluxLayout, targets: &[ResolvedGradientTarget]) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(stride, flux_layout, targets),
    )
}

fn main_body(stride: u32, flux_layout: &FluxLayout, targets: &[ResolvedGradientTarget]) -> Block {
    let unknown_stride = flux_layout.stride;

    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "cell_center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_typed_expr(
        "cell_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("cell_center")).expr(),
    ));

    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));

    // Accumulators: one vec2 per gradient.
    for target in targets {
        let var_name = format!("grad_acc_{}", target.component);
        stmts.push(dsl::var_typed_expr(
            &var_name,
            Type::vec2_f32(),
            Some(dsl::vec2_f32(0.0, 0.0)),
        ));
    }

    // Face loop.
    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neighbor_raw",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "is_boundary",
            Expr::ident("neighbor_raw").eq(-1),
        ));
        body.push(dsl::let_expr(
            "boundary_type",
            dsl::array_access("face_boundary", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "face_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_typed_expr(
            "face_center_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
        ));
        body.push(dsl::var_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            Some(
                typed::VecExpr::<2>::from_xy_fields(
                    Expr::ident("face_normals").index(Expr::ident("face_idx")),
                )
                .expr(),
            ),
        ));
        let cell_to_face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec")).sub(
            &typed::VecExpr::<2>::from_expr(Expr::ident("cell_center_vec")),
        );
        body.push(dsl::if_block_expr(
            cell_to_face
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
                .lt(0.0),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("normal_vec"),
                typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .neg()
                    .expr(),
            )]),
            None,
        ));

        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center_vec",
            Type::vec2_f32(),
            Some(Expr::ident("face_center_vec")),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            dsl::block(vec![
                dsl::let_expr(
                    "neighbor",
                    Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
                ),
                dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
                dsl::if_block_expr(
                    Expr::ident("owner").ne(Expr::ident("idx")),
                    dsl::block(vec![dsl::assign_expr(
                        Expr::ident("other_idx"),
                        Expr::ident("owner"),
                    )]),
                    None,
                ),
                dsl::let_expr(
                    "other_center",
                    dsl::array_access("cell_centers", Expr::ident("other_idx")),
                ),
                dsl::assign_expr(
                    Expr::ident("other_center_vec"),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
                ),
            ]),
            None,
        ));

        // Match OpenFOAM's linear interpolation weights (basicFvGeometryScheme) by using
        // projected distances along the face normal (area cancels out).
        body.push(dsl::let_expr(
            "d_own",
            dsl::abs(
                typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
                    .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                        "cell_center_vec",
                    )))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            ),
        ));
        body.push(dsl::let_expr(
            "d_neigh",
            dsl::abs(
                typed::VecExpr::<2>::from_expr(Expr::ident("other_center_vec"))
                    .sub(&typed::VecExpr::<2>::from_expr(Expr::ident(
                        "face_center_vec",
                    )))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            ),
        ));
        body.push(dsl::let_expr(
            "total_dist",
            Expr::ident("d_own") + Expr::ident("d_neigh"),
        ));
        body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
        body.push(dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ));
        body.push(dsl::let_expr(
            "lambda_other",
            Expr::from(1.0) - Expr::ident("lambda"),
        ));

        for target in targets {
            let cell_val =
                Expr::ident("state").index(Expr::ident("idx") * stride + target.base_offset);
            let interior_other =
                Expr::ident("state").index(Expr::ident("other_idx") * stride + target.base_offset);

            let mut other_val = if let Some(off) = target.bc_unknown_offset {
                let bc_table_idx =
                    Expr::ident("face_idx") * Expr::from(unknown_stride) + Expr::from(off);
                let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
                let value = dsl::array_access("bc_value", bc_table_idx);
                let from_bc = dsl::select(
                    dsl::select(cell_val.clone(), value.clone(), kind.eq(Expr::from(1u32))),
                    cell_val.clone() + value * Expr::ident("d_own"),
                    kind.eq(Expr::from(2u32)),
                );
                dsl::select(interior_other, from_bc, Expr::ident("is_boundary"))
            } else {
                dsl::select(interior_other, cell_val.clone(), Expr::ident("is_boundary"))
            };

            // SlipWall projection for velocity-like vec2 fields: enforce zero normal component at
            // boundary faces by overriding the boundary face value.
            if target.base_component <= 1 {
                if let (Some(vec_x_off), Some(vec_y_off)) =
                    (target.slip_vec2_x_offset, target.slip_vec2_y_offset)
                {
                    let slip_mask = Expr::ident("is_boundary")
                        & Expr::ident("boundary_type").eq(Expr::from(4u32));

                    let vx = Expr::ident("state").index(Expr::ident("idx") * stride + vec_x_off);
                    let vy = Expr::ident("state").index(Expr::ident("idx") * stride + vec_y_off);
                    let nx = Expr::ident("normal_vec").field("x");
                    let ny = Expr::ident("normal_vec").field("y");
                    let un = vx.clone() * nx.clone() + vy.clone() * ny.clone();

                    let projected = match target.base_component {
                        0 => vx - un.clone() * nx,
                        1 => vy - un * ny,
                        _ => unreachable!("base_component <= 1 guarded above"),
                    };

                    other_val = dsl::select(other_val, projected, slip_mask);
                }
            }

            let phi_face =
                cell_val * Expr::ident("lambda") + other_val * Expr::ident("lambda_other");

            let acc_name = format!("grad_acc_{}", target.component);
            let contrib = typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .mul_scalar(phi_face * Expr::ident("area"))
                .expr();
            body.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(&acc_name),
                contrib,
            ));
        }

        dsl::block(body)
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        face_loop_body,
    ));

    // Write out gradients (divide by volume).
    for target in targets {
        let acc_name = format!("grad_acc_{}", target.component);
        let grad_vec = typed::VecExpr::<2>::from_expr(Expr::ident(&acc_name))
            .mul_scalar(Expr::from(1.0) / dsl::max(Expr::ident("vol"), 1e-12))
            .expr();
        stmts.push(dsl::let_typed_expr(
            &format!("grad_out_{}", target.component),
            Type::vec2_f32(),
            grad_vec,
        ));

        let out = Expr::ident(&format!("grad_out_{}", target.component));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + target.grad_x_offset),
            out.clone().field("x"),
        ));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + target.grad_y_offset),
            out.field("y"),
        ));
    }

    Block::new(stmts)
}
