//! Traits for port-based module system.
//!
//! This module defines the core traits that are implemented by the derive macros
//! in `cfd2_macros`.

use super::{PortRegistry, PortRegistryError};

/// Trait for modules that declare their port requirements.
///
/// This trait is automatically implemented by the `#[derive(ModulePorts)]` macro.
/// It provides a standardized way for modules to:
/// - Declare their port requirements (fields, parameters, buffers)
/// - Register ports with a PortRegistry
/// - Generate WGSL bindings and access code
///
/// # Example
///
/// ```rust,ignore
/// #[derive(ModulePorts)]
/// #[port(module = "eos")]
/// pub struct EosModule {
///     pub params: EosParams,
/// }
/// ```
pub trait ModulePorts {
    /// The type representing this module's port set.
    type PortSet;

    /// The module name (used for identification and logging).
    const MODULE_NAME: &'static str;

    /// Get the module name.
    fn module_name(&self) -> &'static str {
        Self::MODULE_NAME
    }

    /// Register all ports required by this module.
    ///
    /// This method is called during model initialization to register all
    /// fields, parameters, and buffers that the module needs.
    ///
    /// # Errors
    ///
    /// Returns an error if any required port cannot be registered
    /// (e.g., field not found in state layout, type mismatch).
    fn register_ports(&self, registry: &mut PortRegistry) -> Result<(), PortRegistryError>;

    /// Validate that all required ports exist and have correct types.
    ///
    /// This is called after registration to verify the configuration.
    fn validate_ports(&self, _registry: &PortRegistry) -> Result<(), PortValidationError> {
        Ok(())
    }

    /// Get the port set for this module.
    ///
    /// Returns the typed port handles that can be used for WGSL generation.
    fn port_set(&self) -> &Self::PortSet;
}

/// Trait for collections of related ports (parameter sets or field sets).
///
/// This trait is automatically implemented by the `#[derive(PortSet)]` macro
/// for structs containing port fields.
///
/// # Example
///
/// ```rust,ignore
/// #[derive(PortSet)]
/// pub struct EosParams {
///     #[param(name = "eos.gamma", wgsl = "gamma")]
///     pub gamma: ParamPort<F32, Dimensionless>,
/// }
/// ```
pub trait PortSet {
    /// The name of this port set.
    const SET_NAME: &'static str;

    /// Register all ports in this set with the registry.
    ///
    /// # Errors
    ///
    /// Returns an error if any port cannot be registered.
    fn register(&self, registry: &mut PortRegistry) -> Result<(), PortRegistryError>;

    /// Create this port set from a registry.
    ///
    /// This method is typically generated by the macro and handles
    /// looking up and validating all ports in the set.
    fn from_registry(registry: &mut PortRegistry) -> Result<Self, PortRegistryError>
    where
        Self: Sized;

    /// Generate an IR-safe port manifest describing this port set.
    ///
    /// This method is typically generated by the macro and returns
    /// a pure-data representation of all declared ports.
    fn port_manifest() -> crate::solver::ir::ports::PortManifest
    where
        Self: Sized,
    {
        crate::solver::ir::ports::PortManifest::default()
    }
}

/// Error type for port validation.
#[derive(Debug, Clone, PartialEq)]
pub enum PortValidationError {
    /// A required field was not found in the state layout.
    MissingField { module: &'static str, field: String },
    /// A field was found but has the wrong kind.
    FieldKindMismatch {
        field: String,
        expected: String,
        found: String,
    },
    /// A field was found but has the wrong physical dimension.
    DimensionMismatch {
        field: String,
        expected: String,
        found: String,
    },
    /// A required parameter was not found.
    MissingParameter { module: &'static str, param: String },
    /// A parameter was found but has the wrong type.
    ParameterTypeMismatch {
        param: String,
        expected: String,
        found: String,
    },
}

impl std::fmt::Display for PortValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PortValidationError::MissingField { module, field } => {
                write!(
                    f,
                    "Module '{}' requires field '{}' which was not found",
                    module, field
                )
            }
            PortValidationError::FieldKindMismatch {
                field,
                expected,
                found,
            } => {
                write!(
                    f,
                    "Field '{}' has kind '{}' but expected '{}'",
                    field, found, expected
                )
            }
            PortValidationError::DimensionMismatch {
                field,
                expected,
                found,
            } => {
                write!(
                    f,
                    "Field '{}' has dimension '{}' but expected '{}'",
                    field, found, expected
                )
            }
            PortValidationError::MissingParameter { module, param } => {
                write!(
                    f,
                    "Module '{}' requires parameter '{}' which was not found",
                    module, param
                )
            }
            PortValidationError::ParameterTypeMismatch {
                param,
                expected,
                found,
            } => {
                write!(
                    f,
                    "Parameter '{}' has type '{}' but expected '{}'",
                    param, found, expected
                )
            }
        }
    }
}

impl std::error::Error for PortValidationError {}

/// Trait for modules that provide kernel specifications.
///
/// This is an extension trait for `ModulePorts` that adds kernel definitions.
pub trait KernelProvider: ModulePorts {
    /// Get the kernel specifications for this module.
    fn kernel_specs(&self) -> &[crate::solver::model::kernel::ModelKernelSpec];

    /// Get the kernel generators for this module.
    fn kernel_generators(&self) -> &[crate::solver::model::kernel::ModelKernelGeneratorSpec];
}

/// Trait for type-safe module initialization.
///
/// This trait bridges the gap between the old `KernelBundleModule` construction
/// and the new port-based system during migration.
pub trait IntoModule {
    /// The module type produced.
    type Module: ModulePorts;

    /// Convert into a module with port-based configuration.
    fn into_module(self) -> Self::Module;
}

/// Extension trait for creating port registries from modules.
pub trait ModulePortRegistry {
    /// Create a PortRegistry and register all module ports.
    fn create_port_registry(
        &self,
        state_layout: crate::solver::model::backend::state_layout::StateLayout,
    ) -> Result<PortRegistry, PortRegistryError>;
}

impl<T: ModulePorts> ModulePortRegistry for T {
    fn create_port_registry(
        &self,
        state_layout: crate::solver::model::backend::state_layout::StateLayout,
    ) -> Result<PortRegistry, PortRegistryError> {
        let mut registry = PortRegistry::new(state_layout);
        self.register_ports(&mut registry)?;
        Ok(registry)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::ports::{
        Dimensionless, ParamPort, PortId, Time, Vector2, Velocity, F32,
    };

    // Test that the trait bounds work correctly
    fn assert_module_ports<T: ModulePorts>() {}

    #[test]
    fn port_validation_error_display() {
        let err = PortValidationError::MissingField {
            module: "test",
            field: "velocity".to_string(),
        };
        assert_eq!(
            err.to_string(),
            "Module 'test' requires field 'velocity' which was not found"
        );

        let err = PortValidationError::FieldKindMismatch {
            field: "U".to_string(),
            expected: "Vector2".to_string(),
            found: "Scalar".to_string(),
        };
        assert_eq!(
            err.to_string(),
            "Field 'U' has kind 'Scalar' but expected 'Vector2'"
        );
    }
}
