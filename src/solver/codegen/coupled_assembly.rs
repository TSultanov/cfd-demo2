use super::coeff_expr::{coeff_cell_expr, coeff_face_expr};
use super::ir::DiscreteSystem;
use super::plan::{momentum_plan, MomentumPlan};
use super::state_access::{state_scalar_expr, state_vec2_expr};
use crate::solver::model::IncompressibleMomentumFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl::generate_wgsl_library_items;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_coupled_assembly_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (coupled assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.extend(generate_wgsl_library_items(system));
    let plan = {
        let plan = momentum_plan(system, fields.u.name(), fields.p.name());
        if plan.pressure_diffusion.is_none() {
            panic!(
                "missing pressure diffusion term for field '{}'",
                fields.p.name()
            );
        }
        plan
    };
    module.push(Item::Function(main_fn(layout, &plan, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment(
        "Group 0: Mesh".to_string(),
    ));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Solver (Coupled)".to_string(),
    ));
    items.extend(solver_bindings());
    items.push(Item::Function(safe_inverse_fn()));
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "grad_u",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            3,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_v",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            4,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "scalar_matrix_values",
            Type::array(Type::F32),
            2,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_u_inv",
            Type::array(Type::F32),
            2,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_v_inv",
            Type::array(Type::F32),
            2,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_p_inv",
            Type::array(Type::F32),
            2,
            8,
            AccessMode::ReadWrite,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn safe_inverse_fn() -> Function {
    let params = vec![Param::new("val", Type::F32, Vec::new())];
    let body = Block::new(vec![
        dsl::if_block(
            "abs(val) > 1e-14",
            dsl::block(vec![Stmt::Return(Some(dsl::expr("1.0 / val")))]),
            None,
        ),
        Stmt::Return(Some(dsl::expr("0.0"))),
    ]);
    Function::new("safe_inverse", params, Some(Type::F32), Vec::new(), body)
}

fn main_fn(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    let body = main_body(layout, plan, fields);
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        body,
    )
}

fn main_body(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Block {
    let mut stmts = Vec::new();
    let u_field = fields.u.name();
    let d_p_field = fields.d_p.name();
    let u_components = fields.u.kind().component_count();
    let p_components = fields.p.kind().component_count();
    if u_components != 2 {
        panic!(
            "expected vector2 velocity field, got {} components",
            u_components
        );
    }
    if p_components != 1 {
        panic!(
            "expected scalar pressure field, got {} components",
            p_components
        );
    }
    let coupled_stride = u_components + p_components;
    let p_offset = u_components;
    let row_stride_2 = coupled_stride * 2;
    let block_stride = coupled_stride * coupled_stride;
    let start_row_0_expr = format!("{block_stride}u * scalar_offset");
    let start_row_1_expr = format!("start_row_0 + {coupled_stride}u * num_neighbors");
    let start_row_2_expr = format!("start_row_0 + {row_stride_2}u * num_neighbors");
    let row_entry = |row: &str, rank: &str, comp: usize| {
        format!("{row} + {coupled_stride}u * {rank} + {comp}u")
    };
    let u_old_expr = state_vec2_expr(layout, "state_old", "idx", u_field);
    let u_old_old_expr = state_vec2_expr(layout, "state_old_old", "idx", u_field);

    stmts.push(dsl::let_("idx", "global_id.x"));
    stmts.push(dsl::if_block(
        "idx >= arrayLength(&cell_vols)",
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_("center", "cell_centers[idx]"));
    stmts.push(dsl::let_("vol", "cell_vols[idx]"));
    stmts.push(dsl::let_("start", "cell_face_offsets[idx]"));
    stmts.push(dsl::let_("end", "cell_face_offsets[idx + 1]"));
    stmts.push(dsl::let_("scalar_offset", "scalar_row_offsets[idx]"));
    stmts.push(dsl::let_(
        "num_neighbors",
        "scalar_row_offsets[idx + 1] - scalar_offset",
    ));
    stmts.push(dsl::let_("start_row_0", &start_row_0_expr));
    stmts.push(dsl::let_("start_row_1", &start_row_1_expr));
    stmts.push(dsl::let_("start_row_2", &start_row_2_expr));
    stmts.push(dsl::var_typed("diag_u", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("diag_v", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("diag_p", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("sum_diag_up", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("sum_diag_vp", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("sum_diag_pu", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("sum_diag_pv", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("sum_diag_pp", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("rhs_u", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("rhs_v", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("rhs_p", Type::F32, Some("0.0")));
    stmts.push(dsl::var_typed("scalar_diag_p", Type::F32, Some("0.0")));
    if let Some(ddt_op) = &plan.ddt {
        let rho_expr = coeff_cell_expr(layout, ddt_op.coeff.as_ref(), "idx", "constants.density");
        stmts.push(dsl::let_("u_n", &u_old_expr));
        stmts.push(dsl::let_("rho", &rho_expr));
        stmts.push(dsl::var(
            "coeff_time",
            "vol * rho / constants.dt",
        ));
        stmts.push(dsl::var("rhs_time_u", "coeff_time * u_n.x"));
        stmts.push(dsl::var("rhs_time_v", "coeff_time * u_n.y"));
        stmts.push(dsl::if_block(
            "constants.time_scheme == 1u",
            dsl::block(vec![
                dsl::let_("dt", "constants.dt"),
                dsl::let_("dt_old", "constants.dt_old"),
                dsl::let_("r", "dt / dt_old"),
                dsl::let_("u_nm1", &u_old_old_expr),
                dsl::assign(
                    "coeff_time",
                    "vol * rho / dt * (1.0 + 2.0 * r) / (1.0 + r)",
                ),
                dsl::let_("factor_n", "(1.0 + r)"),
                dsl::let_("factor_nm1", "(r * r) / (1.0 + r)"),
                dsl::assign(
                    "rhs_time_u",
                    "(vol * rho / dt) * (factor_n * u_n.x - factor_nm1 * u_nm1.x)",
                ),
                dsl::assign(
                    "rhs_time_v",
                    "(vol * rho / dt) * (factor_n * u_n.y - factor_nm1 * u_nm1.y)",
                ),
            ]),
            None,
        ));
        stmts.push(dsl::assign_op(AssignOp::Add, "diag_u", "coeff_time"));
        stmts.push(dsl::assign_op(AssignOp::Add, "diag_v", "coeff_time"));
        stmts.push(dsl::assign_op(AssignOp::Add, "rhs_u", "rhs_time_u"));
        stmts.push(dsl::assign_op(AssignOp::Add, "rhs_v", "rhs_time_v"));
    }

    let d_p_idx_expr = state_scalar_expr(layout, "state", "idx", d_p_field);
    let u_idx_expr = state_vec2_expr(layout, "state", "idx", u_field);
    let pressure_coeff_face_expr = coeff_face_expr(
        layout,
        plan.pressure_diffusion.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        "other_idx",
        "lambda",
        "d_p_face",
    );
    let pressure_coeff_cell_expr = coeff_cell_expr(
        layout,
        plan.pressure_diffusion.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        "d_p_own",
    );

    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_("face_idx", "cell_faces[k]"));
        body.push(dsl::let_("owner", "face_owner[face_idx]"));
        body.push(dsl::let_("neigh_idx", "face_neighbor[face_idx]"));
        body.push(dsl::let_("boundary_type", "face_boundary[face_idx]"));
        body.push(dsl::var("normal", "face_normals[face_idx]"));
        body.push(dsl::let_("area", "face_areas[face_idx]"));
        body.push(dsl::let_("f_center", "face_centers[face_idx]"));
        body.push(dsl::var_typed("normal_sign", Type::F32, Some("1.0")));
        body.push(dsl::if_block(
            "owner != idx",
            dsl::block(vec![
                dsl::assign("normal.x", "-normal.x"),
                dsl::assign("normal.y", "-normal.y"),
                dsl::assign("normal_sign", "-1.0"),
            ]),
            None,
        ));
        body.push(dsl::let_("flux", "fluxes[face_idx] * normal_sign"));
        body.push(dsl::var_typed(
            "other_center",
            Type::Custom("Vector2".to_string()),
            None,
        ));
        body.push(dsl::var("is_boundary", "false"));
        body.push(dsl::var("other_idx", "0u"));
        body.push(dsl::var_typed("d_p_neigh", Type::F32, Some("0.0")));

        let d_p_other_expr = state_scalar_expr(layout, "state", "other_idx", d_p_field);
        body.push(dsl::if_block(
            "neigh_idx != -1",
            dsl::block(vec![
                dsl::assign("other_idx", "u32(neigh_idx)"),
                dsl::if_block(
                    "owner != idx",
                    dsl::block(vec![dsl::assign("other_idx", "owner")]),
                    None,
                ),
                dsl::assign("other_center", "cell_centers[other_idx]"),
                dsl::assign("d_p_neigh", &d_p_other_expr),
            ]),
            Some(dsl::block(vec![
                dsl::assign("is_boundary", "true"),
                dsl::assign("other_idx", "idx"),
                dsl::assign("other_center", "f_center"),
                dsl::assign("d_p_neigh", &d_p_idx_expr),
            ])),
        ));

        body.push(dsl::let_("d_vec_x", "other_center.x - center.x"));
        body.push(dsl::let_("d_vec_y", "other_center.y - center.y"));
        body.push(dsl::let_(
            "dist_proj",
            "abs(d_vec_x * normal.x + d_vec_y * normal.y)",
        ));
        body.push(dsl::let_("dist", "max(dist_proj, 1e-6)"));
        if let Some(diff_op) = &plan.diffusion {
            let mu_expr = coeff_face_expr(
                layout,
                diff_op.coeff.as_ref(),
                "idx",
                "other_idx",
                "0.5",
                "1.0",
            );
            body.push(dsl::let_(
                "diff_coeff",
                &format!("codegen_diff_coeff({}, area, dist)", mu_expr),
            ));
        } else {
            body.push(dsl::let_("diff_coeff", "0.0"));
        }

        if plan.convection.is_some() {
            body.push(dsl::let_("conv_coeff", "codegen_conv_coeff(flux)"));
            body.push(dsl::let_("conv_coeff_diag", "conv_coeff.x"));
            body.push(dsl::let_("conv_coeff_off", "conv_coeff.y"));
        } else {
            body.push(dsl::let_("conv_coeff_diag", "0.0"));
            body.push(dsl::let_("conv_coeff_off", "0.0"));
        }
        body.push(dsl::let_("scalar_mat_idx", "cell_face_matrix_indices[k]"));
        body.push(dsl::var("neighbor_rank", "0u"));
        body.push(dsl::if_block(
            "scalar_mat_idx != 4294967295u",
            dsl::block(vec![dsl::assign(
                "neighbor_rank",
                "scalar_mat_idx - scalar_offset",
            )]),
            Some(dsl::block(vec![dsl::assign(
                "neighbor_rank",
                "scalar_mat_idx - scalar_offset",
            )])),
        ));
        body.push(dsl::let_(
            "idx_0_0",
            &row_entry("start_row_0", "neighbor_rank", 0),
        ));
        body.push(dsl::let_(
            "idx_0_1",
            &row_entry("start_row_0", "neighbor_rank", 1),
        ));
        body.push(dsl::let_(
            "idx_0_2",
            &row_entry("start_row_0", "neighbor_rank", p_offset),
        ));
        body.push(dsl::let_(
            "idx_1_0",
            &row_entry("start_row_1", "neighbor_rank", 0),
        ));
        body.push(dsl::let_(
            "idx_1_1",
            &row_entry("start_row_1", "neighbor_rank", 1),
        ));
        body.push(dsl::let_(
            "idx_1_2",
            &row_entry("start_row_1", "neighbor_rank", p_offset),
        ));
        body.push(dsl::let_(
            "idx_2_0",
            &row_entry("start_row_2", "neighbor_rank", 0),
        ));
        body.push(dsl::let_(
            "idx_2_1",
            &row_entry("start_row_2", "neighbor_rank", 1),
        ));
        body.push(dsl::let_(
            "idx_2_2",
            &row_entry("start_row_2", "neighbor_rank", p_offset),
        ));

        let u_neigh_expr = state_vec2_expr(layout, "state", "other_idx", u_field);
        let d_p_idx_expr = state_scalar_expr(layout, "state", "idx", d_p_field);

        let mut inlet_stmts = vec![
            dsl::let_(
                "ramp",
                "smoothstep(0.0, constants.ramp_time, constants.time)",
            ),
            dsl::let_("u_bc_x", "constants.inlet_velocity * ramp"),
            dsl::let_("u_bc_y", "0.0"),
            dsl::assign_op(AssignOp::Add, "diag_u", "diff_coeff"),
            dsl::assign_op(AssignOp::Add, "diag_v", "diff_coeff"),
            dsl::assign_op(AssignOp::Add, "rhs_u", "diff_coeff * u_bc_x"),
            dsl::assign_op(AssignOp::Add, "rhs_v", "diff_coeff * u_bc_y"),
            dsl::if_block(
                "flux > 0.0",
                dsl::block(vec![
                    dsl::assign_op(AssignOp::Add, "diag_u", "flux"),
                    dsl::assign_op(AssignOp::Add, "diag_v", "flux"),
                ]),
                Some(dsl::block(vec![
                    dsl::assign_op(AssignOp::Sub, "rhs_u", "flux * u_bc_x"),
                    dsl::assign_op(AssignOp::Sub, "rhs_v", "flux * u_bc_y"),
                ])),
            ),
        ];
        if plan.gradient.is_some() {
            inlet_stmts.extend(vec![
                dsl::let_("pg_force_x", "area * normal.x"),
                dsl::let_("pg_force_y", "area * normal.y"),
                dsl::assign_op(AssignOp::Add, "sum_diag_up", "pg_force_x"),
                dsl::assign_op(AssignOp::Add, "sum_diag_vp", "pg_force_y"),
            ]);
        }
        inlet_stmts.extend(vec![
            dsl::let_(
                "flux_bc",
                "(u_bc_x * normal.x + u_bc_y * normal.y) * area",
            ),
            dsl::assign_op(AssignOp::Sub, "rhs_p", "flux_bc"),
        ]);
        let inlet_block = dsl::block(inlet_stmts);

        let mut wall_stmts = vec![
            dsl::assign_op(AssignOp::Add, "diag_u", "diff_coeff"),
            dsl::assign_op(AssignOp::Add, "diag_v", "diff_coeff"),
        ];
        if plan.gradient.is_some() {
            wall_stmts.extend(vec![
                dsl::let_("pg_force_x", "area * normal.x"),
                dsl::let_("pg_force_y", "area * normal.y"),
                dsl::assign_op(AssignOp::Add, "sum_diag_up", "pg_force_x"),
                dsl::assign_op(AssignOp::Add, "sum_diag_vp", "pg_force_y"),
            ]);
        }
        let wall_block = dsl::block(wall_stmts);

        let outlet_block = dsl::block(vec![
            dsl::if_block(
                "flux > 0.0",
                dsl::block(vec![
                    dsl::assign_op(AssignOp::Add, "diag_u", "flux"),
                    dsl::assign_op(AssignOp::Add, "diag_v", "flux"),
                ]),
                None,
            ),
            dsl::let_("div_coeff_x", "normal.x * area"),
            dsl::let_("div_coeff_y", "normal.y * area"),
            dsl::assign_op(AssignOp::Add, "sum_diag_pu", "div_coeff_x"),
            dsl::assign_op(AssignOp::Add, "sum_diag_pv", "div_coeff_y"),
            dsl::let_("d_p_own", &d_p_idx_expr),
            dsl::let_("pressure_coeff_cell", &pressure_coeff_cell_expr),
            dsl::let_("lapl_coeff", "pressure_coeff_cell * area / dist"),
            dsl::assign_op(AssignOp::Add, "sum_diag_pp", "lapl_coeff"),
            dsl::let_("scalar_coeff", "pressure_coeff_cell * area / dist"),
            dsl::assign_op(AssignOp::Add, "scalar_diag_p", "scalar_coeff"),
        ]);

        let boundary_stmt = dsl::if_block(
            "boundary_type == 1u",
            inlet_block,
            Some(dsl::block(vec![dsl::if_block(
                "boundary_type == 3u",
                wall_block,
                Some(dsl::block(vec![dsl::if_block(
                    "boundary_type == 2u",
                    outlet_block,
                    None,
                )])),
            )])),
        );

        let mut interior_stmts = vec![
            dsl::let_("coeff", "-diff_coeff + conv_coeff_off"),
            dsl::assign("matrix_values[idx_0_0]", "coeff"),
            dsl::assign("matrix_values[idx_0_1]", "0.0"),
            dsl::assign("matrix_values[idx_1_0]", "0.0"),
            dsl::assign("matrix_values[idx_1_1]", "coeff"),
            dsl::assign_op(AssignOp::Add, "diag_u", "diff_coeff + conv_coeff_diag"),
            dsl::assign_op(AssignOp::Add, "diag_v", "diff_coeff + conv_coeff_diag"),
        ];

        if let Some(conv_op) = &plan.convection {
            let scheme_id = conv_op.scheme as u32;
            interior_stmts.push(dsl::let_typed(
                "scheme_id",
                Type::U32,
                &format!("{}u", scheme_id),
            ));
            interior_stmts.push(dsl::if_block(
                "scheme_id != 0u",
                dsl::block(vec![
                    dsl::let_("u_own", &u_idx_expr),
                    dsl::let_("u_neigh", &u_neigh_expr),
                    dsl::var("phi_upwind_u", "u_own.x"),
                    dsl::var("phi_upwind_v", "u_own.y"),
                    dsl::if_block(
                        "flux < 0.0",
                        dsl::block(vec![
                            dsl::assign("phi_upwind_u", "u_neigh.x"),
                            dsl::assign("phi_upwind_v", "u_neigh.y"),
                        ]),
                        None,
                    ),
                    dsl::var("phi_ho_u", "phi_upwind_u"),
                    dsl::var("phi_ho_v", "phi_upwind_v"),
                    dsl::if_block(
                        "scheme_id == 1u",
                        dsl::block(vec![dsl::if_block(
                            "flux > 0.0",
                            dsl::block(vec![
                                dsl::let_("grad_u_own", "grad_u[idx]"),
                                dsl::let_("grad_v_own", "grad_v[idx]"),
                                dsl::let_("r_x", "f_center.x - center.x"),
                                dsl::let_("r_y", "f_center.y - center.y"),
                                dsl::assign(
                                    "phi_ho_u",
                                    "u_own.x + (grad_u_own.x * r_x + grad_u_own.y * r_y)",
                                ),
                                dsl::assign(
                                    "phi_ho_v",
                                    "u_own.y + (grad_v_own.x * r_x + grad_v_own.y * r_y)",
                                ),
                            ]),
                            Some(dsl::block(vec![
                                dsl::let_("grad_u_neigh", "grad_u[other_idx]"),
                                dsl::let_("grad_v_neigh", "grad_v[other_idx]"),
                                dsl::let_("r_x", "f_center.x - other_center.x"),
                                dsl::let_("r_y", "f_center.y - other_center.y"),
                                dsl::assign(
                                    "phi_ho_u",
                                    "u_neigh.x + (grad_u_neigh.x * r_x + grad_u_neigh.y * r_y)",
                                ),
                                dsl::assign(
                                    "phi_ho_v",
                                    "u_neigh.y + (grad_v_neigh.x * r_x + grad_v_neigh.y * r_y)",
                                ),
                            ])),
                        )]),
                        Some(dsl::block(vec![dsl::if_block(
                            "scheme_id == 2u",
                            dsl::block(vec![dsl::if_block(
                                "flux > 0.0",
                                dsl::block(vec![
                                    dsl::let_("grad_u_own", "grad_u[idx]"),
                                    dsl::let_("grad_v_own", "grad_v[idx]"),
                                    dsl::let_("d_cd_x", "other_center.x - center.x"),
                                    dsl::let_("d_cd_y", "other_center.y - center.y"),
                                    dsl::let_(
                                        "grad_term_u",
                                        "grad_u_own.x * d_cd_x + grad_u_own.y * d_cd_y",
                                    ),
                                    dsl::let_(
                                        "grad_term_v",
                                        "grad_v_own.x * d_cd_x + grad_v_own.y * d_cd_y",
                                    ),
                                    dsl::assign(
                                        "phi_ho_u",
                                        "0.625 * u_own.x + 0.375 * u_neigh.x + 0.125 * grad_term_u",
                                    ),
                                    dsl::assign(
                                        "phi_ho_v",
                                        "0.625 * u_own.y + 0.375 * u_neigh.y + 0.125 * grad_term_v",
                                    ),
                                ]),
                                Some(dsl::block(vec![
                                    dsl::let_("grad_u_neigh", "grad_u[other_idx]"),
                                    dsl::let_("grad_v_neigh", "grad_v[other_idx]"),
                                    dsl::let_("d_cd_x", "center.x - other_center.x"),
                                    dsl::let_("d_cd_y", "center.y - other_center.y"),
                                    dsl::let_(
                                        "grad_term_u",
                                        "grad_u_neigh.x * d_cd_x + grad_u_neigh.y * d_cd_y",
                                    ),
                                    dsl::let_(
                                        "grad_term_v",
                                        "grad_v_neigh.x * d_cd_x + grad_v_neigh.y * d_cd_y",
                                    ),
                                    dsl::assign(
                                        "phi_ho_u",
                                        "0.625 * u_neigh.x + 0.375 * u_own.x + 0.125 * grad_term_u",
                                    ),
                                    dsl::assign(
                                        "phi_ho_v",
                                        "0.625 * u_neigh.y + 0.375 * u_own.y + 0.125 * grad_term_v",
                                    ),
                                ])),
                            )]),
                            None,
                        )])),
                    ),
                    dsl::let_("correction_u", "flux * (phi_ho_u - phi_upwind_u)"),
                    dsl::let_("correction_v", "flux * (phi_ho_v - phi_upwind_v)"),
                    dsl::assign_op(AssignOp::Sub, "rhs_u", "correction_u"),
                    dsl::assign_op(AssignOp::Sub, "rhs_v", "correction_v"),
                ]),
                None,
            ));
        }

        interior_stmts.push(dsl::let_(
            "d_own",
            "distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y))",
        ));
        interior_stmts.push(dsl::let_(
            "d_neigh",
            "distance(vec2<f32>(other_center.x, other_center.y), vec2<f32>(f_center.x, f_center.y))",
        ));
        interior_stmts.push(dsl::let_("total_dist", "d_own + d_neigh"));
        interior_stmts.push(dsl::var("lambda", "0.5"));
        interior_stmts.push(dsl::if_block(
            "total_dist > 1e-6",
            dsl::block(vec![dsl::assign("lambda", "d_neigh / total_dist")]),
            None,
        ));

        if plan.gradient.is_some() {
            interior_stmts.extend(vec![
                dsl::let_("pg_force_x", "area * normal.x"),
                dsl::let_("pg_force_y", "area * normal.y"),
                dsl::assign(
                    "matrix_values[idx_0_2]",
                    "(1.0 - lambda) * pg_force_x",
                ),
                dsl::assign(
                    "matrix_values[idx_1_2]",
                    "(1.0 - lambda) * pg_force_y",
                ),
                dsl::assign_op(AssignOp::Add, "sum_diag_up", "lambda * pg_force_x"),
                dsl::assign_op(AssignOp::Add, "sum_diag_vp", "lambda * pg_force_y"),
            ]);
        }

        interior_stmts.extend(vec![
            dsl::let_("div_coeff_x", "normal.x * area"),
            dsl::let_("div_coeff_y", "normal.y * area"),
            dsl::assign(
                "matrix_values[idx_2_0]",
                "(1.0 - lambda) * div_coeff_x",
            ),
            dsl::assign(
                "matrix_values[idx_2_1]",
                "(1.0 - lambda) * div_coeff_y",
            ),
            dsl::assign_op(AssignOp::Add, "sum_diag_pu", "lambda * div_coeff_x"),
            dsl::assign_op(AssignOp::Add, "sum_diag_pv", "lambda * div_coeff_y"),
            dsl::let_("d_p_own", &d_p_idx_expr),
            dsl::let_(
                "d_p_face",
                "lambda * d_p_own + (1.0 - lambda) * d_p_neigh",
            ),
            dsl::let_("pressure_coeff_face", &pressure_coeff_face_expr),
            dsl::let_("lapl_coeff", "pressure_coeff_face * area / dist"),
            dsl::assign("matrix_values[idx_2_2]", "-lapl_coeff"),
            dsl::assign_op(AssignOp::Add, "sum_diag_pp", "lapl_coeff"),
            dsl::let_("scalar_coeff", "pressure_coeff_face * area / dist"),
            dsl::if_block(
                "scalar_mat_idx != 4294967295u",
                dsl::block(vec![dsl::assign(
                    "scalar_matrix_values[scalar_mat_idx]",
                    "-scalar_coeff",
                )]),
                None,
            ),
            dsl::assign_op(AssignOp::Add, "scalar_diag_p", "scalar_coeff"),
        ]);

        body.push(dsl::if_block(
            "!is_boundary",
            dsl::block(interior_stmts),
            Some(dsl::block(vec![boundary_stmt])),
        ));

        body
    };

    stmts.push(dsl::for_loop(
        dsl::for_init_var("k", "start"),
        "k < end",
        dsl::for_step_increment("k"),
        dsl::block(face_loop_body),
    ));

    let scalar_diag_idx_expr = format!("diagonal_indices[idx]");
    stmts.push(dsl::let_("scalar_diag_idx", &scalar_diag_idx_expr));
    stmts.push(dsl::let_("diag_rank", "scalar_diag_idx - scalar_offset"));
    stmts.push(dsl::let_(
        "d_0_0",
        &row_entry("start_row_0", "diag_rank", 0),
    ));
    stmts.push(dsl::let_(
        "d_0_1",
        &row_entry("start_row_0", "diag_rank", 1),
    ));
    stmts.push(dsl::let_(
        "d_0_2",
        &row_entry("start_row_0", "diag_rank", p_offset),
    ));
    stmts.push(dsl::let_(
        "d_1_0",
        &row_entry("start_row_1", "diag_rank", 0),
    ));
    stmts.push(dsl::let_(
        "d_1_1",
        &row_entry("start_row_1", "diag_rank", 1),
    ));
    stmts.push(dsl::let_(
        "d_1_2",
        &row_entry("start_row_1", "diag_rank", p_offset),
    ));
    stmts.push(dsl::let_(
        "d_2_0",
        &row_entry("start_row_2", "diag_rank", 0),
    ));
    stmts.push(dsl::let_(
        "d_2_1",
        &row_entry("start_row_2", "diag_rank", 1),
    ));
    stmts.push(dsl::let_(
        "d_2_2",
        &row_entry("start_row_2", "diag_rank", p_offset),
    ));
    stmts.push(dsl::assign("matrix_values[d_0_0]", "diag_u"));
    stmts.push(dsl::assign("matrix_values[d_0_1]", "0.0"));
    stmts.push(dsl::assign("matrix_values[d_0_2]", "sum_diag_up"));
    stmts.push(dsl::assign("matrix_values[d_1_0]", "0.0"));
    stmts.push(dsl::assign("matrix_values[d_1_1]", "diag_v"));
    stmts.push(dsl::assign("matrix_values[d_1_2]", "sum_diag_vp"));
    stmts.push(dsl::assign("matrix_values[d_2_0]", "sum_diag_pu"));
    stmts.push(dsl::assign("matrix_values[d_2_1]", "sum_diag_pv"));
    stmts.push(dsl::assign("matrix_values[d_2_2]", "diag_p + sum_diag_pp"));
    stmts.push(dsl::assign(
        &format!("rhs[{coupled_stride}u * idx + 0u]"),
        "rhs_u",
    ));
    stmts.push(dsl::assign(
        &format!("rhs[{coupled_stride}u * idx + 1u]"),
        "rhs_v",
    ));
    stmts.push(dsl::assign(
        &format!("rhs[{coupled_stride}u * idx + {p_offset}u]"),
        "rhs_p",
    ));
    stmts.push(dsl::assign(
        "scalar_matrix_values[scalar_diag_idx]",
        "scalar_diag_p",
    ));
    stmts.push(dsl::assign(
        "diag_u_inv[idx]",
        "safe_inverse(diag_u)",
    ));
    stmts.push(dsl::assign(
        "diag_v_inv[idx]",
        "safe_inverse(diag_v)",
    ));
    stmts.push(dsl::assign(
        "diag_p_inv[idx]",
        "safe_inverse(scalar_diag_p)",
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::backend::ast::{fvm, surface_scalar, vol_scalar, vol_vector, Coefficient};
    use crate::solver::codegen::ir::lower_system;
    use crate::solver::model::IncompressibleMomentumFields;
    use crate::solver::model::backend::SchemeRegistry;
    use crate::solver::scheme::Scheme;

    fn default_layout() -> StateLayout {
        StateLayout::new(vec![
            vol_vector("U"),
            vol_scalar("p"),
            vol_scalar("d_p"),
            vol_vector("grad_p"),
            vol_vector("grad_component"),
        ])
    }

    fn default_fields() -> IncompressibleMomentumFields {
        IncompressibleMomentumFields::new()
    }

    #[test]
    fn generate_coupled_assembly_wgsl_includes_codegen_helpers() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi");
        let nu = vol_scalar("nu");
        let p = vol_scalar("p");
        let d_p = vol_scalar("d_p");
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi, u.clone()))
            .with_term(fvm::laplacian(
                Coefficient::field(nu).unwrap(),
                u.clone(),
            ));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone()).with_term(
                fvm::laplacian(Coefficient::field(d_p).unwrap(), p),
            ),
        );

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let layout = default_layout();
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &layout, &fields);

        assert!(wgsl.contains("codegen_conv_coeff"));
        assert!(wgsl.contains("codegen_diff_coeff"));
        assert!(wgsl.contains("state: array<f32>"));
    }

    #[test]
    fn coupled_assembly_codegen_embeds_scheme_id_from_registry() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi");
        let p = vol_scalar("p");
        let d_p = vol_scalar("d_p");
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi.clone(), u.clone()));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone()).with_term(
                fvm::laplacian(Coefficient::field(d_p).unwrap(), p),
            ),
        );

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::model::backend::ast::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry);
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &default_layout(), &fields);

        assert!(wgsl.contains("scheme_id: u32 = 2u"));
    }

    #[test]
    fn coupled_assembly_codegen_zeros_diffusion_when_missing() {
        let u = vol_vector("U");
        let p = vol_scalar("p");
        let d_p = vol_scalar("d_p");
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone()).with_term(
                fvm::laplacian(Coefficient::field(d_p).unwrap(), p),
            ),
        );

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &default_layout(), &fields);

        assert!(wgsl.contains("let diff_coeff = 0.0"));
    }

    #[test]
    fn coupled_assembly_codegen_maps_named_coefficients() {
        let u = vol_vector("U");
        let nu = vol_scalar("nu");
        let rho = vol_scalar("rho");
        let p = vol_scalar("p");
        let d_p = vol_scalar("d_p");
        let eqn = crate::solver::model::backend::ast::Equation::new(u.clone())
            .with_term(fvm::ddt_coeff(
                Coefficient::field(rho).unwrap(),
                u.clone(),
            ))
            .with_term(fvm::laplacian(
                Coefficient::field(nu).unwrap(),
                u.clone(),
            ));
        let mut system = crate::solver::model::backend::ast::EquationSystem::new();
        system.add_equation(eqn);
        system.add_equation(
            crate::solver::model::backend::ast::Equation::new(p.clone()).with_term(
                fvm::laplacian(Coefficient::field(d_p).unwrap(), p),
            ),
        );

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let fields = default_fields();
        let wgsl = generate_coupled_assembly_wgsl(&discrete, &default_layout(), &fields);

        assert!(wgsl.contains("let rho = constants.density"));
        assert!(wgsl.contains("codegen_diff_coeff(constants.viscosity, area, dist)"));
    }
}
