pub fn generate_rhie_chow_correct_velocity_wgsl(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
) -> String {
    let mut out = String::new();
    out.push_str("// GENERATED BY CFD2 CODEGEN (rhie_chow_correct_velocity)\n\n");
    out.push_str("// DO NOT EDIT MANUALLY\n\n");

    out.push_str(&format!(
        "const STATE_STRIDE: u32 = {state_stride}u;\n\
const U_X_OFFSET: u32 = {u_x_offset}u;\n\
const U_Y_OFFSET: u32 = {u_y_offset}u;\n\
const D_P_OFFSET: u32 = {d_p_offset}u;\n\
const GRAD_P_X_OFFSET: u32 = {grad_p_x_offset}u;\n\
const GRAD_P_Y_OFFSET: u32 = {grad_p_y_offset}u;\n\n"
    ));

    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    out.push_str(
        "struct Constants {\n\
    dt: f32,\n\
    dt_old: f32,\n\
    dtau: f32,\n\
    time: f32,\n\
    viscosity: f32,\n\
    density: f32,\n\
    component: u32,\n\
    alpha_p: f32,\n\
    scheme: u32,\n\
    alpha_u: f32,\n\
    stride_x: u32,\n\
    time_scheme: u32,\n\
}\n\n",
    );

    out.push_str(
        "@group(0) @binding(0)\n\
var<storage, read_write> state: array<f32>;\n\n",
    );

    out.push_str("@group(0) @binding(1)\nvar<uniform> constants: Constants;\n\n");

    out.push_str(
        "@compute\n\
@workgroup_size(64)\n\
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\
    let idx = global_id.y * constants.stride_x + global_id.x;\n\
    let num_cells = arrayLength(&state) / max(STATE_STRIDE, 1u);\n\
    if (idx >= num_cells) {\n\
        return;\n\
    }\n\
\n\
    let base = idx * STATE_STRIDE;\n\
    let d_p = state[base + D_P_OFFSET];\n\
    let grad_px = state[base + GRAD_P_X_OFFSET];\n\
    let grad_py = state[base + GRAD_P_Y_OFFSET];\n\
\n\
    state[base + U_X_OFFSET] = state[base + U_X_OFFSET] - d_p * grad_px;\n\
    state[base + U_Y_OFFSET] = state[base + U_Y_OFFSET] - d_p * grad_py;\n\
}\n",
    );

    out
}

pub fn generate_rhie_chow_store_grad_p_wgsl(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> String {
    let mut out = String::new();
    out.push_str("// GENERATED BY CFD2 CODEGEN (rhie_chow_store_grad_p)\n\n");
    out.push_str("// DO NOT EDIT MANUALLY\n\n");

    out.push_str(&format!(
        "const STATE_STRIDE: u32 = {state_stride}u;\n\
const GRAD_P_X_OFFSET: u32 = {grad_p_x_offset}u;\n\
const GRAD_P_Y_OFFSET: u32 = {grad_p_y_offset}u;\n\
const GRAD_OLD_X_OFFSET: u32 = {grad_old_x_offset}u;\n\
const GRAD_OLD_Y_OFFSET: u32 = {grad_old_y_offset}u;\n\n"
    ));

    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    out.push_str(
        "struct Constants {\n\
    dt: f32,\n\
    dt_old: f32,\n\
    dtau: f32,\n\
    time: f32,\n\
    viscosity: f32,\n\
    density: f32,\n\
    component: u32,\n\
    alpha_p: f32,\n\
    scheme: u32,\n\
    alpha_u: f32,\n\
    stride_x: u32,\n\
    time_scheme: u32,\n\
}\n\n",
    );

    out.push_str(
        "@group(0) @binding(0)\n\
var<storage, read_write> state: array<f32>;\n\n",
    );

    out.push_str("@group(0) @binding(1)\nvar<uniform> constants: Constants;\n\n");

    out.push_str(
        "@compute\n\
@workgroup_size(64)\n\
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\
    let idx = global_id.y * constants.stride_x + global_id.x;\n\
    let num_cells = arrayLength(&state) / max(STATE_STRIDE, 1u);\n\
    if (idx >= num_cells) {\n\
        return;\n\
    }\n\
\n\
    let base = idx * STATE_STRIDE;\n\
    state[base + GRAD_OLD_X_OFFSET] = state[base + GRAD_P_X_OFFSET];\n\
    state[base + GRAD_OLD_Y_OFFSET] = state[base + GRAD_P_Y_OFFSET];\n\
}\n",
    );

    out
}

pub fn generate_rhie_chow_correct_velocity_delta_wgsl(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> String {
    let mut out = String::new();
    out.push_str("// GENERATED BY CFD2 CODEGEN (rhie_chow_correct_velocity_delta)\n\n");
    out.push_str("// DO NOT EDIT MANUALLY\n\n");

    out.push_str(&format!(
        "const STATE_STRIDE: u32 = {state_stride}u;\n\
const U_X_OFFSET: u32 = {u_x_offset}u;\n\
const U_Y_OFFSET: u32 = {u_y_offset}u;\n\
const D_P_OFFSET: u32 = {d_p_offset}u;\n\
const GRAD_P_X_OFFSET: u32 = {grad_p_x_offset}u;\n\
const GRAD_P_Y_OFFSET: u32 = {grad_p_y_offset}u;\n\
const GRAD_OLD_X_OFFSET: u32 = {grad_old_x_offset}u;\n\
const GRAD_OLD_Y_OFFSET: u32 = {grad_old_y_offset}u;\n\n"
    ));

    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    out.push_str(
        "struct Constants {\n\
    dt: f32,\n\
    dt_old: f32,\n\
    dtau: f32,\n\
    time: f32,\n\
    viscosity: f32,\n\
    density: f32,\n\
    component: u32,\n\
    alpha_p: f32,\n\
    scheme: u32,\n\
    alpha_u: f32,\n\
    stride_x: u32,\n\
    time_scheme: u32,\n\
}\n\n",
    );

    out.push_str(
        "@group(0) @binding(0)\n\
var<storage, read_write> state: array<f32>;\n\n",
    );

    out.push_str("@group(0) @binding(1)\nvar<uniform> constants: Constants;\n\n");

    out.push_str(
        "@compute\n\
@workgroup_size(64)\n\
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n\
    let idx = global_id.y * constants.stride_x + global_id.x;\n\
    let num_cells = arrayLength(&state) / max(STATE_STRIDE, 1u);\n\
    if (idx >= num_cells) {\n\
        return;\n\
    }\n\
\n\
    let base = idx * STATE_STRIDE;\n\
    let d_p = state[base + D_P_OFFSET];\n\
    let grad_px = state[base + GRAD_P_X_OFFSET];\n\
    let grad_py = state[base + GRAD_P_Y_OFFSET];\n\
    let grad_old_x = state[base + GRAD_OLD_X_OFFSET];\n\
    let grad_old_y = state[base + GRAD_OLD_Y_OFFSET];\n\
\n\
    // Apply SIMPLE-style velocity correction using the change in pressure gradient:\n\
    //   U_new = HbyA - d_p * grad(p_new)\n\
    //   U_old = HbyA - d_p * grad(p_old)\n\
    // => U_new = U_old - d_p * (grad(p_new) - grad(p_old))\n\
    let corr_x = d_p * (grad_px - grad_old_x);\n\
    let corr_y = d_p * (grad_py - grad_old_y);\n\
    state[base + U_X_OFFSET] = state[base + U_X_OFFSET] - corr_x;\n\
    state[base + U_Y_OFFSET] = state[base + U_Y_OFFSET] - corr_y;\n\
}\n",
    );

    out
}
