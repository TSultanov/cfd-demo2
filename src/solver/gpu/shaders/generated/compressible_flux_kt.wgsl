// GENERATED BY CFD2 CODEGEN (compressible_flux_kt)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
    pressure_coupling_alpha: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(8) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(9) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@group(1) @binding(9) 
var<storage, read> state_iter: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let center_owner = cell_centers[owner];
    var normal = face_normals[idx];
    var is_boundary = false;
    var other_idx = owner;
    let rho_l_cell = state_old[owner * 7u + 0u];
    let rho_u_l_cell = vec2<f32>(state_old[owner * 7u + 1u], state_old[owner * 7u + 2u]);
    let rho_e_l_cell = state_old[owner * 7u + 3u];
    var rho_l = rho_l_cell;
    var rho_u_l = rho_u_l_cell;
    var rho_e_l = rho_e_l_cell;
    var rho_r = rho_l;
    var rho_u_r = rho_u_l;
    var rho_e_r = rho_e_l;
    var center_r = face_center;
    if (neighbor != -1) {
        let neigh_idx = u32(neighbor);
        other_idx = neigh_idx;
        let rho_neigh = state_old[neigh_idx * 7u + 0u];
        let rho_u_neigh = vec2<f32>(state_old[neigh_idx * 7u + 1u], state_old[neigh_idx * 7u + 2u]);
        let rho_e_neigh = state_old[neigh_idx * 7u + 3u];
        rho_r = rho_neigh;
        rho_u_r.x = rho_u_neigh.x;
        rho_u_r.y = rho_u_neigh.y;
        rho_e_r = rho_e_neigh;
        center_r = cell_centers[neigh_idx];
    } else {
        is_boundary = true;
        if (boundary_type == 1u) {
            rho_u_r.x = rho_r * constants.inlet_velocity;
            rho_u_r.y = 0.0;
        } else {
            if (boundary_type == 3u) {
                let m_dot_n = rho_u_l.x * normal.x + rho_u_l.y * normal.y;
                rho_u_r.x = rho_u_l.x - 2.0 * m_dot_n * normal.x;
                rho_u_r.y = rho_u_l.y - 2.0 * m_dot_n * normal.y;
            }
        }
    }
    let rho_r_cell = rho_r;
    let rho_u_r_cell = rho_u_r;
    let rho_e_r_cell = rho_e_r;
    if (!is_boundary && constants.scheme == 1u) {
        let r_l_x = face_center.x - center_owner.x;
        let r_l_y = face_center.y - center_owner.y;
        let r_r_x = face_center.x - center_r.x;
        let r_r_y = face_center.y - center_r.y;
        let grad_rho_l = grad_rho[owner];
        let grad_rho_u_x_l = grad_rho_u_x[owner];
        let grad_rho_u_y_l = grad_rho_u_y[owner];
        let grad_rho_e_l = grad_rho_e[owner];
        let grad_rho_r = grad_rho[other_idx];
        let grad_rho_u_x_r = grad_rho_u_x[other_idx];
        let grad_rho_u_y_r = grad_rho_u_y[other_idx];
        let grad_rho_e_r = grad_rho_e[other_idx];
        let diff_rho_l = rho_r_cell - rho_l_cell;
        let min_diff_rho_l = min(diff_rho_l, 0.0);
        let max_diff_rho_l = max(diff_rho_l, 0.0);
        let delta_rho_l = grad_rho_l.x * r_l_x + grad_rho_l.y * r_l_y;
        let delta_rho_l_limited = min(max(delta_rho_l, min_diff_rho_l), max_diff_rho_l);
        let diff_rho_u_x_l = rho_u_r_cell.x - rho_u_l_cell.x;
        let min_diff_rho_u_x_l = min(diff_rho_u_x_l, 0.0);
        let max_diff_rho_u_x_l = max(diff_rho_u_x_l, 0.0);
        let delta_rho_u_x_l = grad_rho_u_x_l.x * r_l_x + grad_rho_u_x_l.y * r_l_y;
        let delta_rho_u_x_l_limited = min(max(delta_rho_u_x_l, min_diff_rho_u_x_l), max_diff_rho_u_x_l);
        let diff_rho_u_y_l = rho_u_r_cell.y - rho_u_l_cell.y;
        let min_diff_rho_u_y_l = min(diff_rho_u_y_l, 0.0);
        let max_diff_rho_u_y_l = max(diff_rho_u_y_l, 0.0);
        let delta_rho_u_y_l = grad_rho_u_y_l.x * r_l_x + grad_rho_u_y_l.y * r_l_y;
        let delta_rho_u_y_l_limited = min(max(delta_rho_u_y_l, min_diff_rho_u_y_l), max_diff_rho_u_y_l);
        let diff_rho_e_l = rho_e_r_cell - rho_e_l_cell;
        let min_diff_rho_e_l = min(diff_rho_e_l, 0.0);
        let max_diff_rho_e_l = max(diff_rho_e_l, 0.0);
        let delta_rho_e_l = grad_rho_e_l.x * r_l_x + grad_rho_e_l.y * r_l_y;
        let delta_rho_e_l_limited = min(max(delta_rho_e_l, min_diff_rho_e_l), max_diff_rho_e_l);
        let rho_l_face = rho_l_cell + delta_rho_l_limited;
        let rho_u_x_l_face = rho_u_l_cell.x + delta_rho_u_x_l_limited;
        let rho_u_y_l_face = rho_u_l_cell.y + delta_rho_u_y_l_limited;
        let rho_e_l_face = rho_e_l_cell + delta_rho_e_l_limited;
        let diff_rho_r = rho_l_cell - rho_r_cell;
        let min_diff_rho_r = min(diff_rho_r, 0.0);
        let max_diff_rho_r = max(diff_rho_r, 0.0);
        let delta_rho_r = grad_rho_r.x * r_r_x + grad_rho_r.y * r_r_y;
        let delta_rho_r_limited = min(max(delta_rho_r, min_diff_rho_r), max_diff_rho_r);
        let diff_rho_u_x_r = rho_u_l_cell.x - rho_u_r_cell.x;
        let min_diff_rho_u_x_r = min(diff_rho_u_x_r, 0.0);
        let max_diff_rho_u_x_r = max(diff_rho_u_x_r, 0.0);
        let delta_rho_u_x_r = grad_rho_u_x_r.x * r_r_x + grad_rho_u_x_r.y * r_r_y;
        let delta_rho_u_x_r_limited = min(max(delta_rho_u_x_r, min_diff_rho_u_x_r), max_diff_rho_u_x_r);
        let diff_rho_u_y_r = rho_u_l_cell.y - rho_u_r_cell.y;
        let min_diff_rho_u_y_r = min(diff_rho_u_y_r, 0.0);
        let max_diff_rho_u_y_r = max(diff_rho_u_y_r, 0.0);
        let delta_rho_u_y_r = grad_rho_u_y_r.x * r_r_x + grad_rho_u_y_r.y * r_r_y;
        let delta_rho_u_y_r_limited = min(max(delta_rho_u_y_r, min_diff_rho_u_y_r), max_diff_rho_u_y_r);
        let diff_rho_e_r = rho_e_l_cell - rho_e_r_cell;
        let min_diff_rho_e_r = min(diff_rho_e_r, 0.0);
        let max_diff_rho_e_r = max(diff_rho_e_r, 0.0);
        let delta_rho_e_r = grad_rho_e_r.x * r_r_x + grad_rho_e_r.y * r_r_y;
        let delta_rho_e_r_limited = min(max(delta_rho_e_r, min_diff_rho_e_r), max_diff_rho_e_r);
        let rho_r_face = rho_r_cell + delta_rho_r_limited;
        let rho_u_x_r_face = rho_u_r_cell.x + delta_rho_u_x_r_limited;
        let rho_u_y_r_face = rho_u_r_cell.y + delta_rho_u_y_r_limited;
        let rho_e_r_face = rho_e_r_cell + delta_rho_e_r_limited;
        rho_l = rho_l_face;
        rho_u_l.x = rho_u_x_l_face;
        rho_u_l.y = rho_u_y_l_face;
        rho_e_l = rho_e_l_face;
        rho_r = rho_r_face;
        rho_u_r.x = rho_u_x_r_face;
        rho_u_r.y = rho_u_y_r_face;
        rho_e_r = rho_e_r_face;
    }
    let inv_rho_l = 1.0 / max(rho_l, 1e-8);
    let u_l_x = rho_u_l.x * inv_rho_l;
    let u_l_y = rho_u_l.y * inv_rho_l;
    let ke_l = 0.5 * rho_l * (u_l_x * u_l_x + u_l_y * u_l_y);
    let p_l = max(0.0, (1.4 - 1.0) * (rho_e_l - ke_l));
    let u_n_l = u_l_x * normal.x + u_l_y * normal.y;
    let c_l = sqrt(1.4 * p_l * inv_rho_l);
    let inv_rho_r = 1.0 / max(rho_r, 1e-8);
    let u_r_x = rho_u_r.x * inv_rho_r;
    let u_r_y = rho_u_r.y * inv_rho_r;
    let ke_r = 0.5 * rho_r * (u_r_x * u_r_x + u_r_y * u_r_y);
    let p_r = max(0.0, (1.4 - 1.0) * (rho_e_r - ke_r));
    let u_n_r = u_r_x * normal.x + u_r_y * normal.y;
    let c_r = sqrt(1.4 * p_r * inv_rho_r);
    let u_face_x = 0.5 * (u_l_x + u_r_x);
    let u_face_y = 0.5 * (u_l_y + u_r_y);
    let u_face_n = u_face_x * normal.x + u_face_y * normal.y;
    let c_bar = 0.5 * (c_l + c_r);
    let mach = abs(u_face_n) / max(c_bar, 1e-6);
    let mach2 = mach * mach;
    var c_l_eff = c_l;
    var c_r_eff = c_r;
    if (constants.precond_model == 0u) {
        c_l_eff = c_l * mach;
        c_r_eff = c_r * mach;
    } else {
        if (constants.precond_model == 1u) {
            let theta = min(1.0, max(mach2, constants.precond_theta_floor));
            let one_minus_theta = 1.0 - theta;
            c_l_eff = sqrt(theta * c_l * c_l + one_minus_theta * u_n_l * u_n_l);
            c_r_eff = sqrt(theta * c_r * c_r + one_minus_theta * u_n_r * u_n_r);
        }
    }
    let dx = center_r.x - center_owner.x;
    let dy = center_r.y - center_owner.y;
    let dist = max(sqrt(dx * dx + dy * dy), 1e-6);
    let mu = constants.viscosity;
    let a_plus = max(0.0, max(u_n_l + c_l_eff, u_n_r + c_r_eff));
    let a_minus = min(0.0, min(u_n_l - c_l_eff, u_n_r - c_r_eff));
    let denom = max(a_plus - a_minus, 1e-6);
    let a_prod = a_plus * a_minus;
    let a_pos = a_plus / denom;
    let a_neg = 1.0 - a_pos;
    let a_prod_scaled = a_prod / denom;
    let flux_rho_l = rho_l * u_n_l;
    let flux_rho_r = rho_r * u_n_r;
    var flux_rho = a_pos * flux_rho_l + a_neg * flux_rho_r + a_prod_scaled * (rho_r - rho_l);
    let flux_rho_u_x_l = rho_u_l.x * u_n_l + p_l * normal.x;
    let flux_rho_u_x_r = rho_u_r.x * u_n_r + p_r * normal.x;
    var flux_rho_u_x = a_pos * flux_rho_u_x_l + a_neg * flux_rho_u_x_r + a_prod_scaled * (rho_u_r.x - rho_u_l.x);
    let flux_rho_u_y_l = rho_u_l.y * u_n_l + p_l * normal.y;
    let flux_rho_u_y_r = rho_u_r.y * u_n_r + p_r * normal.y;
    var flux_rho_u_y = a_pos * flux_rho_u_y_l + a_neg * flux_rho_u_y_r + a_prod_scaled * (rho_u_r.y - rho_u_l.y);
    let diff_u_x = -mu * (u_r_x - u_l_x) / dist;
    let diff_u_y = -mu * (u_r_y - u_l_y) / dist;
    flux_rho_u_x = flux_rho_u_x + diff_u_x;
    flux_rho_u_y = flux_rho_u_y + diff_u_y;
    let flux_rho_e_l = (rho_e_l + p_l) * u_n_l;
    let flux_rho_e_r = (rho_e_r + p_r) * u_n_r;
    var flux_rho_e = a_pos * flux_rho_e_l + a_neg * flux_rho_e_r + a_prod_scaled * (rho_e_r - rho_e_l);
    let inv_rho_l_cell = 1.0 / max(rho_l_cell, 1e-8);
    let inv_rho_r_cell = 1.0 / max(rho_r_cell, 1e-8);
    let u_l_x_cell = rho_u_l_cell.x * inv_rho_l_cell;
    let u_l_y_cell = rho_u_l_cell.y * inv_rho_l_cell;
    let u_r_x_cell = rho_u_r_cell.x * inv_rho_r_cell;
    let u_r_y_cell = rho_u_r_cell.y * inv_rho_r_cell;
    let u2_l_cell = u_l_x_cell * u_l_x_cell + u_l_y_cell * u_l_y_cell;
    let u2_r_cell = u_r_x_cell * u_r_x_cell + u_r_y_cell * u_r_y_cell;
    let grad_rho_l = grad_rho[owner];
    let grad_rho_u_x_l = grad_rho_u_x[owner];
    let grad_rho_u_y_l = grad_rho_u_y[owner];
    let grad_rho_e_l = grad_rho_e[owner];
    let grad_rho_r = grad_rho[other_idx];
    let grad_rho_u_x_r = grad_rho_u_x[other_idx];
    let grad_rho_u_y_r = grad_rho_u_y[other_idx];
    let grad_rho_e_r = grad_rho_e[other_idx];
    let grad_u_x_l_x = (grad_rho_u_x_l.x - u_l_x_cell * grad_rho_l.x) * inv_rho_l_cell;
    let grad_u_x_l_y = (grad_rho_u_x_l.y - u_l_x_cell * grad_rho_l.y) * inv_rho_l_cell;
    let grad_u_y_l_x = (grad_rho_u_y_l.x - u_l_y_cell * grad_rho_l.x) * inv_rho_l_cell;
    let grad_u_y_l_y = (grad_rho_u_y_l.y - u_l_y_cell * grad_rho_l.y) * inv_rho_l_cell;
    let grad_u_x_r_x = (grad_rho_u_x_r.x - u_r_x_cell * grad_rho_r.x) * inv_rho_r_cell;
    let grad_u_x_r_y = (grad_rho_u_x_r.y - u_r_x_cell * grad_rho_r.y) * inv_rho_r_cell;
    let grad_u_y_r_x = (grad_rho_u_y_r.x - u_r_y_cell * grad_rho_r.x) * inv_rho_r_cell;
    let grad_u_y_r_y = (grad_rho_u_y_r.y - u_r_y_cell * grad_rho_r.y) * inv_rho_r_cell;
    let grad_u2_l_x = 2.0 * u_l_x_cell * grad_u_x_l_x + 2.0 * u_l_y_cell * grad_u_y_l_x;
    let grad_u2_l_y = 2.0 * u_l_x_cell * grad_u_x_l_y + 2.0 * u_l_y_cell * grad_u_y_l_y;
    let grad_u2_r_x = 2.0 * u_r_x_cell * grad_u_x_r_x + 2.0 * u_r_y_cell * grad_u_y_r_x;
    let grad_u2_r_y = 2.0 * u_r_x_cell * grad_u_x_r_y + 2.0 * u_r_y_cell * grad_u_y_r_y;
    let grad_rho_u2_l_x = u2_l_cell * grad_rho_l.x + rho_l_cell * grad_u2_l_x;
    let grad_rho_u2_l_y = u2_l_cell * grad_rho_l.y + rho_l_cell * grad_u2_l_y;
    let grad_rho_u2_r_x = u2_r_cell * grad_rho_r.x + rho_r_cell * grad_u2_r_x;
    let grad_rho_u2_r_y = u2_r_cell * grad_rho_r.y + rho_r_cell * grad_u2_r_y;
    let grad_p_l_x = (1.4 - 1.0) * (grad_rho_e_l.x - 0.5 * grad_rho_u2_l_x);
    let grad_p_l_y = (1.4 - 1.0) * (grad_rho_e_l.y - 0.5 * grad_rho_u2_l_y);
    let grad_p_r_x = (1.4 - 1.0) * (grad_rho_e_r.x - 0.5 * grad_rho_u2_r_x);
    let grad_p_r_y = (1.4 - 1.0) * (grad_rho_e_r.y - 0.5 * grad_rho_u2_r_y);
    let grad_p_l_n = grad_p_l_x * normal.x + grad_p_l_y * normal.y;
    let grad_p_r_n = grad_p_r_x * normal.x + grad_p_r_y * normal.y;
    let grad_p_face_n = 0.5 * (grad_p_l_n + grad_p_r_n);
    let grad_p_jump_n = (p_r - p_l) / dist;
    let rho_face = 0.5 * (rho_l + rho_r);
    let p_bar = 0.5 * (p_l + p_r);
    let dp_rel = abs(p_r - p_l) / max(p_bar, 1e-6);
    if (constants.precond_model != 2u && constants.pressure_coupling_alpha > 0.0) {
        let pc_theta = min(1.0, max(mach2, constants.precond_theta_floor));
        let pc_low_mach = 1.0 - pc_theta;
        let pc_smooth = 1.0 / (1.0 + dp_rel / 0.2 * dp_rel / 0.2);
        let pc_alpha = constants.pressure_coupling_alpha * pc_low_mach * pc_smooth;
        let m_corr = pc_alpha * constants.dt / max(rho_face, 1e-8) * (grad_p_face_n - grad_p_jump_n);
        let h_l = (rho_e_l + p_l) * inv_rho_l;
        let h_r = (rho_e_r + p_r) * inv_rho_r;
        let h_face = 0.5 * (h_l + h_r);
        flux_rho = flux_rho + m_corr;
        flux_rho_u_x = flux_rho_u_x + m_corr * u_face_x;
        flux_rho_u_y = flux_rho_u_y + m_corr * u_face_y;
        flux_rho_e = flux_rho_e + m_corr * h_face;
    }
    flux_rho_e = flux_rho_e + diff_u_x * u_face_x + diff_u_y * u_face_y;
    let base = idx * 4u;
    fluxes[base + 0u] = flux_rho * area;
    fluxes[base + 1u] = flux_rho_u_x * area;
    fluxes[base + 2u] = flux_rho_u_y * area;
    fluxes[base + 3u] = flux_rho_e * area;
}
