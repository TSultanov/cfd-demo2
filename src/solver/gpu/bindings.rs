// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.2
// Changes made to this file will not be saved.
// SourceHash: 600ed15f2111154d0a8697da64385416cbef361affc11c45fefb33ef3f824f7d

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Amg,
    AmgPack,
    BlockPrecond,
    DotProduct,
    DotProductPair,
    GeneratedDpInitIncompressibleMomentum,
    GeneratedDpInitIncompressibleMomentumGeneric,
    GeneratedDpUpdateFromDiagIncompressibleMomentum,
    GeneratedDpUpdateFromDiagIncompressibleMomentumGeneric,
    GeneratedFluxModuleCompressible,
    GeneratedFluxModuleGradientsIncompressibleMomentum,
    GeneratedFluxModuleGradientsIncompressibleMomentumGeneric,
    GeneratedFluxModuleIncompressibleMomentum,
    GeneratedFluxModuleIncompressibleMomentumGeneric,
    GeneratedGenericCoupledApply,
    GeneratedGenericCoupledAssemblyCompressible,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemo,
    GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledAssemblyIncompressibleMomentum,
    GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric,
    GeneratedGenericCoupledUpdateCompressible,
    GeneratedGenericCoupledUpdateGenericDiffusionDemo,
    GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann,
    GeneratedGenericCoupledUpdateIncompressibleMomentum,
    GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric,
    GeneratedRhieChowCorrectVelocityIncompressibleMomentum,
    GeneratedRhieChowCorrectVelocityIncompressibleMomentumGeneric,
    GenericCoupledSchurSetup,
    GmresCgs,
    GmresLogic,
    GmresOps,
    LinearSolver,
    Preconditioner,
    Scalars,
    SchurPrecond,
    SchurPrecondGeneric,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self { Self :: Amg => amg :: create_pipeline_layout (device) , Self :: AmgPack => amg_pack :: create_pipeline_layout (device) , Self :: BlockPrecond => block_precond :: create_pipeline_layout (device) , Self :: DotProduct => dot_product :: create_pipeline_layout (device) , Self :: DotProductPair => dot_product_pair :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentum => generated :: dp_init_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpInitIncompressibleMomentumGeneric => generated :: dp_init_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => generated :: dp_update_from_diag_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentumGeneric => generated :: dp_update_from_diag_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleCompressible => generated :: flux_module_compressible :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => generated :: flux_module_gradients_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleGradientsIncompressibleMomentumGeneric => generated :: flux_module_gradients_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentum => generated :: flux_module_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedFluxModuleIncompressibleMomentumGeneric => generated :: flux_module_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledApply => generated :: generic_coupled_apply :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyCompressible => generated :: generic_coupled_assembly_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => generated :: generic_coupled_assembly_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => generated :: generic_coupled_assembly_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric => generated :: generic_coupled_assembly_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateCompressible => generated :: generic_coupled_update_compressible :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => generated :: generic_coupled_update_generic_diffusion_demo :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => generated :: generic_coupled_update_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric => generated :: generic_coupled_update_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentum => generated :: rhie_chow_correct_velocity_incompressible_momentum :: create_pipeline_layout (device) , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentumGeneric => generated :: rhie_chow_correct_velocity_incompressible_momentum_generic :: create_pipeline_layout (device) , Self :: GenericCoupledSchurSetup => generic_coupled_schur_setup :: create_pipeline_layout (device) , Self :: GmresCgs => gmres_cgs :: create_pipeline_layout (device) , Self :: GmresLogic => gmres_logic :: create_pipeline_layout (device) , Self :: GmresOps => gmres_ops :: create_pipeline_layout (device) , Self :: LinearSolver => linear_solver :: create_pipeline_layout (device) , Self :: Preconditioner => preconditioner :: create_pipeline_layout (device) , Self :: Scalars => scalars :: create_pipeline_layout (device) , Self :: SchurPrecond => schur_precond :: create_pipeline_layout (device) , Self :: SchurPrecondGeneric => schur_precond_generic :: create_pipeline_layout (device) , }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self { Self :: Amg => { amg :: create_shader_module_embed_source (device) } , Self :: AmgPack => { amg_pack :: create_shader_module_embed_source (device) } , Self :: BlockPrecond => { block_precond :: create_shader_module_embed_source (device) } , Self :: DotProduct => { dot_product :: create_shader_module_embed_source (device) } , Self :: DotProductPair => { dot_product_pair :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentum => { generated :: dp_init_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpInitIncompressibleMomentumGeneric => { generated :: dp_init_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentum => { generated :: dp_update_from_diag_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedDpUpdateFromDiagIncompressibleMomentumGeneric => { generated :: dp_update_from_diag_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleCompressible => { generated :: flux_module_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentum => { generated :: flux_module_gradients_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleGradientsIncompressibleMomentumGeneric => { generated :: flux_module_gradients_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentum => { generated :: flux_module_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedFluxModuleIncompressibleMomentumGeneric => { generated :: flux_module_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledApply => { generated :: generic_coupled_apply :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyCompressible => { generated :: generic_coupled_assembly_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemo => { generated :: generic_coupled_assembly_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann => { generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentum => { generated :: generic_coupled_assembly_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric => { generated :: generic_coupled_assembly_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateCompressible => { generated :: generic_coupled_update_compressible :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemo => { generated :: generic_coupled_update_generic_diffusion_demo :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann => { generated :: generic_coupled_update_generic_diffusion_demo_neumann :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentum => { generated :: generic_coupled_update_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric => { generated :: generic_coupled_update_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentum => { generated :: rhie_chow_correct_velocity_incompressible_momentum :: create_shader_module_embed_source (device) } , Self :: GeneratedRhieChowCorrectVelocityIncompressibleMomentumGeneric => { generated :: rhie_chow_correct_velocity_incompressible_momentum_generic :: create_shader_module_embed_source (device) } , Self :: GenericCoupledSchurSetup => { generic_coupled_schur_setup :: create_shader_module_embed_source (device) } , Self :: GmresCgs => { gmres_cgs :: create_shader_module_embed_source (device) } , Self :: GmresLogic => { gmres_logic :: create_shader_module_embed_source (device) } , Self :: GmresOps => { gmres_ops :: create_shader_module_embed_source (device) } , Self :: LinearSolver => { linear_solver :: create_shader_module_embed_source (device) } , Self :: Preconditioner => { preconditioner :: create_shader_module_embed_source (device) } , Self :: Scalars => { scalars :: create_shader_module_embed_source (device) } , Self :: SchurPrecond => { schur_precond :: create_shader_module_embed_source (device) } , Self :: SchurPrecondGeneric => { schur_precond_generic :: create_shader_module_embed_source (device) } , }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {};
    const AMG_AMG_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg::AmgParams, n) == 0);
        assert!(std::mem::offset_of!(amg::AmgParams, omega) == 4);
        assert!(std::mem::offset_of!(amg::AmgParams, padding) == 8);
        assert!(std::mem::size_of::<amg::AmgParams>() == 16);
    };
    const AMG_PACK_PACK_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(amg_pack::PackParams, num_cells) == 0);
        assert!(std::mem::offset_of!(amg_pack::PackParams, component) == 4);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad1) == 8);
        assert!(std::mem::offset_of!(amg_pack::PackParams, _pad2) == 12);
        assert!(std::mem::size_of::<amg_pack::PackParams>() == 16);
    };
    const BLOCK_PRECOND_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(block_precond::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(block_precond::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(block_precond::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(block_precond::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<block_precond::GmresParams>() == 32);
    };
    const BLOCK_PRECOND_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(block_precond::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(block_precond::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(block_precond::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<block_precond::IterParams>() == 16);
    };
    const DOT_PRODUCT_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product::SolverParams, n) == 0);
        assert!(std::mem::size_of::<dot_product::SolverParams>() == 4);
    };
    const DOT_PRODUCT_PAIR_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(dot_product_pair::SolverParams, n) == 0);
        assert!(std::mem::size_of::<dot_product_pair::SolverParams>() == 4);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dt) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, dtau) == 8
        );
        assert!(
            std::mem::offset_of!(generated::dp_init_incompressible_momentum::Constants, time) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(std::mem::size_of::<generated::dp_init_incompressible_momentum::Constants>() == 48);
    };
    const GENERATED_DP_INIT_INCOMPRESSIBLE_MOMENTUM_GENERIC_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::dp_init_incompressible_momentum_generic::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::size_of::<generated::dp_init_incompressible_momentum_generic::Constants>()
                == 48
        );
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, x) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Vector2, y) == 4);
        assert!(std::mem::size_of::<generated::flux_module_compressible::Vector2>() == 8);
    };
    const GENERATED_FLUX_MODULE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt) == 0);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dt_old) == 4);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, dtau) == 8);
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, time) == 12);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, viscosity) == 16
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, density) == 20
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, component) == 24
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_p) == 28
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, scheme) == 32);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, alpha_u) == 36
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, stride_x) == 40
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, time_scheme) == 44
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gamma) == 48
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_gm1) == 52
        );
        assert!(std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_r) == 56);
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_dp_drho) == 60
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_compressible::Constants, eos_p_offset)
                == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(std::mem::size_of::<generated::flux_module_compressible::Constants>() == 72);
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_gradients_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_FLUX_MODULE_GRADIENTS_INCOMPRESSIBLE_MOMENTUM_GENERIC_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum_generic::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_gradients_incompressible_momentum_generic::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::flux_module_gradients_incompressible_momentum_generic::Vector2,
            >() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::flux_module_incompressible_momentum::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Vector2>() == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum::Constants>() == 72
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_GENERIC_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum_generic::Vector2>()
                == 8
        );
    };
    const GENERATED_FLUX_MODULE_INCOMPRESSIBLE_MOMENTUM_GENERIC_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::flux_module_incompressible_momentum_generic::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::flux_module_incompressible_momentum_generic::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, x) == 0
        );
        assert!(
            std::mem::offset_of!(generated::generic_coupled_assembly_compressible::Vector2, y) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Vector2>() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_compressible::Constants>()
                == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_generic_diffusion_demo::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_assembly_incompressible_momentum::Vector2>(
            ) == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_GENERIC_VECTOR2_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Vector2,
                x
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Vector2,
                y
            ) == 4
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum_generic::Vector2,
            >() == 8
        );
    };
    const GENERATED_GENERIC_COUPLED_ASSEMBLY_INCOMPRESSIBLE_MOMENTUM_GENERIC_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_assembly_incompressible_momentum_generic::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_COMPRESSIBLE_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_compressible::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_compressible::Constants>() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_generic_diffusion_demo::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_GENERIC_DIFFUSION_DEMO_NEUMANN_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants,
            >() == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<generated::generic_coupled_update_incompressible_momentum::Constants>(
            ) == 72
        );
    };
    const GENERATED_GENERIC_COUPLED_UPDATE_INCOMPRESSIBLE_MOMENTUM_GENERIC_CONSTANTS_ASSERTS: () = {
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                dt
            ) == 0
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                dt_old
            ) == 4
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                dtau
            ) == 8
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                time
            ) == 12
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                viscosity
            ) == 16
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                density
            ) == 20
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                component
            ) == 24
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                alpha_p
            ) == 28
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                scheme
            ) == 32
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                alpha_u
            ) == 36
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                stride_x
            ) == 40
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                time_scheme
            ) == 44
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                eos_gamma
            ) == 48
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                eos_gm1
            ) == 52
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                eos_r
            ) == 56
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                eos_dp_drho
            ) == 60
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                eos_p_offset
            ) == 64
        );
        assert!(
            std::mem::offset_of!(
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
                eos_theta_ref
            ) == 68
        );
        assert!(
            std::mem::size_of::<
                generated::generic_coupled_update_incompressible_momentum_generic::Constants,
            >() == 72
        );
    };
    const GENERIC_COUPLED_SCHUR_SETUP_SETUP_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, dispatch_x) == 0);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, num_cells) == 4);
        assert!(
            std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, unknowns_per_cell) == 8
        );
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, p) == 12);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u_len) == 16);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, state_stride) == 20);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, d_p_offset) == 24);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u0123) == 32);
        assert!(std::mem::offset_of!(generic_coupled_schur_setup::SetupParams, u4567) == 48);
        assert!(std::mem::size_of::<generic_coupled_schur_setup::SetupParams>() == 64);
    };
    const GMRES_CGS_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_cgs::Params, n) == 0);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_cgs::Params, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_cgs::Params, omega) == 12);
        assert!(std::mem::offset_of!(gmres_cgs::Params, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_cgs::Params, max_restart) == 20);
        assert!(std::mem::offset_of!(gmres_cgs::Params, column_offset) == 24);
        assert!(std::mem::offset_of!(gmres_cgs::Params, pad3) == 28);
        assert!(std::mem::size_of::<gmres_cgs::Params>() == 32);
    };
    const GMRES_LOGIC_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_logic::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_logic::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_logic::IterParams>() == 16);
    };
    const GMRES_OPS_GMRES_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, n) == 0);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_cells) == 4);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, num_iters) == 8);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, omega) == 12);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, dispatch_x) == 16);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad1) == 20);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad2) == 24);
        assert!(std::mem::offset_of!(gmres_ops::GmresParams, _pad3) == 28);
        assert!(std::mem::size_of::<gmres_ops::GmresParams>() == 32);
    };
    const GMRES_OPS_ITER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(gmres_ops::IterParams, current_idx) == 0);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, max_restart) == 4);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad1) == 8);
        assert!(std::mem::offset_of!(gmres_ops::IterParams, _pad2) == 12);
        assert!(std::mem::size_of::<gmres_ops::IterParams>() == 16);
    };
    const LINEAR_SOLVER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, omega) == 16);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r0_v) == 20);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, t_s) == 24);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, t_t) == 28);
        assert!(std::mem::offset_of!(linear_solver::GpuScalars, r_r) == 32);
        assert!(std::mem::size_of::<linear_solver::GpuScalars>() == 36);
    };
    const LINEAR_SOLVER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(linear_solver::SolverParams, n) == 0);
        assert!(std::mem::size_of::<linear_solver::SolverParams>() == 4);
    };
    const PRECONDITIONER_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, omega) == 16);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, r0_v) == 20);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, t_s) == 24);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, t_t) == 28);
        assert!(std::mem::offset_of!(preconditioner::GpuScalars, r_r) == 32);
        assert!(std::mem::size_of::<preconditioner::GpuScalars>() == 36);
    };
    const PRECONDITIONER_SOLVER_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(preconditioner::SolverParams, n) == 0);
        assert!(std::mem::size_of::<preconditioner::SolverParams>() == 4);
    };
    const PRECONDITIONER_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, mode) == 0);
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, _pad0) == 4);
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, _pad1) == 8);
        assert!(std::mem::offset_of!(preconditioner::PrecondParams, _pad2) == 12);
        assert!(std::mem::size_of::<preconditioner::PrecondParams>() == 16);
    };
    const SCALARS_GPU_SCALARS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_old) == 0);
        assert!(std::mem::offset_of!(scalars::GpuScalars, rho_new) == 4);
        assert!(std::mem::offset_of!(scalars::GpuScalars, alpha) == 8);
        assert!(std::mem::offset_of!(scalars::GpuScalars, beta) == 12);
        assert!(std::mem::offset_of!(scalars::GpuScalars, omega) == 16);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r0_v) == 20);
        assert!(std::mem::offset_of!(scalars::GpuScalars, t_s) == 24);
        assert!(std::mem::offset_of!(scalars::GpuScalars, t_t) == 28);
        assert!(std::mem::offset_of!(scalars::GpuScalars, r_r) == 32);
        assert!(std::mem::size_of::<scalars::GpuScalars>() == 36);
    };
    const SCALARS_REDUCE_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(scalars::ReduceParams, n) == 0);
        assert!(std::mem::offset_of!(scalars::ReduceParams, num_groups) == 4);
        assert!(std::mem::size_of::<scalars::ReduceParams>() == 8);
    };
    const SCHUR_PRECOND_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, omega) == 8);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, unknowns_per_cell) == 12);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u0) == 16);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, u1) == 20);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, p) == 24);
        assert!(std::mem::offset_of!(schur_precond::PrecondParams, _pad0) == 28);
        assert!(std::mem::size_of::<schur_precond::PrecondParams>() == 32);
    };
    const SCHUR_PRECOND_GENERIC_PRECOND_PARAMS_ASSERTS: () = {
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, n) == 0);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, num_cells) == 4);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, omega) == 8);
        assert!(
            std::mem::offset_of!(schur_precond_generic::PrecondParams, unknowns_per_cell) == 12
        );
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, p) == 16);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u_len) == 20);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad0) == 24);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, _pad1) == 28);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u0123) == 32);
        assert!(std::mem::offset_of!(schur_precond_generic::PrecondParams, u4567) == 48);
        assert!(std::mem::size_of::<schur_precond_generic::PrecondParams>() == 64);
    };
}
pub mod amg {
    use super::{_root, _root::*};
    #[repr(C, align(8))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct AmgParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 8, size: 8, type: `vec2<u32>`"]
        pub padding: [u32; 2],
    }
    impl AmgParams {
        pub const fn new(n: u32, omega: f32, padding: [u32; 2]) -> Self {
            Self { n, omega, padding }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SMOOTH_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_smooth_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline smooth_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("smooth_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PROLONGATE_OP_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_prolongate_op_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline prolongate_op"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("prolongate_op"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const RESTRICT_RESIDUAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_restrict_residual_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline restrict_residual"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("restrict_residual"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CLEAR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_clear_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline clear"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("clear"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SMOOTH_OP: &str = "smooth_op";
    pub const ENTRY_PROLONGATE_OP: &str = "prolongate_op";
    pub const ENTRY_RESTRICT_RESIDUAL: &str = "restrict_residual";
    pub const ENTRY_CLEAR: &str = "clear";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub b: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub b: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.x, self.b, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg::AmgParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub op_row_offsets: wgpu::BufferBinding<'a>,
        pub op_col_indices: wgpu::BufferBinding<'a>,
        pub op_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub op_row_offsets: wgpu::BindGroupEntry<'a>,
        pub op_col_indices: wgpu::BindGroupEntry<'a>,
        pub op_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                op_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.op_row_offsets),
                },
                op_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.op_col_indices),
                },
                op_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.op_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.op_row_offsets, self.op_col_indices, self.op_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"op_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"op_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"op_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub coarse_vec: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub coarse_vec: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                coarse_vec: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.coarse_vec),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.coarse_vec]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Amg::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"coarse_vec\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Amg::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Amg::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct AmgParams {
    n: u32,
    omega: f32,
    padding: vec2<u32>,
}

@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> values: array<f32>;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> b: array<f32>;
@group(1) @binding(2) 
var<uniform> params: AmgParams;
@group(2) @binding(0) 
var<storage> op_row_offsets: array<u32>;
@group(2) @binding(1) 
var<storage> op_col_indices: array<u32>;
@group(2) @binding(2) 
var<storage> op_values: array<f32>;
@group(3) @binding(0) 
var<storage, read_write> coarse_vec: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn smooth_op(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sigma: f32 = 0f;
    var diag: f32 = 1f;
    var k: u32;

    let i = global_id.x;
    let _e6 = params.n;
    if (i >= _e6) {
        return;
    }
    let start = row_offsets[i];
    let end = row_offsets[(i + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let val = values[_e24];
            if (col == i) {
                diag = val;
            } else {
                let _e32 = x[col];
                let _e34 = sigma;
                sigma = (_e34 + (val * _e32));
            }
        }
        continuing {
            let _e37 = k;
            k = (_e37 + 1u);
        }
    }
    let _e39 = diag;
    if (abs(_e39) < 0.00000000000001f) {
        diag = 1f;
    }
    let _e46 = b[i];
    let _e47 = sigma;
    let _e49 = diag;
    let x_new = ((_e46 - _e47) / _e49);
    let _e55 = x[i];
    let _e58 = params.omega;
    x[i] = mix(_e55, x_new, _e58);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn prolongate_op(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var correction: f32 = 0f;
    var k_1: u32;

    let i_1 = global_id_1.x;
    let _e5 = params.n;
    if (i_1 >= _e5) {
        return;
    }
    let start_1 = op_row_offsets[i_1];
    let end_1 = op_row_offsets[(i_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e16 = k_1;
        if (_e16 < end_1) {
        } else {
            break;
        }
        {
            let _e19 = k_1;
            let coarse_idx = op_col_indices[_e19];
            let _e23 = k_1;
            let val_1 = op_values[_e23];
            let _e29 = coarse_vec[coarse_idx];
            let _e31 = correction;
            correction = (_e31 + (val_1 * _e29));
        }
        continuing {
            let _e34 = k_1;
            k_1 = (_e34 + 1u);
        }
    }
    let _e38 = correction;
    let _e39 = x[i_1];
    x[i_1] = (_e39 + _e38);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn restrict_residual(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_2: u32;
    var ax: f32;
    var j: u32;

    let i_2 = global_id_2.x;
    let _e5 = params.n;
    if (i_2 >= _e5) {
        return;
    }
    let start_2 = op_row_offsets[i_2];
    let end_2 = op_row_offsets[(i_2 + 1u)];
    k_2 = start_2;
    loop {
        let _e16 = k_2;
        if (_e16 < end_2) {
        } else {
            break;
        }
        {
            let _e19 = k_2;
            let fine_idx = op_col_indices[_e19];
            let _e23 = k_2;
            let r_val = op_values[_e23];
            let a_start = row_offsets[fine_idx];
            let a_end = row_offsets[(fine_idx + 1u)];
            ax = 0f;
            j = a_start;
            loop {
                let _e37 = j;
                if (_e37 < a_end) {
                } else {
                    break;
                }
                {
                    let _e40 = j;
                    let _e42 = values[_e40];
                    let _e45 = j;
                    let _e47 = col_indices[_e45];
                    let _e49 = x[_e47];
                    let _e51 = ax;
                    ax = (_e51 + (_e42 * _e49));
                }
                continuing {
                    let _e54 = j;
                    j = (_e54 + 1u);
                }
            }
            let _e58 = b[fine_idx];
            let _e59 = ax;
            let fine_r = (_e58 - _e59);
            let _e63 = sum;
            sum = (_e63 + (r_val * fine_r));
        }
        continuing {
            let _e66 = k_2;
            k_2 = (_e66 + 1u);
        }
    }
    let _e70 = sum;
    coarse_vec[i_2] = _e70;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn clear(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    let i_3 = global_id_3.x;
    let _e4 = params.n;
    if (i_3 >= _e4) {
        return;
    }
    x[i_3] = 0f;
    return;
}
"#;
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for amg::AmgParams {}
    unsafe impl bytemuck::Pod for amg::AmgParams {}
    unsafe impl bytemuck::Zeroable for amg_pack::PackParams {}
    unsafe impl bytemuck::Pod for amg_pack::PackParams {}
    unsafe impl bytemuck::Zeroable for block_precond::GmresParams {}
    unsafe impl bytemuck::Pod for block_precond::GmresParams {}
    unsafe impl bytemuck::Zeroable for block_precond::IterParams {}
    unsafe impl bytemuck::Pod for block_precond::IterParams {}
    unsafe impl bytemuck::Zeroable for dot_product::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product::SolverParams {}
    unsafe impl bytemuck::Zeroable for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Pod for dot_product_pair::SolverParams {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::dp_init_incompressible_momentum_generic::Constants {}
    unsafe impl bytemuck::Pod for generated::dp_init_incompressible_momentum_generic::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_gradients_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_gradients_incompressible_momentum_generic::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::flux_module_gradients_incompressible_momentum_generic::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable for generated::flux_module_incompressible_momentum_generic::Vector2 {}
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum_generic::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::flux_module_incompressible_momentum_generic::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::flux_module_incompressible_momentum_generic::Constants {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Vector2 {}
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_generic_diffusion_demo::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Vector2
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_assembly_incompressible_momentum::Vector2 {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum_generic::Vector2
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum_generic::Vector2
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_assembly_incompressible_momentum_generic::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_assembly_incompressible_momentum_generic::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_compressible::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_generic_diffusion_demo::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_generic_diffusion_demo_neumann::Constants
    {
    }
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum::Constants
    {
    }
    unsafe impl bytemuck::Pod for generated::generic_coupled_update_incompressible_momentum::Constants {}
    unsafe impl bytemuck::Zeroable
        for generated::generic_coupled_update_incompressible_momentum_generic::Constants
    {
    }
    unsafe impl bytemuck::Pod
        for generated::generic_coupled_update_incompressible_momentum_generic::Constants
    {
    }
    unsafe impl bytemuck::Zeroable for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Pod for generic_coupled_schur_setup::SetupParams {}
    unsafe impl bytemuck::Zeroable for gmres_cgs::Params {}
    unsafe impl bytemuck::Pod for gmres_cgs::Params {}
    unsafe impl bytemuck::Zeroable for gmres_logic::IterParams {}
    unsafe impl bytemuck::Pod for gmres_logic::IterParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Pod for gmres_ops::GmresParams {}
    unsafe impl bytemuck::Zeroable for gmres_ops::IterParams {}
    unsafe impl bytemuck::Pod for gmres_ops::IterParams {}
    unsafe impl bytemuck::Zeroable for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Pod for linear_solver::GpuScalars {}
    unsafe impl bytemuck::Zeroable for linear_solver::SolverParams {}
    unsafe impl bytemuck::Pod for linear_solver::SolverParams {}
    unsafe impl bytemuck::Zeroable for preconditioner::GpuScalars {}
    unsafe impl bytemuck::Pod for preconditioner::GpuScalars {}
    unsafe impl bytemuck::Zeroable for preconditioner::SolverParams {}
    unsafe impl bytemuck::Pod for preconditioner::SolverParams {}
    unsafe impl bytemuck::Zeroable for preconditioner::PrecondParams {}
    unsafe impl bytemuck::Pod for preconditioner::PrecondParams {}
    unsafe impl bytemuck::Zeroable for scalars::GpuScalars {}
    unsafe impl bytemuck::Pod for scalars::GpuScalars {}
    unsafe impl bytemuck::Zeroable for scalars::ReduceParams {}
    unsafe impl bytemuck::Pod for scalars::ReduceParams {}
    unsafe impl bytemuck::Zeroable for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond::PrecondParams {}
    unsafe impl bytemuck::Zeroable for schur_precond_generic::PrecondParams {}
    unsafe impl bytemuck::Pod for schur_precond_generic::PrecondParams {}
}
pub mod amg_pack {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PackParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub component: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PackParams {
        pub const fn new(num_cells: u32, component: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                num_cells,
                component,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const PACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_pack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline pack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("pack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UNPACK_COMPONENT_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_unpack_component_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline unpack_component"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("unpack_component"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_PACK_COMPONENT: &str = "pack_component";
    pub const ENTRY_UNPACK_COMPONENT: &str = "unpack_component";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub input_buf: wgpu::BufferBinding<'a>,
        pub output_buf: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub input_buf: wgpu::BindGroupEntry<'a>,
        pub output_buf: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                input_buf: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.input_buf),
                },
                output_buf: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.output_buf),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.input_buf, self.output_buf]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"input_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"output_buf\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("AmgPack::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::amg_pack::PackParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("AmgPack::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("AmgPack::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("amg_pack.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PackParams {
    num_cells: u32,
    component: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> input_buf: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> output_buf: array<f32>;
@group(1) @binding(0) 
var<uniform> params: PackParams;

@compute @workgroup_size(64, 1, 1) 
fn pack_component(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let _e4 = params.num_cells;
    if (idx >= _e4) {
        return;
    }
    let _e10 = params.component;
    let base = ((idx * 4u) + _e10);
    let _e16 = input_buf[base];
    output_buf[idx] = _e16;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn unpack_component(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    let idx_1 = global_id_1.x;
    let _e4 = params.num_cells;
    if (idx_1 >= _e4) {
        return;
    }
    let _e10 = params.component;
    let base_1 = ((idx_1 * 4u) + _e10);
    let _e16 = input_buf[idx_1];
    output_buf[base_1] = _e16;
    return;
}
"#;
}
pub mod block_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_BLOCK_INV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_block_inv_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_block_inv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_block_inv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const APPLY_BLOCK_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_apply_block_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline apply_block_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("apply_block_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_BLOCK_INV: &str = "build_block_inv";
    pub const ENTRY_APPLY_BLOCK_PRECOND: &str = "apply_block_precond";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.block_inv]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BlockPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::block_precond::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BlockPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("BlockPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("block_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 1000000000000f);
    }
    return 0f;
}

fn swap_rows(a_1: ptr<function, array<array<f32, 4>, 4>>, b: ptr<function, array<array<f32, 4>, 4>>, r0_: u32, r1_: u32) {
    var c_5: u32 = 0u;

    if (r0_ == r1_) {
        return;
    }
    loop {
        let _e5 = c_5;
        if (_e5 < 4u) {
        } else {
            break;
        }
        {
            let _e10 = c_5;
            let tmp = (*a_1)[r0_][_e10];
            let _e14 = c_5;
            let _e17 = c_5;
            let _e19 = (*a_1)[r1_][_e17];
            (*a_1)[r0_][_e14] = _e19;
            let _e21 = c_5;
            (*a_1)[r1_][_e21] = tmp;
            let _e25 = c_5;
            let tmp_b = (*b)[r0_][_e25];
            let _e29 = c_5;
            let _e32 = c_5;
            let _e34 = (*b)[r1_][_e32];
            (*b)[r0_][_e29] = _e34;
            let _e36 = c_5;
            (*b)[r1_][_e36] = tmp_b;
        }
        continuing {
            let _e38 = c_5;
            c_5 = (_e38 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn build_block_inv(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var a: array<array<f32, 4>, 4>;
    var inv: array<array<f32, 4>, 4>;
    var diag_orig: array<f32, 4>;
    var r: u32 = 0u;
    var c: u32;
    var k: u32;
    var singular: bool = false;
    var i: u32 = 0u;
    var pivot: u32;
    var pivot_val: f32;
    var r_1: u32;
    var piv: f32;
    var c_1: u32;
    var r_2: u32;
    var c_2: u32;
    var r_3: u32 = 0u;
    var c_3: u32;
    var r_4: u32 = 0u;
    var c_4: u32;

    let cell = global_id.x;
    let _e6 = params.num_cells;
    if (cell >= _e6) {
        return;
    }
    let base = (cell * 4u);
    loop {
        let _e11 = r;
        if (_e11 < 4u) {
        } else {
            break;
        }
        {
            c = 0u;
            loop {
                let _e16 = c;
                if (_e16 < 4u) {
                } else {
                    break;
                }
                {
                    let _e20 = r;
                    let _e22 = c;
                    a[_e20][_e22] = 0f;
                    let _e26 = r;
                    let _e28 = c;
                    inv[_e26][_e28] = 0f;
                }
                continuing {
                    let _e31 = c;
                    c = (_e31 + 1u);
                }
            }
            let _e34 = r;
            let row = (base + _e34);
            let start = row_offsets[row];
            let end = row_offsets[(row + 1u)];
            k = start;
            loop {
                let _e45 = k;
                if (_e45 < end) {
                } else {
                    break;
                }
                {
                    let _e48 = k;
                    let col = col_indices[_e48];
                    if ((col >= base) && (col < (base + 4u))) {
                        let local = (col - base);
                        let _e57 = r;
                        let _e61 = k;
                        let _e63 = matrix_values[_e61];
                        a[_e57][local] = _e63;
                    }
                }
                continuing {
                    let _e64 = k;
                    k = (_e64 + 1u);
                }
            }
            let _e67 = r;
            let _e69 = r;
            inv[_e67][_e69] = 1f;
            let _e73 = r;
            let _e75 = r;
            let _e77 = r;
            let _e79 = a[_e75][_e77];
            diag_orig[_e73] = _e79;
        }
        continuing {
            let _e80 = r;
            r = (_e80 + 1u);
        }
    }
    loop {
        let _e84 = i;
        if (_e84 < 4u) {
        } else {
            break;
        }
        {
            let _e87 = i;
            pivot = _e87;
            let _e89 = i;
            let _e91 = i;
            let _e93 = a[_e89][_e91];
            pivot_val = abs(_e93);
            let _e96 = i;
            r_1 = (_e96 + 1u);
            loop {
                let _e100 = r_1;
                if (_e100 < 4u) {
                } else {
                    break;
                }
                {
                    let _e103 = r_1;
                    let _e105 = i;
                    let _e107 = a[_e103][_e105];
                    let val_1 = abs(_e107);
                    let _e109 = pivot_val;
                    if (val_1 > _e109) {
                        pivot_val = val_1;
                        let _e111 = r_1;
                        pivot = _e111;
                    }
                }
                continuing {
                    let _e112 = r_1;
                    r_1 = (_e112 + 1u);
                }
            }
            let _e115 = pivot_val;
            if (_e115 < 0.000000000001f) {
                singular = true;
            }
            let _e120 = i;
            let _e121 = pivot;
            swap_rows((&a), (&inv), _e120, _e121);
            let _e122 = i;
            let _e124 = i;
            let _e126 = a[_e122][_e124];
            piv = _e126;
            let _e128 = piv;
            if (abs(_e128) < 0.000000000001f) {
                let _e132 = piv;
                piv = select(0.000000000001f, -0.000000000001f, (_e132 < 0f));
            }
            let _e138 = piv;
            let inv_piv = (1f / _e138);
            c_1 = 0u;
            loop {
                let _e143 = c_1;
                if (_e143 < 4u) {
                } else {
                    break;
                }
                {
                    let _e146 = i;
                    let _e148 = c_1;
                    let _e150 = i;
                    let _e152 = c_1;
                    let _e154 = a[_e150][_e152];
                    a[_e146][_e148] = (_e154 * inv_piv);
                    let _e156 = i;
                    let _e158 = c_1;
                    let _e160 = i;
                    let _e162 = c_1;
                    let _e164 = inv[_e160][_e162];
                    inv[_e156][_e158] = (_e164 * inv_piv);
                }
                continuing {
                    let _e166 = c_1;
                    c_1 = (_e166 + 1u);
                }
            }
            r_2 = 0u;
            loop {
                let _e171 = r_2;
                if (_e171 < 4u) {
                } else {
                    break;
                }
                {
                    let _e174 = r_2;
                    let _e175 = i;
                    if (_e174 == _e175) {
                        continue;
                    }
                    let _e177 = r_2;
                    let _e179 = i;
                    let factor = a[_e177][_e179];
                    c_2 = 0u;
                    loop {
                        let _e184 = c_2;
                        if (_e184 < 4u) {
                        } else {
                            break;
                        }
                        {
                            let _e187 = r_2;
                            let _e189 = c_2;
                            let _e191 = r_2;
                            let _e193 = c_2;
                            let _e195 = a[_e191][_e193];
                            let _e196 = i;
                            let _e198 = c_2;
                            let _e200 = a[_e196][_e198];
                            a[_e187][_e189] = (_e195 - (factor * _e200));
                            let _e203 = r_2;
                            let _e205 = c_2;
                            let _e207 = r_2;
                            let _e209 = c_2;
                            let _e211 = inv[_e207][_e209];
                            let _e212 = i;
                            let _e214 = c_2;
                            let _e216 = inv[_e212][_e214];
                            inv[_e203][_e205] = (_e211 - (factor * _e216));
                        }
                        continuing {
                            let _e219 = c_2;
                            c_2 = (_e219 + 1u);
                        }
                    }
                }
                continuing {
                    let _e222 = r_2;
                    r_2 = (_e222 + 1u);
                }
            }
        }
        continuing {
            let _e225 = i;
            i = (_e225 + 1u);
        }
    }
    let _e228 = singular;
    if _e228 {
        loop {
            let _e230 = r_3;
            if (_e230 < 4u) {
            } else {
                break;
            }
            {
                c_3 = 0u;
                loop {
                    let _e235 = c_3;
                    if (_e235 < 4u) {
                    } else {
                        break;
                    }
                    {
                        let _e238 = r_3;
                        let _e240 = c_3;
                        inv[_e238][_e240] = 0f;
                    }
                    continuing {
                        let _e243 = c_3;
                        c_3 = (_e243 + 1u);
                    }
                }
                let _e246 = r_3;
                let _e248 = r_3;
                let _e250 = r_3;
                let _e252 = diag_orig[_e250];
                let _e253 = safe_inverse(_e252);
                inv[_e246][_e248] = _e253;
            }
            continuing {
                let _e254 = r_3;
                r_3 = (_e254 + 1u);
            }
        }
    }
    let offset = (cell * 16u);
    loop {
        let _e260 = r_4;
        if (_e260 < 4u) {
        } else {
            break;
        }
        {
            c_4 = 0u;
            loop {
                let _e265 = c_4;
                if (_e265 < 4u) {
                } else {
                    break;
                }
                {
                    let _e268 = r_4;
                    let _e273 = c_4;
                    let _e276 = r_4;
                    let _e278 = c_4;
                    let _e280 = inv[_e276][_e278];
                    block_inv[((offset + (_e268 * 4u)) + _e273)] = _e280;
                }
                continuing {
                    let _e281 = c_4;
                    c_4 = (_e281 + 1u);
                }
            }
        }
        continuing {
            let _e284 = r_4;
            r_4 = (_e284 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn apply_block_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    let cell_1 = global_id_1.x;
    let _e4 = params.num_cells;
    if (cell_1 >= _e4) {
        return;
    }
    let base_1 = (cell_1 * 4u);
    let offset_1 = (cell_1 * 16u);
    let x0_ = vec_x[(base_1 + 0u)];
    let x1_ = vec_x[(base_1 + 1u)];
    let x2_ = vec_x[(base_1 + 2u)];
    let x3_ = vec_x[(base_1 + 3u)];
    let _e34 = block_inv[(offset_1 + 0u)];
    let _e40 = block_inv[(offset_1 + 1u)];
    let _e47 = block_inv[(offset_1 + 2u)];
    let _e54 = block_inv[(offset_1 + 3u)];
    let y0_ = ((((_e34 * x0_) + (_e40 * x1_)) + (_e47 * x2_)) + (_e54 * x3_));
    let _e61 = block_inv[(offset_1 + 4u)];
    let _e67 = block_inv[(offset_1 + 5u)];
    let _e74 = block_inv[(offset_1 + 6u)];
    let _e81 = block_inv[(offset_1 + 7u)];
    let y1_ = ((((_e61 * x0_) + (_e67 * x1_)) + (_e74 * x2_)) + (_e81 * x3_));
    let _e88 = block_inv[(offset_1 + 8u)];
    let _e94 = block_inv[(offset_1 + 9u)];
    let _e101 = block_inv[(offset_1 + 10u)];
    let _e108 = block_inv[(offset_1 + 11u)];
    let y2_ = ((((_e88 * x0_) + (_e94 * x1_)) + (_e101 * x2_)) + (_e108 * x3_));
    let _e115 = block_inv[(offset_1 + 12u)];
    let _e121 = block_inv[(offset_1 + 13u)];
    let _e128 = block_inv[(offset_1 + 14u)];
    let _e135 = block_inv[(offset_1 + 15u)];
    let y3_ = ((((_e115 * x0_) + (_e121 * x1_)) + (_e128 * x2_)) + (_e135 * x3_));
    vec_y[(base_1 + 0u)] = y0_;
    vec_y[(base_1 + 1u)] = y1_;
    vec_y[(base_1 + 2u)] = y2_;
    vec_y[(base_1 + 3u)] = y3_;
    return;
}
"#;
}
pub mod dot_product {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result: wgpu::BufferBinding<'a>,
        pub dot_a: wgpu::BufferBinding<'a>,
        pub dot_b: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result: wgpu::BindGroupEntry<'a>,
        pub dot_a: wgpu::BindGroupEntry<'a>,
        pub dot_b: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result),
                },
                dot_a: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_a),
                },
                dot_b: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_b),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.dot_result, self.dot_a, self.dot_b]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProduct::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProduct::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProduct::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result: array<f32>;
@group(1) @binding(1) 
var<storage> dot_a: array<f32>;
@group(1) @binding(2) 
var<storage> dot_b: array<f32>;
var<workgroup> scratch: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>) {
    var val: f32 = 0f;
    var i: u32 = 32u;

    let idx = global_id.x;
    let lid = local_id.x;
    let _e8 = params.n;
    if (idx < _e8) {
        let _e12 = dot_a[idx];
        let _e15 = dot_b[idx];
        val = (_e12 * _e15);
    }
    let _e20 = val;
    scratch[lid] = _e20;
    workgroupBarrier();
    loop {
        let _e22 = i;
        if (_e22 > 0u) {
        } else {
            break;
        }
        {
            let _e25 = i;
            if (lid < _e25) {
                let _e30 = i;
                let _e33 = scratch[(lid + _e30)];
                let _e34 = scratch[lid];
                scratch[lid] = (_e34 + _e33);
            }
            workgroupBarrier();
        }
        continuing {
            let _e37 = i;
            i = (_e37 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e47 = scratch[0];
        dot_result[group_id.x] = _e47;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod dot_product_pair {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_main_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline main"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("main"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_MAIN: &str = "main";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::dot_product_pair::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub dot_result_a: wgpu::BufferBinding<'a>,
        pub dot_result_b: wgpu::BufferBinding<'a>,
        pub dot_a0: wgpu::BufferBinding<'a>,
        pub dot_b0: wgpu::BufferBinding<'a>,
        pub dot_a1: wgpu::BufferBinding<'a>,
        pub dot_b1: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub dot_result_a: wgpu::BindGroupEntry<'a>,
        pub dot_result_b: wgpu::BindGroupEntry<'a>,
        pub dot_a0: wgpu::BindGroupEntry<'a>,
        pub dot_b0: wgpu::BindGroupEntry<'a>,
        pub dot_a1: wgpu::BindGroupEntry<'a>,
        pub dot_b1: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                dot_result_a: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_a),
                },
                dot_result_b: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_b),
                },
                dot_a0: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_a0),
                },
                dot_b0: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.dot_b0),
                },
                dot_a1: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.dot_a1),
                },
                dot_b1: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.dot_b1),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [
                self.dot_result_a,
                self.dot_result_b,
                self.dot_a0,
                self.dot_b0,
                self.dot_a1,
                self.dot_b1,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("DotProductPair::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"dot_result_a\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_b\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_a0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"dot_b0\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"dot_a1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"dot_b1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("DotProductPair::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("DotProductPair::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("dot_product_pair.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SolverParams {
    n: u32,
}

@group(0) @binding(0) 
var<uniform> params: SolverParams;
@group(1) @binding(0) 
var<storage, read_write> dot_result_a: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> dot_result_b: array<f32>;
@group(1) @binding(2) 
var<storage> dot_a0_: array<f32>;
@group(1) @binding(3) 
var<storage> dot_b0_: array<f32>;
@group(1) @binding(4) 
var<storage> dot_a1_: array<f32>;
@group(1) @binding(5) 
var<storage> dot_b1_: array<f32>;
var<workgroup> scratch_a: array<f32, 64>;
var<workgroup> scratch_b: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>) {
    var val0_: f32 = 0f;
    var val1_: f32 = 0f;
    var offset: u32 = 32u;

    let idx = global_id.x;
    let lid = local_id.x;
    let _e8 = params.n;
    if (idx < _e8) {
        let _e12 = dot_a0_[idx];
        let _e15 = dot_b0_[idx];
        val0_ = (_e12 * _e15);
        let _e20 = dot_a1_[idx];
        let _e23 = dot_b1_[idx];
        val1_ = (_e20 * _e23);
    }
    let _e28 = val0_;
    scratch_a[lid] = _e28;
    let _e31 = val1_;
    scratch_b[lid] = _e31;
    workgroupBarrier();
    loop {
        let _e33 = offset;
        if (lid < _e33) {
            let _e38 = offset;
            let _e41 = scratch_a[(lid + _e38)];
            let _e42 = scratch_a[lid];
            scratch_a[lid] = (_e42 + _e41);
            let _e47 = offset;
            let _e50 = scratch_b[(lid + _e47)];
            let _e51 = scratch_b[lid];
            scratch_b[lid] = (_e51 + _e50);
        }
        workgroupBarrier();
        let _e53 = offset;
        if (_e53 == 1u) {
            break;
        }
        let _e56 = offset;
        offset = (_e56 >> 1u);
    }
    if (lid == 0u) {
        let _e67 = scratch_a[0];
        dot_result_a[group_id.x] = _e67;
        let _e73 = scratch_b[0];
        dot_result_b[group_id.x] = _e73;
        return;
    } else {
        return;
    }
}
"#;
}
pub mod generated {
    use super::{_root, _root::*};
    pub mod dp_init_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedDpInitIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::dp_init_incompressible_momentum::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e9 = constants.density;
    let rho = max(_e9, 0.000000000001f);
    let _e14 = constants.dt;
    let dt = max(_e14, 0f);
    let _e19 = cell_vols[idx];
    let vol = max(_e19, 0.000000000001f);
    let d_p = (dt / (rho * vol));
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod dp_init_incompressible_momentum_generic {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                }
            }
        }
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.cell_vols, self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpInitIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: dp_init_incompressible_momentum_generic :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpInitIncompressibleMomentumGeneric::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpInitIncompressibleMomentumGeneric::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_init_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}

const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;

@group(0) @binding(0) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(2) 
var<uniform> constants: Constants;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e9 = constants.density;
    let rho = max(_e9, 0.000000000001f);
    let _e14 = constants.dt;
    let dt = max(_e14, 0f);
    let _e19 = cell_vols[idx];
    let vol = max(_e19, 0.000000000001f);
    let d_p = (dt / (rho * vol));
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum {
        use super::{_root, _root::*};
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const UNKNOWNS_PER_CELL: u32 = 3u32;
        pub const U_LEN: u32 = 2u32;
        pub const U_0: u32 = 0u32;
        pub const U_1: u32 = 1u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedDpUpdateFromDiagIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;
const UNKNOWNS_PER_CELL: u32 = 3u;
const U_LEN: u32 = 2u;
const U_0_: u32 = 0u;
const U_1_: u32 = 1u;

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum_u_inv: f32 = 0f;

    let idx = global_id.x;
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let scalar_offset = scalar_row_offsets[idx];
    let scalar_end = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e19 = diagonal_indices[idx];
    let diag_rank = (_e19 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let row_stride = (num_neighbors * UNKNOWNS_PER_CELL);
    {
        let start_row_u = (start_row_0_ + (U_0_ * row_stride));
        let diag_u = matrix_values[((start_row_u + (diag_rank * UNKNOWNS_PER_CELL)) + U_0_)];
        let _e35 = safe_inverse(diag_u);
        let _e37 = sum_u_inv;
        sum_u_inv = (_e37 + _e35);
    }
    {
        let start_row_u_1 = (start_row_0_ + (U_1_ * row_stride));
        let diag_u_1 = matrix_values[((start_row_u_1 + (diag_rank * UNKNOWNS_PER_CELL)) + U_1_)];
        let _e49 = safe_inverse(diag_u_1);
        let _e50 = sum_u_inv;
        sum_u_inv = (_e50 + _e49);
    }
    let _e52 = sum_u_inv;
    let d_p = (_e52 / 2f);
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod dp_update_from_diag_incompressible_momentum_generic {
        use super::{_root, _root::*};
        pub const STATE_STRIDE: u32 = 8u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const UNKNOWNS_PER_CELL: u32 = 3u32;
        pub const U_LEN: u32 = 2u32;
        pub const U_0: u32 = 0u32;
        pub const U_1: u32 = 1u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    state: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
                [
                    self.scalar_row_offsets,
                    self.diagonal_indices,
                    self.matrix_values,
                    self.state,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedDpUpdateFromDiagIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedDpUpdateFromDiagIncompressibleMomentumGeneric::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedDpUpdateFromDiagIncompressibleMomentumGeneric::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("dp_update_from_diag_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
const STATE_STRIDE: u32 = 8u;
const D_P_OFFSET: u32 = 3u;
const UNKNOWNS_PER_CELL: u32 = 3u;
const U_LEN: u32 = 2u;
const U_0_: u32 = 0u;
const U_1_: u32 = 1u;

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> state: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum_u_inv: f32 = 0f;

    let idx = global_id.x;
    let num_cells = (arrayLength((&scalar_row_offsets)) - 1u);
    if (idx >= num_cells) {
        return;
    }
    let scalar_offset = scalar_row_offsets[idx];
    let scalar_end = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e19 = diagonal_indices[idx];
    let diag_rank = (_e19 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let row_stride = (num_neighbors * UNKNOWNS_PER_CELL);
    {
        let start_row_u = (start_row_0_ + (U_0_ * row_stride));
        let diag_u = matrix_values[((start_row_u + (diag_rank * UNKNOWNS_PER_CELL)) + U_0_)];
        let _e35 = safe_inverse(diag_u);
        let _e37 = sum_u_inv;
        sum_u_inv = (_e37 + _e35);
    }
    {
        let start_row_u_1 = (start_row_0_ + (U_1_ * row_stride));
        let diag_u_1 = matrix_values[((start_row_u_1 + (diag_rank * UNKNOWNS_PER_CELL)) + U_1_)];
        let _e49 = safe_inverse(diag_u_1);
        let _e50 = sum_u_inv;
        sum_u_inv = (_e50 + _e49);
    }
    let _e52 = sum_u_inv;
    let d_p = (_e52 / 2f);
    state[((idx * STATE_STRIDE) + D_P_OFFSET)] = d_p;
    return;
}
"#;
    }
    pub mod flux_module_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"state\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"state_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"state_old_old\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"fluxes\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"constants\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Uniform,
                                has_dynamic_offset: false,
                                min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                    _root::generated::flux_module_compressible::Constants,
                                >(
                                )
                                    as _),
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = (neighbor == -1i);
    neigh_idx = owner;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary {
        c_neigh_vec = face_center_vec;
    }
    let d_own = distance(c_owner_vec, face_center_vec);
    let _e69 = c_neigh_vec;
    let d_neigh = distance(_e69, face_center_vec);
    let total_dist = (d_own + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e76 = lambda;
    let lambda_other = (1f - _e76);
    let _e79 = c_neigh_vec;
    let d_vec = (_e79 - c_owner_vec);
    let _e81 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e81));
    let dist = max(dist_proj, 0.000001f);
    let _e92 = state[((owner * 8u) + 1u)];
    let _e99 = state[((owner * 8u) + 2u)];
    let _e111 = state[((owner * 8u) + 1u)];
    let _e118 = state[((owner * 8u) + 2u)];
    let _e133 = state[((owner * 8u) + 0u)];
    let _e136 = normal_vec;
    let _e140 = constants.eos_gamma;
    let _e147 = state[((owner * 8u) + 4u)];
    let _e155 = state[((owner * 8u) + 0u)];
    let _e159 = constants.eos_dp_drho;
    let _e163 = neigh_idx;
    let _e170 = state[((_e163 * 8u) + 1u)];
    let _e177 = state[((owner * 8u) + 1u)];
    let _e184 = bc_value[((idx * 8u) + 1u)];
    let _e191 = bc_kind[((idx * 8u) + 1u)];
    let _e201 = state[((owner * 8u) + 1u)];
    let _e208 = bc_value[((idx * 8u) + 1u)];
    let _e217 = bc_kind[((idx * 8u) + 1u)];
    let _e222 = neigh_idx;
    let _e229 = state[((_e222 * 8u) + 2u)];
    let _e236 = state[((owner * 8u) + 2u)];
    let _e243 = bc_value[((idx * 8u) + 2u)];
    let _e250 = bc_kind[((idx * 8u) + 2u)];
    let _e260 = state[((owner * 8u) + 2u)];
    let _e267 = bc_value[((idx * 8u) + 2u)];
    let _e276 = bc_kind[((idx * 8u) + 2u)];
    let _e286 = neigh_idx;
    let _e293 = state[((_e286 * 8u) + 1u)];
    let _e300 = state[((owner * 8u) + 1u)];
    let _e307 = bc_value[((idx * 8u) + 1u)];
    let _e314 = bc_kind[((idx * 8u) + 1u)];
    let _e324 = state[((owner * 8u) + 1u)];
    let _e331 = bc_value[((idx * 8u) + 1u)];
    let _e340 = bc_kind[((idx * 8u) + 1u)];
    let _e345 = neigh_idx;
    let _e352 = state[((_e345 * 8u) + 2u)];
    let _e359 = state[((owner * 8u) + 2u)];
    let _e366 = bc_value[((idx * 8u) + 2u)];
    let _e373 = bc_kind[((idx * 8u) + 2u)];
    let _e383 = state[((owner * 8u) + 2u)];
    let _e390 = bc_value[((idx * 8u) + 2u)];
    let _e399 = bc_kind[((idx * 8u) + 2u)];
    let _e412 = neigh_idx;
    let _e419 = state[((_e412 * 8u) + 0u)];
    let _e426 = state[((owner * 8u) + 0u)];
    let _e433 = bc_value[((idx * 8u) + 0u)];
    let _e440 = bc_kind[((idx * 8u) + 0u)];
    let _e450 = state[((owner * 8u) + 0u)];
    let _e457 = bc_value[((idx * 8u) + 0u)];
    let _e466 = bc_kind[((idx * 8u) + 0u)];
    let _e473 = normal_vec;
    let _e477 = constants.eos_gamma;
    let _e478 = neigh_idx;
    let _e485 = state[((_e478 * 8u) + 4u)];
    let _e492 = state[((owner * 8u) + 4u)];
    let _e499 = bc_value[((idx * 8u) + 6u)];
    let _e506 = bc_kind[((idx * 8u) + 6u)];
    let _e516 = state[((owner * 8u) + 4u)];
    let _e523 = bc_value[((idx * 8u) + 6u)];
    let _e532 = bc_kind[((idx * 8u) + 6u)];
    let _e538 = neigh_idx;
    let _e545 = state[((_e538 * 8u) + 0u)];
    let _e552 = state[((owner * 8u) + 0u)];
    let _e559 = bc_value[((idx * 8u) + 0u)];
    let _e566 = bc_kind[((idx * 8u) + 0u)];
    let _e576 = state[((owner * 8u) + 0u)];
    let _e583 = bc_value[((idx * 8u) + 0u)];
    let _e592 = bc_kind[((idx * 8u) + 0u)];
    let _e600 = constants.eos_dp_drho;
    let a_plus = max(0f, max((dot(((vec2<f32>(dot(vec2<f32>(_e92, _e99), vec2<f32>(1f, 0f)), dot(vec2<f32>(_e111, _e118), vec2<f32>(0f, 1f))) * 1f) / vec2(_e133)), _e136) + sqrt((((_e140 * _e147) / _e155) + _e159))), (dot(((vec2<f32>(dot(vec2<f32>(select(_e170, select(select(_e177, _e184, (_e191 == 1u)), (_e201 + (_e208 * d_own)), (_e217 == 2u)), is_boundary), select(_e229, select(select(_e236, _e243, (_e250 == 1u)), (_e260 + (_e267 * d_own)), (_e276 == 2u)), is_boundary)), vec2<f32>(1f, 0f)), dot(vec2<f32>(select(_e293, select(select(_e300, _e307, (_e314 == 1u)), (_e324 + (_e331 * d_own)), (_e340 == 2u)), is_boundary), select(_e352, select(select(_e359, _e366, (_e373 == 1u)), (_e383 + (_e390 * d_own)), (_e399 == 2u)), is_boundary)), vec2<f32>(0f, 1f))) * 1f) / vec2(select(_e419, select(select(_e426, _e433, (_e440 == 1u)), (_e450 + (_e457 * d_own)), (_e466 == 2u)), is_boundary))), _e473) + sqrt((((_e477 * select(_e485, select(select(_e492, _e499, (_e506 == 1u)), (_e516 + (_e523 * d_own)), (_e532 == 2u)), is_boundary)) / select(_e545, select(select(_e552, _e559, (_e566 == 1u)), (_e576 + (_e583 * d_own)), (_e592 == 2u)), is_boundary)) + _e600)))));
    let _e613 = state[((owner * 8u) + 1u)];
    let _e620 = state[((owner * 8u) + 2u)];
    let _e632 = state[((owner * 8u) + 1u)];
    let _e639 = state[((owner * 8u) + 2u)];
    let _e654 = state[((owner * 8u) + 0u)];
    let _e657 = normal_vec;
    let _e661 = constants.eos_gamma;
    let _e668 = state[((owner * 8u) + 4u)];
    let _e676 = state[((owner * 8u) + 0u)];
    let _e680 = constants.eos_dp_drho;
    let _e684 = neigh_idx;
    let _e691 = state[((_e684 * 8u) + 1u)];
    let _e698 = state[((owner * 8u) + 1u)];
    let _e705 = bc_value[((idx * 8u) + 1u)];
    let _e712 = bc_kind[((idx * 8u) + 1u)];
    let _e722 = state[((owner * 8u) + 1u)];
    let _e729 = bc_value[((idx * 8u) + 1u)];
    let _e738 = bc_kind[((idx * 8u) + 1u)];
    let _e743 = neigh_idx;
    let _e750 = state[((_e743 * 8u) + 2u)];
    let _e757 = state[((owner * 8u) + 2u)];
    let _e764 = bc_value[((idx * 8u) + 2u)];
    let _e771 = bc_kind[((idx * 8u) + 2u)];
    let _e781 = state[((owner * 8u) + 2u)];
    let _e788 = bc_value[((idx * 8u) + 2u)];
    let _e797 = bc_kind[((idx * 8u) + 2u)];
    let _e807 = neigh_idx;
    let _e814 = state[((_e807 * 8u) + 1u)];
    let _e821 = state[((owner * 8u) + 1u)];
    let _e828 = bc_value[((idx * 8u) + 1u)];
    let _e835 = bc_kind[((idx * 8u) + 1u)];
    let _e845 = state[((owner * 8u) + 1u)];
    let _e852 = bc_value[((idx * 8u) + 1u)];
    let _e861 = bc_kind[((idx * 8u) + 1u)];
    let _e866 = neigh_idx;
    let _e873 = state[((_e866 * 8u) + 2u)];
    let _e880 = state[((owner * 8u) + 2u)];
    let _e887 = bc_value[((idx * 8u) + 2u)];
    let _e894 = bc_kind[((idx * 8u) + 2u)];
    let _e904 = state[((owner * 8u) + 2u)];
    let _e911 = bc_value[((idx * 8u) + 2u)];
    let _e920 = bc_kind[((idx * 8u) + 2u)];
    let _e933 = neigh_idx;
    let _e940 = state[((_e933 * 8u) + 0u)];
    let _e947 = state[((owner * 8u) + 0u)];
    let _e954 = bc_value[((idx * 8u) + 0u)];
    let _e961 = bc_kind[((idx * 8u) + 0u)];
    let _e971 = state[((owner * 8u) + 0u)];
    let _e978 = bc_value[((idx * 8u) + 0u)];
    let _e987 = bc_kind[((idx * 8u) + 0u)];
    let _e994 = normal_vec;
    let _e998 = constants.eos_gamma;
    let _e999 = neigh_idx;
    let _e1006 = state[((_e999 * 8u) + 4u)];
    let _e1013 = state[((owner * 8u) + 4u)];
    let _e1020 = bc_value[((idx * 8u) + 6u)];
    let _e1027 = bc_kind[((idx * 8u) + 6u)];
    let _e1037 = state[((owner * 8u) + 4u)];
    let _e1044 = bc_value[((idx * 8u) + 6u)];
    let _e1053 = bc_kind[((idx * 8u) + 6u)];
    let _e1059 = neigh_idx;
    let _e1066 = state[((_e1059 * 8u) + 0u)];
    let _e1073 = state[((owner * 8u) + 0u)];
    let _e1080 = bc_value[((idx * 8u) + 0u)];
    let _e1087 = bc_kind[((idx * 8u) + 0u)];
    let _e1097 = state[((owner * 8u) + 0u)];
    let _e1104 = bc_value[((idx * 8u) + 0u)];
    let _e1113 = bc_kind[((idx * 8u) + 0u)];
    let _e1121 = constants.eos_dp_drho;
    let a_minus = min(0f, min((dot(((vec2<f32>(dot(vec2<f32>(_e613, _e620), vec2<f32>(1f, 0f)), dot(vec2<f32>(_e632, _e639), vec2<f32>(0f, 1f))) * 1f) / vec2(_e654)), _e657) - sqrt((((_e661 * _e668) / _e676) + _e680))), (dot(((vec2<f32>(dot(vec2<f32>(select(_e691, select(select(_e698, _e705, (_e712 == 1u)), (_e722 + (_e729 * d_own)), (_e738 == 2u)), is_boundary), select(_e750, select(select(_e757, _e764, (_e771 == 1u)), (_e781 + (_e788 * d_own)), (_e797 == 2u)), is_boundary)), vec2<f32>(1f, 0f)), dot(vec2<f32>(select(_e814, select(select(_e821, _e828, (_e835 == 1u)), (_e845 + (_e852 * d_own)), (_e861 == 2u)), is_boundary), select(_e873, select(select(_e880, _e887, (_e894 == 1u)), (_e904 + (_e911 * d_own)), (_e920 == 2u)), is_boundary)), vec2<f32>(0f, 1f))) * 1f) / vec2(select(_e940, select(select(_e947, _e954, (_e961 == 1u)), (_e971 + (_e978 * d_own)), (_e987 == 2u)), is_boundary))), _e994) - sqrt((((_e998 * select(_e1006, select(select(_e1013, _e1020, (_e1027 == 1u)), (_e1037 + (_e1044 * d_own)), (_e1053 == 2u)), is_boundary)) / select(_e1066, select(select(_e1073, _e1080, (_e1087 == 1u)), (_e1097 + (_e1104 * d_own)), (_e1113 == 2u)), is_boundary)) + _e1121)))));
    let denom = max((a_plus - a_minus), 0.000001f);
    let _e1143 = state[((owner * 8u) + 0u)];
    let _e1151 = state[((owner * 8u) + 1u)];
    let _e1158 = state[((owner * 8u) + 2u)];
    let _e1170 = state[((owner * 8u) + 1u)];
    let _e1177 = state[((owner * 8u) + 2u)];
    let _e1192 = state[((owner * 8u) + 0u)];
    let _e1195 = normal_vec;
    let _e1198 = neigh_idx;
    let _e1205 = state[((_e1198 * 8u) + 0u)];
    let _e1212 = state[((owner * 8u) + 0u)];
    let _e1219 = bc_value[((idx * 8u) + 0u)];
    let _e1226 = bc_kind[((idx * 8u) + 0u)];
    let _e1236 = state[((owner * 8u) + 0u)];
    let _e1243 = bc_value[((idx * 8u) + 0u)];
    let _e1252 = bc_kind[((idx * 8u) + 0u)];
    let _e1258 = neigh_idx;
    let _e1265 = state[((_e1258 * 8u) + 1u)];
    let _e1272 = state[((owner * 8u) + 1u)];
    let _e1279 = bc_value[((idx * 8u) + 1u)];
    let _e1286 = bc_kind[((idx * 8u) + 1u)];
    let _e1296 = state[((owner * 8u) + 1u)];
    let _e1303 = bc_value[((idx * 8u) + 1u)];
    let _e1312 = bc_kind[((idx * 8u) + 1u)];
    let _e1317 = neigh_idx;
    let _e1324 = state[((_e1317 * 8u) + 2u)];
    let _e1331 = state[((owner * 8u) + 2u)];
    let _e1338 = bc_value[((idx * 8u) + 2u)];
    let _e1345 = bc_kind[((idx * 8u) + 2u)];
    let _e1355 = state[((owner * 8u) + 2u)];
    let _e1362 = bc_value[((idx * 8u) + 2u)];
    let _e1371 = bc_kind[((idx * 8u) + 2u)];
    let _e1381 = neigh_idx;
    let _e1388 = state[((_e1381 * 8u) + 1u)];
    let _e1395 = state[((owner * 8u) + 1u)];
    let _e1402 = bc_value[((idx * 8u) + 1u)];
    let _e1409 = bc_kind[((idx * 8u) + 1u)];
    let _e1419 = state[((owner * 8u) + 1u)];
    let _e1426 = bc_value[((idx * 8u) + 1u)];
    let _e1435 = bc_kind[((idx * 8u) + 1u)];
    let _e1440 = neigh_idx;
    let _e1447 = state[((_e1440 * 8u) + 2u)];
    let _e1454 = state[((owner * 8u) + 2u)];
    let _e1461 = bc_value[((idx * 8u) + 2u)];
    let _e1468 = bc_kind[((idx * 8u) + 2u)];
    let _e1478 = state[((owner * 8u) + 2u)];
    let _e1485 = bc_value[((idx * 8u) + 2u)];
    let _e1494 = bc_kind[((idx * 8u) + 2u)];
    let _e1507 = neigh_idx;
    let _e1514 = state[((_e1507 * 8u) + 0u)];
    let _e1521 = state[((owner * 8u) + 0u)];
    let _e1528 = bc_value[((idx * 8u) + 0u)];
    let _e1535 = bc_kind[((idx * 8u) + 0u)];
    let _e1545 = state[((owner * 8u) + 0u)];
    let _e1552 = bc_value[((idx * 8u) + 0u)];
    let _e1561 = bc_kind[((idx * 8u) + 0u)];
    let _e1568 = normal_vec;
    let _e1573 = neigh_idx;
    let _e1580 = state[((_e1573 * 8u) + 0u)];
    let _e1587 = state[((owner * 8u) + 0u)];
    let _e1594 = bc_value[((idx * 8u) + 0u)];
    let _e1601 = bc_kind[((idx * 8u) + 0u)];
    let _e1611 = state[((owner * 8u) + 0u)];
    let _e1618 = bc_value[((idx * 8u) + 0u)];
    let _e1627 = bc_kind[((idx * 8u) + 0u)];
    let _e1638 = state[((owner * 8u) + 0u)];
    fluxes[((idx * 8u) + 0u)] = ((((((a_plus * _e1143) * dot(((vec2<f32>(dot(vec2<f32>(_e1151, _e1158), vec2<f32>(1f, 0f)), dot(vec2<f32>(_e1170, _e1177), vec2<f32>(0f, 1f))) * 1f) / vec2(_e1192)), _e1195)) - ((a_minus * select(_e1205, select(select(_e1212, _e1219, (_e1226 == 1u)), (_e1236 + (_e1243 * d_own)), (_e1252 == 2u)), is_boundary)) * dot(((vec2<f32>(dot(vec2<f32>(select(_e1265, select(select(_e1272, _e1279, (_e1286 == 1u)), (_e1296 + (_e1303 * d_own)), (_e1312 == 2u)), is_boundary), select(_e1324, select(select(_e1331, _e1338, (_e1345 == 1u)), (_e1355 + (_e1362 * d_own)), (_e1371 == 2u)), is_boundary)), vec2<f32>(1f, 0f)), dot(vec2<f32>(select(_e1388, select(select(_e1395, _e1402, (_e1409 == 1u)), (_e1419 + (_e1426 * d_own)), (_e1435 == 2u)), is_boundary), select(_e1447, select(select(_e1454, _e1461, (_e1468 == 1u)), (_e1478 + (_e1485 * d_own)), (_e1494 == 2u)), is_boundary)), vec2<f32>(0f, 1f))) * 1f) / vec2(select(_e1514, select(select(_e1521, _e1528, (_e1535 == 1u)), (_e1545 + (_e1552 * d_own)), (_e1561 == 2u)), is_boundary))), _e1568))) + ((a_plus * a_minus) * (select(_e1580, select(select(_e1587, _e1594, (_e1601 == 1u)), (_e1611 + (_e1618 * d_own)), (_e1627 == 2u)), is_boundary) - _e1638))) / denom) * area);
    let _e1656 = state[((owner * 8u) + 1u)];
    let _e1663 = state[((owner * 8u) + 2u)];
    let _e1675 = state[((owner * 8u) + 1u)];
    let _e1682 = state[((owner * 8u) + 2u)];
    let _e1694 = state[((owner * 8u) + 1u)];
    let _e1701 = state[((owner * 8u) + 2u)];
    let _e1716 = state[((owner * 8u) + 0u)];
    let _e1719 = normal_vec;
    let _e1728 = state[((owner * 8u) + 4u)];
    let _e1729 = normal_vec;
    let _e1737 = neigh_idx;
    let _e1744 = state[((_e1737 * 8u) + 1u)];
    let _e1751 = state[((owner * 8u) + 1u)];
    let _e1758 = bc_value[((idx * 8u) + 1u)];
    let _e1765 = bc_kind[((idx * 8u) + 1u)];
    let _e1775 = state[((owner * 8u) + 1u)];
    let _e1782 = bc_value[((idx * 8u) + 1u)];
    let _e1791 = bc_kind[((idx * 8u) + 1u)];
    let _e1796 = neigh_idx;
    let _e1803 = state[((_e1796 * 8u) + 2u)];
    let _e1810 = state[((owner * 8u) + 2u)];
    let _e1817 = bc_value[((idx * 8u) + 2u)];
    let _e1824 = bc_kind[((idx * 8u) + 2u)];
    let _e1834 = state[((owner * 8u) + 2u)];
    let _e1841 = bc_value[((idx * 8u) + 2u)];
    let _e1850 = bc_kind[((idx * 8u) + 2u)];
    let _e1860 = neigh_idx;
    let _e1867 = state[((_e1860 * 8u) + 1u)];
    let _e1874 = state[((owner * 8u) + 1u)];
    let _e1881 = bc_value[((idx * 8u) + 1u)];
    let _e1888 = bc_kind[((idx * 8u) + 1u)];
    let _e1898 = state[((owner * 8u) + 1u)];
    let _e1905 = bc_value[((idx * 8u) + 1u)];
    let _e1914 = bc_kind[((idx * 8u) + 1u)];
    let _e1919 = neigh_idx;
    let _e1926 = state[((_e1919 * 8u) + 2u)];
    let _e1933 = state[((owner * 8u) + 2u)];
    let _e1940 = bc_value[((idx * 8u) + 2u)];
    let _e1947 = bc_kind[((idx * 8u) + 2u)];
    let _e1957 = state[((owner * 8u) + 2u)];
    let _e1964 = bc_value[((idx * 8u) + 2u)];
    let _e1973 = bc_kind[((idx * 8u) + 2u)];
    let _e1983 = neigh_idx;
    let _e1990 = state[((_e1983 * 8u) + 1u)];
    let _e1997 = state[((owner * 8u) + 1u)];
    let _e2004 = bc_value[((idx * 8u) + 1u)];
    let _e2011 = bc_kind[((idx * 8u) + 1u)];
    let _e2021 = state[((owner * 8u) + 1u)];
    let _e2028 = bc_value[((idx * 8u) + 1u)];
    let _e2037 = bc_kind[((idx * 8u) + 1u)];
    let _e2042 = neigh_idx;
    let _e2049 = state[((_e2042 * 8u) + 2u)];
    let _e2056 = state[((owner * 8u) + 2u)];
    let _e2063 = bc_value[((idx * 8u) + 2u)];
    let _e2070 = bc_kind[((idx * 8u) + 2u)];
    let _e2080 = state[((owner * 8u) + 2u)];
    let _e2087 = bc_value[((idx * 8u) + 2u)];
    let _e2096 = bc_kind[((idx * 8u) + 2u)];
    let _e2109 = neigh_idx;
    let _e2116 = state[((_e2109 * 8u) + 0u)];
    let _e2123 = state[((owner * 8u) + 0u)];
    let _e2130 = bc_value[((idx * 8u) + 0u)];
    let _e2137 = bc_kind[((idx * 8u) + 0u)];
    let _e2147 = state[((owner * 8u) + 0u)];
    let _e2154 = bc_value[((idx * 8u) + 0u)];
    let _e2163 = bc_kind[((idx * 8u) + 0u)];
    let _e2170 = normal_vec;
    let _e2173 = neigh_idx;
    let _e2180 = state[((_e2173 * 8u) + 4u)];
    let _e2187 = state[((owner * 8u) + 4u)];
    let _e2194 = bc_value[((idx * 8u) + 6u)];
    let _e2201 = bc_kind[((idx * 8u) + 6u)];
    let _e2211 = state[((owner * 8u) + 4u)];
    let _e2218 = bc_value[((idx * 8u) + 6u)];
    let _e2227 = bc_kind[((idx * 8u) + 6u)];
    let _e2232 = normal_vec;
    let _e2242 = neigh_idx;
    let _e2249 = state[((_e2242 * 8u) + 1u)];
    let _e2256 = state[((owner * 8u) + 1u)];
    let _e2263 = bc_value[((idx * 8u) + 1u)];
    let _e2270 = bc_kind[((idx * 8u) + 1u)];
    let _e2280 = state[((owner * 8u) + 1u)];
    let _e2287 = bc_value[((idx * 8u) + 1u)];
    let _e2296 = bc_kind[((idx * 8u) + 1u)];
    let _e2301 = neigh_idx;
    let _e2308 = state[((_e2301 * 8u) + 2u)];
    let _e2315 = state[((owner * 8u) + 2u)];
    let _e2322 = bc_value[((idx * 8u) + 2u)];
    let _e2329 = bc_kind[((idx * 8u) + 2u)];
    let _e2339 = state[((owner * 8u) + 2u)];
    let _e2346 = bc_value[((idx * 8u) + 2u)];
    let _e2355 = bc_kind[((idx * 8u) + 2u)];
    let _e2371 = state[((owner * 8u) + 1u)];
    let _e2378 = state[((owner * 8u) + 2u)];
    fluxes[((idx * 8u) + 1u)] = (((((a_plus * ((dot(vec2<f32>(_e1656, _e1663), vec2<f32>(1f, 0f)) * dot(((vec2<f32>(dot(vec2<f32>(_e1675, _e1682), vec2<f32>(1f, 0f)), dot(vec2<f32>(_e1694, _e1701), vec2<f32>(0f, 1f))) * 1f) / vec2(_e1716)), _e1719)) + (_e1728 * dot(_e1729, vec2<f32>(1f, 0f))))) - (a_minus * ((dot(vec2<f32>(select(_e1744, select(select(_e1751, _e1758, (_e1765 == 1u)), (_e1775 + (_e1782 * d_own)), (_e1791 == 2u)), is_boundary), select(_e1803, select(select(_e1810, _e1817, (_e1824 == 1u)), (_e1834 + (_e1841 * d_own)), (_e1850 == 2u)), is_boundary)), vec2<f32>(1f, 0f)) * dot(((vec2<f32>(dot(vec2<f32>(select(_e1867, select(select(_e1874, _e1881, (_e1888 == 1u)), (_e1898 + (_e1905 * d_own)), (_e1914 == 2u)), is_boundary), select(_e1926, select(select(_e1933, _e1940, (_e1947 == 1u)), (_e1957 + (_e1964 * d_own)), (_e1973 == 2u)), is_boundary)), vec2<f32>(1f, 0f)), dot(vec2<f32>(select(_e1990, select(select(_e1997, _e2004, (_e2011 == 1u)), (_e2021 + (_e2028 * d_own)), (_e2037 == 2u)), is_boundary), select(_e2049, select(select(_e2056, _e2063, (_e2070 == 1u)), (_e2080 + (_e2087 * d_own)), (_e2096 == 2u)), is_boundary)), vec2<f32>(0f, 1f))) * 1f) / vec2(select(_e2116, select(select(_e2123, _e2130, (_e2137 == 1u)), (_e2147 + (_e2154 * d_own)), (_e2163 == 2u)), is_boundary))), _e2170)) + (select(_e2180, select(select(_e2187, _e2194, (_e2201 == 1u)), (_e2211 + (_e2218 * d_own)), (_e2227 == 2u)), is_boundary) * dot(_e2232, vec2<f32>(1f, 0f)))))) + ((a_plus * a_minus) * (dot(vec2<f32>(select(_e2249, select(select(_e2256, _e2263, (_e2270 == 1u)), (_e2280 + (_e2287 * d_own)), (_e2296 == 2u)), is_boundary), select(_e2308, select(select(_e2315, _e2322, (_e2329 == 1u)), (_e2339 + (_e2346 * d_own)), (_e2355 == 2u)), is_boundary)), vec2<f32>(1f, 0f)) - dot(vec2<f32>(_e2371, _e2378), vec2<f32>(1f, 0f))))) / denom) * area);
    let _e2401 = state[((owner * 8u) + 1u)];
    let _e2408 = state[((owner * 8u) + 2u)];
    let _e2420 = state[((owner * 8u) + 1u)];
    let _e2427 = state[((owner * 8u) + 2u)];
    let _e2439 = state[((owner * 8u) + 1u)];
    let _e2446 = state[((owner * 8u) + 2u)];
    let _e2461 = state[((owner * 8u) + 0u)];
    let _e2464 = normal_vec;
    let _e2473 = state[((owner * 8u) + 4u)];
    let _e2474 = normal_vec;
    let _e2482 = neigh_idx;
    let _e2489 = state[((_e2482 * 8u) + 1u)];
    let _e2496 = state[((owner * 8u) + 1u)];
    let _e2503 = bc_value[((idx * 8u) + 1u)];
    let _e2510 = bc_kind[((idx * 8u) + 1u)];
    let _e2520 = state[((owner * 8u) + 1u)];
    let _e2527 = bc_value[((idx * 8u) + 1u)];
    let _e2536 = bc_kind[((idx * 8u) + 1u)];
    let _e2541 = neigh_idx;
    let _e2548 = state[((_e2541 * 8u) + 2u)];
    let _e2555 = state[((owner * 8u) + 2u)];
    let _e2562 = bc_value[((idx * 8u) + 2u)];
    let _e2569 = bc_kind[((idx * 8u) + 2u)];
    let _e2579 = state[((owner * 8u) + 2u)];
    let _e2586 = bc_value[((idx * 8u) + 2u)];
    let _e2595 = bc_kind[((idx * 8u) + 2u)];
    let _e2605 = neigh_idx;
    let _e2612 = state[((_e2605 * 8u) + 1u)];
    let _e2619 = state[((owner * 8u) + 1u)];
    let _e2626 = bc_value[((idx * 8u) + 1u)];
    let _e2633 = bc_kind[((idx * 8u) + 1u)];
    let _e2643 = state[((owner * 8u) + 1u)];
    let _e2650 = bc_value[((idx * 8u) + 1u)];
    let _e2659 = bc_kind[((idx * 8u) + 1u)];
    let _e2664 = neigh_idx;
    let _e2671 = state[((_e2664 * 8u) + 2u)];
    let _e2678 = state[((owner * 8u) + 2u)];
    let _e2685 = bc_value[((idx * 8u) + 2u)];
    let _e2692 = bc_kind[((idx * 8u) + 2u)];
    let _e2702 = state[((owner * 8u) + 2u)];
    let _e2709 = bc_value[((idx * 8u) + 2u)];
    let _e2718 = bc_kind[((idx * 8u) + 2u)];
    let _e2728 = neigh_idx;
    let _e2735 = state[((_e2728 * 8u) + 1u)];
    let _e2742 = state[((owner * 8u) + 1u)];
    let _e2749 = bc_value[((idx * 8u) + 1u)];
    let _e2756 = bc_kind[((idx * 8u) + 1u)];
    let _e2766 = state[((owner * 8u) + 1u)];
    let _e2773 = bc_value[((idx * 8u) + 1u)];
    let _e2782 = bc_kind[((idx * 8u) + 1u)];
    let _e2787 = neigh_idx;
    let _e2794 = state[((_e2787 * 8u) + 2u)];
    let _e2801 = state[((owner * 8u) + 2u)];
    let _e2808 = bc_value[((idx * 8u) + 2u)];
    let _e2815 = bc_kind[((idx * 8u) + 2u)];
    let _e2825 = state[((owner * 8u) + 2u)];
    let _e2832 = bc_value[((idx * 8u) + 2u)];
    let _e2841 = bc_kind[((idx * 8u) + 2u)];
    let _e2854 = neigh_idx;
    let _e2861 = state[((_e2854 * 8u) + 0u)];
    let _e2868 = state[((owner * 8u) + 0u)];
    let _e2875 = bc_value[((idx * 8u) + 0u)];
    let _e2882 = bc_kind[((idx * 8u) + 0u)];
    let _e2892 = state[((owner * 8u) + 0u)];
    let _e2899 = bc_value[((idx * 8u) + 0u)];
    let _e2908 = bc_kind[((idx * 8u) + 0u)];
    let _e2915 = normal_vec;
    let _e2918 = neigh_idx;
    let _e2925 = state[((_e2918 * 8u) + 4u)];
    let _e2932 = state[((owner * 8u) + 4u)];
    let _e2939 = bc_value[((idx * 8u) + 6u)];
    let _e2946 = bc_kind[((idx * 8u) + 6u)];
    let _e2956 = state[((owner * 8u) + 4u)];
    let _e2963 = bc_value[((idx * 8u) + 6u)];
    let _e2972 = bc_kind[((idx * 8u) + 6u)];
    let _e2977 = normal_vec;
    let _e2987 = neigh_idx;
    let _e2994 = state[((_e2987 * 8u) + 1u)];
    let _e3001 = state[((owner * 8u) + 1u)];
    let _e3008 = bc_value[((idx * 8u) + 1u)];
    let _e3015 = bc_kind[((idx * 8u) + 1u)];
    let _e3025 = state[((owner * 8u) + 1u)];
    let _e3032 = bc_value[((idx * 8u) + 1u)];
    let _e3041 = bc_kind[((idx * 8u) + 1u)];
    let _e3046 = neigh_idx;
    let _e3053 = state[((_e3046 * 8u) + 2u)];
    let _e3060 = state[((owner * 8u) + 2u)];
    let _e3067 = bc_value[((idx * 8u) + 2u)];
    let _e3074 = bc_kind[((idx * 8u) + 2u)];
    let _e3084 = state[((owner * 8u) + 2u)];
    let _e3091 = bc_value[((idx * 8u) + 2u)];
    let _e3100 = bc_kind[((idx * 8u) + 2u)];
    let _e3116 = state[((owner * 8u) + 1u)];
    let _e3123 = state[((owner * 8u) + 2u)];
    fluxes[((idx * 8u) + 2u)] = (((((a_plus * ((dot(vec2<f32>(_e2401, _e2408), vec2<f32>(0f, 1f)) * dot(((vec2<f32>(dot(vec2<f32>(_e2420, _e2427), vec2<f32>(1f, 0f)), dot(vec2<f32>(_e2439, _e2446), vec2<f32>(0f, 1f))) * 1f) / vec2(_e2461)), _e2464)) + (_e2473 * dot(_e2474, vec2<f32>(0f, 1f))))) - (a_minus * ((dot(vec2<f32>(select(_e2489, select(select(_e2496, _e2503, (_e2510 == 1u)), (_e2520 + (_e2527 * d_own)), (_e2536 == 2u)), is_boundary), select(_e2548, select(select(_e2555, _e2562, (_e2569 == 1u)), (_e2579 + (_e2586 * d_own)), (_e2595 == 2u)), is_boundary)), vec2<f32>(0f, 1f)) * dot(((vec2<f32>(dot(vec2<f32>(select(_e2612, select(select(_e2619, _e2626, (_e2633 == 1u)), (_e2643 + (_e2650 * d_own)), (_e2659 == 2u)), is_boundary), select(_e2671, select(select(_e2678, _e2685, (_e2692 == 1u)), (_e2702 + (_e2709 * d_own)), (_e2718 == 2u)), is_boundary)), vec2<f32>(1f, 0f)), dot(vec2<f32>(select(_e2735, select(select(_e2742, _e2749, (_e2756 == 1u)), (_e2766 + (_e2773 * d_own)), (_e2782 == 2u)), is_boundary), select(_e2794, select(select(_e2801, _e2808, (_e2815 == 1u)), (_e2825 + (_e2832 * d_own)), (_e2841 == 2u)), is_boundary)), vec2<f32>(0f, 1f))) * 1f) / vec2(select(_e2861, select(select(_e2868, _e2875, (_e2882 == 1u)), (_e2892 + (_e2899 * d_own)), (_e2908 == 2u)), is_boundary))), _e2915)) + (select(_e2925, select(select(_e2932, _e2939, (_e2946 == 1u)), (_e2956 + (_e2963 * d_own)), (_e2972 == 2u)), is_boundary) * dot(_e2977, vec2<f32>(0f, 1f)))))) + ((a_plus * a_minus) * (dot(vec2<f32>(select(_e2994, select(select(_e3001, _e3008, (_e3015 == 1u)), (_e3025 + (_e3032 * d_own)), (_e3041 == 2u)), is_boundary), select(_e3053, select(select(_e3060, _e3067, (_e3074 == 1u)), (_e3084 + (_e3091 * d_own)), (_e3100 == 2u)), is_boundary)), vec2<f32>(0f, 1f)) - dot(vec2<f32>(_e3116, _e3123), vec2<f32>(0f, 1f))))) / denom) * area);
    let _e3146 = state[((owner * 8u) + 3u)];
    let _e3153 = state[((owner * 8u) + 4u)];
    let _e3162 = state[((owner * 8u) + 1u)];
    let _e3169 = state[((owner * 8u) + 2u)];
    let _e3181 = state[((owner * 8u) + 1u)];
    let _e3188 = state[((owner * 8u) + 2u)];
    let _e3203 = state[((owner * 8u) + 0u)];
    let _e3206 = normal_vec;
    let _e3209 = neigh_idx;
    let _e3216 = state[((_e3209 * 8u) + 3u)];
    let _e3223 = state[((owner * 8u) + 3u)];
    let _e3230 = bc_value[((idx * 8u) + 3u)];
    let _e3237 = bc_kind[((idx * 8u) + 3u)];
    let _e3247 = state[((owner * 8u) + 3u)];
    let _e3254 = bc_value[((idx * 8u) + 3u)];
    let _e3263 = bc_kind[((idx * 8u) + 3u)];
    let _e3268 = neigh_idx;
    let _e3275 = state[((_e3268 * 8u) + 4u)];
    let _e3282 = state[((owner * 8u) + 4u)];
    let _e3289 = bc_value[((idx * 8u) + 6u)];
    let _e3296 = bc_kind[((idx * 8u) + 6u)];
    let _e3306 = state[((owner * 8u) + 4u)];
    let _e3313 = bc_value[((idx * 8u) + 6u)];
    let _e3322 = bc_kind[((idx * 8u) + 6u)];
    let _e3329 = neigh_idx;
    let _e3336 = state[((_e3329 * 8u) + 1u)];
    let _e3343 = state[((owner * 8u) + 1u)];
    let _e3350 = bc_value[((idx * 8u) + 1u)];
    let _e3357 = bc_kind[((idx * 8u) + 1u)];
    let _e3367 = state[((owner * 8u) + 1u)];
    let _e3374 = bc_value[((idx * 8u) + 1u)];
    let _e3383 = bc_kind[((idx * 8u) + 1u)];
    let _e3388 = neigh_idx;
    let _e3395 = state[((_e3388 * 8u) + 2u)];
    let _e3402 = state[((owner * 8u) + 2u)];
    let _e3409 = bc_value[((idx * 8u) + 2u)];
    let _e3416 = bc_kind[((idx * 8u) + 2u)];
    let _e3426 = state[((owner * 8u) + 2u)];
    let _e3433 = bc_value[((idx * 8u) + 2u)];
    let _e3442 = bc_kind[((idx * 8u) + 2u)];
    let _e3452 = neigh_idx;
    let _e3459 = state[((_e3452 * 8u) + 1u)];
    let _e3466 = state[((owner * 8u) + 1u)];
    let _e3473 = bc_value[((idx * 8u) + 1u)];
    let _e3480 = bc_kind[((idx * 8u) + 1u)];
    let _e3490 = state[((owner * 8u) + 1u)];
    let _e3497 = bc_value[((idx * 8u) + 1u)];
    let _e3506 = bc_kind[((idx * 8u) + 1u)];
    let _e3511 = neigh_idx;
    let _e3518 = state[((_e3511 * 8u) + 2u)];
    let _e3525 = state[((owner * 8u) + 2u)];
    let _e3532 = bc_value[((idx * 8u) + 2u)];
    let _e3539 = bc_kind[((idx * 8u) + 2u)];
    let _e3549 = state[((owner * 8u) + 2u)];
    let _e3556 = bc_value[((idx * 8u) + 2u)];
    let _e3565 = bc_kind[((idx * 8u) + 2u)];
    let _e3578 = neigh_idx;
    let _e3585 = state[((_e3578 * 8u) + 0u)];
    let _e3592 = state[((owner * 8u) + 0u)];
    let _e3599 = bc_value[((idx * 8u) + 0u)];
    let _e3606 = bc_kind[((idx * 8u) + 0u)];
    let _e3616 = state[((owner * 8u) + 0u)];
    let _e3623 = bc_value[((idx * 8u) + 0u)];
    let _e3632 = bc_kind[((idx * 8u) + 0u)];
    let _e3639 = normal_vec;
    let _e3644 = neigh_idx;
    let _e3651 = state[((_e3644 * 8u) + 3u)];
    let _e3658 = state[((owner * 8u) + 3u)];
    let _e3665 = bc_value[((idx * 8u) + 3u)];
    let _e3672 = bc_kind[((idx * 8u) + 3u)];
    let _e3682 = state[((owner * 8u) + 3u)];
    let _e3689 = bc_value[((idx * 8u) + 3u)];
    let _e3698 = bc_kind[((idx * 8u) + 3u)];
    let _e3709 = state[((owner * 8u) + 3u)];
    fluxes[((idx * 8u) + 3u)] = ((((((a_plus * (_e3146 + _e3153)) * dot(((vec2<f32>(dot(vec2<f32>(_e3162, _e3169), vec2<f32>(1f, 0f)), dot(vec2<f32>(_e3181, _e3188), vec2<f32>(0f, 1f))) * 1f) / vec2(_e3203)), _e3206)) - ((a_minus * (select(_e3216, select(select(_e3223, _e3230, (_e3237 == 1u)), (_e3247 + (_e3254 * d_own)), (_e3263 == 2u)), is_boundary) + select(_e3275, select(select(_e3282, _e3289, (_e3296 == 1u)), (_e3306 + (_e3313 * d_own)), (_e3322 == 2u)), is_boundary))) * dot(((vec2<f32>(dot(vec2<f32>(select(_e3336, select(select(_e3343, _e3350, (_e3357 == 1u)), (_e3367 + (_e3374 * d_own)), (_e3383 == 2u)), is_boundary), select(_e3395, select(select(_e3402, _e3409, (_e3416 == 1u)), (_e3426 + (_e3433 * d_own)), (_e3442 == 2u)), is_boundary)), vec2<f32>(1f, 0f)), dot(vec2<f32>(select(_e3459, select(select(_e3466, _e3473, (_e3480 == 1u)), (_e3490 + (_e3497 * d_own)), (_e3506 == 2u)), is_boundary), select(_e3518, select(select(_e3525, _e3532, (_e3539 == 1u)), (_e3549 + (_e3556 * d_own)), (_e3565 == 2u)), is_boundary)), vec2<f32>(0f, 1f))) * 1f) / vec2(select(_e3585, select(select(_e3592, _e3599, (_e3606 == 1u)), (_e3616 + (_e3623 * d_own)), (_e3632 == 2u)), is_boundary))), _e3639))) + ((a_plus * a_minus) * (select(_e3651, select(select(_e3658, _e3665, (_e3672 == 1u)), (_e3682 + (_e3689 * d_own)), (_e3698 == 2u)), is_boundary) - _e3709))) / denom) * area);
    fluxes[((idx * 8u) + 4u)] = (((((a_plus * 0f) - (a_minus * 0f)) + ((a_plus * a_minus) * 0f)) / denom) * area);
    fluxes[((idx * 8u) + 5u)] = (((((a_plus * 0f) - (a_minus * 0f)) + ((a_plus * a_minus) * 0f)) / denom) * area);
    fluxes[((idx * 8u) + 6u)] = (((((a_plus * 0f) - (a_minus * 0f)) + ((a_plus * a_minus) * 0f)) / denom) * area);
    fluxes[((idx * 8u) + 7u)] = (((((a_plus * 0f) - (a_minus * 0f)) + ((a_plus * a_minus) * 0f)) / denom) * area);
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleGradientsIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e25 = k;
        if (_e25 < end) {
        } else {
            break;
        }
        {
            let _e28 = k;
            let face_idx = cell_faces[_e28];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e54 = face_normals[face_idx].x;
            let _e58 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e54, _e58);
            let _e62 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e62) < 0f) {
                let _e66 = normal_vec;
                normal_vec = -(_e66);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e75 = other_idx;
                let other_center = cell_centers[_e75];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e82 = other_center_vec;
            let d_neigh = distance(_e82, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e90 = lambda;
            let lambda_other = (1f - _e90);
            let _e93 = normal_vec;
            let _e100 = state[((idx * 8u) + 2u)];
            let _e101 = lambda;
            let _e103 = other_idx;
            let _e110 = state[((_e103 * 8u) + 2u)];
            let _e117 = state[((idx * 8u) + 2u)];
            let _e124 = bc_value[((face_idx * 3u) + 2u)];
            let _e131 = bc_kind[((face_idx * 3u) + 2u)];
            let _e141 = state[((idx * 8u) + 2u)];
            let _e148 = bc_value[((face_idx * 3u) + 2u)];
            let _e157 = bc_kind[((face_idx * 3u) + 2u)];
            let _e167 = grad_acc_p;
            grad_acc_p = (_e167 + ((_e93 * ((_e100 * _e101) + (select(_e110, select(select(_e117, _e124, (_e131 == 1u)), (_e141 + (_e148 * d_own)), (_e157 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e170 = k;
            k = (_e170 + 1u);
        }
    }
    let _e172 = grad_acc_p;
    let grad_out_p = ((_e172 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_gradients_incompressible_momentum_generic {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 10] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedFluxModuleGradientsIncompressibleMomentumGeneric::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_gradients_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var grad_acc_p: vec2<f32> = vec2<f32>(0f, 0f);
    var k: u32;
    var normal_vec: vec2<f32>;
    var other_idx: u32;
    var other_center_vec: vec2<f32>;
    var lambda: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let cell_center = cell_centers[idx];
    let cell_center_vec = vec2<f32>(cell_center.x, cell_center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    k = start;
    loop {
        let _e25 = k;
        if (_e25 < end) {
        } else {
            break;
        }
        {
            let _e28 = k;
            let face_idx = cell_faces[_e28];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let is_boundary = (neighbor_raw == -1i);
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let face_center = face_centers[face_idx];
            let face_center_vec = vec2<f32>(face_center.x, face_center.y);
            let _e54 = face_normals[face_idx].x;
            let _e58 = face_normals[face_idx].y;
            normal_vec = vec2<f32>(_e54, _e58);
            let _e62 = normal_vec;
            if (dot((face_center_vec - cell_center_vec), _e62) < 0f) {
                let _e66 = normal_vec;
                normal_vec = -(_e66);
            }
            other_idx = idx;
            other_center_vec = face_center_vec;
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e75 = other_idx;
                let other_center = cell_centers[_e75];
                other_center_vec = vec2<f32>(other_center.x, other_center.y);
            }
            let d_own = distance(cell_center_vec, face_center_vec);
            let _e82 = other_center_vec;
            let d_neigh = distance(_e82, face_center_vec);
            let total_dist = (d_own + d_neigh);
            lambda = 0.5f;
            if (total_dist > 0.000001f) {
                lambda = (d_neigh / total_dist);
            }
            let _e90 = lambda;
            let lambda_other = (1f - _e90);
            let _e93 = normal_vec;
            let _e100 = state[((idx * 8u) + 2u)];
            let _e101 = lambda;
            let _e103 = other_idx;
            let _e110 = state[((_e103 * 8u) + 2u)];
            let _e117 = state[((idx * 8u) + 2u)];
            let _e124 = bc_value[((face_idx * 3u) + 2u)];
            let _e131 = bc_kind[((face_idx * 3u) + 2u)];
            let _e141 = state[((idx * 8u) + 2u)];
            let _e148 = bc_value[((face_idx * 3u) + 2u)];
            let _e157 = bc_kind[((face_idx * 3u) + 2u)];
            let _e167 = grad_acc_p;
            grad_acc_p = (_e167 + ((_e93 * ((_e100 * _e101) + (select(_e110, select(select(_e117, _e124, (_e131 == 1u)), (_e141 + (_e148 * d_own)), (_e157 == 2u)), is_boundary) * lambda_other))) * area));
        }
        continuing {
            let _e170 = k;
            k = (_e170 + 1u);
        }
    }
    let _e172 = grad_acc_p;
    let grad_out_p = ((_e172 * 1f) / vec2(max(vol, 0.000000000001f)));
    state[((idx * 8u) + 4u)] = grad_out_p.x;
    state[((idx * 8u) + 5u)] = grad_out_p.y;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedFluxModuleIncompressibleMomentum::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentum::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var phi: f32;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = (neighbor == -1i);
    neigh_idx = owner;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary {
        c_neigh_vec = face_center_vec;
    }
    let d_own = distance(c_owner_vec, face_center_vec);
    let _e69 = c_neigh_vec;
    let d_neigh = distance(_e69, face_center_vec);
    let total_dist = (d_own + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e76 = lambda;
    let lambda_other = (1f - _e76);
    let _e79 = c_neigh_vec;
    let d_vec = (_e79 - c_owner_vec);
    let _e81 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e81));
    let dist = max(dist_proj, 0.000001f);
    let _e88 = constants.density;
    let _e95 = state[((owner * 8u) + 0u)];
    let _e102 = state[((owner * 8u) + 1u)];
    let _e104 = lambda;
    let _e106 = neigh_idx;
    let _e113 = state[((_e106 * 8u) + 0u)];
    let _e120 = state[((owner * 8u) + 0u)];
    let _e127 = bc_value[((idx * 3u) + 0u)];
    let _e134 = bc_kind[((idx * 3u) + 0u)];
    let _e144 = state[((owner * 8u) + 0u)];
    let _e151 = bc_value[((idx * 3u) + 0u)];
    let _e160 = bc_kind[((idx * 3u) + 0u)];
    let _e165 = neigh_idx;
    let _e172 = state[((_e165 * 8u) + 1u)];
    let _e179 = state[((owner * 8u) + 1u)];
    let _e186 = bc_value[((idx * 3u) + 1u)];
    let _e193 = bc_kind[((idx * 3u) + 1u)];
    let _e203 = state[((owner * 8u) + 1u)];
    let _e210 = bc_value[((idx * 3u) + 1u)];
    let _e219 = bc_kind[((idx * 3u) + 1u)];
    let _e227 = normal_vec;
    let _e233 = constants.density;
    let _e240 = state[((owner * 8u) + 3u)];
    let _e241 = lambda;
    let _e243 = neigh_idx;
    let _e250 = state[((_e243 * 8u) + 3u)];
    let _e257 = state[((owner * 8u) + 3u)];
    let _e262 = neigh_idx;
    let _e269 = state[((_e262 * 8u) + 2u)];
    let _e276 = state[((owner * 8u) + 2u)];
    let _e283 = bc_value[((idx * 3u) + 2u)];
    let _e290 = bc_kind[((idx * 3u) + 2u)];
    let _e300 = state[((owner * 8u) + 2u)];
    let _e307 = bc_value[((idx * 3u) + 2u)];
    let _e316 = bc_kind[((idx * 3u) + 2u)];
    let _e327 = state[((owner * 8u) + 2u)];
    phi = (((_e88 * dot(((vec2<f32>(_e95, _e102) * _e104) + (vec2<f32>(select(_e113, select(select(_e120, _e127, (_e134 == 1u)), (_e144 + (_e151 * d_own)), (_e160 == 2u)), is_boundary), select(_e172, select(select(_e179, _e186, (_e193 == 1u)), (_e203 + (_e210 * d_own)), (_e219 == 2u)), is_boundary)) * lambda_other)), _e227)) * area) - ((((_e233 * ((_e240 * _e241) + (select(_e250, _e257, is_boundary) * lambda_other))) * (select(_e269, select(select(_e276, _e283, (_e290 == 1u)), (_e300 + (_e307 * d_own)), (_e316 == 2u)), is_boundary) - _e327)) / dist) * area));
    let _e340 = phi;
    fluxes[((idx * 3u) + 0u)] = _e340;
    let _e347 = phi;
    fluxes[((idx * 3u) + 1u)] = _e347;
    let _e354 = phi;
    fluxes[((idx * 3u) + 2u)] = _e354;
    return;
}
"#;
    }
    pub mod flux_module_incompressible_momentum_generic {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 7] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.cell_centers,
                    self.face_boundary,
                    self.face_centers,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentumGeneric::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.fluxes,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentumGeneric::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: flux_module_incompressible_momentum_generic :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentumGeneric::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedFluxModuleIncompressibleMomentumGeneric::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedFluxModuleIncompressibleMomentumGeneric::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 3],
            ) -> [wgpu::BindGroupLayout; 3] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedFluxModuleIncompressibleMomentumGeneric::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("flux_module_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;
@group(1) @binding(4) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(2) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var neigh_idx: u32;
    var normal_vec: vec2<f32>;
    var c_neigh_vec: vec2<f32>;
    var lambda: f32 = 0.5f;
    var phi: f32;

    let _e5 = constants.stride_x;
    let idx = ((global_id.y * _e5) + global_id.x);
    if (idx >= arrayLength((&face_areas))) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = (neighbor == -1i);
    neigh_idx = owner;
    if (neighbor != -1i) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let _e36 = face_normals[idx].x;
    let _e40 = face_normals[idx].y;
    normal_vec = vec2<f32>(_e36, _e40);
    let c_owner = cell_centers[owner];
    let c_owner_vec = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec = vec2<f32>(face_center.x, face_center.y);
    let _e53 = normal_vec;
    if (dot((face_center_vec - c_owner_vec), _e53) < 0f) {
        let _e57 = normal_vec;
        normal_vec = -(_e57);
    }
    let _e60 = neigh_idx;
    let c_neigh = cell_centers[_e60];
    c_neigh_vec = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec = c_neigh_vec;
    if is_boundary {
        c_neigh_vec = face_center_vec;
    }
    let d_own = distance(c_owner_vec, face_center_vec);
    let _e69 = c_neigh_vec;
    let d_neigh = distance(_e69, face_center_vec);
    let total_dist = (d_own + d_neigh);
    if (total_dist > 0.000001f) {
        lambda = (d_neigh / total_dist);
    }
    let _e76 = lambda;
    let lambda_other = (1f - _e76);
    let _e79 = c_neigh_vec;
    let d_vec = (_e79 - c_owner_vec);
    let _e81 = normal_vec;
    let dist_proj = abs(dot(d_vec, _e81));
    let dist = max(dist_proj, 0.000001f);
    let _e88 = constants.density;
    let _e95 = state[((owner * 8u) + 0u)];
    let _e102 = state[((owner * 8u) + 1u)];
    let _e104 = lambda;
    let _e106 = neigh_idx;
    let _e113 = state[((_e106 * 8u) + 0u)];
    let _e120 = state[((owner * 8u) + 0u)];
    let _e127 = bc_value[((idx * 3u) + 0u)];
    let _e134 = bc_kind[((idx * 3u) + 0u)];
    let _e144 = state[((owner * 8u) + 0u)];
    let _e151 = bc_value[((idx * 3u) + 0u)];
    let _e160 = bc_kind[((idx * 3u) + 0u)];
    let _e165 = neigh_idx;
    let _e172 = state[((_e165 * 8u) + 1u)];
    let _e179 = state[((owner * 8u) + 1u)];
    let _e186 = bc_value[((idx * 3u) + 1u)];
    let _e193 = bc_kind[((idx * 3u) + 1u)];
    let _e203 = state[((owner * 8u) + 1u)];
    let _e210 = bc_value[((idx * 3u) + 1u)];
    let _e219 = bc_kind[((idx * 3u) + 1u)];
    let _e227 = normal_vec;
    let _e233 = constants.density;
    let _e240 = state[((owner * 8u) + 3u)];
    let _e241 = lambda;
    let _e243 = neigh_idx;
    let _e250 = state[((_e243 * 8u) + 3u)];
    let _e257 = state[((owner * 8u) + 3u)];
    let _e262 = neigh_idx;
    let _e269 = state[((_e262 * 8u) + 2u)];
    let _e276 = state[((owner * 8u) + 2u)];
    let _e283 = bc_value[((idx * 3u) + 2u)];
    let _e290 = bc_kind[((idx * 3u) + 2u)];
    let _e300 = state[((owner * 8u) + 2u)];
    let _e307 = bc_value[((idx * 3u) + 2u)];
    let _e316 = bc_kind[((idx * 3u) + 2u)];
    let _e327 = state[((owner * 8u) + 2u)];
    phi = (((_e88 * dot(((vec2<f32>(_e95, _e102) * _e104) + (vec2<f32>(select(_e113, select(select(_e120, _e127, (_e134 == 1u)), (_e144 + (_e151 * d_own)), (_e160 == 2u)), is_boundary), select(_e172, select(select(_e179, _e186, (_e193 == 1u)), (_e203 + (_e210 * d_own)), (_e219 == 2u)), is_boundary)) * lambda_other)), _e227)) * area) - ((((_e233 * ((_e240 * _e241) + (select(_e250, _e257, is_boundary) * lambda_other))) * (select(_e269, select(select(_e276, _e283, (_e290 == 1u)), (_e300 + (_e307 * d_own)), (_e316 == 2u)), is_boundary) - _e327)) / dist) * area));
    let _e340 = phi;
    fluxes[((idx * 3u) + 0u)] = _e340;
    let _e347 = phi;
    fluxes[((idx * 3u) + 1u)] = _e347;
    let _e354 = phi;
    fluxes[((idx * 3u) + 2u)] = _e354;
    return;
}
"#;
    }
    pub mod generic_coupled_apply {
        use super::{_root, _root::*};
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub row_offsets: wgpu::BufferBinding<'a>,
            pub col_indices: wgpu::BufferBinding<'a>,
            pub matrix_values: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub row_offsets: wgpu::BindGroupEntry<'a>,
            pub col_indices: wgpu::BindGroupEntry<'a>,
            pub matrix_values: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    row_offsets: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.row_offsets),
                    },
                    col_indices: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.col_indices),
                    },
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.row_offsets, self.col_indices, self.matrix_values]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"col_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
            pub y: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
            pub y: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                    y: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.y),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.x, self.y]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1::LayoutDescriptor"),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"y\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledApply::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledApply::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_apply.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
@group(0) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> col_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(0) 
var<storage> x: array<f32>;
@group(1) @binding(1) 
var<storage, read_write> y: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let row = global_id.x;
    let n = (arrayLength((&row_offsets)) - 1u);
    if (row >= n) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e17 = k;
        if (_e17 < end) {
        } else {
            break;
        }
        {
            let _e20 = k;
            let col = col_indices[_e20];
            let _e24 = k;
            let _e26 = matrix_values[_e24];
            let _e30 = x[col];
            let _e32 = sum;
            sum = (_e32 + (_e26 * _e30));
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let _e39 = sum;
    y[row] = _e39;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup0::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"face_owner\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"face_neighbor\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"face_areas\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(3): \"face_normals\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 3,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(13): \"face_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 13,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(4): \"cell_centers\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 4,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(5): \"cell_vols\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 5,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(6): \"cell_face_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 6,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(7): \"cell_faces\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 7,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(10): \"cell_face_matrix_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 10,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(11): \"diagonal_indices\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 11,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(12): \"face_boundary\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 12,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyCompressible::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_compressible :: Constants > () as _) , } , count : None , } , # [doc = " @binding(5): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup2::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"matrix_values\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"rhs\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(2): \"scalar_row_offsets\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 2,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyCompressible::BindGroup3::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"bc_kind\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                        #[doc = " @binding(1): \"bc_value\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 1,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: true },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyCompressible::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var diag_3_: f32 = 0f;
    var rhs_3_: f32 = 0f;
    var diag_4_: f32 = 0f;
    var rhs_4_: f32 = 0f;
    var diag_5_: f32 = 0f;
    var rhs_5_: f32 = 0f;
    var diag_6_: f32 = 0f;
    var rhs_6_: f32 = 0f;
    var diag_7_: f32 = 0f;
    var rhs_7_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;
    var phi_3_: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e26 = diagonal_indices[idx];
    let diag_rank = (_e26 - scalar_offset);
    let _e32 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e32 - scalar_offset);
    let start_row_0_ = (scalar_offset * 64u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 8u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 8u) * 2u));
    let start_row_3_ = (start_row_0_ + ((num_neighbors * 8u) * 3u));
    let start_row_4_ = (start_row_0_ + ((num_neighbors * 8u) * 4u));
    let start_row_5_ = (start_row_0_ + ((num_neighbors * 8u) * 5u));
    let start_row_6_ = (start_row_0_ + ((num_neighbors * 8u) * 6u));
    let start_row_7_ = (start_row_0_ + ((num_neighbors * 8u) * 7u));
    loop {
        let _e72 = rank;
        if (_e72 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e74 = rank;
            matrix_values[((start_row_0_ + (_e74 * 8u)) + 0u)] = 0f;
            let _e83 = rank;
            matrix_values[((start_row_0_ + (_e83 * 8u)) + 1u)] = 0f;
            let _e92 = rank;
            matrix_values[((start_row_0_ + (_e92 * 8u)) + 2u)] = 0f;
            let _e101 = rank;
            matrix_values[((start_row_0_ + (_e101 * 8u)) + 3u)] = 0f;
            let _e110 = rank;
            matrix_values[((start_row_0_ + (_e110 * 8u)) + 4u)] = 0f;
            let _e119 = rank;
            matrix_values[((start_row_0_ + (_e119 * 8u)) + 5u)] = 0f;
            let _e128 = rank;
            matrix_values[((start_row_0_ + (_e128 * 8u)) + 6u)] = 0f;
            let _e137 = rank;
            matrix_values[((start_row_0_ + (_e137 * 8u)) + 7u)] = 0f;
            let _e146 = rank;
            matrix_values[((start_row_1_ + (_e146 * 8u)) + 0u)] = 0f;
            let _e155 = rank;
            matrix_values[((start_row_1_ + (_e155 * 8u)) + 1u)] = 0f;
            let _e164 = rank;
            matrix_values[((start_row_1_ + (_e164 * 8u)) + 2u)] = 0f;
            let _e173 = rank;
            matrix_values[((start_row_1_ + (_e173 * 8u)) + 3u)] = 0f;
            let _e182 = rank;
            matrix_values[((start_row_1_ + (_e182 * 8u)) + 4u)] = 0f;
            let _e191 = rank;
            matrix_values[((start_row_1_ + (_e191 * 8u)) + 5u)] = 0f;
            let _e200 = rank;
            matrix_values[((start_row_1_ + (_e200 * 8u)) + 6u)] = 0f;
            let _e209 = rank;
            matrix_values[((start_row_1_ + (_e209 * 8u)) + 7u)] = 0f;
            let _e218 = rank;
            matrix_values[((start_row_2_ + (_e218 * 8u)) + 0u)] = 0f;
            let _e227 = rank;
            matrix_values[((start_row_2_ + (_e227 * 8u)) + 1u)] = 0f;
            let _e236 = rank;
            matrix_values[((start_row_2_ + (_e236 * 8u)) + 2u)] = 0f;
            let _e245 = rank;
            matrix_values[((start_row_2_ + (_e245 * 8u)) + 3u)] = 0f;
            let _e254 = rank;
            matrix_values[((start_row_2_ + (_e254 * 8u)) + 4u)] = 0f;
            let _e263 = rank;
            matrix_values[((start_row_2_ + (_e263 * 8u)) + 5u)] = 0f;
            let _e272 = rank;
            matrix_values[((start_row_2_ + (_e272 * 8u)) + 6u)] = 0f;
            let _e281 = rank;
            matrix_values[((start_row_2_ + (_e281 * 8u)) + 7u)] = 0f;
            let _e290 = rank;
            matrix_values[((start_row_3_ + (_e290 * 8u)) + 0u)] = 0f;
            let _e299 = rank;
            matrix_values[((start_row_3_ + (_e299 * 8u)) + 1u)] = 0f;
            let _e308 = rank;
            matrix_values[((start_row_3_ + (_e308 * 8u)) + 2u)] = 0f;
            let _e317 = rank;
            matrix_values[((start_row_3_ + (_e317 * 8u)) + 3u)] = 0f;
            let _e326 = rank;
            matrix_values[((start_row_3_ + (_e326 * 8u)) + 4u)] = 0f;
            let _e335 = rank;
            matrix_values[((start_row_3_ + (_e335 * 8u)) + 5u)] = 0f;
            let _e344 = rank;
            matrix_values[((start_row_3_ + (_e344 * 8u)) + 6u)] = 0f;
            let _e353 = rank;
            matrix_values[((start_row_3_ + (_e353 * 8u)) + 7u)] = 0f;
            let _e362 = rank;
            matrix_values[((start_row_4_ + (_e362 * 8u)) + 0u)] = 0f;
            let _e371 = rank;
            matrix_values[((start_row_4_ + (_e371 * 8u)) + 1u)] = 0f;
            let _e380 = rank;
            matrix_values[((start_row_4_ + (_e380 * 8u)) + 2u)] = 0f;
            let _e389 = rank;
            matrix_values[((start_row_4_ + (_e389 * 8u)) + 3u)] = 0f;
            let _e398 = rank;
            matrix_values[((start_row_4_ + (_e398 * 8u)) + 4u)] = 0f;
            let _e407 = rank;
            matrix_values[((start_row_4_ + (_e407 * 8u)) + 5u)] = 0f;
            let _e416 = rank;
            matrix_values[((start_row_4_ + (_e416 * 8u)) + 6u)] = 0f;
            let _e425 = rank;
            matrix_values[((start_row_4_ + (_e425 * 8u)) + 7u)] = 0f;
            let _e434 = rank;
            matrix_values[((start_row_5_ + (_e434 * 8u)) + 0u)] = 0f;
            let _e443 = rank;
            matrix_values[((start_row_5_ + (_e443 * 8u)) + 1u)] = 0f;
            let _e452 = rank;
            matrix_values[((start_row_5_ + (_e452 * 8u)) + 2u)] = 0f;
            let _e461 = rank;
            matrix_values[((start_row_5_ + (_e461 * 8u)) + 3u)] = 0f;
            let _e470 = rank;
            matrix_values[((start_row_5_ + (_e470 * 8u)) + 4u)] = 0f;
            let _e479 = rank;
            matrix_values[((start_row_5_ + (_e479 * 8u)) + 5u)] = 0f;
            let _e488 = rank;
            matrix_values[((start_row_5_ + (_e488 * 8u)) + 6u)] = 0f;
            let _e497 = rank;
            matrix_values[((start_row_5_ + (_e497 * 8u)) + 7u)] = 0f;
            let _e506 = rank;
            matrix_values[((start_row_6_ + (_e506 * 8u)) + 0u)] = 0f;
            let _e515 = rank;
            matrix_values[((start_row_6_ + (_e515 * 8u)) + 1u)] = 0f;
            let _e524 = rank;
            matrix_values[((start_row_6_ + (_e524 * 8u)) + 2u)] = 0f;
            let _e533 = rank;
            matrix_values[((start_row_6_ + (_e533 * 8u)) + 3u)] = 0f;
            let _e542 = rank;
            matrix_values[((start_row_6_ + (_e542 * 8u)) + 4u)] = 0f;
            let _e551 = rank;
            matrix_values[((start_row_6_ + (_e551 * 8u)) + 5u)] = 0f;
            let _e560 = rank;
            matrix_values[((start_row_6_ + (_e560 * 8u)) + 6u)] = 0f;
            let _e569 = rank;
            matrix_values[((start_row_6_ + (_e569 * 8u)) + 7u)] = 0f;
            let _e578 = rank;
            matrix_values[((start_row_7_ + (_e578 * 8u)) + 0u)] = 0f;
            let _e587 = rank;
            matrix_values[((start_row_7_ + (_e587 * 8u)) + 1u)] = 0f;
            let _e596 = rank;
            matrix_values[((start_row_7_ + (_e596 * 8u)) + 2u)] = 0f;
            let _e605 = rank;
            matrix_values[((start_row_7_ + (_e605 * 8u)) + 3u)] = 0f;
            let _e614 = rank;
            matrix_values[((start_row_7_ + (_e614 * 8u)) + 4u)] = 0f;
            let _e623 = rank;
            matrix_values[((start_row_7_ + (_e623 * 8u)) + 5u)] = 0f;
            let _e632 = rank;
            matrix_values[((start_row_7_ + (_e632 * 8u)) + 6u)] = 0f;
            let _e641 = rank;
            matrix_values[((start_row_7_ + (_e641 * 8u)) + 7u)] = 0f;
        }
        continuing {
            let _e651 = rank;
            rank = (_e651 + 1u);
        }
    }
    let _e658 = constants.dt;
    let _e660 = diag_0_;
    diag_0_ = (_e660 + ((vol * 1f) / _e658));
    let _e666 = constants.dt;
    let _e675 = state_old[((idx * 8u) + 0u)];
    let _e677 = rhs_0_;
    rhs_0_ = (_e677 + (((vol * 1f) / _e666) * _e675));
    let _e681 = constants.time_scheme;
    if (_e681 == 1u) {
        let _e686 = constants.dt;
        let _e689 = constants.dt_old;
        let r = (_e686 / _e689);
        let _e695 = constants.dt;
        let diag_bdf2_ = ((((vol * 1f) / _e695) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e711 = diag_0_;
        let _e716 = constants.dt;
        diag_0_ = ((_e711 - ((vol * 1f) / _e716)) + diag_bdf2_);
        let _e720 = rhs_0_;
        let _e725 = constants.dt;
        let _e733 = state_old[((idx * 8u) + 0u)];
        let _e740 = constants.dt;
        let _e748 = state_old[((idx * 8u) + 0u)];
        let _e756 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e720 - (((vol * 1f) / _e725) * _e733)) + (((vol * 1f) / _e740) * ((factor_n * _e748) - (factor_nm1_ * _e756))));
    }
    let _e766 = constants.dt;
    let _e768 = diag_1_;
    diag_1_ = (_e768 + ((vol * 1f) / _e766));
    let _e774 = constants.dt;
    let _e783 = state_old[((idx * 8u) + 1u)];
    let _e785 = rhs_1_;
    rhs_1_ = (_e785 + (((vol * 1f) / _e774) * _e783));
    let _e789 = constants.time_scheme;
    if (_e789 == 1u) {
        let _e794 = constants.dt;
        let _e797 = constants.dt_old;
        let r_1 = (_e794 / _e797);
        let _e803 = constants.dt;
        let diag_bdf2_1 = ((((vol * 1f) / _e803) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e819 = diag_1_;
        let _e824 = constants.dt;
        diag_1_ = ((_e819 - ((vol * 1f) / _e824)) + diag_bdf2_1);
        let _e828 = rhs_1_;
        let _e833 = constants.dt;
        let _e841 = state_old[((idx * 8u) + 1u)];
        let _e848 = constants.dt;
        let _e856 = state_old[((idx * 8u) + 1u)];
        let _e864 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e828 - (((vol * 1f) / _e833) * _e841)) + (((vol * 1f) / _e848) * ((factor_n_1 * _e856) - (factor_nm1_1 * _e864))));
    }
    let _e874 = constants.dt;
    let _e876 = diag_2_;
    diag_2_ = (_e876 + ((vol * 1f) / _e874));
    let _e882 = constants.dt;
    let _e891 = state_old[((idx * 8u) + 2u)];
    let _e893 = rhs_2_;
    rhs_2_ = (_e893 + (((vol * 1f) / _e882) * _e891));
    let _e897 = constants.time_scheme;
    if (_e897 == 1u) {
        let _e902 = constants.dt;
        let _e905 = constants.dt_old;
        let r_2 = (_e902 / _e905);
        let _e911 = constants.dt;
        let diag_bdf2_2 = ((((vol * 1f) / _e911) * ((r_2 * 2f) + 1f)) / (r_2 + 1f));
        let factor_n_2 = (r_2 + 1f);
        let factor_nm1_2 = ((r_2 * r_2) / (r_2 + 1f));
        let _e927 = diag_2_;
        let _e932 = constants.dt;
        diag_2_ = ((_e927 - ((vol * 1f) / _e932)) + diag_bdf2_2);
        let _e936 = rhs_2_;
        let _e941 = constants.dt;
        let _e949 = state_old[((idx * 8u) + 2u)];
        let _e956 = constants.dt;
        let _e964 = state_old[((idx * 8u) + 2u)];
        let _e972 = state_old_old[((idx * 8u) + 2u)];
        rhs_2_ = ((_e936 - (((vol * 1f) / _e941) * _e949)) + (((vol * 1f) / _e956) * ((factor_n_2 * _e964) - (factor_nm1_2 * _e972))));
    }
    let _e982 = constants.dt;
    let _e984 = diag_3_;
    diag_3_ = (_e984 + ((vol * 1f) / _e982));
    let _e990 = constants.dt;
    let _e999 = state_old[((idx * 8u) + 3u)];
    let _e1001 = rhs_3_;
    rhs_3_ = (_e1001 + (((vol * 1f) / _e990) * _e999));
    let _e1005 = constants.time_scheme;
    if (_e1005 == 1u) {
        let _e1010 = constants.dt;
        let _e1013 = constants.dt_old;
        let r_3 = (_e1010 / _e1013);
        let _e1019 = constants.dt;
        let diag_bdf2_3 = ((((vol * 1f) / _e1019) * ((r_3 * 2f) + 1f)) / (r_3 + 1f));
        let factor_n_3 = (r_3 + 1f);
        let factor_nm1_3 = ((r_3 * r_3) / (r_3 + 1f));
        let _e1035 = diag_3_;
        let _e1040 = constants.dt;
        diag_3_ = ((_e1035 - ((vol * 1f) / _e1040)) + diag_bdf2_3);
        let _e1044 = rhs_3_;
        let _e1049 = constants.dt;
        let _e1057 = state_old[((idx * 8u) + 3u)];
        let _e1064 = constants.dt;
        let _e1072 = state_old[((idx * 8u) + 3u)];
        let _e1080 = state_old_old[((idx * 8u) + 3u)];
        rhs_3_ = ((_e1044 - (((vol * 1f) / _e1049) * _e1057)) + (((vol * 1f) / _e1064) * ((factor_n_3 * _e1072) - (factor_nm1_3 * _e1080))));
    }
    let _e1091 = state[((idx * 8u) + 0u)];
    let _e1099 = constants.dt;
    let _e1102 = diag_4_;
    diag_4_ = (_e1102 - ((((-1f * _e1091) * 1f) / _e1099) * vol));
    let _e1110 = state[((idx * 8u) + 0u)];
    let _e1118 = constants.dt;
    let _e1121 = diag_5_;
    diag_5_ = (_e1121 - ((((-1f * _e1110) * 1f) / _e1118) * vol));
    let _e1132 = constants.dt;
    let _e1136 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 1u)] = (_e1136 - ((1f / _e1132) * vol));
    let _e1147 = constants.dt;
    let _e1151 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 2u)] = (_e1151 - ((1f / _e1147) * vol));
    let _e1155 = constants.dt;
    let _e1160 = diag_6_;
    diag_6_ = (_e1160 - ((1f / _e1155) * vol));
    let _e1171 = constants.eos_gm1_;
    let _e1178 = constants.dt;
    let _e1181 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 3u)] = (_e1181 - ((((-1f * _e1171) * 1f) / _e1178) * vol));
    let _e1192 = constants.eos_gm1_;
    let _e1199 = constants.dt;
    let _e1207 = state[((idx * 8u) + 6u)];
    let _e1214 = state[((idx * 8u) + 6u)];
    let _e1222 = state[((idx * 8u) + 7u)];
    let _e1229 = state[((idx * 8u) + 7u)];
    let _e1234 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1234 - (((((0.5f * _e1192) * 1f) / _e1199) * ((_e1207 * _e1214) + (_e1222 * _e1229))) * vol));
    let _e1245 = constants.eos_dp_drho;
    let _e1252 = constants.dt;
    let _e1255 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 0u)] = (_e1255 - ((((-1f * _e1245) * 1f) / _e1252) * vol));
    let _e1259 = constants.eos_p_offset;
    let _e1267 = constants.dt;
    let _e1270 = rhs_6_;
    rhs_6_ = (_e1270 + ((((-1f * _e1259) * 1f) / _e1267) * vol));
    let _e1278 = state[((idx * 8u) + 0u)];
    let _e1281 = constants.eos_r;
    let _e1288 = constants.dt;
    let _e1291 = diag_7_;
    diag_7_ = (_e1291 - ((((_e1278 * _e1281) * 1f) / _e1288) * vol));
    let _e1302 = constants.dt;
    let _e1306 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 6u)] = (_e1306 - ((-1f / _e1302) * vol));
    k = start;
    loop {
        let _e1309 = k;
        if (_e1309 < end) {
        } else {
            break;
        }
        {
            let _e1312 = k;
            let face_idx = cell_faces[_e1312];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e1332 = face_normals[face_idx];
            normal = _e1332;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e1340 = normal.x;
                normal.x = -(_e1340);
                let _e1344 = normal.y;
                normal.y = -(_e1344);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e1351 = other_idx;
                let _e1353 = cell_centers[_e1351];
                other_center = _e1353;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e1357 = other_center.x;
            let dx = (_e1357 - center.x);
            let _e1361 = other_center.y;
            let dy = (_e1361 - center.y);
            let _e1365 = normal.x;
            let _e1368 = normal.y;
            let dist_proj = abs(((dx * _e1365) + (dy * _e1368)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e1382 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e1382];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e1392 = fluxes[((face_idx * 8u) + 0u)];
            phi_0_ = _e1392;
            if (owner != idx) {
                let _e1395 = phi_0_;
                let _e1398 = phi_0_;
                phi_0_ = (_e1398 - (_e1395 * 2f));
            }
            let _e1400 = phi_0_;
            let _e1401 = rhs_0_;
            rhs_0_ = (_e1401 - _e1400);
            let _e1405 = constants.viscosity;
            let _e1407 = dist;
            let diff_coeff_rho_u = ((_e1405 * area) / _e1407);
            let _e1409 = is_boundary;
            if !(_e1409) {
                let _e1418 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1418 + diff_coeff_rho_u);
                let _e1427 = matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 8u)) + 4u)] = (_e1427 - diff_coeff_rho_u);
            } else {
                let _e1435 = bc_kind[((face_idx * 8u) + 4u)];
                if (_e1435 == 1u) {
                    let _e1445 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)];
                    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 4u)] = (_e1445 + diff_coeff_rho_u);
                    let _e1453 = bc_value[((face_idx * 8u) + 4u)];
                    let _e1455 = rhs_1_;
                    rhs_1_ = (_e1455 + (diff_coeff_rho_u * _e1453));
                } else {
                    let _e1463 = bc_kind[((face_idx * 8u) + 4u)];
                    if (_e1463 == 2u) {
                        let _e1468 = constants.viscosity;
                        let _e1476 = bc_value[((face_idx * 8u) + 4u)];
                        let _e1479 = rhs_1_;
                        rhs_1_ = (_e1479 + -(((_e1468 * area) * _e1476)));
                    }
                }
            }
            let _e1481 = is_boundary;
            if !(_e1481) {
                let _e1490 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1490 + diff_coeff_rho_u);
                let _e1499 = matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 8u)) + 5u)] = (_e1499 - diff_coeff_rho_u);
            } else {
                let _e1507 = bc_kind[((face_idx * 8u) + 5u)];
                if (_e1507 == 1u) {
                    let _e1517 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)];
                    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 5u)] = (_e1517 + diff_coeff_rho_u);
                    let _e1525 = bc_value[((face_idx * 8u) + 5u)];
                    let _e1527 = rhs_2_;
                    rhs_2_ = (_e1527 + (diff_coeff_rho_u * _e1525));
                } else {
                    let _e1535 = bc_kind[((face_idx * 8u) + 5u)];
                    if (_e1535 == 2u) {
                        let _e1540 = constants.viscosity;
                        let _e1548 = bc_value[((face_idx * 8u) + 5u)];
                        let _e1551 = rhs_2_;
                        rhs_2_ = (_e1551 + -(((_e1540 * area) * _e1548)));
                    }
                }
            }
            let _e1559 = fluxes[((face_idx * 8u) + 1u)];
            phi_1_ = _e1559;
            if (owner != idx) {
                let _e1562 = phi_1_;
                let _e1565 = phi_1_;
                phi_1_ = (_e1565 - (_e1562 * 2f));
            }
            let _e1567 = phi_1_;
            let _e1568 = rhs_1_;
            rhs_1_ = (_e1568 - _e1567);
            let _e1576 = fluxes[((face_idx * 8u) + 2u)];
            phi_2_ = _e1576;
            if (owner != idx) {
                let _e1579 = phi_2_;
                let _e1582 = phi_2_;
                phi_2_ = (_e1582 - (_e1579 * 2f));
            }
            let _e1584 = phi_2_;
            let _e1585 = rhs_2_;
            rhs_2_ = (_e1585 - _e1584);
            let _e1593 = fluxes[((face_idx * 8u) + 3u)];
            phi_3_ = _e1593;
            if (owner != idx) {
                let _e1596 = phi_3_;
                let _e1599 = phi_3_;
                phi_3_ = (_e1599 - (_e1596 * 2f));
            }
            let _e1601 = phi_3_;
            let _e1602 = rhs_3_;
            rhs_3_ = (_e1602 - _e1601);
        }
        continuing {
            let _e1605 = k;
            k = (_e1605 + 1u);
        }
    }
    let _e1614 = diag_0_;
    let _e1615 = matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 8u)) + 0u)] = (_e1615 + _e1614);
    let _e1623 = rhs_0_;
    rhs[((idx * 8u) + 0u)] = _e1623;
    let _e1631 = diag_1_;
    let _e1632 = matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 8u)) + 1u)] = (_e1632 + _e1631);
    let _e1640 = rhs_1_;
    rhs[((idx * 8u) + 1u)] = _e1640;
    let _e1648 = diag_2_;
    let _e1649 = matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 8u)) + 2u)] = (_e1649 + _e1648);
    let _e1657 = rhs_2_;
    rhs[((idx * 8u) + 2u)] = _e1657;
    let _e1665 = diag_3_;
    let _e1666 = matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)];
    matrix_values[((start_row_3_ + (diag_rank * 8u)) + 3u)] = (_e1666 + _e1665);
    let _e1674 = rhs_3_;
    rhs[((idx * 8u) + 3u)] = _e1674;
    let _e1682 = diag_4_;
    let _e1683 = matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)];
    matrix_values[((start_row_4_ + (diag_rank * 8u)) + 4u)] = (_e1683 + _e1682);
    let _e1692 = rhs_4_;
    rhs[((idx * 8u) + 4u)] = _e1692;
    let _e1700 = diag_5_;
    let _e1701 = matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)];
    matrix_values[((start_row_5_ + (diag_rank * 8u)) + 5u)] = (_e1701 + _e1700);
    let _e1710 = rhs_5_;
    rhs[((idx * 8u) + 5u)] = _e1710;
    let _e1718 = diag_6_;
    let _e1719 = matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)];
    matrix_values[((start_row_6_ + (diag_rank * 8u)) + 6u)] = (_e1719 + _e1718);
    let _e1727 = rhs_6_;
    rhs[((idx * 8u) + 6u)] = _e1727;
    let _e1735 = diag_7_;
    let _e1736 = matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)];
    matrix_values[((start_row_7_ + (diag_rank * 8u)) + 7u)] = (_e1736 + _e1735);
    let _e1745 = rhs_7_;
    rhs[((idx * 8u) + 7u)] = _e1745;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup2"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::BindGroup3"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledAssemblyGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e26 = diagonal_indices[idx];
    let diag_rank = (_e26 - scalar_offset);
    let _e32 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e32 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e37 = rank;
        if (_e37 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e39 = rank;
            matrix_values[((start_row_0_ + (_e39 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e49 = rank;
            rank = (_e49 + 1u);
        }
    }
    let _e56 = constants.dt;
    let _e58 = diag_0_;
    diag_0_ = (_e58 + ((vol * 1f) / _e56));
    let _e64 = constants.dt;
    let _e73 = state_old[((idx * 1u) + 0u)];
    let _e75 = rhs_0_;
    rhs_0_ = (_e75 + (((vol * 1f) / _e64) * _e73));
    let _e79 = constants.time_scheme;
    if (_e79 == 1u) {
        let _e84 = constants.dt;
        let _e87 = constants.dt_old;
        let r = (_e84 / _e87);
        let _e93 = constants.dt;
        let diag_bdf2_ = ((((vol * 1f) / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e114 = constants.dt;
        diag_0_ = ((_e109 - ((vol * 1f) / _e114)) + diag_bdf2_);
        let _e118 = rhs_0_;
        let _e123 = constants.dt;
        let _e131 = state_old[((idx * 1u) + 0u)];
        let _e138 = constants.dt;
        let _e146 = state_old[((idx * 1u) + 0u)];
        let _e154 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e118 - (((vol * 1f) / _e123) * _e131)) + (((vol * 1f) / _e138) * ((factor_n * _e146) - (factor_nm1_ * _e154))));
    }
    k = start;
    loop {
        let _e160 = k;
        if (_e160 < end) {
        } else {
            break;
        }
        {
            let _e163 = k;
            let face_idx = cell_faces[_e163];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e183 = face_normals[face_idx];
            normal = _e183;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e191 = normal.x;
                normal.x = -(_e191);
                let _e195 = normal.y;
                normal.y = -(_e195);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e202 = other_idx;
                let _e204 = cell_centers[_e202];
                other_center = _e204;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e208 = other_center.x;
            let dx = (_e208 - center.x);
            let _e212 = other_center.y;
            let dy = (_e212 - center.y);
            let _e216 = normal.x;
            let _e219 = normal.y;
            let dist_proj = abs(((dx * _e216) + (dy * _e219)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e233 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e233];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e239 = dist;
            let diff_coeff_phi = ((1f * area) / _e239);
            let _e241 = is_boundary;
            if !(_e241) {
                let _e243 = diag_0_;
                diag_0_ = (_e243 + diff_coeff_phi);
                let _e252 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e252 - diff_coeff_phi);
            } else {
                let _e260 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e260 == 1u) {
                    let _e263 = diag_0_;
                    diag_0_ = (_e263 + diff_coeff_phi);
                    let _e271 = bc_value[((face_idx * 1u) + 0u)];
                    let _e273 = rhs_0_;
                    rhs_0_ = (_e273 + (diff_coeff_phi * _e271));
                } else {
                    let _e281 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e281 == 2u) {
                        let _e292 = bc_value[((face_idx * 1u) + 0u)];
                        let _e295 = rhs_0_;
                        rhs_0_ = (_e295 + -(((1f * area) * _e292)));
                    }
                }
            }
        }
        continuing {
            let _e298 = k;
            k = (_e298 + 1u);
        }
    }
    let _e307 = diag_0_;
    let _e308 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e308 + _e307);
    let _e316 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e316;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e26 = diagonal_indices[idx];
    let diag_rank = (_e26 - scalar_offset);
    let _e32 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e32 - scalar_offset);
    let start_row_0_ = (scalar_offset * 1u);
    loop {
        let _e37 = rank;
        if (_e37 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e39 = rank;
            matrix_values[((start_row_0_ + (_e39 * 1u)) + 0u)] = 0f;
        }
        continuing {
            let _e49 = rank;
            rank = (_e49 + 1u);
        }
    }
    let _e56 = constants.dt;
    let _e58 = diag_0_;
    diag_0_ = (_e58 + ((vol * 1f) / _e56));
    let _e64 = constants.dt;
    let _e73 = state_old[((idx * 1u) + 0u)];
    let _e75 = rhs_0_;
    rhs_0_ = (_e75 + (((vol * 1f) / _e64) * _e73));
    let _e79 = constants.time_scheme;
    if (_e79 == 1u) {
        let _e84 = constants.dt;
        let _e87 = constants.dt_old;
        let r = (_e84 / _e87);
        let _e93 = constants.dt;
        let diag_bdf2_ = ((((vol * 1f) / _e93) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e109 = diag_0_;
        let _e114 = constants.dt;
        diag_0_ = ((_e109 - ((vol * 1f) / _e114)) + diag_bdf2_);
        let _e118 = rhs_0_;
        let _e123 = constants.dt;
        let _e131 = state_old[((idx * 1u) + 0u)];
        let _e138 = constants.dt;
        let _e146 = state_old[((idx * 1u) + 0u)];
        let _e154 = state_old_old[((idx * 1u) + 0u)];
        rhs_0_ = ((_e118 - (((vol * 1f) / _e123) * _e131)) + (((vol * 1f) / _e138) * ((factor_n * _e146) - (factor_nm1_ * _e154))));
    }
    k = start;
    loop {
        let _e160 = k;
        if (_e160 < end) {
        } else {
            break;
        }
        {
            let _e163 = k;
            let face_idx = cell_faces[_e163];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e183 = face_normals[face_idx];
            normal = _e183;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e191 = normal.x;
                normal.x = -(_e191);
                let _e195 = normal.y;
                normal.y = -(_e195);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e202 = other_idx;
                let _e204 = cell_centers[_e202];
                other_center = _e204;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e208 = other_center.x;
            let dx = (_e208 - center.x);
            let _e212 = other_center.y;
            let dy = (_e212 - center.y);
            let _e216 = normal.x;
            let _e219 = normal.y;
            let dist_proj = abs(((dx * _e216) + (dy * _e219)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e233 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e233];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e239 = dist;
            let diff_coeff_phi = ((1f * area) / _e239);
            let _e241 = is_boundary;
            if !(_e241) {
                let _e243 = diag_0_;
                diag_0_ = (_e243 + diff_coeff_phi);
                let _e252 = matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 1u)) + 0u)] = (_e252 - diff_coeff_phi);
            } else {
                let _e260 = bc_kind[((face_idx * 1u) + 0u)];
                if (_e260 == 1u) {
                    let _e263 = diag_0_;
                    diag_0_ = (_e263 + diff_coeff_phi);
                    let _e271 = bc_value[((face_idx * 1u) + 0u)];
                    let _e273 = rhs_0_;
                    rhs_0_ = (_e273 + (diff_coeff_phi * _e271));
                } else {
                    let _e281 = bc_kind[((face_idx * 1u) + 0u)];
                    if (_e281 == 2u) {
                        let _e292 = bc_value[((face_idx * 1u) + 0u)];
                        let _e295 = rhs_0_;
                        rhs_0_ = (_e295 + -(((1f * area) * _e292)));
                    }
                }
            }
        }
        continuing {
            let _e298 = k;
            k = (_e298 + 1u);
        }
    }
    let _e307 = diag_0_;
    let _e308 = matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 1u)) + 0u)] = (_e308 + _e307);
    let _e316 = rhs_0_;
    rhs[((idx * 1u) + 0u)] = _e316;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum :: Constants > () as _) , } , count : None , } , # [doc = " @binding(5): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentum::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e26 = diagonal_indices[idx];
    let diag_rank = (_e26 - scalar_offset);
    let _e32 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e32 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e47 = rank;
        if (_e47 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e49 = rank;
            matrix_values[((start_row_0_ + (_e49 * 3u)) + 0u)] = 0f;
            let _e58 = rank;
            matrix_values[((start_row_0_ + (_e58 * 3u)) + 1u)] = 0f;
            let _e67 = rank;
            matrix_values[((start_row_0_ + (_e67 * 3u)) + 2u)] = 0f;
            let _e76 = rank;
            matrix_values[((start_row_1_ + (_e76 * 3u)) + 0u)] = 0f;
            let _e85 = rank;
            matrix_values[((start_row_1_ + (_e85 * 3u)) + 1u)] = 0f;
            let _e94 = rank;
            matrix_values[((start_row_1_ + (_e94 * 3u)) + 2u)] = 0f;
            let _e103 = rank;
            matrix_values[((start_row_2_ + (_e103 * 3u)) + 0u)] = 0f;
            let _e112 = rank;
            matrix_values[((start_row_2_ + (_e112 * 3u)) + 1u)] = 0f;
            let _e121 = rank;
            matrix_values[((start_row_2_ + (_e121 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e131 = rank;
            rank = (_e131 + 1u);
        }
    }
    let _e135 = constants.density;
    let _e140 = constants.dt;
    let _e142 = diag_0_;
    diag_0_ = (_e142 + ((vol * _e135) / _e140));
    let _e146 = constants.density;
    let _e150 = constants.dt;
    let _e159 = state_old[((idx * 8u) + 0u)];
    let _e161 = rhs_0_;
    rhs_0_ = (_e161 + (((vol * _e146) / _e150) * _e159));
    let _e165 = constants.time_scheme;
    if (_e165 == 1u) {
        let _e170 = constants.dt;
        let _e173 = constants.dt_old;
        let r = (_e170 / _e173);
        let _e177 = constants.density;
        let _e181 = constants.dt;
        let diag_bdf2_ = ((((vol * _e177) / _e181) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e197 = diag_0_;
        let _e200 = constants.density;
        let _e204 = constants.dt;
        diag_0_ = ((_e197 - ((vol * _e200) / _e204)) + diag_bdf2_);
        let _e208 = rhs_0_;
        let _e211 = constants.density;
        let _e215 = constants.dt;
        let _e223 = state_old[((idx * 8u) + 0u)];
        let _e228 = constants.density;
        let _e232 = constants.dt;
        let _e240 = state_old[((idx * 8u) + 0u)];
        let _e248 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e208 - (((vol * _e211) / _e215) * _e223)) + (((vol * _e228) / _e232) * ((factor_n * _e240) - (factor_nm1_ * _e248))));
    }
    let _e255 = constants.density;
    let _e260 = constants.dt;
    let _e262 = diag_1_;
    diag_1_ = (_e262 + ((vol * _e255) / _e260));
    let _e266 = constants.density;
    let _e270 = constants.dt;
    let _e279 = state_old[((idx * 8u) + 1u)];
    let _e281 = rhs_1_;
    rhs_1_ = (_e281 + (((vol * _e266) / _e270) * _e279));
    let _e285 = constants.time_scheme;
    if (_e285 == 1u) {
        let _e290 = constants.dt;
        let _e293 = constants.dt_old;
        let r_1 = (_e290 / _e293);
        let _e297 = constants.density;
        let _e301 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e297) / _e301) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e317 = diag_1_;
        let _e320 = constants.density;
        let _e324 = constants.dt;
        diag_1_ = ((_e317 - ((vol * _e320) / _e324)) + diag_bdf2_1);
        let _e328 = rhs_1_;
        let _e331 = constants.density;
        let _e335 = constants.dt;
        let _e343 = state_old[((idx * 8u) + 1u)];
        let _e348 = constants.density;
        let _e352 = constants.dt;
        let _e360 = state_old[((idx * 8u) + 1u)];
        let _e368 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e328 - (((vol * _e331) / _e335) * _e343)) + (((vol * _e348) / _e352) * ((factor_n_1 * _e360) - (factor_nm1_1 * _e368))));
    }
    k = start;
    loop {
        let _e374 = k;
        if (_e374 < end) {
        } else {
            break;
        }
        {
            let _e377 = k;
            let face_idx = cell_faces[_e377];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e397 = face_normals[face_idx];
            normal = _e397;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e405 = normal.x;
                normal.x = -(_e405);
                let _e409 = normal.y;
                normal.y = -(_e409);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e416 = other_idx;
                let _e418 = cell_centers[_e416];
                other_center = _e418;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e422 = other_center.x;
            let dx = (_e422 - center.x);
            let _e426 = other_center.y;
            let dy = (_e426 - center.y);
            let _e430 = normal.x;
            let _e433 = normal.y;
            let dist_proj = abs(((dx * _e430) + (dy * _e433)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e447 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e447];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e453 = constants.viscosity;
            let _e455 = dist;
            let diff_coeff_U = ((_e453 * area) / _e455);
            let _e457 = is_boundary;
            if !(_e457) {
                let _e459 = diag_0_;
                diag_0_ = (_e459 + diff_coeff_U);
                let _e468 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e468 - diff_coeff_U);
            } else {
                let _e476 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e476 == 1u) {
                    let _e479 = diag_0_;
                    diag_0_ = (_e479 + diff_coeff_U);
                    let _e487 = bc_value[((face_idx * 3u) + 0u)];
                    let _e489 = rhs_0_;
                    rhs_0_ = (_e489 + (diff_coeff_U * _e487));
                } else {
                    let _e497 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e497 == 2u) {
                        let _e502 = constants.viscosity;
                        let _e510 = bc_value[((face_idx * 3u) + 0u)];
                        let _e513 = rhs_0_;
                        rhs_0_ = (_e513 + -(((_e502 * area) * _e510)));
                    }
                }
            }
            let _e515 = is_boundary;
            if !(_e515) {
                let _e517 = diag_1_;
                diag_1_ = (_e517 + diff_coeff_U);
                let _e526 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e526 - diff_coeff_U);
            } else {
                let _e534 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e534 == 1u) {
                    let _e537 = diag_1_;
                    diag_1_ = (_e537 + diff_coeff_U);
                    let _e545 = bc_value[((face_idx * 3u) + 1u)];
                    let _e547 = rhs_1_;
                    rhs_1_ = (_e547 + (diff_coeff_U * _e545));
                } else {
                    let _e555 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e555 == 2u) {
                        let _e560 = constants.viscosity;
                        let _e568 = bc_value[((face_idx * 3u) + 1u)];
                        let _e571 = rhs_1_;
                        rhs_1_ = (_e571 + -(((_e560 * area) * _e568)));
                    }
                }
            }
            let _e579 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e579;
            if (owner != idx) {
                let _e582 = phi_0_;
                let _e585 = phi_0_;
                phi_0_ = (_e585 - (_e582 * 2f));
            }
            let _e587 = is_boundary;
            if !(_e587) {
                let _e589 = phi_0_;
                let _e592 = diag_0_;
                diag_0_ = (_e592 + max(_e589, 0f));
                let _e601 = phi_0_;
                let _e604 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e604 + min(_e601, 0f));
                let _e606 = phi_0_;
                let _e613 = state[((idx * 8u) + 0u)];
                let _e614 = other_idx;
                let _e621 = state[((_e614 * 8u) + 0u)];
                let _e622 = phi_0_;
                let _e626 = other_idx;
                let _e633 = state[((_e626 * 8u) + 0u)];
                let _e634 = other_idx;
                let _e641 = state[((_e634 * 8u) + 0u)];
                let _e648 = state[((idx * 8u) + 0u)];
                let _e657 = other_idx;
                let _e664 = state[((_e657 * 8u) + 0u)];
                let _e671 = state[((idx * 8u) + 0u)];
                let _e682 = other_idx;
                let _e689 = state[((_e682 * 8u) + 0u)];
                let _e696 = state[((idx * 8u) + 0u)];
                let _e705 = other_idx;
                let _e712 = state[((_e705 * 8u) + 0u)];
                let _e719 = state[((idx * 8u) + 0u)];
                let _e735 = other_center.x;
                let _e737 = other_center.y;
                let _e748 = state[((idx * 8u) + 0u)];
                let _e749 = other_idx;
                let _e756 = state[((_e749 * 8u) + 0u)];
                let _e763 = state[((idx * 8u) + 0u)];
                let _e772 = other_idx;
                let _e779 = state[((_e772 * 8u) + 0u)];
                let _e786 = state[((idx * 8u) + 0u)];
                let _e797 = other_idx;
                let _e804 = state[((_e797 * 8u) + 0u)];
                let _e811 = state[((idx * 8u) + 0u)];
                let _e820 = other_idx;
                let _e827 = state[((_e820 * 8u) + 0u)];
                let _e834 = state[((idx * 8u) + 0u)];
                let _e855 = phi_0_;
                let _e861 = constants.scheme;
                let _e865 = other_idx;
                let _e872 = state[((_e865 * 8u) + 0u)];
                let _e881 = state[((idx * 8u) + 0u)];
                let _e885 = other_idx;
                let _e892 = state[((_e885 * 8u) + 0u)];
                let _e899 = state[((idx * 8u) + 0u)];
                let _e908 = other_idx;
                let _e915 = state[((_e908 * 8u) + 0u)];
                let _e922 = state[((idx * 8u) + 0u)];
                let _e933 = other_idx;
                let _e940 = state[((_e933 * 8u) + 0u)];
                let _e947 = state[((idx * 8u) + 0u)];
                let _e956 = other_idx;
                let _e963 = state[((_e956 * 8u) + 0u)];
                let _e970 = state[((idx * 8u) + 0u)];
                let _e986 = other_center.x;
                let _e988 = other_center.y;
                let _e1001 = state[((idx * 8u) + 0u)];
                let _e1004 = other_idx;
                let _e1011 = state[((_e1004 * 8u) + 0u)];
                let _e1015 = other_idx;
                let _e1022 = state[((_e1015 * 8u) + 0u)];
                let _e1029 = state[((idx * 8u) + 0u)];
                let _e1038 = other_idx;
                let _e1045 = state[((_e1038 * 8u) + 0u)];
                let _e1052 = state[((idx * 8u) + 0u)];
                let _e1063 = other_idx;
                let _e1070 = state[((_e1063 * 8u) + 0u)];
                let _e1077 = state[((idx * 8u) + 0u)];
                let _e1086 = other_idx;
                let _e1093 = state[((_e1086 * 8u) + 0u)];
                let _e1100 = state[((idx * 8u) + 0u)];
                let _e1113 = other_center.x;
                let _e1115 = other_center.y;
                let _e1125 = phi_0_;
                let _e1131 = constants.scheme;
                let _e1135 = other_idx;
                let _e1142 = state[((_e1135 * 8u) + 0u)];
                let _e1143 = other_idx;
                let _e1150 = state[((_e1143 * 8u) + 0u)];
                let _e1157 = state[((idx * 8u) + 0u)];
                let _e1166 = other_idx;
                let _e1173 = state[((_e1166 * 8u) + 0u)];
                let _e1180 = state[((idx * 8u) + 0u)];
                let _e1191 = other_idx;
                let _e1198 = state[((_e1191 * 8u) + 0u)];
                let _e1205 = state[((idx * 8u) + 0u)];
                let _e1214 = other_idx;
                let _e1221 = state[((_e1214 * 8u) + 0u)];
                let _e1228 = state[((idx * 8u) + 0u)];
                let _e1244 = other_center.x;
                let _e1246 = other_center.y;
                let _e1256 = state[((idx * 8u) + 0u)];
                let _e1257 = other_idx;
                let _e1264 = state[((_e1257 * 8u) + 0u)];
                let _e1275 = state[((idx * 8u) + 0u)];
                let _e1276 = other_idx;
                let _e1283 = state[((_e1276 * 8u) + 0u)];
                let _e1295 = state[((idx * 8u) + 0u)];
                let _e1296 = other_idx;
                let _e1303 = state[((_e1296 * 8u) + 0u)];
                let _e1310 = state[((idx * 8u) + 0u)];
                let _e1319 = other_idx;
                let _e1326 = state[((_e1319 * 8u) + 0u)];
                let _e1333 = state[((idx * 8u) + 0u)];
                let _e1344 = other_idx;
                let _e1351 = state[((_e1344 * 8u) + 0u)];
                let _e1358 = state[((idx * 8u) + 0u)];
                let _e1367 = other_idx;
                let _e1374 = state[((_e1367 * 8u) + 0u)];
                let _e1381 = state[((idx * 8u) + 0u)];
                let _e1401 = other_idx;
                let _e1408 = state[((_e1401 * 8u) + 0u)];
                let _e1415 = state[((idx * 8u) + 0u)];
                let _e1420 = other_idx;
                let _e1427 = state[((_e1420 * 8u) + 0u)];
                let _e1434 = state[((idx * 8u) + 0u)];
                let _e1440 = phi_0_;
                let _e1446 = constants.scheme;
                let _e1450 = other_idx;
                let _e1457 = state[((_e1450 * 8u) + 0u)];
                let _e1458 = other_idx;
                let _e1465 = state[((_e1458 * 8u) + 0u)];
                let _e1472 = state[((idx * 8u) + 0u)];
                let _e1481 = other_idx;
                let _e1488 = state[((_e1481 * 8u) + 0u)];
                let _e1495 = state[((idx * 8u) + 0u)];
                let _e1506 = other_idx;
                let _e1513 = state[((_e1506 * 8u) + 0u)];
                let _e1520 = state[((idx * 8u) + 0u)];
                let _e1529 = other_idx;
                let _e1536 = state[((_e1529 * 8u) + 0u)];
                let _e1543 = state[((idx * 8u) + 0u)];
                let _e1559 = other_center.x;
                let _e1561 = other_center.y;
                let _e1571 = state[((idx * 8u) + 0u)];
                let _e1572 = other_idx;
                let _e1579 = state[((_e1572 * 8u) + 0u)];
                let _e1589 = state[((idx * 8u) + 0u)];
                let _e1590 = other_idx;
                let _e1597 = state[((_e1590 * 8u) + 0u)];
                let _e1600 = other_idx;
                let _e1607 = state[((_e1600 * 8u) + 0u)];
                let _e1614 = state[((idx * 8u) + 0u)];
                let _e1623 = other_idx;
                let _e1630 = state[((_e1623 * 8u) + 0u)];
                let _e1637 = state[((idx * 8u) + 0u)];
                let _e1648 = other_idx;
                let _e1655 = state[((_e1648 * 8u) + 0u)];
                let _e1662 = state[((idx * 8u) + 0u)];
                let _e1671 = other_idx;
                let _e1678 = state[((_e1671 * 8u) + 0u)];
                let _e1685 = state[((idx * 8u) + 0u)];
                let _e1701 = other_center.x;
                let _e1703 = other_center.y;
                let _e1718 = state[((idx * 8u) + 0u)];
                let _e1719 = other_idx;
                let _e1726 = state[((_e1719 * 8u) + 0u)];
                let _e1728 = other_idx;
                let _e1735 = state[((_e1728 * 8u) + 0u)];
                let _e1742 = state[((idx * 8u) + 0u)];
                let _e1751 = other_idx;
                let _e1758 = state[((_e1751 * 8u) + 0u)];
                let _e1765 = state[((idx * 8u) + 0u)];
                let _e1776 = other_idx;
                let _e1783 = state[((_e1776 * 8u) + 0u)];
                let _e1790 = state[((idx * 8u) + 0u)];
                let _e1799 = other_idx;
                let _e1806 = state[((_e1799 * 8u) + 0u)];
                let _e1813 = state[((idx * 8u) + 0u)];
                let _e1829 = other_center.x;
                let _e1831 = other_center.y;
                let _e1847 = state[((idx * 8u) + 0u)];
                let _e1848 = other_idx;
                let _e1855 = state[((_e1848 * 8u) + 0u)];
                let _e1862 = state[((idx * 8u) + 0u)];
                let _e1871 = other_idx;
                let _e1878 = state[((_e1871 * 8u) + 0u)];
                let _e1885 = state[((idx * 8u) + 0u)];
                let _e1896 = other_idx;
                let _e1903 = state[((_e1896 * 8u) + 0u)];
                let _e1910 = state[((idx * 8u) + 0u)];
                let _e1919 = other_idx;
                let _e1926 = state[((_e1919 * 8u) + 0u)];
                let _e1933 = state[((idx * 8u) + 0u)];
                let _e1953 = other_idx;
                let _e1960 = state[((_e1953 * 8u) + 0u)];
                let _e1967 = state[((idx * 8u) + 0u)];
                let _e1971 = other_idx;
                let _e1978 = state[((_e1971 * 8u) + 0u)];
                let _e1985 = state[((idx * 8u) + 0u)];
                let _e1988 = other_idx;
                let _e1995 = state[((_e1988 * 8u) + 0u)];
                let _e2002 = state[((idx * 8u) + 0u)];
                let _e2011 = other_idx;
                let _e2018 = state[((_e2011 * 8u) + 0u)];
                let _e2025 = state[((idx * 8u) + 0u)];
                let _e2036 = other_idx;
                let _e2043 = state[((_e2036 * 8u) + 0u)];
                let _e2050 = state[((idx * 8u) + 0u)];
                let _e2059 = other_idx;
                let _e2066 = state[((_e2059 * 8u) + 0u)];
                let _e2073 = state[((idx * 8u) + 0u)];
                let _e2098 = other_idx;
                let _e2105 = state[((_e2098 * 8u) + 0u)];
                let _e2112 = state[((idx * 8u) + 0u)];
                let _e2114 = other_idx;
                let _e2121 = state[((_e2114 * 8u) + 0u)];
                let _e2128 = state[((idx * 8u) + 0u)];
                let _e2137 = other_idx;
                let _e2144 = state[((_e2137 * 8u) + 0u)];
                let _e2151 = state[((idx * 8u) + 0u)];
                let _e2162 = other_idx;
                let _e2169 = state[((_e2162 * 8u) + 0u)];
                let _e2176 = state[((idx * 8u) + 0u)];
                let _e2185 = other_idx;
                let _e2192 = state[((_e2185 * 8u) + 0u)];
                let _e2199 = state[((idx * 8u) + 0u)];
                let _e2225 = phi_0_;
                let _e2231 = constants.scheme;
                let _e2235 = other_idx;
                let _e2242 = state[((_e2235 * 8u) + 0u)];
                let _e2243 = other_idx;
                let _e2250 = state[((_e2243 * 8u) + 0u)];
                let _e2259 = state[((idx * 8u) + 0u)];
                let _e2263 = other_idx;
                let _e2270 = state[((_e2263 * 8u) + 0u)];
                let _e2277 = state[((idx * 8u) + 0u)];
                let _e2286 = other_idx;
                let _e2293 = state[((_e2286 * 8u) + 0u)];
                let _e2300 = state[((idx * 8u) + 0u)];
                let _e2311 = other_idx;
                let _e2318 = state[((_e2311 * 8u) + 0u)];
                let _e2325 = state[((idx * 8u) + 0u)];
                let _e2334 = other_idx;
                let _e2341 = state[((_e2334 * 8u) + 0u)];
                let _e2348 = state[((idx * 8u) + 0u)];
                let _e2364 = other_center.x;
                let _e2366 = other_center.y;
                let _e2373 = other_idx;
                let _e2380 = state[((_e2373 * 8u) + 0u)];
                let _e2388 = state[((idx * 8u) + 0u)];
                let _e2389 = other_idx;
                let _e2396 = state[((_e2389 * 8u) + 0u)];
                let _e2407 = state[((idx * 8u) + 0u)];
                let _e2408 = other_idx;
                let _e2415 = state[((_e2408 * 8u) + 0u)];
                let _e2427 = state[((idx * 8u) + 0u)];
                let _e2434 = state[((idx * 8u) + 0u)];
                let _e2437 = other_idx;
                let _e2444 = state[((_e2437 * 8u) + 0u)];
                let _e2448 = other_idx;
                let _e2455 = state[((_e2448 * 8u) + 0u)];
                let _e2462 = state[((idx * 8u) + 0u)];
                let _e2471 = other_idx;
                let _e2478 = state[((_e2471 * 8u) + 0u)];
                let _e2485 = state[((idx * 8u) + 0u)];
                let _e2496 = other_idx;
                let _e2503 = state[((_e2496 * 8u) + 0u)];
                let _e2510 = state[((idx * 8u) + 0u)];
                let _e2519 = other_idx;
                let _e2526 = state[((_e2519 * 8u) + 0u)];
                let _e2533 = state[((idx * 8u) + 0u)];
                let _e2546 = other_center.x;
                let _e2548 = other_center.y;
                let _e2564 = state[((idx * 8u) + 0u)];
                let _e2566 = other_idx;
                let _e2573 = state[((_e2566 * 8u) + 0u)];
                let _e2580 = state[((idx * 8u) + 0u)];
                let _e2585 = other_idx;
                let _e2592 = state[((_e2585 * 8u) + 0u)];
                let _e2599 = state[((idx * 8u) + 0u)];
                let _e2605 = phi_0_;
                let _e2611 = constants.scheme;
                let _e2615 = other_idx;
                let _e2622 = state[((_e2615 * 8u) + 0u)];
                let _e2623 = other_idx;
                let _e2630 = state[((_e2623 * 8u) + 0u)];
                let _e2639 = state[((idx * 8u) + 0u)];
                let _e2643 = other_idx;
                let _e2650 = state[((_e2643 * 8u) + 0u)];
                let _e2657 = state[((idx * 8u) + 0u)];
                let _e2666 = other_idx;
                let _e2673 = state[((_e2666 * 8u) + 0u)];
                let _e2680 = state[((idx * 8u) + 0u)];
                let _e2691 = other_idx;
                let _e2698 = state[((_e2691 * 8u) + 0u)];
                let _e2705 = state[((idx * 8u) + 0u)];
                let _e2714 = other_idx;
                let _e2721 = state[((_e2714 * 8u) + 0u)];
                let _e2728 = state[((idx * 8u) + 0u)];
                let _e2744 = other_center.x;
                let _e2746 = other_center.y;
                let _e2753 = other_idx;
                let _e2760 = state[((_e2753 * 8u) + 0u)];
                let _e2768 = state[((idx * 8u) + 0u)];
                let _e2769 = other_idx;
                let _e2776 = state[((_e2769 * 8u) + 0u)];
                let _e2786 = state[((idx * 8u) + 0u)];
                let _e2787 = other_idx;
                let _e2794 = state[((_e2787 * 8u) + 0u)];
                let _e2797 = other_idx;
                let _e2804 = state[((_e2797 * 8u) + 0u)];
                let _e2813 = state[((idx * 8u) + 0u)];
                let _e2817 = other_idx;
                let _e2824 = state[((_e2817 * 8u) + 0u)];
                let _e2831 = state[((idx * 8u) + 0u)];
                let _e2840 = other_idx;
                let _e2847 = state[((_e2840 * 8u) + 0u)];
                let _e2854 = state[((idx * 8u) + 0u)];
                let _e2865 = other_idx;
                let _e2872 = state[((_e2865 * 8u) + 0u)];
                let _e2879 = state[((idx * 8u) + 0u)];
                let _e2888 = other_idx;
                let _e2895 = state[((_e2888 * 8u) + 0u)];
                let _e2902 = state[((idx * 8u) + 0u)];
                let _e2918 = other_center.x;
                let _e2920 = other_center.y;
                let _e2927 = other_idx;
                let _e2934 = state[((_e2927 * 8u) + 0u)];
                let _e2947 = state[((idx * 8u) + 0u)];
                let _e2948 = other_idx;
                let _e2955 = state[((_e2948 * 8u) + 0u)];
                let _e2957 = other_idx;
                let _e2964 = state[((_e2957 * 8u) + 0u)];
                let _e2973 = state[((idx * 8u) + 0u)];
                let _e2977 = other_idx;
                let _e2984 = state[((_e2977 * 8u) + 0u)];
                let _e2991 = state[((idx * 8u) + 0u)];
                let _e3000 = other_idx;
                let _e3007 = state[((_e3000 * 8u) + 0u)];
                let _e3014 = state[((idx * 8u) + 0u)];
                let _e3025 = other_idx;
                let _e3032 = state[((_e3025 * 8u) + 0u)];
                let _e3039 = state[((idx * 8u) + 0u)];
                let _e3048 = other_idx;
                let _e3055 = state[((_e3048 * 8u) + 0u)];
                let _e3062 = state[((idx * 8u) + 0u)];
                let _e3078 = other_center.x;
                let _e3080 = other_center.y;
                let _e3087 = other_idx;
                let _e3094 = state[((_e3087 * 8u) + 0u)];
                let _e3108 = state[((idx * 8u) + 0u)];
                let _e3115 = state[((idx * 8u) + 0u)];
                let _e3118 = other_idx;
                let _e3125 = state[((_e3118 * 8u) + 0u)];
                let _e3129 = other_idx;
                let _e3136 = state[((_e3129 * 8u) + 0u)];
                let _e3143 = state[((idx * 8u) + 0u)];
                let _e3152 = other_idx;
                let _e3159 = state[((_e3152 * 8u) + 0u)];
                let _e3166 = state[((idx * 8u) + 0u)];
                let _e3177 = other_idx;
                let _e3184 = state[((_e3177 * 8u) + 0u)];
                let _e3191 = state[((idx * 8u) + 0u)];
                let _e3200 = other_idx;
                let _e3207 = state[((_e3200 * 8u) + 0u)];
                let _e3214 = state[((idx * 8u) + 0u)];
                let _e3227 = other_center.x;
                let _e3229 = other_center.y;
                let _e3245 = state[((idx * 8u) + 0u)];
                let _e3247 = other_idx;
                let _e3254 = state[((_e3247 * 8u) + 0u)];
                let _e3261 = state[((idx * 8u) + 0u)];
                let _e3265 = other_idx;
                let _e3272 = state[((_e3265 * 8u) + 0u)];
                let _e3279 = state[((idx * 8u) + 0u)];
                let _e3288 = state[((idx * 8u) + 0u)];
                let _e3291 = other_idx;
                let _e3298 = state[((_e3291 * 8u) + 0u)];
                let _e3302 = other_idx;
                let _e3309 = state[((_e3302 * 8u) + 0u)];
                let _e3316 = state[((idx * 8u) + 0u)];
                let _e3325 = other_idx;
                let _e3332 = state[((_e3325 * 8u) + 0u)];
                let _e3339 = state[((idx * 8u) + 0u)];
                let _e3350 = other_idx;
                let _e3357 = state[((_e3350 * 8u) + 0u)];
                let _e3364 = state[((idx * 8u) + 0u)];
                let _e3373 = other_idx;
                let _e3380 = state[((_e3373 * 8u) + 0u)];
                let _e3387 = state[((idx * 8u) + 0u)];
                let _e3400 = other_center.x;
                let _e3402 = other_center.y;
                let _e3418 = state[((idx * 8u) + 0u)];
                let _e3425 = other_idx;
                let _e3432 = state[((_e3425 * 8u) + 0u)];
                let _e3439 = state[((idx * 8u) + 0u)];
                let _e3447 = state[((idx * 8u) + 0u)];
                let _e3450 = other_idx;
                let _e3457 = state[((_e3450 * 8u) + 0u)];
                let _e3461 = other_idx;
                let _e3468 = state[((_e3461 * 8u) + 0u)];
                let _e3475 = state[((idx * 8u) + 0u)];
                let _e3484 = other_idx;
                let _e3491 = state[((_e3484 * 8u) + 0u)];
                let _e3498 = state[((idx * 8u) + 0u)];
                let _e3509 = other_idx;
                let _e3516 = state[((_e3509 * 8u) + 0u)];
                let _e3523 = state[((idx * 8u) + 0u)];
                let _e3532 = other_idx;
                let _e3539 = state[((_e3532 * 8u) + 0u)];
                let _e3546 = state[((idx * 8u) + 0u)];
                let _e3559 = other_center.x;
                let _e3561 = other_center.y;
                let _e3577 = state[((idx * 8u) + 0u)];
                let _e3585 = phi_0_;
                let _e3591 = constants.scheme;
                let _e3601 = state[((idx * 8u) + 0u)];
                let _e3602 = other_idx;
                let _e3609 = state[((_e3602 * 8u) + 0u)];
                let _e3610 = phi_0_;
                let _e3616 = rhs_0_;
                rhs_0_ = (_e3616 - (_e606 * (select(select(select(select(select(select(select(_e613, _e621, (_e622 < 0f)), select((_e633 + dot(vec2<f32>(vec2<f32>((((_e641 - _e648) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e664 - _e671) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e689 - _e696) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e712 - _e719) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e735, _e737)))), (_e748 + dot(vec2<f32>(vec2<f32>((((_e756 - _e763) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e779 - _e786) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e804 - _e811) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e827 - _e834) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e855 > 0f)), (_e861 == 1u)), select((((_e872 * 0.625f) + (_e881 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e892 - _e899) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e915 - _e922) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e940 - _e947) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e963 - _e970) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e986, _e988))) * 0.125f)), (((_e1001 * 0.625f) + (_e1011 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e1022 - _e1029) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1045 - _e1052) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1070 - _e1077) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1093 - _e1100) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e1113, _e1115) - vec2<f32>(center.x, center.y))) * 0.125f)), (_e1125 > 0f)), (_e1131 == 2u)), select((_e1142 + min(max(dot(vec2<f32>(vec2<f32>((((_e1150 - _e1157) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1173 - _e1180) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1198 - _e1205) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1221 - _e1228) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1244, _e1246))), min((_e1256 - _e1264), 0f)), max((_e1275 - _e1283), 0f))), (_e1295 + min(max(dot(vec2<f32>(vec2<f32>((((_e1303 - _e1310) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1326 - _e1333) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1351 - _e1358) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1374 - _e1381) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1408 - _e1415), 0f)), max((_e1427 - _e1434), 0f))), (_e1440 > 0f)), (_e1446 == 3u)), select((_e1457 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e1465 - _e1472) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1488 - _e1495) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1513 - _e1520) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1536 - _e1543) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1559, _e1561))) * abs((_e1571 - _e1579))) / max(abs((_e1589 - _e1597)), (abs(dot(vec2<f32>(vec2<f32>((((_e1607 - _e1614) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1630 - _e1637) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1655 - _e1662) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1678 - _e1685) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1701, _e1703)))) + 0.00000001f))), (((_e1718 - _e1726) * dot(vec2<f32>(vec2<f32>((((_e1735 - _e1742) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1758 - _e1765) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1783 - _e1790) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1806 - _e1813) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1829, _e1831)))) > 0f))), (_e1847 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e1855 - _e1862) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1878 - _e1885) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1903 - _e1910) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1926 - _e1933) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1960 - _e1967))) / max(abs((_e1978 - _e1985)), (abs(dot(vec2<f32>(vec2<f32>((((_e1995 - _e2002) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2018 - _e2025) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2043 - _e2050) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2066 - _e2073) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))), (((_e2105 - _e2112) * dot(vec2<f32>(vec2<f32>((((_e2121 - _e2128) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2144 - _e2151) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2169 - _e2176) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2192 - _e2199) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) > 0f))), (_e2225 > 0f)), (_e2231 == 4u)), select((_e2242 + min(max(((((_e2250 * 0.625f) + (_e2259 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2270 - _e2277) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2293 - _e2300) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2318 - _e2325) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2341 - _e2348) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2364, _e2366))) * 0.125f)) - _e2380), min((_e2388 - _e2396), 0f)), max((_e2407 - _e2415), 0f))), (_e2427 + min(max(((((_e2434 * 0.625f) + (_e2444 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2455 - _e2462) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2478 - _e2485) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2503 - _e2510) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2526 - _e2533) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e2546, _e2548) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2564), min((_e2573 - _e2580), 0f)), max((_e2592 - _e2599), 0f))), (_e2605 > 0f)), (_e2611 == 5u)), select((_e2622 + select(0f, ((((((_e2630 * 0.625f) + (_e2639 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2650 - _e2657) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2673 - _e2680) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2698 - _e2705) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2721 - _e2728) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2744, _e2746))) * 0.125f)) - _e2760) * abs((_e2768 - _e2776))) / max(abs((_e2786 - _e2794)), (abs(((((_e2804 * 0.625f) + (_e2813 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2824 - _e2831) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2847 - _e2854) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2872 - _e2879) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2895 - _e2902) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2918, _e2920))) * 0.125f)) - _e2934)) + 0.00000001f))), (((_e2947 - _e2955) * ((((_e2964 * 0.625f) + (_e2973 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2984 - _e2991) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3007 - _e3014) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3032 - _e3039) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3055 - _e3062) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3078, _e3080))) * 0.125f)) - _e3094)) > 0f))), (_e3108 + select(0f, ((((((_e3115 * 0.625f) + (_e3125 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3136 - _e3143) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3159 - _e3166) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3184 - _e3191) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3207 - _e3214) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e3227, _e3229) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3245) * abs((_e3254 - _e3261))) / max(abs((_e3272 - _e3279)), (abs(((((_e3288 * 0.625f) + (_e3298 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3309 - _e3316) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3332 - _e3339) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3357 - _e3364) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3380 - _e3387) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e3400, _e3402) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3418)) + 0.00000001f))), (((_e3432 - _e3439) * ((((_e3447 * 0.625f) + (_e3457 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3468 - _e3475) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3491 - _e3498) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3516 - _e3523) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3539 - _e3546) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e3559, _e3561) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3577)) > 0f))), (_e3585 > 0f)), (_e3591 == 6u)) - select(_e3601, _e3609, (_e3610 < 0f)))));
            } else {
                let _e3624 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3624 == 1u) {
                    let _e3627 = phi_0_;
                    let _e3630 = diag_0_;
                    diag_0_ = (_e3630 + max(_e3627, 0f));
                    let _e3632 = phi_0_;
                    let _e3641 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3643 = rhs_0_;
                    rhs_0_ = (_e3643 - (min(_e3632, 0f) * _e3641));
                } else {
                    let _e3645 = phi_0_;
                    let _e3646 = diag_0_;
                    diag_0_ = (_e3646 + _e3645);
                }
            }
            let _e3654 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3654;
            if (owner != idx) {
                let _e3657 = phi_1_;
                let _e3660 = phi_1_;
                phi_1_ = (_e3660 - (_e3657 * 2f));
            }
            let _e3662 = is_boundary;
            if !(_e3662) {
                let _e3664 = phi_1_;
                let _e3667 = diag_1_;
                diag_1_ = (_e3667 + max(_e3664, 0f));
                let _e3676 = phi_1_;
                let _e3679 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3679 + min(_e3676, 0f));
                let _e3681 = phi_1_;
                let _e3688 = state[((idx * 8u) + 1u)];
                let _e3689 = other_idx;
                let _e3696 = state[((_e3689 * 8u) + 1u)];
                let _e3697 = phi_1_;
                let _e3701 = other_idx;
                let _e3708 = state[((_e3701 * 8u) + 1u)];
                let _e3709 = other_idx;
                let _e3716 = state[((_e3709 * 8u) + 1u)];
                let _e3723 = state[((idx * 8u) + 1u)];
                let _e3732 = other_idx;
                let _e3739 = state[((_e3732 * 8u) + 1u)];
                let _e3746 = state[((idx * 8u) + 1u)];
                let _e3757 = other_idx;
                let _e3764 = state[((_e3757 * 8u) + 1u)];
                let _e3771 = state[((idx * 8u) + 1u)];
                let _e3780 = other_idx;
                let _e3787 = state[((_e3780 * 8u) + 1u)];
                let _e3794 = state[((idx * 8u) + 1u)];
                let _e3810 = other_center.x;
                let _e3812 = other_center.y;
                let _e3823 = state[((idx * 8u) + 1u)];
                let _e3824 = other_idx;
                let _e3831 = state[((_e3824 * 8u) + 1u)];
                let _e3838 = state[((idx * 8u) + 1u)];
                let _e3847 = other_idx;
                let _e3854 = state[((_e3847 * 8u) + 1u)];
                let _e3861 = state[((idx * 8u) + 1u)];
                let _e3872 = other_idx;
                let _e3879 = state[((_e3872 * 8u) + 1u)];
                let _e3886 = state[((idx * 8u) + 1u)];
                let _e3895 = other_idx;
                let _e3902 = state[((_e3895 * 8u) + 1u)];
                let _e3909 = state[((idx * 8u) + 1u)];
                let _e3930 = phi_1_;
                let _e3936 = constants.scheme;
                let _e3940 = other_idx;
                let _e3947 = state[((_e3940 * 8u) + 1u)];
                let _e3956 = state[((idx * 8u) + 1u)];
                let _e3960 = other_idx;
                let _e3967 = state[((_e3960 * 8u) + 1u)];
                let _e3974 = state[((idx * 8u) + 1u)];
                let _e3983 = other_idx;
                let _e3990 = state[((_e3983 * 8u) + 1u)];
                let _e3997 = state[((idx * 8u) + 1u)];
                let _e4008 = other_idx;
                let _e4015 = state[((_e4008 * 8u) + 1u)];
                let _e4022 = state[((idx * 8u) + 1u)];
                let _e4031 = other_idx;
                let _e4038 = state[((_e4031 * 8u) + 1u)];
                let _e4045 = state[((idx * 8u) + 1u)];
                let _e4061 = other_center.x;
                let _e4063 = other_center.y;
                let _e4076 = state[((idx * 8u) + 1u)];
                let _e4079 = other_idx;
                let _e4086 = state[((_e4079 * 8u) + 1u)];
                let _e4090 = other_idx;
                let _e4097 = state[((_e4090 * 8u) + 1u)];
                let _e4104 = state[((idx * 8u) + 1u)];
                let _e4113 = other_idx;
                let _e4120 = state[((_e4113 * 8u) + 1u)];
                let _e4127 = state[((idx * 8u) + 1u)];
                let _e4138 = other_idx;
                let _e4145 = state[((_e4138 * 8u) + 1u)];
                let _e4152 = state[((idx * 8u) + 1u)];
                let _e4161 = other_idx;
                let _e4168 = state[((_e4161 * 8u) + 1u)];
                let _e4175 = state[((idx * 8u) + 1u)];
                let _e4188 = other_center.x;
                let _e4190 = other_center.y;
                let _e4200 = phi_1_;
                let _e4206 = constants.scheme;
                let _e4210 = other_idx;
                let _e4217 = state[((_e4210 * 8u) + 1u)];
                let _e4218 = other_idx;
                let _e4225 = state[((_e4218 * 8u) + 1u)];
                let _e4232 = state[((idx * 8u) + 1u)];
                let _e4241 = other_idx;
                let _e4248 = state[((_e4241 * 8u) + 1u)];
                let _e4255 = state[((idx * 8u) + 1u)];
                let _e4266 = other_idx;
                let _e4273 = state[((_e4266 * 8u) + 1u)];
                let _e4280 = state[((idx * 8u) + 1u)];
                let _e4289 = other_idx;
                let _e4296 = state[((_e4289 * 8u) + 1u)];
                let _e4303 = state[((idx * 8u) + 1u)];
                let _e4319 = other_center.x;
                let _e4321 = other_center.y;
                let _e4331 = state[((idx * 8u) + 1u)];
                let _e4332 = other_idx;
                let _e4339 = state[((_e4332 * 8u) + 1u)];
                let _e4350 = state[((idx * 8u) + 1u)];
                let _e4351 = other_idx;
                let _e4358 = state[((_e4351 * 8u) + 1u)];
                let _e4370 = state[((idx * 8u) + 1u)];
                let _e4371 = other_idx;
                let _e4378 = state[((_e4371 * 8u) + 1u)];
                let _e4385 = state[((idx * 8u) + 1u)];
                let _e4394 = other_idx;
                let _e4401 = state[((_e4394 * 8u) + 1u)];
                let _e4408 = state[((idx * 8u) + 1u)];
                let _e4419 = other_idx;
                let _e4426 = state[((_e4419 * 8u) + 1u)];
                let _e4433 = state[((idx * 8u) + 1u)];
                let _e4442 = other_idx;
                let _e4449 = state[((_e4442 * 8u) + 1u)];
                let _e4456 = state[((idx * 8u) + 1u)];
                let _e4476 = other_idx;
                let _e4483 = state[((_e4476 * 8u) + 1u)];
                let _e4490 = state[((idx * 8u) + 1u)];
                let _e4495 = other_idx;
                let _e4502 = state[((_e4495 * 8u) + 1u)];
                let _e4509 = state[((idx * 8u) + 1u)];
                let _e4515 = phi_1_;
                let _e4521 = constants.scheme;
                let _e4525 = other_idx;
                let _e4532 = state[((_e4525 * 8u) + 1u)];
                let _e4533 = other_idx;
                let _e4540 = state[((_e4533 * 8u) + 1u)];
                let _e4547 = state[((idx * 8u) + 1u)];
                let _e4556 = other_idx;
                let _e4563 = state[((_e4556 * 8u) + 1u)];
                let _e4570 = state[((idx * 8u) + 1u)];
                let _e4581 = other_idx;
                let _e4588 = state[((_e4581 * 8u) + 1u)];
                let _e4595 = state[((idx * 8u) + 1u)];
                let _e4604 = other_idx;
                let _e4611 = state[((_e4604 * 8u) + 1u)];
                let _e4618 = state[((idx * 8u) + 1u)];
                let _e4634 = other_center.x;
                let _e4636 = other_center.y;
                let _e4646 = state[((idx * 8u) + 1u)];
                let _e4647 = other_idx;
                let _e4654 = state[((_e4647 * 8u) + 1u)];
                let _e4664 = state[((idx * 8u) + 1u)];
                let _e4665 = other_idx;
                let _e4672 = state[((_e4665 * 8u) + 1u)];
                let _e4675 = other_idx;
                let _e4682 = state[((_e4675 * 8u) + 1u)];
                let _e4689 = state[((idx * 8u) + 1u)];
                let _e4698 = other_idx;
                let _e4705 = state[((_e4698 * 8u) + 1u)];
                let _e4712 = state[((idx * 8u) + 1u)];
                let _e4723 = other_idx;
                let _e4730 = state[((_e4723 * 8u) + 1u)];
                let _e4737 = state[((idx * 8u) + 1u)];
                let _e4746 = other_idx;
                let _e4753 = state[((_e4746 * 8u) + 1u)];
                let _e4760 = state[((idx * 8u) + 1u)];
                let _e4776 = other_center.x;
                let _e4778 = other_center.y;
                let _e4793 = state[((idx * 8u) + 1u)];
                let _e4794 = other_idx;
                let _e4801 = state[((_e4794 * 8u) + 1u)];
                let _e4803 = other_idx;
                let _e4810 = state[((_e4803 * 8u) + 1u)];
                let _e4817 = state[((idx * 8u) + 1u)];
                let _e4826 = other_idx;
                let _e4833 = state[((_e4826 * 8u) + 1u)];
                let _e4840 = state[((idx * 8u) + 1u)];
                let _e4851 = other_idx;
                let _e4858 = state[((_e4851 * 8u) + 1u)];
                let _e4865 = state[((idx * 8u) + 1u)];
                let _e4874 = other_idx;
                let _e4881 = state[((_e4874 * 8u) + 1u)];
                let _e4888 = state[((idx * 8u) + 1u)];
                let _e4904 = other_center.x;
                let _e4906 = other_center.y;
                let _e4922 = state[((idx * 8u) + 1u)];
                let _e4923 = other_idx;
                let _e4930 = state[((_e4923 * 8u) + 1u)];
                let _e4937 = state[((idx * 8u) + 1u)];
                let _e4946 = other_idx;
                let _e4953 = state[((_e4946 * 8u) + 1u)];
                let _e4960 = state[((idx * 8u) + 1u)];
                let _e4971 = other_idx;
                let _e4978 = state[((_e4971 * 8u) + 1u)];
                let _e4985 = state[((idx * 8u) + 1u)];
                let _e4994 = other_idx;
                let _e5001 = state[((_e4994 * 8u) + 1u)];
                let _e5008 = state[((idx * 8u) + 1u)];
                let _e5028 = other_idx;
                let _e5035 = state[((_e5028 * 8u) + 1u)];
                let _e5042 = state[((idx * 8u) + 1u)];
                let _e5046 = other_idx;
                let _e5053 = state[((_e5046 * 8u) + 1u)];
                let _e5060 = state[((idx * 8u) + 1u)];
                let _e5063 = other_idx;
                let _e5070 = state[((_e5063 * 8u) + 1u)];
                let _e5077 = state[((idx * 8u) + 1u)];
                let _e5086 = other_idx;
                let _e5093 = state[((_e5086 * 8u) + 1u)];
                let _e5100 = state[((idx * 8u) + 1u)];
                let _e5111 = other_idx;
                let _e5118 = state[((_e5111 * 8u) + 1u)];
                let _e5125 = state[((idx * 8u) + 1u)];
                let _e5134 = other_idx;
                let _e5141 = state[((_e5134 * 8u) + 1u)];
                let _e5148 = state[((idx * 8u) + 1u)];
                let _e5173 = other_idx;
                let _e5180 = state[((_e5173 * 8u) + 1u)];
                let _e5187 = state[((idx * 8u) + 1u)];
                let _e5189 = other_idx;
                let _e5196 = state[((_e5189 * 8u) + 1u)];
                let _e5203 = state[((idx * 8u) + 1u)];
                let _e5212 = other_idx;
                let _e5219 = state[((_e5212 * 8u) + 1u)];
                let _e5226 = state[((idx * 8u) + 1u)];
                let _e5237 = other_idx;
                let _e5244 = state[((_e5237 * 8u) + 1u)];
                let _e5251 = state[((idx * 8u) + 1u)];
                let _e5260 = other_idx;
                let _e5267 = state[((_e5260 * 8u) + 1u)];
                let _e5274 = state[((idx * 8u) + 1u)];
                let _e5300 = phi_1_;
                let _e5306 = constants.scheme;
                let _e5310 = other_idx;
                let _e5317 = state[((_e5310 * 8u) + 1u)];
                let _e5318 = other_idx;
                let _e5325 = state[((_e5318 * 8u) + 1u)];
                let _e5334 = state[((idx * 8u) + 1u)];
                let _e5338 = other_idx;
                let _e5345 = state[((_e5338 * 8u) + 1u)];
                let _e5352 = state[((idx * 8u) + 1u)];
                let _e5361 = other_idx;
                let _e5368 = state[((_e5361 * 8u) + 1u)];
                let _e5375 = state[((idx * 8u) + 1u)];
                let _e5386 = other_idx;
                let _e5393 = state[((_e5386 * 8u) + 1u)];
                let _e5400 = state[((idx * 8u) + 1u)];
                let _e5409 = other_idx;
                let _e5416 = state[((_e5409 * 8u) + 1u)];
                let _e5423 = state[((idx * 8u) + 1u)];
                let _e5439 = other_center.x;
                let _e5441 = other_center.y;
                let _e5448 = other_idx;
                let _e5455 = state[((_e5448 * 8u) + 1u)];
                let _e5463 = state[((idx * 8u) + 1u)];
                let _e5464 = other_idx;
                let _e5471 = state[((_e5464 * 8u) + 1u)];
                let _e5482 = state[((idx * 8u) + 1u)];
                let _e5483 = other_idx;
                let _e5490 = state[((_e5483 * 8u) + 1u)];
                let _e5502 = state[((idx * 8u) + 1u)];
                let _e5509 = state[((idx * 8u) + 1u)];
                let _e5512 = other_idx;
                let _e5519 = state[((_e5512 * 8u) + 1u)];
                let _e5523 = other_idx;
                let _e5530 = state[((_e5523 * 8u) + 1u)];
                let _e5537 = state[((idx * 8u) + 1u)];
                let _e5546 = other_idx;
                let _e5553 = state[((_e5546 * 8u) + 1u)];
                let _e5560 = state[((idx * 8u) + 1u)];
                let _e5571 = other_idx;
                let _e5578 = state[((_e5571 * 8u) + 1u)];
                let _e5585 = state[((idx * 8u) + 1u)];
                let _e5594 = other_idx;
                let _e5601 = state[((_e5594 * 8u) + 1u)];
                let _e5608 = state[((idx * 8u) + 1u)];
                let _e5621 = other_center.x;
                let _e5623 = other_center.y;
                let _e5639 = state[((idx * 8u) + 1u)];
                let _e5641 = other_idx;
                let _e5648 = state[((_e5641 * 8u) + 1u)];
                let _e5655 = state[((idx * 8u) + 1u)];
                let _e5660 = other_idx;
                let _e5667 = state[((_e5660 * 8u) + 1u)];
                let _e5674 = state[((idx * 8u) + 1u)];
                let _e5680 = phi_1_;
                let _e5686 = constants.scheme;
                let _e5690 = other_idx;
                let _e5697 = state[((_e5690 * 8u) + 1u)];
                let _e5698 = other_idx;
                let _e5705 = state[((_e5698 * 8u) + 1u)];
                let _e5714 = state[((idx * 8u) + 1u)];
                let _e5718 = other_idx;
                let _e5725 = state[((_e5718 * 8u) + 1u)];
                let _e5732 = state[((idx * 8u) + 1u)];
                let _e5741 = other_idx;
                let _e5748 = state[((_e5741 * 8u) + 1u)];
                let _e5755 = state[((idx * 8u) + 1u)];
                let _e5766 = other_idx;
                let _e5773 = state[((_e5766 * 8u) + 1u)];
                let _e5780 = state[((idx * 8u) + 1u)];
                let _e5789 = other_idx;
                let _e5796 = state[((_e5789 * 8u) + 1u)];
                let _e5803 = state[((idx * 8u) + 1u)];
                let _e5819 = other_center.x;
                let _e5821 = other_center.y;
                let _e5828 = other_idx;
                let _e5835 = state[((_e5828 * 8u) + 1u)];
                let _e5843 = state[((idx * 8u) + 1u)];
                let _e5844 = other_idx;
                let _e5851 = state[((_e5844 * 8u) + 1u)];
                let _e5861 = state[((idx * 8u) + 1u)];
                let _e5862 = other_idx;
                let _e5869 = state[((_e5862 * 8u) + 1u)];
                let _e5872 = other_idx;
                let _e5879 = state[((_e5872 * 8u) + 1u)];
                let _e5888 = state[((idx * 8u) + 1u)];
                let _e5892 = other_idx;
                let _e5899 = state[((_e5892 * 8u) + 1u)];
                let _e5906 = state[((idx * 8u) + 1u)];
                let _e5915 = other_idx;
                let _e5922 = state[((_e5915 * 8u) + 1u)];
                let _e5929 = state[((idx * 8u) + 1u)];
                let _e5940 = other_idx;
                let _e5947 = state[((_e5940 * 8u) + 1u)];
                let _e5954 = state[((idx * 8u) + 1u)];
                let _e5963 = other_idx;
                let _e5970 = state[((_e5963 * 8u) + 1u)];
                let _e5977 = state[((idx * 8u) + 1u)];
                let _e5993 = other_center.x;
                let _e5995 = other_center.y;
                let _e6002 = other_idx;
                let _e6009 = state[((_e6002 * 8u) + 1u)];
                let _e6022 = state[((idx * 8u) + 1u)];
                let _e6023 = other_idx;
                let _e6030 = state[((_e6023 * 8u) + 1u)];
                let _e6032 = other_idx;
                let _e6039 = state[((_e6032 * 8u) + 1u)];
                let _e6048 = state[((idx * 8u) + 1u)];
                let _e6052 = other_idx;
                let _e6059 = state[((_e6052 * 8u) + 1u)];
                let _e6066 = state[((idx * 8u) + 1u)];
                let _e6075 = other_idx;
                let _e6082 = state[((_e6075 * 8u) + 1u)];
                let _e6089 = state[((idx * 8u) + 1u)];
                let _e6100 = other_idx;
                let _e6107 = state[((_e6100 * 8u) + 1u)];
                let _e6114 = state[((idx * 8u) + 1u)];
                let _e6123 = other_idx;
                let _e6130 = state[((_e6123 * 8u) + 1u)];
                let _e6137 = state[((idx * 8u) + 1u)];
                let _e6153 = other_center.x;
                let _e6155 = other_center.y;
                let _e6162 = other_idx;
                let _e6169 = state[((_e6162 * 8u) + 1u)];
                let _e6183 = state[((idx * 8u) + 1u)];
                let _e6190 = state[((idx * 8u) + 1u)];
                let _e6193 = other_idx;
                let _e6200 = state[((_e6193 * 8u) + 1u)];
                let _e6204 = other_idx;
                let _e6211 = state[((_e6204 * 8u) + 1u)];
                let _e6218 = state[((idx * 8u) + 1u)];
                let _e6227 = other_idx;
                let _e6234 = state[((_e6227 * 8u) + 1u)];
                let _e6241 = state[((idx * 8u) + 1u)];
                let _e6252 = other_idx;
                let _e6259 = state[((_e6252 * 8u) + 1u)];
                let _e6266 = state[((idx * 8u) + 1u)];
                let _e6275 = other_idx;
                let _e6282 = state[((_e6275 * 8u) + 1u)];
                let _e6289 = state[((idx * 8u) + 1u)];
                let _e6302 = other_center.x;
                let _e6304 = other_center.y;
                let _e6320 = state[((idx * 8u) + 1u)];
                let _e6322 = other_idx;
                let _e6329 = state[((_e6322 * 8u) + 1u)];
                let _e6336 = state[((idx * 8u) + 1u)];
                let _e6340 = other_idx;
                let _e6347 = state[((_e6340 * 8u) + 1u)];
                let _e6354 = state[((idx * 8u) + 1u)];
                let _e6363 = state[((idx * 8u) + 1u)];
                let _e6366 = other_idx;
                let _e6373 = state[((_e6366 * 8u) + 1u)];
                let _e6377 = other_idx;
                let _e6384 = state[((_e6377 * 8u) + 1u)];
                let _e6391 = state[((idx * 8u) + 1u)];
                let _e6400 = other_idx;
                let _e6407 = state[((_e6400 * 8u) + 1u)];
                let _e6414 = state[((idx * 8u) + 1u)];
                let _e6425 = other_idx;
                let _e6432 = state[((_e6425 * 8u) + 1u)];
                let _e6439 = state[((idx * 8u) + 1u)];
                let _e6448 = other_idx;
                let _e6455 = state[((_e6448 * 8u) + 1u)];
                let _e6462 = state[((idx * 8u) + 1u)];
                let _e6475 = other_center.x;
                let _e6477 = other_center.y;
                let _e6493 = state[((idx * 8u) + 1u)];
                let _e6500 = other_idx;
                let _e6507 = state[((_e6500 * 8u) + 1u)];
                let _e6514 = state[((idx * 8u) + 1u)];
                let _e6522 = state[((idx * 8u) + 1u)];
                let _e6525 = other_idx;
                let _e6532 = state[((_e6525 * 8u) + 1u)];
                let _e6536 = other_idx;
                let _e6543 = state[((_e6536 * 8u) + 1u)];
                let _e6550 = state[((idx * 8u) + 1u)];
                let _e6559 = other_idx;
                let _e6566 = state[((_e6559 * 8u) + 1u)];
                let _e6573 = state[((idx * 8u) + 1u)];
                let _e6584 = other_idx;
                let _e6591 = state[((_e6584 * 8u) + 1u)];
                let _e6598 = state[((idx * 8u) + 1u)];
                let _e6607 = other_idx;
                let _e6614 = state[((_e6607 * 8u) + 1u)];
                let _e6621 = state[((idx * 8u) + 1u)];
                let _e6634 = other_center.x;
                let _e6636 = other_center.y;
                let _e6652 = state[((idx * 8u) + 1u)];
                let _e6660 = phi_1_;
                let _e6666 = constants.scheme;
                let _e6676 = state[((idx * 8u) + 1u)];
                let _e6677 = other_idx;
                let _e6684 = state[((_e6677 * 8u) + 1u)];
                let _e6685 = phi_1_;
                let _e6691 = rhs_1_;
                rhs_1_ = (_e6691 - (_e3681 * (select(select(select(select(select(select(select(_e3688, _e3696, (_e3697 < 0f)), select((_e3708 + dot(vec2<f32>(vec2<f32>((((_e3716 - _e3723) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3739 - _e3746) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3764 - _e3771) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3787 - _e3794) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3810, _e3812)))), (_e3823 + dot(vec2<f32>(vec2<f32>((((_e3831 - _e3838) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3854 - _e3861) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3879 - _e3886) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3902 - _e3909) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3930 > 0f)), (_e3936 == 1u)), select((((_e3947 * 0.625f) + (_e3956 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3967 - _e3974) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3990 - _e3997) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4015 - _e4022) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4038 - _e4045) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4061, _e4063))) * 0.125f)), (((_e4076 * 0.625f) + (_e4086 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e4097 - _e4104) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4120 - _e4127) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4145 - _e4152) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4168 - _e4175) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e4188, _e4190) - vec2<f32>(center.x, center.y))) * 0.125f)), (_e4200 > 0f)), (_e4206 == 2u)), select((_e4217 + min(max(dot(vec2<f32>(vec2<f32>((((_e4225 - _e4232) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4248 - _e4255) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4273 - _e4280) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4296 - _e4303) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4319, _e4321))), min((_e4331 - _e4339), 0f)), max((_e4350 - _e4358), 0f))), (_e4370 + min(max(dot(vec2<f32>(vec2<f32>((((_e4378 - _e4385) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4401 - _e4408) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4426 - _e4433) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4449 - _e4456) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e4483 - _e4490), 0f)), max((_e4502 - _e4509), 0f))), (_e4515 > 0f)), (_e4521 == 3u)), select((_e4532 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e4540 - _e4547) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4563 - _e4570) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4588 - _e4595) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4611 - _e4618) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4634, _e4636))) * abs((_e4646 - _e4654))) / max(abs((_e4664 - _e4672)), (abs(dot(vec2<f32>(vec2<f32>((((_e4682 - _e4689) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4705 - _e4712) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4730 - _e4737) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4753 - _e4760) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4776, _e4778)))) + 0.00000001f))), (((_e4793 - _e4801) * dot(vec2<f32>(vec2<f32>((((_e4810 - _e4817) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4833 - _e4840) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4858 - _e4865) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4881 - _e4888) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4904, _e4906)))) > 0f))), (_e4922 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e4930 - _e4937) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4953 - _e4960) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4978 - _e4985) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5001 - _e5008) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e5035 - _e5042))) / max(abs((_e5053 - _e5060)), (abs(dot(vec2<f32>(vec2<f32>((((_e5070 - _e5077) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5093 - _e5100) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5118 - _e5125) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5141 - _e5148) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))), (((_e5180 - _e5187) * dot(vec2<f32>(vec2<f32>((((_e5196 - _e5203) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5219 - _e5226) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5244 - _e5251) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5267 - _e5274) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) > 0f))), (_e5300 > 0f)), (_e5306 == 4u)), select((_e5317 + min(max(((((_e5325 * 0.625f) + (_e5334 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5345 - _e5352) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5368 - _e5375) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5393 - _e5400) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5416 - _e5423) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5439, _e5441))) * 0.125f)) - _e5455), min((_e5463 - _e5471), 0f)), max((_e5482 - _e5490), 0f))), (_e5502 + min(max(((((_e5509 * 0.625f) + (_e5519 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5530 - _e5537) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5553 - _e5560) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5578 - _e5585) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5601 - _e5608) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e5621, _e5623) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5639), min((_e5648 - _e5655), 0f)), max((_e5667 - _e5674), 0f))), (_e5680 > 0f)), (_e5686 == 5u)), select((_e5697 + select(0f, ((((((_e5705 * 0.625f) + (_e5714 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5725 - _e5732) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5748 - _e5755) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5773 - _e5780) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5796 - _e5803) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5819, _e5821))) * 0.125f)) - _e5835) * abs((_e5843 - _e5851))) / max(abs((_e5861 - _e5869)), (abs(((((_e5879 * 0.625f) + (_e5888 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5899 - _e5906) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5922 - _e5929) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5947 - _e5954) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5970 - _e5977) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5993, _e5995))) * 0.125f)) - _e6009)) + 0.00000001f))), (((_e6022 - _e6030) * ((((_e6039 * 0.625f) + (_e6048 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6059 - _e6066) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6082 - _e6089) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6107 - _e6114) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6130 - _e6137) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e6153, _e6155))) * 0.125f)) - _e6169)) > 0f))), (_e6183 + select(0f, ((((((_e6190 * 0.625f) + (_e6200 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6211 - _e6218) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6234 - _e6241) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6259 - _e6266) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6282 - _e6289) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e6302, _e6304) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e6320) * abs((_e6329 - _e6336))) / max(abs((_e6347 - _e6354)), (abs(((((_e6363 * 0.625f) + (_e6373 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6384 - _e6391) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6407 - _e6414) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6432 - _e6439) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6455 - _e6462) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e6475, _e6477) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e6493)) + 0.00000001f))), (((_e6507 - _e6514) * ((((_e6522 * 0.625f) + (_e6532 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6543 - _e6550) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6566 - _e6573) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6591 - _e6598) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6614 - _e6621) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e6634, _e6636) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e6652)) > 0f))), (_e6660 > 0f)), (_e6666 == 6u)) - select(_e6676, _e6684, (_e6685 < 0f)))));
            } else {
                let _e6699 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e6699 == 1u) {
                    let _e6702 = phi_1_;
                    let _e6705 = diag_1_;
                    diag_1_ = (_e6705 + max(_e6702, 0f));
                    let _e6707 = phi_1_;
                    let _e6716 = bc_value[((face_idx * 3u) + 1u)];
                    let _e6718 = rhs_1_;
                    rhs_1_ = (_e6718 - (min(_e6707, 0f) * _e6716));
                } else {
                    let _e6720 = phi_1_;
                    let _e6721 = diag_1_;
                    diag_1_ = (_e6721 + _e6720);
                }
            }
            let _e6733 = normal.x;
            let _e6735 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)] = (_e6735 + ((0.5f * area) * _e6733));
            let _e6747 = normal.x;
            let _e6749 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)] = (_e6749 + ((0.5f * area) * _e6747));
            let _e6761 = normal.y;
            let _e6763 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)] = (_e6763 + ((0.5f * area) * _e6761));
            let _e6775 = normal.y;
            let _e6777 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)] = (_e6777 + ((0.5f * area) * _e6775));
            let _e6781 = constants.density;
            let _e6788 = state[((idx * 8u) + 3u)];
            let _e6791 = dist;
            let diff_coeff_p = (((_e6781 * _e6788) * area) / _e6791);
            let _e6793 = is_boundary;
            if !(_e6793) {
                let _e6796 = diag_2_;
                diag_2_ = (_e6796 + diff_coeff_p);
                let _e6805 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e6805 - diff_coeff_p);
            } else {
                let _e6813 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e6813 == 1u) {
                    let _e6816 = diag_2_;
                    diag_2_ = (_e6816 + diff_coeff_p);
                    let _e6825 = bc_value[((face_idx * 3u) + 2u)];
                    let _e6827 = rhs_2_;
                    rhs_2_ = (_e6827 + (diff_coeff_p * _e6825));
                } else {
                    let _e6835 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e6835 == 2u) {
                        let _e6840 = constants.density;
                        let _e6847 = state[((idx * 8u) + 3u)];
                        let _e6856 = bc_value[((face_idx * 3u) + 2u)];
                        let _e6859 = rhs_2_;
                        rhs_2_ = (_e6859 + -((((_e6840 * _e6847) * area) * _e6856)));
                    }
                }
            }
            let _e6867 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e6867;
            if (owner != idx) {
                let _e6870 = phi_2_;
                let _e6873 = phi_2_;
                phi_2_ = (_e6873 - (_e6870 * 2f));
            }
            let _e6875 = phi_2_;
            let _e6876 = rhs_2_;
            rhs_2_ = (_e6876 - _e6875);
        }
        continuing {
            let _e6879 = k;
            k = (_e6879 + 1u);
        }
    }
    let _e6888 = diag_0_;
    let _e6889 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e6889 + _e6888);
    let _e6897 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e6897;
    let _e6905 = diag_1_;
    let _e6906 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e6906 + _e6905);
    let _e6914 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e6914;
    let _e6922 = diag_2_;
    let _e6923 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e6923 + _e6922);
    let _e6931 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e6931;
    return;
}
"#;
    }
    pub mod generic_coupled_assembly_incompressible_momentum_generic {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Vector2 {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub x: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub y: f32,
        }
        impl Vector2 {
            pub const fn new(x: f32, y: f32) -> Self {
                Self { x, y }
            }
        }
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub face_owner: wgpu::BufferBinding<'a>,
            pub face_neighbor: wgpu::BufferBinding<'a>,
            pub face_areas: wgpu::BufferBinding<'a>,
            pub face_normals: wgpu::BufferBinding<'a>,
            pub face_centers: wgpu::BufferBinding<'a>,
            pub cell_centers: wgpu::BufferBinding<'a>,
            pub cell_vols: wgpu::BufferBinding<'a>,
            pub cell_face_offsets: wgpu::BufferBinding<'a>,
            pub cell_faces: wgpu::BufferBinding<'a>,
            pub cell_face_matrix_indices: wgpu::BufferBinding<'a>,
            pub diagonal_indices: wgpu::BufferBinding<'a>,
            pub face_boundary: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub face_owner: wgpu::BindGroupEntry<'a>,
            pub face_neighbor: wgpu::BindGroupEntry<'a>,
            pub face_areas: wgpu::BindGroupEntry<'a>,
            pub face_normals: wgpu::BindGroupEntry<'a>,
            pub face_centers: wgpu::BindGroupEntry<'a>,
            pub cell_centers: wgpu::BindGroupEntry<'a>,
            pub cell_vols: wgpu::BindGroupEntry<'a>,
            pub cell_face_offsets: wgpu::BindGroupEntry<'a>,
            pub cell_faces: wgpu::BindGroupEntry<'a>,
            pub cell_face_matrix_indices: wgpu::BindGroupEntry<'a>,
            pub diagonal_indices: wgpu::BindGroupEntry<'a>,
            pub face_boundary: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    face_owner: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.face_owner),
                    },
                    face_neighbor: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.face_neighbor),
                    },
                    face_areas: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.face_areas),
                    },
                    face_normals: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.face_normals),
                    },
                    face_centers: wgpu::BindGroupEntry {
                        binding: 13,
                        resource: wgpu::BindingResource::Buffer(params.face_centers),
                    },
                    cell_centers: wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::Buffer(params.cell_centers),
                    },
                    cell_vols: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.cell_vols),
                    },
                    cell_face_offsets: wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_offsets),
                    },
                    cell_faces: wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Buffer(params.cell_faces),
                    },
                    cell_face_matrix_indices: wgpu::BindGroupEntry {
                        binding: 10,
                        resource: wgpu::BindingResource::Buffer(params.cell_face_matrix_indices),
                    },
                    diagonal_indices: wgpu::BindGroupEntry {
                        binding: 11,
                        resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                    },
                    face_boundary: wgpu::BindGroupEntry {
                        binding: 12,
                        resource: wgpu::BindingResource::Buffer(params.face_boundary),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 12] {
                [
                    self.face_owner,
                    self.face_neighbor,
                    self.face_areas,
                    self.face_normals,
                    self.face_centers,
                    self.cell_centers,
                    self.cell_vols,
                    self.cell_face_offsets,
                    self.cell_faces,
                    self.cell_face_matrix_indices,
                    self.diagonal_indices,
                    self.face_boundary,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"face_owner\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"face_neighbor\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"face_areas\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"face_normals\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(13): \"face_centers\""] wgpu :: BindGroupLayoutEntry { binding : 13 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(4): \"cell_centers\""] wgpu :: BindGroupLayoutEntry { binding : 4 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(5): \"cell_vols\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(6): \"cell_face_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 6 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(7): \"cell_faces\""] wgpu :: BindGroupLayoutEntry { binding : 7 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(10): \"cell_face_matrix_indices\""] wgpu :: BindGroupLayoutEntry { binding : 10 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(11): \"diagonal_indices\""] wgpu :: BindGroupLayoutEntry { binding : 11 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(12): \"face_boundary\""] wgpu :: BindGroupLayoutEntry { binding : 12 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub state_old: wgpu::BufferBinding<'a>,
            pub state_old_old: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
            pub fluxes: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub state_old: wgpu::BindGroupEntry<'a>,
            pub state_old_old: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
            pub fluxes: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    state_old: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.state_old),
                    },
                    state_old_old: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.state_old_old),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                    fluxes: wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Buffer(params.fluxes),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
                [
                    self.state,
                    self.state_old,
                    self.state_old_old,
                    self.constants,
                    self.fluxes,
                ]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"state_old\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"state_old_old\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(3): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 3 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_assembly_incompressible_momentum_generic :: Constants > () as _) , } , count : None , } , # [doc = " @binding(5): \"fluxes\""] wgpu :: BindGroupLayoutEntry { binding : 5 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2EntriesParams<'a> {
            pub matrix_values: wgpu::BufferBinding<'a>,
            pub rhs: wgpu::BufferBinding<'a>,
            pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup2Entries<'a> {
            pub matrix_values: wgpu::BindGroupEntry<'a>,
            pub rhs: wgpu::BindGroupEntry<'a>,
            pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup2Entries<'a> {
            pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
                Self {
                    matrix_values: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.matrix_values),
                    },
                    rhs: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.rhs),
                    },
                    scalar_row_offsets: wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
                [self.matrix_values, self.rhs, self.scalar_row_offsets]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup2(wgpu::BindGroup);
        impl WgpuBindGroup2 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup2::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"matrix_values\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"rhs\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(2): \"scalar_row_offsets\""] wgpu :: BindGroupLayoutEntry { binding : 2 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup2",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(2, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3EntriesParams<'a> {
            pub bc_kind: wgpu::BufferBinding<'a>,
            pub bc_value: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup3Entries<'a> {
            pub bc_kind: wgpu::BindGroupEntry<'a>,
            pub bc_value: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup3Entries<'a> {
            pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
                Self {
                    bc_kind: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.bc_kind),
                    },
                    bc_value: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.bc_value),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.bc_kind, self.bc_value]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup3(wgpu::BindGroup);
        impl WgpuBindGroup3 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup3::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"bc_kind\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"bc_value\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : true } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::BindGroup3",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(3, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
            pub bind_group2: &'a WgpuBindGroup2,
            pub bind_group3: &'a WgpuBindGroup3,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
                self.bind_group2.set(pass);
                self.bind_group3.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 4],
            ) -> [wgpu::BindGroupLayout; 4] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledAssemblyIncompressibleMomentumGeneric::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                    &WgpuBindGroup2::get_bind_group_layout(device),
                    &WgpuBindGroup3::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_assembly_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage> face_owner: array<u32>;
@group(0) @binding(1) 
var<storage> face_neighbor: array<i32>;
@group(0) @binding(2) 
var<storage> face_areas: array<f32>;
@group(0) @binding(3) 
var<storage> face_normals: array<Vector2_>;
@group(0) @binding(13) 
var<storage> face_centers: array<Vector2_>;
@group(0) @binding(4) 
var<storage> cell_centers: array<Vector2_>;
@group(0) @binding(5) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<storage> cell_face_offsets: array<u32>;
@group(0) @binding(7) 
var<storage> cell_faces: array<u32>;
@group(0) @binding(10) 
var<storage> cell_face_matrix_indices: array<u32>;
@group(0) @binding(11) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(12) 
var<storage> face_boundary: array<u32>;
@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(1) @binding(1) 
var<storage> state_old: array<f32>;
@group(1) @binding(2) 
var<storage> state_old_old: array<f32>;
@group(1) @binding(3) 
var<uniform> constants: Constants;
@group(1) @binding(5) 
var<storage, read_write> fluxes: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;
@group(2) @binding(2) 
var<storage> scalar_row_offsets: array<u32>;
@group(3) @binding(0) 
var<storage> bc_kind: array<u32>;
@group(3) @binding(1) 
var<storage> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rank: u32 = 0u;
    var diag_0_: f32 = 0f;
    var rhs_0_: f32 = 0f;
    var diag_1_: f32 = 0f;
    var rhs_1_: f32 = 0f;
    var diag_2_: f32 = 0f;
    var rhs_2_: f32 = 0f;
    var k: u32;
    var normal: Vector2_;
    var is_boundary: bool;
    var other_idx: u32;
    var other_center: Vector2_;
    var dist: f32;
    var phi_0_: f32;
    var phi_1_: f32;
    var phi_2_: f32;

    let idx = global_id.x;
    if (idx >= arrayLength((&cell_vols))) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[(idx + 1u)];
    let scalar_offset = scalar_row_offsets[idx];
    let _e26 = diagonal_indices[idx];
    let diag_rank = (_e26 - scalar_offset);
    let _e32 = scalar_row_offsets[(idx + 1u)];
    let num_neighbors = (_e32 - scalar_offset);
    let start_row_0_ = (scalar_offset * 9u);
    let start_row_1_ = (start_row_0_ + ((num_neighbors * 3u) * 1u));
    let start_row_2_ = (start_row_0_ + ((num_neighbors * 3u) * 2u));
    loop {
        let _e47 = rank;
        if (_e47 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e49 = rank;
            matrix_values[((start_row_0_ + (_e49 * 3u)) + 0u)] = 0f;
            let _e58 = rank;
            matrix_values[((start_row_0_ + (_e58 * 3u)) + 1u)] = 0f;
            let _e67 = rank;
            matrix_values[((start_row_0_ + (_e67 * 3u)) + 2u)] = 0f;
            let _e76 = rank;
            matrix_values[((start_row_1_ + (_e76 * 3u)) + 0u)] = 0f;
            let _e85 = rank;
            matrix_values[((start_row_1_ + (_e85 * 3u)) + 1u)] = 0f;
            let _e94 = rank;
            matrix_values[((start_row_1_ + (_e94 * 3u)) + 2u)] = 0f;
            let _e103 = rank;
            matrix_values[((start_row_2_ + (_e103 * 3u)) + 0u)] = 0f;
            let _e112 = rank;
            matrix_values[((start_row_2_ + (_e112 * 3u)) + 1u)] = 0f;
            let _e121 = rank;
            matrix_values[((start_row_2_ + (_e121 * 3u)) + 2u)] = 0f;
        }
        continuing {
            let _e131 = rank;
            rank = (_e131 + 1u);
        }
    }
    let _e135 = constants.density;
    let _e140 = constants.dt;
    let _e142 = diag_0_;
    diag_0_ = (_e142 + ((vol * _e135) / _e140));
    let _e146 = constants.density;
    let _e150 = constants.dt;
    let _e159 = state_old[((idx * 8u) + 0u)];
    let _e161 = rhs_0_;
    rhs_0_ = (_e161 + (((vol * _e146) / _e150) * _e159));
    let _e165 = constants.time_scheme;
    if (_e165 == 1u) {
        let _e170 = constants.dt;
        let _e173 = constants.dt_old;
        let r = (_e170 / _e173);
        let _e177 = constants.density;
        let _e181 = constants.dt;
        let diag_bdf2_ = ((((vol * _e177) / _e181) * ((r * 2f) + 1f)) / (r + 1f));
        let factor_n = (r + 1f);
        let factor_nm1_ = ((r * r) / (r + 1f));
        let _e197 = diag_0_;
        let _e200 = constants.density;
        let _e204 = constants.dt;
        diag_0_ = ((_e197 - ((vol * _e200) / _e204)) + diag_bdf2_);
        let _e208 = rhs_0_;
        let _e211 = constants.density;
        let _e215 = constants.dt;
        let _e223 = state_old[((idx * 8u) + 0u)];
        let _e228 = constants.density;
        let _e232 = constants.dt;
        let _e240 = state_old[((idx * 8u) + 0u)];
        let _e248 = state_old_old[((idx * 8u) + 0u)];
        rhs_0_ = ((_e208 - (((vol * _e211) / _e215) * _e223)) + (((vol * _e228) / _e232) * ((factor_n * _e240) - (factor_nm1_ * _e248))));
    }
    let _e255 = constants.density;
    let _e260 = constants.dt;
    let _e262 = diag_1_;
    diag_1_ = (_e262 + ((vol * _e255) / _e260));
    let _e266 = constants.density;
    let _e270 = constants.dt;
    let _e279 = state_old[((idx * 8u) + 1u)];
    let _e281 = rhs_1_;
    rhs_1_ = (_e281 + (((vol * _e266) / _e270) * _e279));
    let _e285 = constants.time_scheme;
    if (_e285 == 1u) {
        let _e290 = constants.dt;
        let _e293 = constants.dt_old;
        let r_1 = (_e290 / _e293);
        let _e297 = constants.density;
        let _e301 = constants.dt;
        let diag_bdf2_1 = ((((vol * _e297) / _e301) * ((r_1 * 2f) + 1f)) / (r_1 + 1f));
        let factor_n_1 = (r_1 + 1f);
        let factor_nm1_1 = ((r_1 * r_1) / (r_1 + 1f));
        let _e317 = diag_1_;
        let _e320 = constants.density;
        let _e324 = constants.dt;
        diag_1_ = ((_e317 - ((vol * _e320) / _e324)) + diag_bdf2_1);
        let _e328 = rhs_1_;
        let _e331 = constants.density;
        let _e335 = constants.dt;
        let _e343 = state_old[((idx * 8u) + 1u)];
        let _e348 = constants.density;
        let _e352 = constants.dt;
        let _e360 = state_old[((idx * 8u) + 1u)];
        let _e368 = state_old_old[((idx * 8u) + 1u)];
        rhs_1_ = ((_e328 - (((vol * _e331) / _e335) * _e343)) + (((vol * _e348) / _e352) * ((factor_n_1 * _e360) - (factor_nm1_1 * _e368))));
    }
    k = start;
    loop {
        let _e374 = k;
        if (_e374 < end) {
        } else {
            break;
        }
        {
            let _e377 = k;
            let face_idx = cell_faces[_e377];
            let owner = face_owner[face_idx];
            let neighbor_raw = face_neighbor[face_idx];
            let boundary_type = face_boundary[face_idx];
            let area = face_areas[face_idx];
            let f_center = face_centers[face_idx];
            let _e397 = face_normals[face_idx];
            normal = _e397;
            is_boundary = false;
            other_idx = idx;
            if (owner != idx) {
                let _e405 = normal.x;
                normal.x = -(_e405);
                let _e409 = normal.y;
                normal.y = -(_e409);
            }
            if (neighbor_raw != -1i) {
                let neighbor = u32(neighbor_raw);
                other_idx = neighbor;
                if (owner != idx) {
                    other_idx = owner;
                }
                let _e416 = other_idx;
                let _e418 = cell_centers[_e416];
                other_center = _e418;
            } else {
                is_boundary = true;
                other_idx = idx;
                other_center = f_center;
            }
            let _e422 = other_center.x;
            let dx = (_e422 - center.x);
            let _e426 = other_center.y;
            let dy = (_e426 - center.y);
            let _e430 = normal.x;
            let _e433 = normal.y;
            let dist_proj = abs(((dx * _e430) + (dy * _e433)));
            let dist_euc = sqrt(((dx * dx) + (dy * dy)));
            dist = max(dist_euc, 0.000001f);
            if (dist_proj > 0.000001f) {
                dist = dist_proj;
            }
            let _e447 = k;
            let scalar_mat_idx = cell_face_matrix_indices[_e447];
            let neighbor_rank = (scalar_mat_idx - scalar_offset);
            let _e453 = constants.viscosity;
            let _e455 = dist;
            let diff_coeff_U = ((_e453 * area) / _e455);
            let _e457 = is_boundary;
            if !(_e457) {
                let _e459 = diag_0_;
                diag_0_ = (_e459 + diff_coeff_U);
                let _e468 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e468 - diff_coeff_U);
            } else {
                let _e476 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e476 == 1u) {
                    let _e479 = diag_0_;
                    diag_0_ = (_e479 + diff_coeff_U);
                    let _e487 = bc_value[((face_idx * 3u) + 0u)];
                    let _e489 = rhs_0_;
                    rhs_0_ = (_e489 + (diff_coeff_U * _e487));
                } else {
                    let _e497 = bc_kind[((face_idx * 3u) + 0u)];
                    if (_e497 == 2u) {
                        let _e502 = constants.viscosity;
                        let _e510 = bc_value[((face_idx * 3u) + 0u)];
                        let _e513 = rhs_0_;
                        rhs_0_ = (_e513 + -(((_e502 * area) * _e510)));
                    }
                }
            }
            let _e515 = is_boundary;
            if !(_e515) {
                let _e517 = diag_1_;
                diag_1_ = (_e517 + diff_coeff_U);
                let _e526 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e526 - diff_coeff_U);
            } else {
                let _e534 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e534 == 1u) {
                    let _e537 = diag_1_;
                    diag_1_ = (_e537 + diff_coeff_U);
                    let _e545 = bc_value[((face_idx * 3u) + 1u)];
                    let _e547 = rhs_1_;
                    rhs_1_ = (_e547 + (diff_coeff_U * _e545));
                } else {
                    let _e555 = bc_kind[((face_idx * 3u) + 1u)];
                    if (_e555 == 2u) {
                        let _e560 = constants.viscosity;
                        let _e568 = bc_value[((face_idx * 3u) + 1u)];
                        let _e571 = rhs_1_;
                        rhs_1_ = (_e571 + -(((_e560 * area) * _e568)));
                    }
                }
            }
            let _e579 = fluxes[((face_idx * 3u) + 0u)];
            phi_0_ = _e579;
            if (owner != idx) {
                let _e582 = phi_0_;
                let _e585 = phi_0_;
                phi_0_ = (_e585 - (_e582 * 2f));
            }
            let _e587 = is_boundary;
            if !(_e587) {
                let _e589 = phi_0_;
                let _e592 = diag_0_;
                diag_0_ = (_e592 + max(_e589, 0f));
                let _e601 = phi_0_;
                let _e604 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)];
                matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 0u)] = (_e604 + min(_e601, 0f));
                let _e606 = phi_0_;
                let _e613 = state[((idx * 8u) + 0u)];
                let _e614 = other_idx;
                let _e621 = state[((_e614 * 8u) + 0u)];
                let _e622 = phi_0_;
                let _e626 = other_idx;
                let _e633 = state[((_e626 * 8u) + 0u)];
                let _e634 = other_idx;
                let _e641 = state[((_e634 * 8u) + 0u)];
                let _e648 = state[((idx * 8u) + 0u)];
                let _e657 = other_idx;
                let _e664 = state[((_e657 * 8u) + 0u)];
                let _e671 = state[((idx * 8u) + 0u)];
                let _e682 = other_idx;
                let _e689 = state[((_e682 * 8u) + 0u)];
                let _e696 = state[((idx * 8u) + 0u)];
                let _e705 = other_idx;
                let _e712 = state[((_e705 * 8u) + 0u)];
                let _e719 = state[((idx * 8u) + 0u)];
                let _e735 = other_center.x;
                let _e737 = other_center.y;
                let _e748 = state[((idx * 8u) + 0u)];
                let _e749 = other_idx;
                let _e756 = state[((_e749 * 8u) + 0u)];
                let _e763 = state[((idx * 8u) + 0u)];
                let _e772 = other_idx;
                let _e779 = state[((_e772 * 8u) + 0u)];
                let _e786 = state[((idx * 8u) + 0u)];
                let _e797 = other_idx;
                let _e804 = state[((_e797 * 8u) + 0u)];
                let _e811 = state[((idx * 8u) + 0u)];
                let _e820 = other_idx;
                let _e827 = state[((_e820 * 8u) + 0u)];
                let _e834 = state[((idx * 8u) + 0u)];
                let _e855 = phi_0_;
                let _e861 = constants.scheme;
                let _e865 = other_idx;
                let _e872 = state[((_e865 * 8u) + 0u)];
                let _e881 = state[((idx * 8u) + 0u)];
                let _e885 = other_idx;
                let _e892 = state[((_e885 * 8u) + 0u)];
                let _e899 = state[((idx * 8u) + 0u)];
                let _e908 = other_idx;
                let _e915 = state[((_e908 * 8u) + 0u)];
                let _e922 = state[((idx * 8u) + 0u)];
                let _e933 = other_idx;
                let _e940 = state[((_e933 * 8u) + 0u)];
                let _e947 = state[((idx * 8u) + 0u)];
                let _e956 = other_idx;
                let _e963 = state[((_e956 * 8u) + 0u)];
                let _e970 = state[((idx * 8u) + 0u)];
                let _e986 = other_center.x;
                let _e988 = other_center.y;
                let _e1001 = state[((idx * 8u) + 0u)];
                let _e1004 = other_idx;
                let _e1011 = state[((_e1004 * 8u) + 0u)];
                let _e1015 = other_idx;
                let _e1022 = state[((_e1015 * 8u) + 0u)];
                let _e1029 = state[((idx * 8u) + 0u)];
                let _e1038 = other_idx;
                let _e1045 = state[((_e1038 * 8u) + 0u)];
                let _e1052 = state[((idx * 8u) + 0u)];
                let _e1063 = other_idx;
                let _e1070 = state[((_e1063 * 8u) + 0u)];
                let _e1077 = state[((idx * 8u) + 0u)];
                let _e1086 = other_idx;
                let _e1093 = state[((_e1086 * 8u) + 0u)];
                let _e1100 = state[((idx * 8u) + 0u)];
                let _e1113 = other_center.x;
                let _e1115 = other_center.y;
                let _e1125 = phi_0_;
                let _e1131 = constants.scheme;
                let _e1135 = other_idx;
                let _e1142 = state[((_e1135 * 8u) + 0u)];
                let _e1143 = other_idx;
                let _e1150 = state[((_e1143 * 8u) + 0u)];
                let _e1157 = state[((idx * 8u) + 0u)];
                let _e1166 = other_idx;
                let _e1173 = state[((_e1166 * 8u) + 0u)];
                let _e1180 = state[((idx * 8u) + 0u)];
                let _e1191 = other_idx;
                let _e1198 = state[((_e1191 * 8u) + 0u)];
                let _e1205 = state[((idx * 8u) + 0u)];
                let _e1214 = other_idx;
                let _e1221 = state[((_e1214 * 8u) + 0u)];
                let _e1228 = state[((idx * 8u) + 0u)];
                let _e1244 = other_center.x;
                let _e1246 = other_center.y;
                let _e1256 = state[((idx * 8u) + 0u)];
                let _e1257 = other_idx;
                let _e1264 = state[((_e1257 * 8u) + 0u)];
                let _e1275 = state[((idx * 8u) + 0u)];
                let _e1276 = other_idx;
                let _e1283 = state[((_e1276 * 8u) + 0u)];
                let _e1295 = state[((idx * 8u) + 0u)];
                let _e1296 = other_idx;
                let _e1303 = state[((_e1296 * 8u) + 0u)];
                let _e1310 = state[((idx * 8u) + 0u)];
                let _e1319 = other_idx;
                let _e1326 = state[((_e1319 * 8u) + 0u)];
                let _e1333 = state[((idx * 8u) + 0u)];
                let _e1344 = other_idx;
                let _e1351 = state[((_e1344 * 8u) + 0u)];
                let _e1358 = state[((idx * 8u) + 0u)];
                let _e1367 = other_idx;
                let _e1374 = state[((_e1367 * 8u) + 0u)];
                let _e1381 = state[((idx * 8u) + 0u)];
                let _e1401 = other_idx;
                let _e1408 = state[((_e1401 * 8u) + 0u)];
                let _e1415 = state[((idx * 8u) + 0u)];
                let _e1420 = other_idx;
                let _e1427 = state[((_e1420 * 8u) + 0u)];
                let _e1434 = state[((idx * 8u) + 0u)];
                let _e1440 = phi_0_;
                let _e1446 = constants.scheme;
                let _e1450 = other_idx;
                let _e1457 = state[((_e1450 * 8u) + 0u)];
                let _e1458 = other_idx;
                let _e1465 = state[((_e1458 * 8u) + 0u)];
                let _e1472 = state[((idx * 8u) + 0u)];
                let _e1481 = other_idx;
                let _e1488 = state[((_e1481 * 8u) + 0u)];
                let _e1495 = state[((idx * 8u) + 0u)];
                let _e1506 = other_idx;
                let _e1513 = state[((_e1506 * 8u) + 0u)];
                let _e1520 = state[((idx * 8u) + 0u)];
                let _e1529 = other_idx;
                let _e1536 = state[((_e1529 * 8u) + 0u)];
                let _e1543 = state[((idx * 8u) + 0u)];
                let _e1559 = other_center.x;
                let _e1561 = other_center.y;
                let _e1571 = state[((idx * 8u) + 0u)];
                let _e1572 = other_idx;
                let _e1579 = state[((_e1572 * 8u) + 0u)];
                let _e1589 = state[((idx * 8u) + 0u)];
                let _e1590 = other_idx;
                let _e1597 = state[((_e1590 * 8u) + 0u)];
                let _e1600 = other_idx;
                let _e1607 = state[((_e1600 * 8u) + 0u)];
                let _e1614 = state[((idx * 8u) + 0u)];
                let _e1623 = other_idx;
                let _e1630 = state[((_e1623 * 8u) + 0u)];
                let _e1637 = state[((idx * 8u) + 0u)];
                let _e1648 = other_idx;
                let _e1655 = state[((_e1648 * 8u) + 0u)];
                let _e1662 = state[((idx * 8u) + 0u)];
                let _e1671 = other_idx;
                let _e1678 = state[((_e1671 * 8u) + 0u)];
                let _e1685 = state[((idx * 8u) + 0u)];
                let _e1701 = other_center.x;
                let _e1703 = other_center.y;
                let _e1718 = state[((idx * 8u) + 0u)];
                let _e1719 = other_idx;
                let _e1726 = state[((_e1719 * 8u) + 0u)];
                let _e1728 = other_idx;
                let _e1735 = state[((_e1728 * 8u) + 0u)];
                let _e1742 = state[((idx * 8u) + 0u)];
                let _e1751 = other_idx;
                let _e1758 = state[((_e1751 * 8u) + 0u)];
                let _e1765 = state[((idx * 8u) + 0u)];
                let _e1776 = other_idx;
                let _e1783 = state[((_e1776 * 8u) + 0u)];
                let _e1790 = state[((idx * 8u) + 0u)];
                let _e1799 = other_idx;
                let _e1806 = state[((_e1799 * 8u) + 0u)];
                let _e1813 = state[((idx * 8u) + 0u)];
                let _e1829 = other_center.x;
                let _e1831 = other_center.y;
                let _e1847 = state[((idx * 8u) + 0u)];
                let _e1848 = other_idx;
                let _e1855 = state[((_e1848 * 8u) + 0u)];
                let _e1862 = state[((idx * 8u) + 0u)];
                let _e1871 = other_idx;
                let _e1878 = state[((_e1871 * 8u) + 0u)];
                let _e1885 = state[((idx * 8u) + 0u)];
                let _e1896 = other_idx;
                let _e1903 = state[((_e1896 * 8u) + 0u)];
                let _e1910 = state[((idx * 8u) + 0u)];
                let _e1919 = other_idx;
                let _e1926 = state[((_e1919 * 8u) + 0u)];
                let _e1933 = state[((idx * 8u) + 0u)];
                let _e1953 = other_idx;
                let _e1960 = state[((_e1953 * 8u) + 0u)];
                let _e1967 = state[((idx * 8u) + 0u)];
                let _e1971 = other_idx;
                let _e1978 = state[((_e1971 * 8u) + 0u)];
                let _e1985 = state[((idx * 8u) + 0u)];
                let _e1988 = other_idx;
                let _e1995 = state[((_e1988 * 8u) + 0u)];
                let _e2002 = state[((idx * 8u) + 0u)];
                let _e2011 = other_idx;
                let _e2018 = state[((_e2011 * 8u) + 0u)];
                let _e2025 = state[((idx * 8u) + 0u)];
                let _e2036 = other_idx;
                let _e2043 = state[((_e2036 * 8u) + 0u)];
                let _e2050 = state[((idx * 8u) + 0u)];
                let _e2059 = other_idx;
                let _e2066 = state[((_e2059 * 8u) + 0u)];
                let _e2073 = state[((idx * 8u) + 0u)];
                let _e2098 = other_idx;
                let _e2105 = state[((_e2098 * 8u) + 0u)];
                let _e2112 = state[((idx * 8u) + 0u)];
                let _e2114 = other_idx;
                let _e2121 = state[((_e2114 * 8u) + 0u)];
                let _e2128 = state[((idx * 8u) + 0u)];
                let _e2137 = other_idx;
                let _e2144 = state[((_e2137 * 8u) + 0u)];
                let _e2151 = state[((idx * 8u) + 0u)];
                let _e2162 = other_idx;
                let _e2169 = state[((_e2162 * 8u) + 0u)];
                let _e2176 = state[((idx * 8u) + 0u)];
                let _e2185 = other_idx;
                let _e2192 = state[((_e2185 * 8u) + 0u)];
                let _e2199 = state[((idx * 8u) + 0u)];
                let _e2225 = phi_0_;
                let _e2231 = constants.scheme;
                let _e2235 = other_idx;
                let _e2242 = state[((_e2235 * 8u) + 0u)];
                let _e2243 = other_idx;
                let _e2250 = state[((_e2243 * 8u) + 0u)];
                let _e2259 = state[((idx * 8u) + 0u)];
                let _e2263 = other_idx;
                let _e2270 = state[((_e2263 * 8u) + 0u)];
                let _e2277 = state[((idx * 8u) + 0u)];
                let _e2286 = other_idx;
                let _e2293 = state[((_e2286 * 8u) + 0u)];
                let _e2300 = state[((idx * 8u) + 0u)];
                let _e2311 = other_idx;
                let _e2318 = state[((_e2311 * 8u) + 0u)];
                let _e2325 = state[((idx * 8u) + 0u)];
                let _e2334 = other_idx;
                let _e2341 = state[((_e2334 * 8u) + 0u)];
                let _e2348 = state[((idx * 8u) + 0u)];
                let _e2364 = other_center.x;
                let _e2366 = other_center.y;
                let _e2373 = other_idx;
                let _e2380 = state[((_e2373 * 8u) + 0u)];
                let _e2388 = state[((idx * 8u) + 0u)];
                let _e2389 = other_idx;
                let _e2396 = state[((_e2389 * 8u) + 0u)];
                let _e2407 = state[((idx * 8u) + 0u)];
                let _e2408 = other_idx;
                let _e2415 = state[((_e2408 * 8u) + 0u)];
                let _e2427 = state[((idx * 8u) + 0u)];
                let _e2434 = state[((idx * 8u) + 0u)];
                let _e2437 = other_idx;
                let _e2444 = state[((_e2437 * 8u) + 0u)];
                let _e2448 = other_idx;
                let _e2455 = state[((_e2448 * 8u) + 0u)];
                let _e2462 = state[((idx * 8u) + 0u)];
                let _e2471 = other_idx;
                let _e2478 = state[((_e2471 * 8u) + 0u)];
                let _e2485 = state[((idx * 8u) + 0u)];
                let _e2496 = other_idx;
                let _e2503 = state[((_e2496 * 8u) + 0u)];
                let _e2510 = state[((idx * 8u) + 0u)];
                let _e2519 = other_idx;
                let _e2526 = state[((_e2519 * 8u) + 0u)];
                let _e2533 = state[((idx * 8u) + 0u)];
                let _e2546 = other_center.x;
                let _e2548 = other_center.y;
                let _e2564 = state[((idx * 8u) + 0u)];
                let _e2566 = other_idx;
                let _e2573 = state[((_e2566 * 8u) + 0u)];
                let _e2580 = state[((idx * 8u) + 0u)];
                let _e2585 = other_idx;
                let _e2592 = state[((_e2585 * 8u) + 0u)];
                let _e2599 = state[((idx * 8u) + 0u)];
                let _e2605 = phi_0_;
                let _e2611 = constants.scheme;
                let _e2615 = other_idx;
                let _e2622 = state[((_e2615 * 8u) + 0u)];
                let _e2623 = other_idx;
                let _e2630 = state[((_e2623 * 8u) + 0u)];
                let _e2639 = state[((idx * 8u) + 0u)];
                let _e2643 = other_idx;
                let _e2650 = state[((_e2643 * 8u) + 0u)];
                let _e2657 = state[((idx * 8u) + 0u)];
                let _e2666 = other_idx;
                let _e2673 = state[((_e2666 * 8u) + 0u)];
                let _e2680 = state[((idx * 8u) + 0u)];
                let _e2691 = other_idx;
                let _e2698 = state[((_e2691 * 8u) + 0u)];
                let _e2705 = state[((idx * 8u) + 0u)];
                let _e2714 = other_idx;
                let _e2721 = state[((_e2714 * 8u) + 0u)];
                let _e2728 = state[((idx * 8u) + 0u)];
                let _e2744 = other_center.x;
                let _e2746 = other_center.y;
                let _e2753 = other_idx;
                let _e2760 = state[((_e2753 * 8u) + 0u)];
                let _e2768 = state[((idx * 8u) + 0u)];
                let _e2769 = other_idx;
                let _e2776 = state[((_e2769 * 8u) + 0u)];
                let _e2786 = state[((idx * 8u) + 0u)];
                let _e2787 = other_idx;
                let _e2794 = state[((_e2787 * 8u) + 0u)];
                let _e2797 = other_idx;
                let _e2804 = state[((_e2797 * 8u) + 0u)];
                let _e2813 = state[((idx * 8u) + 0u)];
                let _e2817 = other_idx;
                let _e2824 = state[((_e2817 * 8u) + 0u)];
                let _e2831 = state[((idx * 8u) + 0u)];
                let _e2840 = other_idx;
                let _e2847 = state[((_e2840 * 8u) + 0u)];
                let _e2854 = state[((idx * 8u) + 0u)];
                let _e2865 = other_idx;
                let _e2872 = state[((_e2865 * 8u) + 0u)];
                let _e2879 = state[((idx * 8u) + 0u)];
                let _e2888 = other_idx;
                let _e2895 = state[((_e2888 * 8u) + 0u)];
                let _e2902 = state[((idx * 8u) + 0u)];
                let _e2918 = other_center.x;
                let _e2920 = other_center.y;
                let _e2927 = other_idx;
                let _e2934 = state[((_e2927 * 8u) + 0u)];
                let _e2947 = state[((idx * 8u) + 0u)];
                let _e2948 = other_idx;
                let _e2955 = state[((_e2948 * 8u) + 0u)];
                let _e2957 = other_idx;
                let _e2964 = state[((_e2957 * 8u) + 0u)];
                let _e2973 = state[((idx * 8u) + 0u)];
                let _e2977 = other_idx;
                let _e2984 = state[((_e2977 * 8u) + 0u)];
                let _e2991 = state[((idx * 8u) + 0u)];
                let _e3000 = other_idx;
                let _e3007 = state[((_e3000 * 8u) + 0u)];
                let _e3014 = state[((idx * 8u) + 0u)];
                let _e3025 = other_idx;
                let _e3032 = state[((_e3025 * 8u) + 0u)];
                let _e3039 = state[((idx * 8u) + 0u)];
                let _e3048 = other_idx;
                let _e3055 = state[((_e3048 * 8u) + 0u)];
                let _e3062 = state[((idx * 8u) + 0u)];
                let _e3078 = other_center.x;
                let _e3080 = other_center.y;
                let _e3087 = other_idx;
                let _e3094 = state[((_e3087 * 8u) + 0u)];
                let _e3108 = state[((idx * 8u) + 0u)];
                let _e3115 = state[((idx * 8u) + 0u)];
                let _e3118 = other_idx;
                let _e3125 = state[((_e3118 * 8u) + 0u)];
                let _e3129 = other_idx;
                let _e3136 = state[((_e3129 * 8u) + 0u)];
                let _e3143 = state[((idx * 8u) + 0u)];
                let _e3152 = other_idx;
                let _e3159 = state[((_e3152 * 8u) + 0u)];
                let _e3166 = state[((idx * 8u) + 0u)];
                let _e3177 = other_idx;
                let _e3184 = state[((_e3177 * 8u) + 0u)];
                let _e3191 = state[((idx * 8u) + 0u)];
                let _e3200 = other_idx;
                let _e3207 = state[((_e3200 * 8u) + 0u)];
                let _e3214 = state[((idx * 8u) + 0u)];
                let _e3227 = other_center.x;
                let _e3229 = other_center.y;
                let _e3245 = state[((idx * 8u) + 0u)];
                let _e3247 = other_idx;
                let _e3254 = state[((_e3247 * 8u) + 0u)];
                let _e3261 = state[((idx * 8u) + 0u)];
                let _e3265 = other_idx;
                let _e3272 = state[((_e3265 * 8u) + 0u)];
                let _e3279 = state[((idx * 8u) + 0u)];
                let _e3288 = state[((idx * 8u) + 0u)];
                let _e3291 = other_idx;
                let _e3298 = state[((_e3291 * 8u) + 0u)];
                let _e3302 = other_idx;
                let _e3309 = state[((_e3302 * 8u) + 0u)];
                let _e3316 = state[((idx * 8u) + 0u)];
                let _e3325 = other_idx;
                let _e3332 = state[((_e3325 * 8u) + 0u)];
                let _e3339 = state[((idx * 8u) + 0u)];
                let _e3350 = other_idx;
                let _e3357 = state[((_e3350 * 8u) + 0u)];
                let _e3364 = state[((idx * 8u) + 0u)];
                let _e3373 = other_idx;
                let _e3380 = state[((_e3373 * 8u) + 0u)];
                let _e3387 = state[((idx * 8u) + 0u)];
                let _e3400 = other_center.x;
                let _e3402 = other_center.y;
                let _e3418 = state[((idx * 8u) + 0u)];
                let _e3425 = other_idx;
                let _e3432 = state[((_e3425 * 8u) + 0u)];
                let _e3439 = state[((idx * 8u) + 0u)];
                let _e3447 = state[((idx * 8u) + 0u)];
                let _e3450 = other_idx;
                let _e3457 = state[((_e3450 * 8u) + 0u)];
                let _e3461 = other_idx;
                let _e3468 = state[((_e3461 * 8u) + 0u)];
                let _e3475 = state[((idx * 8u) + 0u)];
                let _e3484 = other_idx;
                let _e3491 = state[((_e3484 * 8u) + 0u)];
                let _e3498 = state[((idx * 8u) + 0u)];
                let _e3509 = other_idx;
                let _e3516 = state[((_e3509 * 8u) + 0u)];
                let _e3523 = state[((idx * 8u) + 0u)];
                let _e3532 = other_idx;
                let _e3539 = state[((_e3532 * 8u) + 0u)];
                let _e3546 = state[((idx * 8u) + 0u)];
                let _e3559 = other_center.x;
                let _e3561 = other_center.y;
                let _e3577 = state[((idx * 8u) + 0u)];
                let _e3585 = phi_0_;
                let _e3591 = constants.scheme;
                let _e3601 = state[((idx * 8u) + 0u)];
                let _e3602 = other_idx;
                let _e3609 = state[((_e3602 * 8u) + 0u)];
                let _e3610 = phi_0_;
                let _e3616 = rhs_0_;
                rhs_0_ = (_e3616 - (_e606 * (select(select(select(select(select(select(select(_e613, _e621, (_e622 < 0f)), select((_e633 + dot(vec2<f32>(vec2<f32>((((_e641 - _e648) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e664 - _e671) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e689 - _e696) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e712 - _e719) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e735, _e737)))), (_e748 + dot(vec2<f32>(vec2<f32>((((_e756 - _e763) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e779 - _e786) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e804 - _e811) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e827 - _e834) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e855 > 0f)), (_e861 == 1u)), select((((_e872 * 0.625f) + (_e881 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e892 - _e899) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e915 - _e922) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e940 - _e947) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e963 - _e970) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e986, _e988))) * 0.125f)), (((_e1001 * 0.625f) + (_e1011 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e1022 - _e1029) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1045 - _e1052) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1070 - _e1077) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1093 - _e1100) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e1113, _e1115) - vec2<f32>(center.x, center.y))) * 0.125f)), (_e1125 > 0f)), (_e1131 == 2u)), select((_e1142 + min(max(dot(vec2<f32>(vec2<f32>((((_e1150 - _e1157) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1173 - _e1180) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1198 - _e1205) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1221 - _e1228) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1244, _e1246))), min((_e1256 - _e1264), 0f)), max((_e1275 - _e1283), 0f))), (_e1295 + min(max(dot(vec2<f32>(vec2<f32>((((_e1303 - _e1310) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1326 - _e1333) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1351 - _e1358) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1374 - _e1381) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e1408 - _e1415), 0f)), max((_e1427 - _e1434), 0f))), (_e1440 > 0f)), (_e1446 == 3u)), select((_e1457 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e1465 - _e1472) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1488 - _e1495) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1513 - _e1520) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1536 - _e1543) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1559, _e1561))) * abs((_e1571 - _e1579))) / max(abs((_e1589 - _e1597)), (abs(dot(vec2<f32>(vec2<f32>((((_e1607 - _e1614) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1630 - _e1637) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1655 - _e1662) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1678 - _e1685) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1701, _e1703)))) + 0.00000001f))), (((_e1718 - _e1726) * dot(vec2<f32>(vec2<f32>((((_e1735 - _e1742) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1758 - _e1765) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1783 - _e1790) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1806 - _e1813) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e1829, _e1831)))) > 0f))), (_e1847 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e1855 - _e1862) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1878 - _e1885) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e1903 - _e1910) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e1926 - _e1933) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e1960 - _e1967))) / max(abs((_e1978 - _e1985)), (abs(dot(vec2<f32>(vec2<f32>((((_e1995 - _e2002) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2018 - _e2025) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2043 - _e2050) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2066 - _e2073) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))), (((_e2105 - _e2112) * dot(vec2<f32>(vec2<f32>((((_e2121 - _e2128) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2144 - _e2151) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2169 - _e2176) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2192 - _e2199) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) > 0f))), (_e2225 > 0f)), (_e2231 == 4u)), select((_e2242 + min(max(((((_e2250 * 0.625f) + (_e2259 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2270 - _e2277) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2293 - _e2300) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2318 - _e2325) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2341 - _e2348) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2364, _e2366))) * 0.125f)) - _e2380), min((_e2388 - _e2396), 0f)), max((_e2407 - _e2415), 0f))), (_e2427 + min(max(((((_e2434 * 0.625f) + (_e2444 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2455 - _e2462) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2478 - _e2485) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2503 - _e2510) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2526 - _e2533) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e2546, _e2548) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e2564), min((_e2573 - _e2580), 0f)), max((_e2592 - _e2599), 0f))), (_e2605 > 0f)), (_e2611 == 5u)), select((_e2622 + select(0f, ((((((_e2630 * 0.625f) + (_e2639 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2650 - _e2657) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2673 - _e2680) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2698 - _e2705) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2721 - _e2728) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2744, _e2746))) * 0.125f)) - _e2760) * abs((_e2768 - _e2776))) / max(abs((_e2786 - _e2794)), (abs(((((_e2804 * 0.625f) + (_e2813 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2824 - _e2831) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2847 - _e2854) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e2872 - _e2879) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e2895 - _e2902) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e2918, _e2920))) * 0.125f)) - _e2934)) + 0.00000001f))), (((_e2947 - _e2955) * ((((_e2964 * 0.625f) + (_e2973 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e2984 - _e2991) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3007 - _e3014) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3032 - _e3039) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3055 - _e3062) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e3078, _e3080))) * 0.125f)) - _e3094)) > 0f))), (_e3108 + select(0f, ((((((_e3115 * 0.625f) + (_e3125 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3136 - _e3143) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3159 - _e3166) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3184 - _e3191) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3207 - _e3214) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e3227, _e3229) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3245) * abs((_e3254 - _e3261))) / max(abs((_e3272 - _e3279)), (abs(((((_e3288 * 0.625f) + (_e3298 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3309 - _e3316) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3332 - _e3339) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3357 - _e3364) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3380 - _e3387) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e3400, _e3402) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3418)) + 0.00000001f))), (((_e3432 - _e3439) * ((((_e3447 * 0.625f) + (_e3457 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3468 - _e3475) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3491 - _e3498) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3516 - _e3523) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3539 - _e3546) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e3559, _e3561) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e3577)) > 0f))), (_e3585 > 0f)), (_e3591 == 6u)) - select(_e3601, _e3609, (_e3610 < 0f)))));
            } else {
                let _e3624 = bc_kind[((face_idx * 3u) + 0u)];
                if (_e3624 == 1u) {
                    let _e3627 = phi_0_;
                    let _e3630 = diag_0_;
                    diag_0_ = (_e3630 + max(_e3627, 0f));
                    let _e3632 = phi_0_;
                    let _e3641 = bc_value[((face_idx * 3u) + 0u)];
                    let _e3643 = rhs_0_;
                    rhs_0_ = (_e3643 - (min(_e3632, 0f) * _e3641));
                } else {
                    let _e3645 = phi_0_;
                    let _e3646 = diag_0_;
                    diag_0_ = (_e3646 + _e3645);
                }
            }
            let _e3654 = fluxes[((face_idx * 3u) + 1u)];
            phi_1_ = _e3654;
            if (owner != idx) {
                let _e3657 = phi_1_;
                let _e3660 = phi_1_;
                phi_1_ = (_e3660 - (_e3657 * 2f));
            }
            let _e3662 = is_boundary;
            if !(_e3662) {
                let _e3664 = phi_1_;
                let _e3667 = diag_1_;
                diag_1_ = (_e3667 + max(_e3664, 0f));
                let _e3676 = phi_1_;
                let _e3679 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)];
                matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 1u)] = (_e3679 + min(_e3676, 0f));
                let _e3681 = phi_1_;
                let _e3688 = state[((idx * 8u) + 1u)];
                let _e3689 = other_idx;
                let _e3696 = state[((_e3689 * 8u) + 1u)];
                let _e3697 = phi_1_;
                let _e3701 = other_idx;
                let _e3708 = state[((_e3701 * 8u) + 1u)];
                let _e3709 = other_idx;
                let _e3716 = state[((_e3709 * 8u) + 1u)];
                let _e3723 = state[((idx * 8u) + 1u)];
                let _e3732 = other_idx;
                let _e3739 = state[((_e3732 * 8u) + 1u)];
                let _e3746 = state[((idx * 8u) + 1u)];
                let _e3757 = other_idx;
                let _e3764 = state[((_e3757 * 8u) + 1u)];
                let _e3771 = state[((idx * 8u) + 1u)];
                let _e3780 = other_idx;
                let _e3787 = state[((_e3780 * 8u) + 1u)];
                let _e3794 = state[((idx * 8u) + 1u)];
                let _e3810 = other_center.x;
                let _e3812 = other_center.y;
                let _e3823 = state[((idx * 8u) + 1u)];
                let _e3824 = other_idx;
                let _e3831 = state[((_e3824 * 8u) + 1u)];
                let _e3838 = state[((idx * 8u) + 1u)];
                let _e3847 = other_idx;
                let _e3854 = state[((_e3847 * 8u) + 1u)];
                let _e3861 = state[((idx * 8u) + 1u)];
                let _e3872 = other_idx;
                let _e3879 = state[((_e3872 * 8u) + 1u)];
                let _e3886 = state[((idx * 8u) + 1u)];
                let _e3895 = other_idx;
                let _e3902 = state[((_e3895 * 8u) + 1u)];
                let _e3909 = state[((idx * 8u) + 1u)];
                let _e3930 = phi_1_;
                let _e3936 = constants.scheme;
                let _e3940 = other_idx;
                let _e3947 = state[((_e3940 * 8u) + 1u)];
                let _e3956 = state[((idx * 8u) + 1u)];
                let _e3960 = other_idx;
                let _e3967 = state[((_e3960 * 8u) + 1u)];
                let _e3974 = state[((idx * 8u) + 1u)];
                let _e3983 = other_idx;
                let _e3990 = state[((_e3983 * 8u) + 1u)];
                let _e3997 = state[((idx * 8u) + 1u)];
                let _e4008 = other_idx;
                let _e4015 = state[((_e4008 * 8u) + 1u)];
                let _e4022 = state[((idx * 8u) + 1u)];
                let _e4031 = other_idx;
                let _e4038 = state[((_e4031 * 8u) + 1u)];
                let _e4045 = state[((idx * 8u) + 1u)];
                let _e4061 = other_center.x;
                let _e4063 = other_center.y;
                let _e4076 = state[((idx * 8u) + 1u)];
                let _e4079 = other_idx;
                let _e4086 = state[((_e4079 * 8u) + 1u)];
                let _e4090 = other_idx;
                let _e4097 = state[((_e4090 * 8u) + 1u)];
                let _e4104 = state[((idx * 8u) + 1u)];
                let _e4113 = other_idx;
                let _e4120 = state[((_e4113 * 8u) + 1u)];
                let _e4127 = state[((idx * 8u) + 1u)];
                let _e4138 = other_idx;
                let _e4145 = state[((_e4138 * 8u) + 1u)];
                let _e4152 = state[((idx * 8u) + 1u)];
                let _e4161 = other_idx;
                let _e4168 = state[((_e4161 * 8u) + 1u)];
                let _e4175 = state[((idx * 8u) + 1u)];
                let _e4188 = other_center.x;
                let _e4190 = other_center.y;
                let _e4200 = phi_1_;
                let _e4206 = constants.scheme;
                let _e4210 = other_idx;
                let _e4217 = state[((_e4210 * 8u) + 1u)];
                let _e4218 = other_idx;
                let _e4225 = state[((_e4218 * 8u) + 1u)];
                let _e4232 = state[((idx * 8u) + 1u)];
                let _e4241 = other_idx;
                let _e4248 = state[((_e4241 * 8u) + 1u)];
                let _e4255 = state[((idx * 8u) + 1u)];
                let _e4266 = other_idx;
                let _e4273 = state[((_e4266 * 8u) + 1u)];
                let _e4280 = state[((idx * 8u) + 1u)];
                let _e4289 = other_idx;
                let _e4296 = state[((_e4289 * 8u) + 1u)];
                let _e4303 = state[((idx * 8u) + 1u)];
                let _e4319 = other_center.x;
                let _e4321 = other_center.y;
                let _e4331 = state[((idx * 8u) + 1u)];
                let _e4332 = other_idx;
                let _e4339 = state[((_e4332 * 8u) + 1u)];
                let _e4350 = state[((idx * 8u) + 1u)];
                let _e4351 = other_idx;
                let _e4358 = state[((_e4351 * 8u) + 1u)];
                let _e4370 = state[((idx * 8u) + 1u)];
                let _e4371 = other_idx;
                let _e4378 = state[((_e4371 * 8u) + 1u)];
                let _e4385 = state[((idx * 8u) + 1u)];
                let _e4394 = other_idx;
                let _e4401 = state[((_e4394 * 8u) + 1u)];
                let _e4408 = state[((idx * 8u) + 1u)];
                let _e4419 = other_idx;
                let _e4426 = state[((_e4419 * 8u) + 1u)];
                let _e4433 = state[((idx * 8u) + 1u)];
                let _e4442 = other_idx;
                let _e4449 = state[((_e4442 * 8u) + 1u)];
                let _e4456 = state[((idx * 8u) + 1u)];
                let _e4476 = other_idx;
                let _e4483 = state[((_e4476 * 8u) + 1u)];
                let _e4490 = state[((idx * 8u) + 1u)];
                let _e4495 = other_idx;
                let _e4502 = state[((_e4495 * 8u) + 1u)];
                let _e4509 = state[((idx * 8u) + 1u)];
                let _e4515 = phi_1_;
                let _e4521 = constants.scheme;
                let _e4525 = other_idx;
                let _e4532 = state[((_e4525 * 8u) + 1u)];
                let _e4533 = other_idx;
                let _e4540 = state[((_e4533 * 8u) + 1u)];
                let _e4547 = state[((idx * 8u) + 1u)];
                let _e4556 = other_idx;
                let _e4563 = state[((_e4556 * 8u) + 1u)];
                let _e4570 = state[((idx * 8u) + 1u)];
                let _e4581 = other_idx;
                let _e4588 = state[((_e4581 * 8u) + 1u)];
                let _e4595 = state[((idx * 8u) + 1u)];
                let _e4604 = other_idx;
                let _e4611 = state[((_e4604 * 8u) + 1u)];
                let _e4618 = state[((idx * 8u) + 1u)];
                let _e4634 = other_center.x;
                let _e4636 = other_center.y;
                let _e4646 = state[((idx * 8u) + 1u)];
                let _e4647 = other_idx;
                let _e4654 = state[((_e4647 * 8u) + 1u)];
                let _e4664 = state[((idx * 8u) + 1u)];
                let _e4665 = other_idx;
                let _e4672 = state[((_e4665 * 8u) + 1u)];
                let _e4675 = other_idx;
                let _e4682 = state[((_e4675 * 8u) + 1u)];
                let _e4689 = state[((idx * 8u) + 1u)];
                let _e4698 = other_idx;
                let _e4705 = state[((_e4698 * 8u) + 1u)];
                let _e4712 = state[((idx * 8u) + 1u)];
                let _e4723 = other_idx;
                let _e4730 = state[((_e4723 * 8u) + 1u)];
                let _e4737 = state[((idx * 8u) + 1u)];
                let _e4746 = other_idx;
                let _e4753 = state[((_e4746 * 8u) + 1u)];
                let _e4760 = state[((idx * 8u) + 1u)];
                let _e4776 = other_center.x;
                let _e4778 = other_center.y;
                let _e4793 = state[((idx * 8u) + 1u)];
                let _e4794 = other_idx;
                let _e4801 = state[((_e4794 * 8u) + 1u)];
                let _e4803 = other_idx;
                let _e4810 = state[((_e4803 * 8u) + 1u)];
                let _e4817 = state[((idx * 8u) + 1u)];
                let _e4826 = other_idx;
                let _e4833 = state[((_e4826 * 8u) + 1u)];
                let _e4840 = state[((idx * 8u) + 1u)];
                let _e4851 = other_idx;
                let _e4858 = state[((_e4851 * 8u) + 1u)];
                let _e4865 = state[((idx * 8u) + 1u)];
                let _e4874 = other_idx;
                let _e4881 = state[((_e4874 * 8u) + 1u)];
                let _e4888 = state[((idx * 8u) + 1u)];
                let _e4904 = other_center.x;
                let _e4906 = other_center.y;
                let _e4922 = state[((idx * 8u) + 1u)];
                let _e4923 = other_idx;
                let _e4930 = state[((_e4923 * 8u) + 1u)];
                let _e4937 = state[((idx * 8u) + 1u)];
                let _e4946 = other_idx;
                let _e4953 = state[((_e4946 * 8u) + 1u)];
                let _e4960 = state[((idx * 8u) + 1u)];
                let _e4971 = other_idx;
                let _e4978 = state[((_e4971 * 8u) + 1u)];
                let _e4985 = state[((idx * 8u) + 1u)];
                let _e4994 = other_idx;
                let _e5001 = state[((_e4994 * 8u) + 1u)];
                let _e5008 = state[((idx * 8u) + 1u)];
                let _e5028 = other_idx;
                let _e5035 = state[((_e5028 * 8u) + 1u)];
                let _e5042 = state[((idx * 8u) + 1u)];
                let _e5046 = other_idx;
                let _e5053 = state[((_e5046 * 8u) + 1u)];
                let _e5060 = state[((idx * 8u) + 1u)];
                let _e5063 = other_idx;
                let _e5070 = state[((_e5063 * 8u) + 1u)];
                let _e5077 = state[((idx * 8u) + 1u)];
                let _e5086 = other_idx;
                let _e5093 = state[((_e5086 * 8u) + 1u)];
                let _e5100 = state[((idx * 8u) + 1u)];
                let _e5111 = other_idx;
                let _e5118 = state[((_e5111 * 8u) + 1u)];
                let _e5125 = state[((idx * 8u) + 1u)];
                let _e5134 = other_idx;
                let _e5141 = state[((_e5134 * 8u) + 1u)];
                let _e5148 = state[((idx * 8u) + 1u)];
                let _e5173 = other_idx;
                let _e5180 = state[((_e5173 * 8u) + 1u)];
                let _e5187 = state[((idx * 8u) + 1u)];
                let _e5189 = other_idx;
                let _e5196 = state[((_e5189 * 8u) + 1u)];
                let _e5203 = state[((idx * 8u) + 1u)];
                let _e5212 = other_idx;
                let _e5219 = state[((_e5212 * 8u) + 1u)];
                let _e5226 = state[((idx * 8u) + 1u)];
                let _e5237 = other_idx;
                let _e5244 = state[((_e5237 * 8u) + 1u)];
                let _e5251 = state[((idx * 8u) + 1u)];
                let _e5260 = other_idx;
                let _e5267 = state[((_e5260 * 8u) + 1u)];
                let _e5274 = state[((idx * 8u) + 1u)];
                let _e5300 = phi_1_;
                let _e5306 = constants.scheme;
                let _e5310 = other_idx;
                let _e5317 = state[((_e5310 * 8u) + 1u)];
                let _e5318 = other_idx;
                let _e5325 = state[((_e5318 * 8u) + 1u)];
                let _e5334 = state[((idx * 8u) + 1u)];
                let _e5338 = other_idx;
                let _e5345 = state[((_e5338 * 8u) + 1u)];
                let _e5352 = state[((idx * 8u) + 1u)];
                let _e5361 = other_idx;
                let _e5368 = state[((_e5361 * 8u) + 1u)];
                let _e5375 = state[((idx * 8u) + 1u)];
                let _e5386 = other_idx;
                let _e5393 = state[((_e5386 * 8u) + 1u)];
                let _e5400 = state[((idx * 8u) + 1u)];
                let _e5409 = other_idx;
                let _e5416 = state[((_e5409 * 8u) + 1u)];
                let _e5423 = state[((idx * 8u) + 1u)];
                let _e5439 = other_center.x;
                let _e5441 = other_center.y;
                let _e5448 = other_idx;
                let _e5455 = state[((_e5448 * 8u) + 1u)];
                let _e5463 = state[((idx * 8u) + 1u)];
                let _e5464 = other_idx;
                let _e5471 = state[((_e5464 * 8u) + 1u)];
                let _e5482 = state[((idx * 8u) + 1u)];
                let _e5483 = other_idx;
                let _e5490 = state[((_e5483 * 8u) + 1u)];
                let _e5502 = state[((idx * 8u) + 1u)];
                let _e5509 = state[((idx * 8u) + 1u)];
                let _e5512 = other_idx;
                let _e5519 = state[((_e5512 * 8u) + 1u)];
                let _e5523 = other_idx;
                let _e5530 = state[((_e5523 * 8u) + 1u)];
                let _e5537 = state[((idx * 8u) + 1u)];
                let _e5546 = other_idx;
                let _e5553 = state[((_e5546 * 8u) + 1u)];
                let _e5560 = state[((idx * 8u) + 1u)];
                let _e5571 = other_idx;
                let _e5578 = state[((_e5571 * 8u) + 1u)];
                let _e5585 = state[((idx * 8u) + 1u)];
                let _e5594 = other_idx;
                let _e5601 = state[((_e5594 * 8u) + 1u)];
                let _e5608 = state[((idx * 8u) + 1u)];
                let _e5621 = other_center.x;
                let _e5623 = other_center.y;
                let _e5639 = state[((idx * 8u) + 1u)];
                let _e5641 = other_idx;
                let _e5648 = state[((_e5641 * 8u) + 1u)];
                let _e5655 = state[((idx * 8u) + 1u)];
                let _e5660 = other_idx;
                let _e5667 = state[((_e5660 * 8u) + 1u)];
                let _e5674 = state[((idx * 8u) + 1u)];
                let _e5680 = phi_1_;
                let _e5686 = constants.scheme;
                let _e5690 = other_idx;
                let _e5697 = state[((_e5690 * 8u) + 1u)];
                let _e5698 = other_idx;
                let _e5705 = state[((_e5698 * 8u) + 1u)];
                let _e5714 = state[((idx * 8u) + 1u)];
                let _e5718 = other_idx;
                let _e5725 = state[((_e5718 * 8u) + 1u)];
                let _e5732 = state[((idx * 8u) + 1u)];
                let _e5741 = other_idx;
                let _e5748 = state[((_e5741 * 8u) + 1u)];
                let _e5755 = state[((idx * 8u) + 1u)];
                let _e5766 = other_idx;
                let _e5773 = state[((_e5766 * 8u) + 1u)];
                let _e5780 = state[((idx * 8u) + 1u)];
                let _e5789 = other_idx;
                let _e5796 = state[((_e5789 * 8u) + 1u)];
                let _e5803 = state[((idx * 8u) + 1u)];
                let _e5819 = other_center.x;
                let _e5821 = other_center.y;
                let _e5828 = other_idx;
                let _e5835 = state[((_e5828 * 8u) + 1u)];
                let _e5843 = state[((idx * 8u) + 1u)];
                let _e5844 = other_idx;
                let _e5851 = state[((_e5844 * 8u) + 1u)];
                let _e5861 = state[((idx * 8u) + 1u)];
                let _e5862 = other_idx;
                let _e5869 = state[((_e5862 * 8u) + 1u)];
                let _e5872 = other_idx;
                let _e5879 = state[((_e5872 * 8u) + 1u)];
                let _e5888 = state[((idx * 8u) + 1u)];
                let _e5892 = other_idx;
                let _e5899 = state[((_e5892 * 8u) + 1u)];
                let _e5906 = state[((idx * 8u) + 1u)];
                let _e5915 = other_idx;
                let _e5922 = state[((_e5915 * 8u) + 1u)];
                let _e5929 = state[((idx * 8u) + 1u)];
                let _e5940 = other_idx;
                let _e5947 = state[((_e5940 * 8u) + 1u)];
                let _e5954 = state[((idx * 8u) + 1u)];
                let _e5963 = other_idx;
                let _e5970 = state[((_e5963 * 8u) + 1u)];
                let _e5977 = state[((idx * 8u) + 1u)];
                let _e5993 = other_center.x;
                let _e5995 = other_center.y;
                let _e6002 = other_idx;
                let _e6009 = state[((_e6002 * 8u) + 1u)];
                let _e6022 = state[((idx * 8u) + 1u)];
                let _e6023 = other_idx;
                let _e6030 = state[((_e6023 * 8u) + 1u)];
                let _e6032 = other_idx;
                let _e6039 = state[((_e6032 * 8u) + 1u)];
                let _e6048 = state[((idx * 8u) + 1u)];
                let _e6052 = other_idx;
                let _e6059 = state[((_e6052 * 8u) + 1u)];
                let _e6066 = state[((idx * 8u) + 1u)];
                let _e6075 = other_idx;
                let _e6082 = state[((_e6075 * 8u) + 1u)];
                let _e6089 = state[((idx * 8u) + 1u)];
                let _e6100 = other_idx;
                let _e6107 = state[((_e6100 * 8u) + 1u)];
                let _e6114 = state[((idx * 8u) + 1u)];
                let _e6123 = other_idx;
                let _e6130 = state[((_e6123 * 8u) + 1u)];
                let _e6137 = state[((idx * 8u) + 1u)];
                let _e6153 = other_center.x;
                let _e6155 = other_center.y;
                let _e6162 = other_idx;
                let _e6169 = state[((_e6162 * 8u) + 1u)];
                let _e6183 = state[((idx * 8u) + 1u)];
                let _e6190 = state[((idx * 8u) + 1u)];
                let _e6193 = other_idx;
                let _e6200 = state[((_e6193 * 8u) + 1u)];
                let _e6204 = other_idx;
                let _e6211 = state[((_e6204 * 8u) + 1u)];
                let _e6218 = state[((idx * 8u) + 1u)];
                let _e6227 = other_idx;
                let _e6234 = state[((_e6227 * 8u) + 1u)];
                let _e6241 = state[((idx * 8u) + 1u)];
                let _e6252 = other_idx;
                let _e6259 = state[((_e6252 * 8u) + 1u)];
                let _e6266 = state[((idx * 8u) + 1u)];
                let _e6275 = other_idx;
                let _e6282 = state[((_e6275 * 8u) + 1u)];
                let _e6289 = state[((idx * 8u) + 1u)];
                let _e6302 = other_center.x;
                let _e6304 = other_center.y;
                let _e6320 = state[((idx * 8u) + 1u)];
                let _e6322 = other_idx;
                let _e6329 = state[((_e6322 * 8u) + 1u)];
                let _e6336 = state[((idx * 8u) + 1u)];
                let _e6340 = other_idx;
                let _e6347 = state[((_e6340 * 8u) + 1u)];
                let _e6354 = state[((idx * 8u) + 1u)];
                let _e6363 = state[((idx * 8u) + 1u)];
                let _e6366 = other_idx;
                let _e6373 = state[((_e6366 * 8u) + 1u)];
                let _e6377 = other_idx;
                let _e6384 = state[((_e6377 * 8u) + 1u)];
                let _e6391 = state[((idx * 8u) + 1u)];
                let _e6400 = other_idx;
                let _e6407 = state[((_e6400 * 8u) + 1u)];
                let _e6414 = state[((idx * 8u) + 1u)];
                let _e6425 = other_idx;
                let _e6432 = state[((_e6425 * 8u) + 1u)];
                let _e6439 = state[((idx * 8u) + 1u)];
                let _e6448 = other_idx;
                let _e6455 = state[((_e6448 * 8u) + 1u)];
                let _e6462 = state[((idx * 8u) + 1u)];
                let _e6475 = other_center.x;
                let _e6477 = other_center.y;
                let _e6493 = state[((idx * 8u) + 1u)];
                let _e6500 = other_idx;
                let _e6507 = state[((_e6500 * 8u) + 1u)];
                let _e6514 = state[((idx * 8u) + 1u)];
                let _e6522 = state[((idx * 8u) + 1u)];
                let _e6525 = other_idx;
                let _e6532 = state[((_e6525 * 8u) + 1u)];
                let _e6536 = other_idx;
                let _e6543 = state[((_e6536 * 8u) + 1u)];
                let _e6550 = state[((idx * 8u) + 1u)];
                let _e6559 = other_idx;
                let _e6566 = state[((_e6559 * 8u) + 1u)];
                let _e6573 = state[((idx * 8u) + 1u)];
                let _e6584 = other_idx;
                let _e6591 = state[((_e6584 * 8u) + 1u)];
                let _e6598 = state[((idx * 8u) + 1u)];
                let _e6607 = other_idx;
                let _e6614 = state[((_e6607 * 8u) + 1u)];
                let _e6621 = state[((idx * 8u) + 1u)];
                let _e6634 = other_center.x;
                let _e6636 = other_center.y;
                let _e6652 = state[((idx * 8u) + 1u)];
                let _e6660 = phi_1_;
                let _e6666 = constants.scheme;
                let _e6676 = state[((idx * 8u) + 1u)];
                let _e6677 = other_idx;
                let _e6684 = state[((_e6677 * 8u) + 1u)];
                let _e6685 = phi_1_;
                let _e6691 = rhs_1_;
                rhs_1_ = (_e6691 - (_e3681 * (select(select(select(select(select(select(select(_e3688, _e3696, (_e3697 < 0f)), select((_e3708 + dot(vec2<f32>(vec2<f32>((((_e3716 - _e3723) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3739 - _e3746) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3764 - _e3771) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3787 - _e3794) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e3810, _e3812)))), (_e3823 + dot(vec2<f32>(vec2<f32>((((_e3831 - _e3838) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3854 - _e3861) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e3879 - _e3886) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3902 - _e3909) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))), (_e3930 > 0f)), (_e3936 == 1u)), select((((_e3947 * 0.625f) + (_e3956 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e3967 - _e3974) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e3990 - _e3997) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4015 - _e4022) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4038 - _e4045) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e4061, _e4063))) * 0.125f)), (((_e4076 * 0.625f) + (_e4086 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e4097 - _e4104) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4120 - _e4127) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4145 - _e4152) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4168 - _e4175) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e4188, _e4190) - vec2<f32>(center.x, center.y))) * 0.125f)), (_e4200 > 0f)), (_e4206 == 2u)), select((_e4217 + min(max(dot(vec2<f32>(vec2<f32>((((_e4225 - _e4232) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4248 - _e4255) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4273 - _e4280) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4296 - _e4303) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4319, _e4321))), min((_e4331 - _e4339), 0f)), max((_e4350 - _e4358), 0f))), (_e4370 + min(max(dot(vec2<f32>(vec2<f32>((((_e4378 - _e4385) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4401 - _e4408) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4426 - _e4433) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4449 - _e4456) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))), min((_e4483 - _e4490), 0f)), max((_e4502 - _e4509), 0f))), (_e4515 > 0f)), (_e4521 == 3u)), select((_e4532 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e4540 - _e4547) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4563 - _e4570) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4588 - _e4595) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4611 - _e4618) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4634, _e4636))) * abs((_e4646 - _e4654))) / max(abs((_e4664 - _e4672)), (abs(dot(vec2<f32>(vec2<f32>((((_e4682 - _e4689) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4705 - _e4712) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4730 - _e4737) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4753 - _e4760) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4776, _e4778)))) + 0.00000001f))), (((_e4793 - _e4801) * dot(vec2<f32>(vec2<f32>((((_e4810 - _e4817) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4833 - _e4840) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4858 - _e4865) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4881 - _e4888) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(_e4904, _e4906)))) > 0f))), (_e4922 + select(0f, ((dot(vec2<f32>(vec2<f32>((((_e4930 - _e4937) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e4953 - _e4960) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e4978 - _e4985) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5001 - _e5008) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y))) * abs((_e5035 - _e5042))) / max(abs((_e5053 - _e5060)), (abs(dot(vec2<f32>(vec2<f32>((((_e5070 - _e5077) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5093 - _e5100) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5118 - _e5125) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5141 - _e5148) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) + 0.00000001f))), (((_e5180 - _e5187) * dot(vec2<f32>(vec2<f32>((((_e5196 - _e5203) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5219 - _e5226) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5244 - _e5251) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5267 - _e5274) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)))) > 0f))), (_e5300 > 0f)), (_e5306 == 4u)), select((_e5317 + min(max(((((_e5325 * 0.625f) + (_e5334 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5345 - _e5352) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5368 - _e5375) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5393 - _e5400) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5416 - _e5423) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5439, _e5441))) * 0.125f)) - _e5455), min((_e5463 - _e5471), 0f)), max((_e5482 - _e5490), 0f))), (_e5502 + min(max(((((_e5509 * 0.625f) + (_e5519 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5530 - _e5537) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5553 - _e5560) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5578 - _e5585) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5601 - _e5608) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e5621, _e5623) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e5639), min((_e5648 - _e5655), 0f)), max((_e5667 - _e5674), 0f))), (_e5680 > 0f)), (_e5686 == 5u)), select((_e5697 + select(0f, ((((((_e5705 * 0.625f) + (_e5714 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5725 - _e5732) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5748 - _e5755) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5773 - _e5780) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5796 - _e5803) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5819, _e5821))) * 0.125f)) - _e5835) * abs((_e5843 - _e5851))) / max(abs((_e5861 - _e5869)), (abs(((((_e5879 * 0.625f) + (_e5888 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e5899 - _e5906) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5922 - _e5929) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e5947 - _e5954) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e5970 - _e5977) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e5993, _e5995))) * 0.125f)) - _e6009)) + 0.00000001f))), (((_e6022 - _e6030) * ((((_e6039 * 0.625f) + (_e6048 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6059 - _e6066) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6082 - _e6089) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6107 - _e6114) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6130 - _e6137) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(center.x, center.y) - vec2<f32>(_e6153, _e6155))) * 0.125f)) - _e6169)) > 0f))), (_e6183 + select(0f, ((((((_e6190 * 0.625f) + (_e6200 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6211 - _e6218) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6234 - _e6241) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6259 - _e6266) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6282 - _e6289) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e6302, _e6304) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e6320) * abs((_e6329 - _e6336))) / max(abs((_e6347 - _e6354)), (abs(((((_e6363 * 0.625f) + (_e6373 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6384 - _e6391) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6407 - _e6414) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6432 - _e6439) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6455 - _e6462) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e6475, _e6477) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e6493)) + 0.00000001f))), (((_e6507 - _e6514) * ((((_e6522 * 0.625f) + (_e6532 * 0.375f)) + (dot(vec2<f32>(vec2<f32>((((_e6543 - _e6550) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6566 - _e6573) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).x, vec2<f32>((((_e6591 - _e6598) * dx) / max(((dx * dx) + (dy * dy)), 0.000000000001f)), (((_e6614 - _e6621) * dy) / max(((dx * dx) + (dy * dy)), 0.000000000001f))).y), (vec2<f32>(_e6634, _e6636) - vec2<f32>(center.x, center.y))) * 0.125f)) - _e6652)) > 0f))), (_e6660 > 0f)), (_e6666 == 6u)) - select(_e6676, _e6684, (_e6685 < 0f)))));
            } else {
                let _e6699 = bc_kind[((face_idx * 3u) + 1u)];
                if (_e6699 == 1u) {
                    let _e6702 = phi_1_;
                    let _e6705 = diag_1_;
                    diag_1_ = (_e6705 + max(_e6702, 0f));
                    let _e6707 = phi_1_;
                    let _e6716 = bc_value[((face_idx * 3u) + 1u)];
                    let _e6718 = rhs_1_;
                    rhs_1_ = (_e6718 - (min(_e6707, 0f) * _e6716));
                } else {
                    let _e6720 = phi_1_;
                    let _e6721 = diag_1_;
                    diag_1_ = (_e6721 + _e6720);
                }
            }
            let _e6733 = normal.x;
            let _e6735 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (diag_rank * 3u)) + 2u)] = (_e6735 + ((0.5f * area) * _e6733));
            let _e6747 = normal.x;
            let _e6749 = matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_0_ + (neighbor_rank * 3u)) + 2u)] = (_e6749 + ((0.5f * area) * _e6747));
            let _e6761 = normal.y;
            let _e6763 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (diag_rank * 3u)) + 2u)] = (_e6763 + ((0.5f * area) * _e6761));
            let _e6775 = normal.y;
            let _e6777 = matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)];
            matrix_values[((start_row_1_ + (neighbor_rank * 3u)) + 2u)] = (_e6777 + ((0.5f * area) * _e6775));
            let _e6781 = constants.density;
            let _e6788 = state[((idx * 8u) + 3u)];
            let _e6791 = dist;
            let diff_coeff_p = (((_e6781 * _e6788) * area) / _e6791);
            let _e6793 = is_boundary;
            if !(_e6793) {
                let _e6796 = diag_2_;
                diag_2_ = (_e6796 + diff_coeff_p);
                let _e6805 = matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)];
                matrix_values[((start_row_2_ + (neighbor_rank * 3u)) + 2u)] = (_e6805 - diff_coeff_p);
            } else {
                let _e6813 = bc_kind[((face_idx * 3u) + 2u)];
                if (_e6813 == 1u) {
                    let _e6816 = diag_2_;
                    diag_2_ = (_e6816 + diff_coeff_p);
                    let _e6825 = bc_value[((face_idx * 3u) + 2u)];
                    let _e6827 = rhs_2_;
                    rhs_2_ = (_e6827 + (diff_coeff_p * _e6825));
                } else {
                    let _e6835 = bc_kind[((face_idx * 3u) + 2u)];
                    if (_e6835 == 2u) {
                        let _e6840 = constants.density;
                        let _e6847 = state[((idx * 8u) + 3u)];
                        let _e6856 = bc_value[((face_idx * 3u) + 2u)];
                        let _e6859 = rhs_2_;
                        rhs_2_ = (_e6859 + -((((_e6840 * _e6847) * area) * _e6856)));
                    }
                }
            }
            let _e6867 = fluxes[((face_idx * 3u) + 2u)];
            phi_2_ = _e6867;
            if (owner != idx) {
                let _e6870 = phi_2_;
                let _e6873 = phi_2_;
                phi_2_ = (_e6873 - (_e6870 * 2f));
            }
            let _e6875 = phi_2_;
            let _e6876 = rhs_2_;
            rhs_2_ = (_e6876 - _e6875);
        }
        continuing {
            let _e6879 = k;
            k = (_e6879 + 1u);
        }
    }
    let _e6888 = diag_0_;
    let _e6889 = matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)];
    matrix_values[((start_row_0_ + (diag_rank * 3u)) + 0u)] = (_e6889 + _e6888);
    let _e6897 = rhs_0_;
    rhs[((idx * 3u) + 0u)] = _e6897;
    let _e6905 = diag_1_;
    let _e6906 = matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)];
    matrix_values[((start_row_1_ + (diag_rank * 3u)) + 1u)] = (_e6906 + _e6905);
    let _e6914 = rhs_1_;
    rhs[((idx * 3u) + 1u)] = _e6914;
    let _e6922 = diag_2_;
    let _e6923 = matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)];
    matrix_values[((start_row_2_ + (diag_rank * 3u)) + 2u)] = (_e6923 + _e6922);
    let _e6931 = rhs_2_;
    rhs[((idx * 3u) + 2u)] = _e6931;
    return;
}
"#;
    }
    pub mod generic_coupled_update_compressible {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateCompressible::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_compressible :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
                wgpu::BindGroupLayoutDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateCompressible::BindGroup1::LayoutDescriptor",
                    ),
                    entries: &[
                        #[doc = " @binding(0): \"x\""]
                        wgpu::BindGroupLayoutEntry {
                            binding: 0,
                            visibility: wgpu::ShaderStages::COMPUTE,
                            ty: wgpu::BindingType::Buffer {
                                ty: wgpu::BufferBindingType::Storage { read_only: false },
                                has_dynamic_offset: false,
                                min_binding_size: None,
                            },
                            count: None,
                        },
                    ],
                };
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateCompressible::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateCompressible::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_compressible.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e19 = state[((idx * 8u) + 0u)];
    let _e26 = x[((idx * 8u) + 0u)];
    let _e33 = state[((idx * 8u) + 0u)];
    let _e40 = x[((idx * 8u) + 0u)];
    let _e49 = state[((idx * 8u) + 0u)];
    let _e56 = state[((idx * 8u) + 0u)];
    let _e64 = state[((idx * 8u) + 0u)];
    let _e76 = x[((idx * 8u) + 0u)];
    let _e83 = x[((idx * 8u) + 0u)];
    let _e91 = x[((idx * 8u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e19, select(_e26, mix(_e33, _e40, 1f), ((_e49 == _e56) && (abs(_e64) < 340000000000000000000000000000000000000f))), ((_e76 == _e83) && (abs(_e91) < 340000000000000000000000000000000000000f)));
    let _e109 = state[((idx * 8u) + 0u)];
    let _e116 = x[((idx * 8u) + 0u)];
    let _e123 = state[((idx * 8u) + 0u)];
    let _e130 = x[((idx * 8u) + 0u)];
    let _e139 = state[((idx * 8u) + 0u)];
    let _e146 = state[((idx * 8u) + 0u)];
    let _e154 = state[((idx * 8u) + 0u)];
    let _e166 = x[((idx * 8u) + 0u)];
    let _e173 = x[((idx * 8u) + 0u)];
    let _e181 = x[((idx * 8u) + 0u)];
    x[((idx * 8u) + 0u)] = select(_e109, select(_e116, mix(_e123, _e130, 1f), ((_e139 == _e146) && (abs(_e154) < 340000000000000000000000000000000000000f))), ((_e166 == _e173) && (abs(_e181) < 340000000000000000000000000000000000000f)));
    let _e199 = state[((idx * 8u) + 1u)];
    let _e206 = x[((idx * 8u) + 1u)];
    let _e213 = state[((idx * 8u) + 1u)];
    let _e220 = x[((idx * 8u) + 1u)];
    let _e229 = state[((idx * 8u) + 1u)];
    let _e236 = state[((idx * 8u) + 1u)];
    let _e244 = state[((idx * 8u) + 1u)];
    let _e256 = x[((idx * 8u) + 1u)];
    let _e263 = x[((idx * 8u) + 1u)];
    let _e271 = x[((idx * 8u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e199, select(_e206, mix(_e213, _e220, 1f), ((_e229 == _e236) && (abs(_e244) < 340000000000000000000000000000000000000f))), ((_e256 == _e263) && (abs(_e271) < 340000000000000000000000000000000000000f)));
    let _e289 = state[((idx * 8u) + 1u)];
    let _e296 = x[((idx * 8u) + 1u)];
    let _e303 = state[((idx * 8u) + 1u)];
    let _e310 = x[((idx * 8u) + 1u)];
    let _e319 = state[((idx * 8u) + 1u)];
    let _e326 = state[((idx * 8u) + 1u)];
    let _e334 = state[((idx * 8u) + 1u)];
    let _e346 = x[((idx * 8u) + 1u)];
    let _e353 = x[((idx * 8u) + 1u)];
    let _e361 = x[((idx * 8u) + 1u)];
    x[((idx * 8u) + 1u)] = select(_e289, select(_e296, mix(_e303, _e310, 1f), ((_e319 == _e326) && (abs(_e334) < 340000000000000000000000000000000000000f))), ((_e346 == _e353) && (abs(_e361) < 340000000000000000000000000000000000000f)));
    let _e379 = state[((idx * 8u) + 2u)];
    let _e386 = x[((idx * 8u) + 2u)];
    let _e393 = state[((idx * 8u) + 2u)];
    let _e400 = x[((idx * 8u) + 2u)];
    let _e409 = state[((idx * 8u) + 2u)];
    let _e416 = state[((idx * 8u) + 2u)];
    let _e424 = state[((idx * 8u) + 2u)];
    let _e436 = x[((idx * 8u) + 2u)];
    let _e443 = x[((idx * 8u) + 2u)];
    let _e451 = x[((idx * 8u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e379, select(_e386, mix(_e393, _e400, 1f), ((_e409 == _e416) && (abs(_e424) < 340000000000000000000000000000000000000f))), ((_e436 == _e443) && (abs(_e451) < 340000000000000000000000000000000000000f)));
    let _e469 = state[((idx * 8u) + 2u)];
    let _e476 = x[((idx * 8u) + 2u)];
    let _e483 = state[((idx * 8u) + 2u)];
    let _e490 = x[((idx * 8u) + 2u)];
    let _e499 = state[((idx * 8u) + 2u)];
    let _e506 = state[((idx * 8u) + 2u)];
    let _e514 = state[((idx * 8u) + 2u)];
    let _e526 = x[((idx * 8u) + 2u)];
    let _e533 = x[((idx * 8u) + 2u)];
    let _e541 = x[((idx * 8u) + 2u)];
    x[((idx * 8u) + 2u)] = select(_e469, select(_e476, mix(_e483, _e490, 1f), ((_e499 == _e506) && (abs(_e514) < 340000000000000000000000000000000000000f))), ((_e526 == _e533) && (abs(_e541) < 340000000000000000000000000000000000000f)));
    let _e559 = state[((idx * 8u) + 3u)];
    let _e566 = x[((idx * 8u) + 3u)];
    let _e573 = state[((idx * 8u) + 3u)];
    let _e580 = x[((idx * 8u) + 3u)];
    let _e589 = state[((idx * 8u) + 3u)];
    let _e596 = state[((idx * 8u) + 3u)];
    let _e604 = state[((idx * 8u) + 3u)];
    let _e616 = x[((idx * 8u) + 3u)];
    let _e623 = x[((idx * 8u) + 3u)];
    let _e631 = x[((idx * 8u) + 3u)];
    state[((idx * 8u) + 3u)] = select(_e559, select(_e566, mix(_e573, _e580, 1f), ((_e589 == _e596) && (abs(_e604) < 340000000000000000000000000000000000000f))), ((_e616 == _e623) && (abs(_e631) < 340000000000000000000000000000000000000f)));
    let _e649 = state[((idx * 8u) + 3u)];
    let _e656 = x[((idx * 8u) + 3u)];
    let _e663 = state[((idx * 8u) + 3u)];
    let _e670 = x[((idx * 8u) + 3u)];
    let _e679 = state[((idx * 8u) + 3u)];
    let _e686 = state[((idx * 8u) + 3u)];
    let _e694 = state[((idx * 8u) + 3u)];
    let _e706 = x[((idx * 8u) + 3u)];
    let _e713 = x[((idx * 8u) + 3u)];
    let _e721 = x[((idx * 8u) + 3u)];
    x[((idx * 8u) + 3u)] = select(_e649, select(_e656, mix(_e663, _e670, 1f), ((_e679 == _e686) && (abs(_e694) < 340000000000000000000000000000000000000f))), ((_e706 == _e713) && (abs(_e721) < 340000000000000000000000000000000000000f)));
    let _e739 = state[((idx * 8u) + 6u)];
    let _e746 = x[((idx * 8u) + 4u)];
    let _e753 = state[((idx * 8u) + 6u)];
    let _e760 = x[((idx * 8u) + 4u)];
    let _e769 = state[((idx * 8u) + 6u)];
    let _e776 = state[((idx * 8u) + 6u)];
    let _e784 = state[((idx * 8u) + 6u)];
    let _e796 = x[((idx * 8u) + 4u)];
    let _e803 = x[((idx * 8u) + 4u)];
    let _e811 = x[((idx * 8u) + 4u)];
    state[((idx * 8u) + 6u)] = select(_e739, select(_e746, mix(_e753, _e760, 1f), ((_e769 == _e776) && (abs(_e784) < 340000000000000000000000000000000000000f))), ((_e796 == _e803) && (abs(_e811) < 340000000000000000000000000000000000000f)));
    let _e829 = state[((idx * 8u) + 6u)];
    let _e836 = x[((idx * 8u) + 4u)];
    let _e843 = state[((idx * 8u) + 6u)];
    let _e850 = x[((idx * 8u) + 4u)];
    let _e859 = state[((idx * 8u) + 6u)];
    let _e866 = state[((idx * 8u) + 6u)];
    let _e874 = state[((idx * 8u) + 6u)];
    let _e886 = x[((idx * 8u) + 4u)];
    let _e893 = x[((idx * 8u) + 4u)];
    let _e901 = x[((idx * 8u) + 4u)];
    x[((idx * 8u) + 4u)] = select(_e829, select(_e836, mix(_e843, _e850, 1f), ((_e859 == _e866) && (abs(_e874) < 340000000000000000000000000000000000000f))), ((_e886 == _e893) && (abs(_e901) < 340000000000000000000000000000000000000f)));
    let _e919 = state[((idx * 8u) + 7u)];
    let _e926 = x[((idx * 8u) + 5u)];
    let _e933 = state[((idx * 8u) + 7u)];
    let _e940 = x[((idx * 8u) + 5u)];
    let _e949 = state[((idx * 8u) + 7u)];
    let _e956 = state[((idx * 8u) + 7u)];
    let _e964 = state[((idx * 8u) + 7u)];
    let _e976 = x[((idx * 8u) + 5u)];
    let _e983 = x[((idx * 8u) + 5u)];
    let _e991 = x[((idx * 8u) + 5u)];
    state[((idx * 8u) + 7u)] = select(_e919, select(_e926, mix(_e933, _e940, 1f), ((_e949 == _e956) && (abs(_e964) < 340000000000000000000000000000000000000f))), ((_e976 == _e983) && (abs(_e991) < 340000000000000000000000000000000000000f)));
    let _e1009 = state[((idx * 8u) + 7u)];
    let _e1016 = x[((idx * 8u) + 5u)];
    let _e1023 = state[((idx * 8u) + 7u)];
    let _e1030 = x[((idx * 8u) + 5u)];
    let _e1039 = state[((idx * 8u) + 7u)];
    let _e1046 = state[((idx * 8u) + 7u)];
    let _e1054 = state[((idx * 8u) + 7u)];
    let _e1066 = x[((idx * 8u) + 5u)];
    let _e1073 = x[((idx * 8u) + 5u)];
    let _e1081 = x[((idx * 8u) + 5u)];
    x[((idx * 8u) + 5u)] = select(_e1009, select(_e1016, mix(_e1023, _e1030, 1f), ((_e1039 == _e1046) && (abs(_e1054) < 340000000000000000000000000000000000000f))), ((_e1066 == _e1073) && (abs(_e1081) < 340000000000000000000000000000000000000f)));
    let _e1099 = state[((idx * 8u) + 4u)];
    let _e1106 = x[((idx * 8u) + 6u)];
    let _e1113 = state[((idx * 8u) + 4u)];
    let _e1120 = x[((idx * 8u) + 6u)];
    let _e1129 = state[((idx * 8u) + 4u)];
    let _e1136 = state[((idx * 8u) + 4u)];
    let _e1144 = state[((idx * 8u) + 4u)];
    let _e1156 = x[((idx * 8u) + 6u)];
    let _e1163 = x[((idx * 8u) + 6u)];
    let _e1171 = x[((idx * 8u) + 6u)];
    state[((idx * 8u) + 4u)] = select(_e1099, select(_e1106, mix(_e1113, _e1120, 1f), ((_e1129 == _e1136) && (abs(_e1144) < 340000000000000000000000000000000000000f))), ((_e1156 == _e1163) && (abs(_e1171) < 340000000000000000000000000000000000000f)));
    let _e1189 = state[((idx * 8u) + 4u)];
    let _e1196 = x[((idx * 8u) + 6u)];
    let _e1203 = state[((idx * 8u) + 4u)];
    let _e1210 = x[((idx * 8u) + 6u)];
    let _e1219 = state[((idx * 8u) + 4u)];
    let _e1226 = state[((idx * 8u) + 4u)];
    let _e1234 = state[((idx * 8u) + 4u)];
    let _e1246 = x[((idx * 8u) + 6u)];
    let _e1253 = x[((idx * 8u) + 6u)];
    let _e1261 = x[((idx * 8u) + 6u)];
    x[((idx * 8u) + 6u)] = select(_e1189, select(_e1196, mix(_e1203, _e1210, 1f), ((_e1219 == _e1226) && (abs(_e1234) < 340000000000000000000000000000000000000f))), ((_e1246 == _e1253) && (abs(_e1261) < 340000000000000000000000000000000000000f)));
    let _e1279 = state[((idx * 8u) + 5u)];
    let _e1286 = x[((idx * 8u) + 7u)];
    let _e1293 = state[((idx * 8u) + 5u)];
    let _e1300 = x[((idx * 8u) + 7u)];
    let _e1309 = state[((idx * 8u) + 5u)];
    let _e1316 = state[((idx * 8u) + 5u)];
    let _e1324 = state[((idx * 8u) + 5u)];
    let _e1336 = x[((idx * 8u) + 7u)];
    let _e1343 = x[((idx * 8u) + 7u)];
    let _e1351 = x[((idx * 8u) + 7u)];
    state[((idx * 8u) + 5u)] = select(_e1279, select(_e1286, mix(_e1293, _e1300, 1f), ((_e1309 == _e1316) && (abs(_e1324) < 340000000000000000000000000000000000000f))), ((_e1336 == _e1343) && (abs(_e1351) < 340000000000000000000000000000000000000f)));
    let _e1369 = state[((idx * 8u) + 5u)];
    let _e1376 = x[((idx * 8u) + 7u)];
    let _e1383 = state[((idx * 8u) + 5u)];
    let _e1390 = x[((idx * 8u) + 7u)];
    let _e1399 = state[((idx * 8u) + 5u)];
    let _e1406 = state[((idx * 8u) + 5u)];
    let _e1414 = state[((idx * 8u) + 5u)];
    let _e1426 = x[((idx * 8u) + 7u)];
    let _e1433 = x[((idx * 8u) + 7u)];
    let _e1441 = x[((idx * 8u) + 7u)];
    x[((idx * 8u) + 7u)] = select(_e1369, select(_e1376, mix(_e1383, _e1390, 1f), ((_e1399 == _e1406) && (abs(_e1414) < 340000000000000000000000000000000000000f))), ((_e1426 == _e1433) && (abs(_e1441) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateGenericDiffusionDemo::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e19 = state[((idx * 1u) + 0u)];
    let _e26 = x[((idx * 1u) + 0u)];
    let _e33 = state[((idx * 1u) + 0u)];
    let _e40 = x[((idx * 1u) + 0u)];
    let _e49 = state[((idx * 1u) + 0u)];
    let _e56 = state[((idx * 1u) + 0u)];
    let _e64 = state[((idx * 1u) + 0u)];
    let _e76 = x[((idx * 1u) + 0u)];
    let _e83 = x[((idx * 1u) + 0u)];
    let _e91 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e19, select(_e26, mix(_e33, _e40, 1f), ((_e49 == _e56) && (abs(_e64) < 340000000000000000000000000000000000000f))), ((_e76 == _e83) && (abs(_e91) < 340000000000000000000000000000000000000f)));
    let _e109 = state[((idx * 1u) + 0u)];
    let _e116 = x[((idx * 1u) + 0u)];
    let _e123 = state[((idx * 1u) + 0u)];
    let _e130 = x[((idx * 1u) + 0u)];
    let _e139 = state[((idx * 1u) + 0u)];
    let _e146 = state[((idx * 1u) + 0u)];
    let _e154 = state[((idx * 1u) + 0u)];
    let _e166 = x[((idx * 1u) + 0u)];
    let _e173 = x[((idx * 1u) + 0u)];
    let _e181 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e109, select(_e116, mix(_e123, _e130, 1f), ((_e139 == _e146) && (abs(_e154) < 340000000000000000000000000000000000000f))), ((_e166 == _e173) && (abs(_e181) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_generic_diffusion_demo_neumann {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_generic_diffusion_demo_neumann :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateGenericDiffusionDemoNeumann::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_generic_diffusion_demo_neumann.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 1u);
    if (idx >= num_cells) {
        return;
    }
    let _e19 = state[((idx * 1u) + 0u)];
    let _e26 = x[((idx * 1u) + 0u)];
    let _e33 = state[((idx * 1u) + 0u)];
    let _e40 = x[((idx * 1u) + 0u)];
    let _e49 = state[((idx * 1u) + 0u)];
    let _e56 = state[((idx * 1u) + 0u)];
    let _e64 = state[((idx * 1u) + 0u)];
    let _e76 = x[((idx * 1u) + 0u)];
    let _e83 = x[((idx * 1u) + 0u)];
    let _e91 = x[((idx * 1u) + 0u)];
    state[((idx * 1u) + 0u)] = select(_e19, select(_e26, mix(_e33, _e40, 1f), ((_e49 == _e56) && (abs(_e64) < 340000000000000000000000000000000000000f))), ((_e76 == _e83) && (abs(_e91) < 340000000000000000000000000000000000000f)));
    let _e109 = state[((idx * 1u) + 0u)];
    let _e116 = x[((idx * 1u) + 0u)];
    let _e123 = state[((idx * 1u) + 0u)];
    let _e130 = x[((idx * 1u) + 0u)];
    let _e139 = state[((idx * 1u) + 0u)];
    let _e146 = state[((idx * 1u) + 0u)];
    let _e154 = state[((idx * 1u) + 0u)];
    let _e166 = x[((idx * 1u) + 0u)];
    let _e173 = x[((idx * 1u) + 0u)];
    let _e181 = x[((idx * 1u) + 0u)];
    x[((idx * 1u) + 0u)] = select(_e109, select(_e116, mix(_e123, _e130, 1f), ((_e139 == _e146) && (abs(_e154) < 340000000000000000000000000000000000000f))), ((_e166 == _e173) && (abs(_e181) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup0"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::BindGroup1"),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("GeneratedGenericCoupledUpdateIncompressibleMomentum::PipelineLayout"),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e19 = state[((idx * 8u) + 0u)];
    let _e26 = x[((idx * 3u) + 0u)];
    let _e33 = state[((idx * 8u) + 0u)];
    let _e40 = x[((idx * 3u) + 0u)];
    let _e43 = constants.alpha_u;
    let _e51 = state[((idx * 8u) + 0u)];
    let _e58 = state[((idx * 8u) + 0u)];
    let _e66 = state[((idx * 8u) + 0u)];
    let _e78 = x[((idx * 3u) + 0u)];
    let _e85 = x[((idx * 3u) + 0u)];
    let _e93 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e19, select(_e26, mix(_e33, _e40, _e43), ((_e51 == _e58) && (abs(_e66) < 340000000000000000000000000000000000000f))), ((_e78 == _e85) && (abs(_e93) < 340000000000000000000000000000000000000f)));
    let _e111 = state[((idx * 8u) + 0u)];
    let _e118 = x[((idx * 3u) + 0u)];
    let _e125 = state[((idx * 8u) + 0u)];
    let _e132 = x[((idx * 3u) + 0u)];
    let _e135 = constants.alpha_u;
    let _e143 = state[((idx * 8u) + 0u)];
    let _e150 = state[((idx * 8u) + 0u)];
    let _e158 = state[((idx * 8u) + 0u)];
    let _e170 = x[((idx * 3u) + 0u)];
    let _e177 = x[((idx * 3u) + 0u)];
    let _e185 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e111, select(_e118, mix(_e125, _e132, _e135), ((_e143 == _e150) && (abs(_e158) < 340000000000000000000000000000000000000f))), ((_e170 == _e177) && (abs(_e185) < 340000000000000000000000000000000000000f)));
    let _e203 = state[((idx * 8u) + 1u)];
    let _e210 = x[((idx * 3u) + 1u)];
    let _e217 = state[((idx * 8u) + 1u)];
    let _e224 = x[((idx * 3u) + 1u)];
    let _e227 = constants.alpha_u;
    let _e235 = state[((idx * 8u) + 1u)];
    let _e242 = state[((idx * 8u) + 1u)];
    let _e250 = state[((idx * 8u) + 1u)];
    let _e262 = x[((idx * 3u) + 1u)];
    let _e269 = x[((idx * 3u) + 1u)];
    let _e277 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e203, select(_e210, mix(_e217, _e224, _e227), ((_e235 == _e242) && (abs(_e250) < 340000000000000000000000000000000000000f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f)));
    let _e295 = state[((idx * 8u) + 1u)];
    let _e302 = x[((idx * 3u) + 1u)];
    let _e309 = state[((idx * 8u) + 1u)];
    let _e316 = x[((idx * 3u) + 1u)];
    let _e319 = constants.alpha_u;
    let _e327 = state[((idx * 8u) + 1u)];
    let _e334 = state[((idx * 8u) + 1u)];
    let _e342 = state[((idx * 8u) + 1u)];
    let _e354 = x[((idx * 3u) + 1u)];
    let _e361 = x[((idx * 3u) + 1u)];
    let _e369 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e295, select(_e302, mix(_e309, _e316, _e319), ((_e327 == _e334) && (abs(_e342) < 340000000000000000000000000000000000000f))), ((_e354 == _e361) && (abs(_e369) < 340000000000000000000000000000000000000f)));
    let _e387 = state[((idx * 8u) + 2u)];
    let _e394 = x[((idx * 3u) + 2u)];
    let _e401 = state[((idx * 8u) + 2u)];
    let _e408 = x[((idx * 3u) + 2u)];
    let _e411 = constants.alpha_p;
    let _e419 = state[((idx * 8u) + 2u)];
    let _e426 = state[((idx * 8u) + 2u)];
    let _e434 = state[((idx * 8u) + 2u)];
    let _e446 = x[((idx * 3u) + 2u)];
    let _e453 = x[((idx * 3u) + 2u)];
    let _e461 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e387, select(_e394, mix(_e401, _e408, _e411), ((_e419 == _e426) && (abs(_e434) < 340000000000000000000000000000000000000f))), ((_e446 == _e453) && (abs(_e461) < 340000000000000000000000000000000000000f)));
    let _e479 = state[((idx * 8u) + 2u)];
    let _e486 = x[((idx * 3u) + 2u)];
    let _e493 = state[((idx * 8u) + 2u)];
    let _e500 = x[((idx * 3u) + 2u)];
    let _e503 = constants.alpha_p;
    let _e511 = state[((idx * 8u) + 2u)];
    let _e518 = state[((idx * 8u) + 2u)];
    let _e526 = state[((idx * 8u) + 2u)];
    let _e538 = x[((idx * 3u) + 2u)];
    let _e545 = x[((idx * 3u) + 2u)];
    let _e553 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e479, select(_e486, mix(_e493, _e500, _e503), ((_e511 == _e518) && (abs(_e526) < 340000000000000000000000000000000000000f))), ((_e538 == _e545) && (abs(_e553) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod generic_coupled_update_incompressible_momentum_generic {
        use super::{_root, _root::*};
        #[repr(C, align(4))]
        #[derive(Debug, PartialEq, Clone, Copy)]
        pub struct Constants {
            #[doc = "offset: 0, size: 4, type: `f32`"]
            pub dt: f32,
            #[doc = "offset: 4, size: 4, type: `f32`"]
            pub dt_old: f32,
            #[doc = "offset: 8, size: 4, type: `f32`"]
            pub dtau: f32,
            #[doc = "offset: 12, size: 4, type: `f32`"]
            pub time: f32,
            #[doc = "offset: 16, size: 4, type: `f32`"]
            pub viscosity: f32,
            #[doc = "offset: 20, size: 4, type: `f32`"]
            pub density: f32,
            #[doc = "offset: 24, size: 4, type: `u32`"]
            pub component: u32,
            #[doc = "offset: 28, size: 4, type: `f32`"]
            pub alpha_p: f32,
            #[doc = "offset: 32, size: 4, type: `u32`"]
            pub scheme: u32,
            #[doc = "offset: 36, size: 4, type: `f32`"]
            pub alpha_u: f32,
            #[doc = "offset: 40, size: 4, type: `u32`"]
            pub stride_x: u32,
            #[doc = "offset: 44, size: 4, type: `u32`"]
            pub time_scheme: u32,
            #[doc = "offset: 48, size: 4, type: `f32`"]
            pub eos_gamma: f32,
            #[doc = "offset: 52, size: 4, type: `f32`"]
            pub eos_gm1: f32,
            #[doc = "offset: 56, size: 4, type: `f32`"]
            pub eos_r: f32,
            #[doc = "offset: 60, size: 4, type: `f32`"]
            pub eos_dp_drho: f32,
            #[doc = "offset: 64, size: 4, type: `f32`"]
            pub eos_p_offset: f32,
            #[doc = "offset: 68, size: 4, type: `f32`"]
            pub eos_theta_ref: f32,
        }
        impl Constants {
            pub const fn new(
                dt: f32,
                dt_old: f32,
                dtau: f32,
                time: f32,
                viscosity: f32,
                density: f32,
                component: u32,
                alpha_p: f32,
                scheme: u32,
                alpha_u: f32,
                stride_x: u32,
                time_scheme: u32,
                eos_gamma: f32,
                eos_gm1: f32,
                eos_r: f32,
                eos_dp_drho: f32,
                eos_p_offset: f32,
                eos_theta_ref: f32,
            ) -> Self {
                Self {
                    dt,
                    dt_old,
                    dtau,
                    time,
                    viscosity,
                    density,
                    component,
                    alpha_p,
                    scheme,
                    alpha_u,
                    stride_x,
                    time_scheme,
                    eos_gamma,
                    eos_gm1,
                    eos_r,
                    eos_dp_drho,
                    eos_p_offset,
                    eos_theta_ref,
                }
            }
        }
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
            pub constants: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
            pub constants: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                    constants: wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(params.constants),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
                [self.state, self.constants]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , } , # [doc = " @binding(1): \"constants\""] wgpu :: BindGroupLayoutEntry { binding : 1 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Uniform , has_dynamic_offset : false , min_binding_size : std :: num :: NonZeroU64 :: new (std :: mem :: size_of :: < _root :: generated :: generic_coupled_update_incompressible_momentum_generic :: Constants > () as _) , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1EntriesParams<'a> {
            pub x: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup1Entries<'a> {
            pub x: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup1Entries<'a> {
            pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
                Self {
                    x: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.x),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.x]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup1(wgpu::BindGroup);
        impl WgpuBindGroup1 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric::BindGroup1::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"x\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric::BindGroup1",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(1, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
            pub bind_group1: &'a WgpuBindGroup1,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
                self.bind_group1.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 2],
            ) -> [wgpu::BindGroupLayout; 2] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedGenericCoupledUpdateIncompressibleMomentumGeneric::PipelineLayout",
                ),
                bind_group_layouts: &[
                    &WgpuBindGroup0::get_bind_group_layout(device),
                    &WgpuBindGroup1::get_bind_group_layout(device),
                ],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("generic_coupled_update_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
struct Vector2_ {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1_: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(1) 
var<uniform> constants: Constants;
@group(1) @binding(0) 
var<storage, read_write> x: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let _e19 = state[((idx * 8u) + 0u)];
    let _e26 = x[((idx * 3u) + 0u)];
    let _e33 = state[((idx * 8u) + 0u)];
    let _e40 = x[((idx * 3u) + 0u)];
    let _e43 = constants.alpha_u;
    let _e51 = state[((idx * 8u) + 0u)];
    let _e58 = state[((idx * 8u) + 0u)];
    let _e66 = state[((idx * 8u) + 0u)];
    let _e78 = x[((idx * 3u) + 0u)];
    let _e85 = x[((idx * 3u) + 0u)];
    let _e93 = x[((idx * 3u) + 0u)];
    state[((idx * 8u) + 0u)] = select(_e19, select(_e26, mix(_e33, _e40, _e43), ((_e51 == _e58) && (abs(_e66) < 340000000000000000000000000000000000000f))), ((_e78 == _e85) && (abs(_e93) < 340000000000000000000000000000000000000f)));
    let _e111 = state[((idx * 8u) + 0u)];
    let _e118 = x[((idx * 3u) + 0u)];
    let _e125 = state[((idx * 8u) + 0u)];
    let _e132 = x[((idx * 3u) + 0u)];
    let _e135 = constants.alpha_u;
    let _e143 = state[((idx * 8u) + 0u)];
    let _e150 = state[((idx * 8u) + 0u)];
    let _e158 = state[((idx * 8u) + 0u)];
    let _e170 = x[((idx * 3u) + 0u)];
    let _e177 = x[((idx * 3u) + 0u)];
    let _e185 = x[((idx * 3u) + 0u)];
    x[((idx * 3u) + 0u)] = select(_e111, select(_e118, mix(_e125, _e132, _e135), ((_e143 == _e150) && (abs(_e158) < 340000000000000000000000000000000000000f))), ((_e170 == _e177) && (abs(_e185) < 340000000000000000000000000000000000000f)));
    let _e203 = state[((idx * 8u) + 1u)];
    let _e210 = x[((idx * 3u) + 1u)];
    let _e217 = state[((idx * 8u) + 1u)];
    let _e224 = x[((idx * 3u) + 1u)];
    let _e227 = constants.alpha_u;
    let _e235 = state[((idx * 8u) + 1u)];
    let _e242 = state[((idx * 8u) + 1u)];
    let _e250 = state[((idx * 8u) + 1u)];
    let _e262 = x[((idx * 3u) + 1u)];
    let _e269 = x[((idx * 3u) + 1u)];
    let _e277 = x[((idx * 3u) + 1u)];
    state[((idx * 8u) + 1u)] = select(_e203, select(_e210, mix(_e217, _e224, _e227), ((_e235 == _e242) && (abs(_e250) < 340000000000000000000000000000000000000f))), ((_e262 == _e269) && (abs(_e277) < 340000000000000000000000000000000000000f)));
    let _e295 = state[((idx * 8u) + 1u)];
    let _e302 = x[((idx * 3u) + 1u)];
    let _e309 = state[((idx * 8u) + 1u)];
    let _e316 = x[((idx * 3u) + 1u)];
    let _e319 = constants.alpha_u;
    let _e327 = state[((idx * 8u) + 1u)];
    let _e334 = state[((idx * 8u) + 1u)];
    let _e342 = state[((idx * 8u) + 1u)];
    let _e354 = x[((idx * 3u) + 1u)];
    let _e361 = x[((idx * 3u) + 1u)];
    let _e369 = x[((idx * 3u) + 1u)];
    x[((idx * 3u) + 1u)] = select(_e295, select(_e302, mix(_e309, _e316, _e319), ((_e327 == _e334) && (abs(_e342) < 340000000000000000000000000000000000000f))), ((_e354 == _e361) && (abs(_e369) < 340000000000000000000000000000000000000f)));
    let _e387 = state[((idx * 8u) + 2u)];
    let _e394 = x[((idx * 3u) + 2u)];
    let _e401 = state[((idx * 8u) + 2u)];
    let _e408 = x[((idx * 3u) + 2u)];
    let _e411 = constants.alpha_p;
    let _e419 = state[((idx * 8u) + 2u)];
    let _e426 = state[((idx * 8u) + 2u)];
    let _e434 = state[((idx * 8u) + 2u)];
    let _e446 = x[((idx * 3u) + 2u)];
    let _e453 = x[((idx * 3u) + 2u)];
    let _e461 = x[((idx * 3u) + 2u)];
    state[((idx * 8u) + 2u)] = select(_e387, select(_e394, mix(_e401, _e408, _e411), ((_e419 == _e426) && (abs(_e434) < 340000000000000000000000000000000000000f))), ((_e446 == _e453) && (abs(_e461) < 340000000000000000000000000000000000000f)));
    let _e479 = state[((idx * 8u) + 2u)];
    let _e486 = x[((idx * 3u) + 2u)];
    let _e493 = state[((idx * 8u) + 2u)];
    let _e500 = x[((idx * 3u) + 2u)];
    let _e503 = constants.alpha_p;
    let _e511 = state[((idx * 8u) + 2u)];
    let _e518 = state[((idx * 8u) + 2u)];
    let _e526 = state[((idx * 8u) + 2u)];
    let _e538 = x[((idx * 3u) + 2u)];
    let _e545 = x[((idx * 3u) + 2u)];
    let _e553 = x[((idx * 3u) + 2u)];
    x[((idx * 3u) + 2u)] = select(_e479, select(_e486, mix(_e493, _e500, _e503), ((_e511 == _e518) && (abs(_e526) < 340000000000000000000000000000000000000f))), ((_e538 == _e545) && (abs(_e553) < 340000000000000000000000000000000000000f)));
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_incompressible_momentum {
        use super::{_root, _root::*};
        pub const STATE_STRIDE: u32 = 8u32;
        pub const U_X_OFFSET: u32 = 0u32;
        pub const U_Y_OFFSET: u32 = 1u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const GRAD_P_X_OFFSET: u32 = 4u32;
        pub const GRAD_P_Y_OFFSET: u32 = 5u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityIncompressibleMomentum::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityIncompressibleMomentum::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityIncompressibleMomentum::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_incompressible_momentum.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
const STATE_STRIDE: u32 = 8u;
const U_X_OFFSET: u32 = 0u;
const U_Y_OFFSET: u32 = 1u;
const D_P_OFFSET: u32 = 3u;
const GRAD_P_X_OFFSET: u32 = 4u;
const GRAD_P_Y_OFFSET: u32 = 5u;

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * STATE_STRIDE);
    let d_p = state[(base + D_P_OFFSET)];
    let grad_px = state[(base + GRAD_P_X_OFFSET)];
    let grad_py = state[(base + GRAD_P_Y_OFFSET)];
    let _e32 = state[(base + U_X_OFFSET)];
    state[(base + U_X_OFFSET)] = (_e32 - (d_p * grad_px));
    let _e43 = state[(base + U_Y_OFFSET)];
    state[(base + U_Y_OFFSET)] = (_e43 - (d_p * grad_py));
    return;
}
"#;
    }
    pub mod rhie_chow_correct_velocity_incompressible_momentum_generic {
        use super::{_root, _root::*};
        pub const STATE_STRIDE: u32 = 8u32;
        pub const U_X_OFFSET: u32 = 0u32;
        pub const U_Y_OFFSET: u32 = 1u32;
        pub const D_P_OFFSET: u32 = 3u32;
        pub const GRAD_P_X_OFFSET: u32 = 4u32;
        pub const GRAD_P_Y_OFFSET: u32 = 5u32;
        pub mod compute {
            use super::{_root, _root::*};
            pub const MAIN_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
            pub fn create_main_pipeline_embed_source(
                device: &wgpu::Device,
            ) -> wgpu::ComputePipeline {
                let module = super::create_shader_module_embed_source(device);
                let layout = super::create_pipeline_layout(device);
                device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    label: Some("Compute Pipeline main"),
                    layout: Some(&layout),
                    module: &module,
                    entry_point: Some("main"),
                    compilation_options: Default::default(),
                    cache: None,
                })
            }
        }
        pub const ENTRY_MAIN: &str = "main";
        #[derive(Debug)]
        pub struct WgpuBindGroup0EntriesParams<'a> {
            pub state: wgpu::BufferBinding<'a>,
        }
        #[derive(Clone, Debug)]
        pub struct WgpuBindGroup0Entries<'a> {
            pub state: wgpu::BindGroupEntry<'a>,
        }
        impl<'a> WgpuBindGroup0Entries<'a> {
            pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
                Self {
                    state: wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(params.state),
                    },
                }
            }
            pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
                [self.state]
            }
            pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
                self.into_array().into_iter().collect()
            }
        }
        #[derive(Debug)]
        pub struct WgpuBindGroup0(wgpu::BindGroup);
        impl WgpuBindGroup0 {
            pub const LAYOUT_DESCRIPTOR : wgpu :: BindGroupLayoutDescriptor < 'static > = wgpu :: BindGroupLayoutDescriptor { label : Some ("GeneratedRhieChowCorrectVelocityIncompressibleMomentumGeneric::BindGroup0::LayoutDescriptor") , entries : & [# [doc = " @binding(0): \"state\""] wgpu :: BindGroupLayoutEntry { binding : 0 , visibility : wgpu :: ShaderStages :: COMPUTE , ty : wgpu :: BindingType :: Buffer { ty : wgpu :: BufferBindingType :: Storage { read_only : false } , has_dynamic_offset : false , min_binding_size : None , } , count : None , }] , } ;
            pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
                device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
            }
            pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
                let bind_group_layout = Self::get_bind_group_layout(device);
                let entries = bindings.into_array();
                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some(
                        "GeneratedRhieChowCorrectVelocityIncompressibleMomentumGeneric::BindGroup0",
                    ),
                    layout: &bind_group_layout,
                    entries: &entries,
                });
                Self(bind_group)
            }
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                pass.set_bind_group(0, &self.0, &[]);
            }
        }
        #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
        #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
        #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
        #[doc = "   - Bind group 1: More frequent updates"]
        #[doc = "   - Bind group 2: More frequent updates"]
        #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
        #[derive(Debug, Copy, Clone)]
        pub struct WgpuBindGroups<'a> {
            pub bind_group0: &'a WgpuBindGroup0,
        }
        impl<'a> WgpuBindGroups<'a> {
            pub fn set(&self, pass: &mut impl SetBindGroup) {
                self.bind_group0.set(pass);
            }
        }
        #[derive(Debug)]
        pub struct WgpuPipelineLayout;
        impl WgpuPipelineLayout {
            pub fn bind_group_layout_entries(
                entries: [wgpu::BindGroupLayout; 1],
            ) -> [wgpu::BindGroupLayout; 1] {
                entries
            }
        }
        pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(
                    "GeneratedRhieChowCorrectVelocityIncompressibleMomentumGeneric::PipelineLayout",
                ),
                bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
                push_constant_ranges: &[],
            })
        }
        pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
            let source = std::borrow::Cow::Borrowed(SHADER_STRING);
            device.create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("rhie_chow_correct_velocity_incompressible_momentum_generic.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
        }
        pub const SHADER_STRING: &str = r#"
const STATE_STRIDE: u32 = 8u;
const U_X_OFFSET: u32 = 0u;
const U_Y_OFFSET: u32 = 1u;
const D_P_OFFSET: u32 = 3u;
const GRAD_P_X_OFFSET: u32 = 4u;
const GRAD_P_Y_OFFSET: u32 = 5u;

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;

@compute @workgroup_size(64, 1, 1) 
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = (arrayLength((&state)) / 8u);
    if (idx >= num_cells) {
        return;
    }
    let base = (idx * STATE_STRIDE);
    let d_p = state[(base + D_P_OFFSET)];
    let grad_px = state[(base + GRAD_P_X_OFFSET)];
    let grad_py = state[(base + GRAD_P_Y_OFFSET)];
    let _e32 = state[(base + U_X_OFFSET)];
    state[(base + U_X_OFFSET)] = (_e32 - (d_p * grad_px));
    let _e43 = state[(base + U_Y_OFFSET)];
    state[(base + U_Y_OFFSET)] = (_e43 - (d_p * grad_py));
    return;
}
"#;
    }
}
pub mod generic_coupled_schur_setup {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub state_stride: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub d_p_offset: u32,
        pub _pad_d_p_offset: [u8; 0x4],
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl SetupParams {
        pub const fn new(
            dispatch_x: u32,
            num_cells: u32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            state_stride: u32,
            d_p_offset: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                dispatch_x,
                num_cells,
                unknowns_per_cell,
                p,
                u_len,
                state_stride,
                d_p_offset,
                _pad_d_p_offset: [0; 0x4],
                u0123,
                u4567,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SetupParamsInit {
        pub dispatch_x: u32,
        pub num_cells: u32,
        pub unknowns_per_cell: u32,
        pub p: u32,
        pub u_len: u32,
        pub state_stride: u32,
        pub d_p_offset: u32,
        pub u0123: [u32; 4],
        pub u4567: [u32; 4],
    }
    impl SetupParamsInit {
        pub fn build(&self) -> SetupParams {
            SetupParams {
                dispatch_x: self.dispatch_x,
                num_cells: self.num_cells,
                unknowns_per_cell: self.unknowns_per_cell,
                p: self.p,
                u_len: self.u_len,
                state_stride: self.state_stride,
                d_p_offset: self.d_p_offset,
                _pad_d_p_offset: [0; 0x4],
                u0123: self.u0123,
                u4567: self.u4567,
            }
        }
    }
    impl From<SetupParamsInit> for SetupParams {
        fn from(data: SetupParamsInit) -> Self {
            data.build()
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_DIAG_AND_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_diag_and_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_diag_and_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_diag_and_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_DIAG_AND_PRESSURE: &str = "build_diag_and_pressure";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalar_row_offsets: wgpu::BufferBinding<'a>,
        pub diagonal_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
        pub state: wgpu::BufferBinding<'a>,
        pub cell_vols: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalar_row_offsets: wgpu::BindGroupEntry<'a>,
        pub diagonal_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
        pub state: wgpu::BindGroupEntry<'a>,
        pub cell_vols: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalar_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalar_row_offsets),
                },
                diagonal_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diagonal_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
                state: wgpu::BindGroupEntry {
                    binding: 7,
                    resource: wgpu::BindingResource::Buffer(params.state),
                },
                cell_vols: wgpu::BindGroupEntry {
                    binding: 8,
                    resource: wgpu::BindingResource::Buffer(params.cell_vols),
                },
                params: wgpu::BindGroupEntry {
                    binding: 6,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 9] {
            [
                self.scalar_row_offsets,
                self.diagonal_indices,
                self.matrix_values,
                self.diag_u_inv,
                self.diag_p_inv,
                self.p_matrix_values,
                self.state,
                self.cell_vols,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalar_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diagonal_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(7): \"state\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 7,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(8): \"cell_vols\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 8,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(6): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 6,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::generic_coupled_schur_setup::SetupParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GenericCoupledSchurSetup::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GenericCoupledSchurSetup::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("generic_coupled_schur_setup.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct SetupParams {
    dispatch_x: u32,
    num_cells: u32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    state_stride: u32,
    d_p_offset: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> scalar_row_offsets: array<u32>;
@group(0) @binding(1) 
var<storage> diagonal_indices: array<u32>;
@group(0) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> p_matrix_values: array<f32>;
@group(0) @binding(7) 
var<storage, read_write> state: array<f32>;
@group(0) @binding(8) 
var<storage> cell_vols: array<f32>;
@group(0) @binding(6) 
var<uniform> params: SetupParams;

fn u_index(i_1: u32) -> u32 {
    if (i_1 < 4u) {
        let _e6 = params.u0123_[i_1];
        return _e6;
    }
    let _e12 = params.u4567_[(i_1 - 4u)];
    return _e12;
}

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_diag_and_pressure(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum_u_inv: f32 = 0f;
    var i: u32 = 0u;
    var d_p: f32 = 0f;
    var rank: u32 = 0u;

    let _e6 = params.dispatch_x;
    let cell = ((global_id.y * _e6) + global_id.x);
    let _e12 = params.num_cells;
    if (cell >= _e12) {
        return;
    }
    let cell_vol = cell_vols[cell];
    let scalar_offset = scalar_row_offsets[cell];
    let scalar_end = scalar_row_offsets[(cell + 1u)];
    let num_neighbors = (scalar_end - scalar_offset);
    let _e28 = diagonal_indices[cell];
    let diag_rank = (_e28 - scalar_offset);
    let _e32 = params.unknowns_per_cell;
    let _e35 = params.unknowns_per_cell;
    let block_stride = (_e32 * _e35);
    let start_row_0_ = (scalar_offset * block_stride);
    let _e40 = params.unknowns_per_cell;
    let row_stride = (num_neighbors * _e40);
    let _e44 = params.p;
    let start_row_p = (start_row_0_ + (_e44 * row_stride));
    let _e49 = params.unknowns_per_cell;
    let _e55 = params.p;
    let diag_p = matrix_values[((start_row_p + (diag_rank * _e49)) + _e55)];
    loop {
        let _e60 = i;
        let _e63 = params.u_len;
        if (_e60 < _e63) {
        } else {
            break;
        }
        {
            let _e65 = i;
            let _e66 = u_index(_e65);
            let start_row_u = (start_row_0_ + (_e66 * row_stride));
            let _e72 = params.unknowns_per_cell;
            let diag_u = matrix_values[((start_row_u + (diag_rank * _e72)) + _e66)];
            let _e78 = safe_inverse(diag_u);
            let _e82 = params.u_len;
            let _e84 = i;
            diag_u_inv[((cell * _e82) + _e84)] = _e78;
            let _e88 = sum_u_inv;
            sum_u_inv = (_e88 + _e78);
        }
        continuing {
            let _e91 = i;
            i = (_e91 + 1u);
        }
    }
    let _e95 = safe_inverse(diag_p);
    diag_p_inv[cell] = _e95;
    let _e98 = params.d_p_offset;
    let _e103 = params.state_stride;
    if ((_e98 != 4294967295u) && (_e103 > 0u)) {
        let _e109 = params.u_len;
        if (_e109 > 0u) {
            let _e112 = sum_u_inv;
            let _e115 = params.u_len;
            d_p = (_e112 / f32(_e115));
        }
        let _e121 = params.state_stride;
        let _e126 = params.d_p_offset;
        let _e129 = d_p;
        state[((cell * _e121) + _e126)] = _e129;
    }
    loop {
        let _e131 = rank;
        if (_e131 < num_neighbors) {
        } else {
            break;
        }
        {
            let _e134 = rank;
            let _e137 = rank;
            let _e140 = params.unknowns_per_cell;
            let _e146 = params.p;
            let _e149 = matrix_values[((start_row_p + (_e137 * _e140)) + _e146)];
            p_matrix_values[(scalar_offset + _e134)] = _e149;
        }
        continuing {
            let _e151 = rank;
            rank = (_e151 + 1u);
        }
    }
    return;
}
"#;
}
pub mod gmres_cgs {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct Params {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub column_offset: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub pad3: u32,
    }
    impl Params {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            max_restart: u32,
            column_offset: u32,
            pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                max_restart,
                column_offset,
                pad3,
            }
        }
    }
    pub const WORKGROUP_SIZE: u32 = 64u32;
    pub mod compute {
        use super::{_root, _root::*};
        pub const CALC_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_calc_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline calc_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("calc_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_DOTS_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_dots_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_dots_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_dots_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_W_CGS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_update_w_cgs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_w_cgs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_w_cgs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_CALC_DOTS_CGS: &str = "calc_dots_cgs";
    pub const ENTRY_REDUCE_DOTS_CGS: &str = "reduce_dots_cgs";
    pub const ENTRY_UPDATE_W_CGS: &str = "update_w_cgs";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub b_basis: wgpu::BufferBinding<'a>,
        pub b_w: wgpu::BufferBinding<'a>,
        pub b_dot_partial: wgpu::BufferBinding<'a>,
        pub b_hessenberg: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub b_basis: wgpu::BindGroupEntry<'a>,
        pub b_w: wgpu::BindGroupEntry<'a>,
        pub b_dot_partial: wgpu::BindGroupEntry<'a>,
        pub b_hessenberg: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                b_basis: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.b_basis),
                },
                b_w: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.b_w),
                },
                b_dot_partial: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.b_dot_partial),
                },
                b_hessenberg: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.b_hessenberg),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.b_basis,
                self.b_w,
                self.b_dot_partial,
                self.b_hessenberg,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresCgs::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_cgs::Params,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"b_basis\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"b_w\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"b_dot_partial\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"b_hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresCgs::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresCgs::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_cgs.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct Params {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    max_restart: u32,
    column_offset: u32,
    pad3_: u32,
}

const WORKGROUP_SIZE: u32 = 64u;

@group(0) @binding(0) 
var<uniform> params: Params;
@group(0) @binding(1) 
var<storage> b_basis: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> b_w: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> b_dot_partial: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> b_hessenberg: array<f32>;
var<workgroup> sdata: array<f32, 64>;
var<workgroup> sdata_vec4_: array<vec4<f32>, 64>;

@compute @workgroup_size(64, 1, 1) 
fn calc_dots_cgs(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) group_id: vec3<u32>, @builtin(num_workgroups) num_groups: vec3<u32>) {
    var w_val: f32 = 0f;
    var i: u32 = 0u;
    var v: vec4<f32>;

    let idx = global_id.x;
    let j = params.num_iters;
    let n = params.n;
    let stride_bytes = (((n * 4u) + 255u) & 4294967040u);
    let stride_words = (stride_bytes / 4u);
    if (idx < n) {
        let _e21 = b_w[idx];
        w_val = _e21;
    }
    loop {
        let _e24 = i;
        if (_e24 <= j) {
        } else {
            break;
        }
        {
            v = vec4(0f);
            if (idx < n) {
                let _e30 = i;
                if (_e30 <= j) {
                    let _e34 = i;
                    let _e38 = b_basis[((_e34 * stride_words) + idx)];
                    v.x = _e38;
                }
                let _e39 = i;
                if ((_e39 + 1u) <= j) {
                    let _e44 = i;
                    let _e51 = b_basis[(((_e44 + 1u) * stride_words) + idx)];
                    v.y = _e51;
                }
                let _e52 = i;
                if ((_e52 + 2u) <= j) {
                    let _e57 = i;
                    let _e64 = b_basis[(((_e57 + 2u) * stride_words) + idx)];
                    v.z = _e64;
                }
                let _e65 = i;
                if ((_e65 + 3u) <= j) {
                    let _e70 = i;
                    let _e77 = b_basis[(((_e70 + 3u) * stride_words) + idx)];
                    v.w = _e77;
                }
            }
            let _e78 = v;
            let _e79 = w_val;
            let prod = (_e78 * _e79);
            sdata_vec4_[local_id.x] = prod;
            workgroupBarrier();
            if (local_id.x < 32u) {
                let _e96 = sdata_vec4_[(local_id.x + 32u)];
                let _e97 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e97 + _e96);
            }
            workgroupBarrier();
            if (local_id.x < 16u) {
                let _e110 = sdata_vec4_[(local_id.x + 16u)];
                let _e111 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e111 + _e110);
            }
            workgroupBarrier();
            if (local_id.x < 8u) {
                let _e124 = sdata_vec4_[(local_id.x + 8u)];
                let _e125 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e125 + _e124);
            }
            workgroupBarrier();
            if (local_id.x < 4u) {
                let _e138 = sdata_vec4_[(local_id.x + 4u)];
                let _e139 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e139 + _e138);
            }
            workgroupBarrier();
            if (local_id.x < 2u) {
                let _e152 = sdata_vec4_[(local_id.x + 2u)];
                let _e153 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e153 + _e152);
            }
            workgroupBarrier();
            if (local_id.x < 1u) {
                let _e166 = sdata_vec4_[(local_id.x + 1u)];
                let _e167 = sdata_vec4_[local_id.x];
                sdata_vec4_[local_id.x] = (_e167 + _e166);
                let sum_1 = sdata_vec4_[0];
                let _e172 = i;
                if (_e172 <= j) {
                    let _e177 = i;
                    b_dot_partial[((_e177 * num_groups.x) + group_id.x)] = sum_1.x;
                }
                let _e184 = i;
                if ((_e184 + 1u) <= j) {
                    let _e188 = i;
                    b_dot_partial[(((_e188 + 1u) * num_groups.x) + group_id.x)] = sum_1.y;
                }
                let _e198 = i;
                if ((_e198 + 2u) <= j) {
                    let _e202 = i;
                    b_dot_partial[(((_e202 + 2u) * num_groups.x) + group_id.x)] = sum_1.z;
                }
                let _e212 = i;
                if ((_e212 + 3u) <= j) {
                    let _e216 = i;
                    b_dot_partial[(((_e216 + 3u) * num_groups.x) + group_id.x)] = sum_1.w;
                }
            }
            workgroupBarrier();
        }
        continuing {
            let _e227 = i;
            i = (_e227 + 4u);
        }
    }
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_dots_cgs(@builtin(global_invocation_id) global_id_1: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) group_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let i_2 = group_id_1.x;
    let j_1 = params.num_iters;
    let _e8 = params.n;
    let num_groups_n = ((_e8 + 63u) / 64u);
    k = local_id_1.x;
    loop {
        let _e16 = k;
        if (_e16 < num_groups_n) {
        } else {
            break;
        }
        {
            let _e21 = k;
            let _e24 = b_dot_partial[((i_2 * num_groups_n) + _e21)];
            let _e25 = sum;
            sum = (_e25 + _e24);
        }
        continuing {
            let _e28 = k;
            k = (_e28 + 64u);
        }
    }
    let _e33 = sum;
    sdata[local_id_1.x] = _e33;
    workgroupBarrier();
    if (local_id_1.x < 32u) {
        let _e45 = sdata[(local_id_1.x + 32u)];
        let _e46 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e46 + _e45);
    }
    workgroupBarrier();
    if (local_id_1.x < 16u) {
        let _e59 = sdata[(local_id_1.x + 16u)];
        let _e60 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e60 + _e59);
    }
    workgroupBarrier();
    if (local_id_1.x < 8u) {
        let _e73 = sdata[(local_id_1.x + 8u)];
        let _e74 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e74 + _e73);
    }
    workgroupBarrier();
    if (local_id_1.x < 4u) {
        let _e87 = sdata[(local_id_1.x + 4u)];
        let _e88 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e88 + _e87);
    }
    workgroupBarrier();
    if (local_id_1.x < 2u) {
        let _e101 = sdata[(local_id_1.x + 2u)];
        let _e102 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e102 + _e101);
    }
    workgroupBarrier();
    if (local_id_1.x < 1u) {
        let _e115 = sdata[(local_id_1.x + 1u)];
        let _e116 = sdata[local_id_1.x];
        sdata[local_id_1.x] = (_e116 + _e115);
        let max_restart = params.max_restart;
        let h_idx = ((j_1 * (max_restart + 1u)) + i_2);
        let _e129 = sdata[0];
        b_hessenberg[h_idx] = _e129;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn update_w_cgs(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var correction: f32 = 0f;
    var i_1: u32 = 0u;

    let idx_1 = global_id_2.x;
    let j_2 = params.num_iters;
    let n_1 = params.n;
    let max_restart_1 = params.max_restart;
    let stride_bytes_1 = (((n_1 * 4u) + 255u) & 4294967040u);
    let stride_words_1 = (stride_bytes_1 / 4u);
    if (idx_1 >= n_1) {
        return;
    }
    loop {
        let _e23 = i_1;
        if (_e23 <= j_2) {
        } else {
            break;
        }
        {
            let _e25 = i_1;
            if (_e25 <= j_2) {
                let _e31 = i_1;
                let h_val = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + _e31)];
                let _e36 = i_1;
                let v_val = b_basis[((_e36 * stride_words_1) + idx_1)];
                let _e43 = correction;
                correction = (_e43 + (h_val * v_val));
            }
            let _e45 = i_1;
            if ((_e45 + 1u) <= j_2) {
                let _e52 = i_1;
                let h_val_1 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e52 + 1u))];
                let _e59 = i_1;
                let v_val_1 = b_basis[(((_e59 + 1u) * stride_words_1) + idx_1)];
                let _e68 = correction;
                correction = (_e68 + (h_val_1 * v_val_1));
            }
            let _e70 = i_1;
            if ((_e70 + 2u) <= j_2) {
                let _e77 = i_1;
                let h_val_2 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e77 + 2u))];
                let _e84 = i_1;
                let v_val_2 = b_basis[(((_e84 + 2u) * stride_words_1) + idx_1)];
                let _e93 = correction;
                correction = (_e93 + (h_val_2 * v_val_2));
            }
            let _e95 = i_1;
            if ((_e95 + 3u) <= j_2) {
                let _e102 = i_1;
                let h_val_3 = b_hessenberg[((j_2 * (max_restart_1 + 1u)) + (_e102 + 3u))];
                let _e109 = i_1;
                let v_val_3 = b_basis[(((_e109 + 3u) * stride_words_1) + idx_1)];
                let _e118 = correction;
                correction = (_e118 + (h_val_3 * v_val_3));
            }
        }
        continuing {
            let _e121 = i_1;
            i_1 = (_e121 + 4u);
        }
    }
    let _e127 = b_w[idx_1];
    let _e128 = correction;
    b_w[idx_1] = (_e127 - _e128);
    return;
}
"#;
}
pub mod gmres_logic {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const UPDATE_HESSENBERG_GIVENS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_hessenberg_givens_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_hessenberg_givens"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_hessenberg_givens"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SOLVE_TRIANGULAR_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_solve_triangular_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline solve_triangular"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("solve_triangular"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_UPDATE_HESSENBERG_GIVENS: &str = "update_hessenberg_givens";
    pub const ENTRY_SOLVE_TRIANGULAR: &str = "solve_triangular";
    pub const ENTRY_FINISH_NORM: &str = "finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub givens: wgpu::BufferBinding<'a>,
        pub g_rhs: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub givens: wgpu::BindGroupEntry<'a>,
        pub g_rhs: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                hessenberg: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                givens: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.givens),
                },
                g_rhs: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.g_rhs),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [self.hessenberg, self.givens, self.g_rhs, self.y_sol]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"givens\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"g_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub iter_params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                iter_params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.iter_params, self.scalars]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresLogic::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_logic::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresLogic::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresLogic::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_logic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> hessenberg: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> givens: array<vec2<f32>>;
@group(0) @binding(2) 
var<storage, read_write> g_rhs: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> y_sol: array<f32>;
@group(1) @binding(0) 
var<uniform> iter_params: IterParams;
@group(1) @binding(1) 
var<storage, read_write> scalars: array<f32>;

fn h_idx(row: u32, col: u32) -> u32 {
    let _e2 = iter_params.max_restart;
    return ((col * (_e2 + 1u)) + row);
}

@compute @workgroup_size(1, 1, 1) 
fn update_hessenberg_givens(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var i: u32 = 0u;
    var c: f32 = 1f;
    var s: f32 = 0f;
    var rho: f32;

    let j_1 = iter_params.current_idx;
    loop {
        let _e7 = i;
        if (_e7 < j_1) {
        } else {
            break;
        }
        {
            let _e9 = i;
            let _e10 = h_idx(_e9, j_1);
            let _e11 = i;
            let _e14 = h_idx((_e11 + 1u), j_1);
            let h_ij = hessenberg[_e10];
            let h_i1j = hessenberg[_e14];
            let _e22 = i;
            let cs = givens[_e22];
            let c_1 = cs.x;
            let s_1 = cs.y;
            hessenberg[_e10] = ((c_1 * h_ij) + (s_1 * h_i1j));
            hessenberg[_e14] = ((-(s_1) * h_ij) + (c_1 * h_i1j));
        }
        continuing {
            let _e39 = i;
            i = (_e39 + 1u);
        }
    }
    let _e41 = h_idx(j_1, j_1);
    let _e44 = h_idx((j_1 + 1u), j_1);
    let h_jj = hessenberg[_e41];
    let h_j1j = hessenberg[_e44];
    rho = sqrt(((h_jj * h_jj) + (h_j1j * h_j1j)));
    let _e56 = rho;
    if (abs(_e56) > 0.00000000000000000001f) {
        let _e60 = rho;
        c = (h_jj / _e60);
        let _e63 = rho;
        s = (h_j1j / _e63);
    }
    let _e68 = c;
    let _e69 = s;
    givens[j_1] = vec2<f32>(_e68, _e69);
    let _e73 = rho;
    hessenberg[_e41] = _e73;
    hessenberg[_e44] = 0f;
    let g_j = g_rhs[j_1];
    let g_j1_ = g_rhs[(j_1 + 1u)];
    let _e87 = c;
    let _e89 = s;
    g_rhs[j_1] = ((_e87 * g_j) + (_e89 * g_j1_));
    let _e96 = s;
    let _e99 = c;
    g_rhs[(j_1 + 1u)] = ((-(_e96) * g_j) + (_e99 * g_j1_));
    let _e108 = g_rhs[(j_1 + 1u)];
    scalars[0] = abs(_e108);
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn solve_triangular(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var loop_i: u32 = 0u;
    var sum: f32;
    var j: u32;

    let k = iter_params.current_idx;
    loop {
        let _e5 = loop_i;
        if (_e5 < k) {
        } else {
            break;
        }
        {
            let _e9 = loop_i;
            let i_1 = ((k - 1u) - _e9);
            let _e13 = g_rhs[i_1];
            sum = _e13;
            j = (i_1 + 1u);
            loop {
                let _e18 = j;
                if (_e18 < k) {
                } else {
                    break;
                }
                {
                    let _e20 = j;
                    let _e21 = h_idx(i_1, _e20);
                    let _e24 = hessenberg[_e21];
                    let _e26 = j;
                    let _e28 = y_sol[_e26];
                    let _e30 = sum;
                    sum = (_e30 - (_e24 * _e28));
                }
                continuing {
                    let _e33 = j;
                    j = (_e33 + 1u);
                }
            }
            let _e35 = h_idx(i_1, i_1);
            let diag = hessenberg[_e35];
            if (abs(diag) > 0.000000000001f) {
                let _e44 = sum;
                y_sol[i_1] = (_e44 / diag);
            } else {
                y_sol[i_1] = 0f;
            }
        }
        continuing {
            let _e50 = loop_i;
            loop_i = (_e50 + 1u);
        }
    }
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn finish_norm(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let norm_sq = scalars[0];
    let norm = sqrt(norm_sq);
    let _e7 = iter_params.current_idx;
    hessenberg[_e7] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod gmres_ops {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GmresParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub num_iters: u32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub dispatch_x: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad2: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad3: u32,
    }
    impl GmresParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            num_iters: u32,
            omega: f32,
            dispatch_x: u32,
            _pad1: u32,
            _pad2: u32,
            _pad3: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                num_iters,
                omega,
                dispatch_x,
                _pad1,
                _pad2,
                _pad3,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct IterParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub current_idx: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub max_restart: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl IterParams {
        pub const fn new(current_idx: u32, max_restart: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                current_idx,
                max_restart,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPY_FROM_Y_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpy_from_y_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpy_from_y"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpy_from_y"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const AXPBY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_axpby_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline axpby"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("axpby"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SCALE_IN_PLACE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_scale_in_place_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline scale_in_place"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("scale_in_place"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const COPY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_copy_pipeline_embed_source(device: &wgpu::Device) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline copy"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("copy"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const DOT_PRODUCT_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_dot_product_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline dot_product_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("dot_product_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const NORM_SQ_PARTIAL_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_norm_sq_partial_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline norm_sq_partial"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("norm_sq_partial"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const ORTHOGONALIZE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_orthogonalize_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline orthogonalize"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("orthogonalize"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_FINAL_AND_FINISH_NORM_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_reduce_final_and_finish_norm_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_final_and_finish_norm"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_final_and_finish_norm"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV: &str = "spmv";
    pub const ENTRY_AXPY: &str = "axpy";
    pub const ENTRY_AXPY_FROM_Y: &str = "axpy_from_y";
    pub const ENTRY_AXPBY: &str = "axpby";
    pub const ENTRY_SCALE: &str = "scale";
    pub const ENTRY_SCALE_IN_PLACE: &str = "scale_in_place";
    pub const ENTRY_COPY: &str = "copy";
    pub const ENTRY_DOT_PRODUCT_PARTIAL: &str = "dot_product_partial";
    pub const ENTRY_NORM_SQ_PARTIAL: &str = "norm_sq_partial";
    pub const ENTRY_ORTHOGONALIZE: &str = "orthogonalize";
    pub const ENTRY_REDUCE_FINAL: &str = "reduce_final";
    pub const ENTRY_REDUCE_FINAL_AND_FINISH_NORM: &str = "reduce_final_and_finish_norm";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub vec_x: wgpu::BufferBinding<'a>,
        pub vec_y: wgpu::BufferBinding<'a>,
        pub vec_z: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub vec_x: wgpu::BindGroupEntry<'a>,
        pub vec_y: wgpu::BindGroupEntry<'a>,
        pub vec_z: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                vec_x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.vec_x),
                },
                vec_y: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.vec_y),
                },
                vec_z: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.vec_z),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.vec_x, self.vec_y, self.vec_z]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"vec_x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"vec_y\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"vec_z\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u: wgpu::BufferBinding<'a>,
        pub diag_v: wgpu::BufferBinding<'a>,
        pub diag_p: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u: wgpu::BindGroupEntry<'a>,
        pub diag_v: wgpu::BindGroupEntry<'a>,
        pub diag_p: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u),
                },
                diag_v: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v),
                },
                diag_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u, self.diag_v, self.diag_p]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub params: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub iter_params: wgpu::BufferBinding<'a>,
        pub hessenberg: wgpu::BufferBinding<'a>,
        pub y_sol: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub params: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub iter_params: wgpu::BindGroupEntry<'a>,
        pub hessenberg: wgpu::BindGroupEntry<'a>,
        pub y_sol: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                params: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                iter_params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.iter_params),
                },
                hessenberg: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.hessenberg),
                },
                y_sol: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.y_sol),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.params,
                self.scalars,
                self.iter_params,
                self.hessenberg,
                self.y_sol,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("GmresOps::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::GmresParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"iter_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::gmres_ops::IterParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"hessenberg\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"y_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("GmresOps::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("GmresOps::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("gmres_ops.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GmresParams {
    n: u32,
    num_cells: u32,
    num_iters: u32,
    omega: f32,
    dispatch_x: u32,
    _pad1_: u32,
    _pad2_: u32,
    _pad3_: u32,
}

struct IterParams {
    current_idx: u32,
    max_restart: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(3) @binding(0) 
var<uniform> params: GmresParams;
@group(0) @binding(0) 
var<storage> vec_x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> vec_y: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> vec_z: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p: array<f32>;
@group(3) @binding(1) 
var<storage, read_write> scalars: array<f32>;
@group(3) @binding(2) 
var<uniform> iter_params: IterParams;
@group(3) @binding(3) 
var<storage, read_write> hessenberg: array<f32>;
@group(3) @binding(4) 
var<storage> y_sol: array<f32>;
var<workgroup> partial_sums: array<f32, 64>;

fn get_global_index(global_id_12: vec3<u32>) -> u32 {
    let _e5 = params.dispatch_x;
    return (global_id_12.x + (global_id_12.y * _e5));
}

fn get_workgroup_index(wg_id_2: vec3<u32>) -> u32 {
    let _e2 = params.dispatch_x;
    let dispatch_wg_x = (_e2 / 64u);
    return (wg_id_2.x + (wg_id_2.y * dispatch_wg_x));
}

@compute @workgroup_size(64, 1, 1) 
fn spmv(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let _e2 = get_global_index(global_id);
    let _e5 = params.n;
    if (_e2 >= _e5) {
        return;
    }
    let start = row_offsets[_e2];
    let end = row_offsets[(_e2 + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col = col_indices[_e19];
            let _e23 = k;
            let val = matrix_values[_e23];
            let _e29 = vec_x[col];
            let _e31 = sum;
            sum = (_e31 + (val * _e29));
        }
        continuing {
            let _e34 = k;
            k = (_e34 + 1u);
        }
    }
    let _e38 = sum;
    vec_y[_e2] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    let _e1 = get_global_index(global_id_1);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha = scalars[0];
    let _e13 = vec_x[_e1];
    let _e17 = vec_y[_e1];
    vec_y[_e1] = ((alpha * _e13) + _e17);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpy_from_y(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    let _e1 = get_global_index(global_id_2);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let _e9 = iter_params.current_idx;
    let alpha_1 = y_sol[_e9];
    let _e16 = vec_x[_e1];
    let _e20 = vec_y[_e1];
    vec_y[_e1] = ((alpha_1 * _e16) + _e20);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn axpby(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    let _e1 = get_global_index(global_id_3);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha_2 = scalars[0];
    let beta = scalars[1];
    let _e16 = vec_x[_e1];
    let _e20 = vec_y[_e1];
    vec_z[_e1] = ((alpha_2 * _e16) + (beta * _e20));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale(@builtin(global_invocation_id) global_id_4: vec3<u32>) {
    let _e1 = get_global_index(global_id_4);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha_3 = scalars[0];
    let _e13 = vec_x[_e1];
    vec_y[_e1] = (alpha_3 * _e13);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn scale_in_place(@builtin(global_invocation_id) global_id_5: vec3<u32>) {
    let _e1 = get_global_index(global_id_5);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let alpha_4 = scalars[0];
    let _e13 = vec_y[_e1];
    vec_y[_e1] = (alpha_4 * _e13);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn copy(@builtin(global_invocation_id) global_id_6: vec3<u32>) {
    let _e1 = get_global_index(global_id_6);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let _e10 = vec_x[_e1];
    vec_y[_e1] = _e10;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn dot_product_partial(@builtin(global_invocation_id) global_id_7: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>, @builtin(workgroup_id) wg_id: vec3<u32>) {
    var local_sum: f32 = 0f;
    var stride: u32 = 32u;

    let _e3 = get_global_index(global_id_7);
    let lid = local_id.x;
    let _e7 = get_workgroup_index(wg_id);
    let _e10 = params.n;
    if (_e3 < _e10) {
        let _e14 = vec_x[_e3];
        let _e17 = vec_y[_e3];
        local_sum = (_e14 * _e17);
    }
    let _e22 = local_sum;
    partial_sums[lid] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = stride;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = stride;
            if (lid < _e27) {
                let _e32 = stride;
                let _e35 = partial_sums[(lid + _e32)];
                let _e36 = partial_sums[lid];
                partial_sums[lid] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = stride;
            stride = (_e39 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e47 = partial_sums[0];
        vec_z[_e7] = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn norm_sq_partial(@builtin(global_invocation_id) global_id_8: vec3<u32>, @builtin(local_invocation_id) local_id_1: vec3<u32>, @builtin(workgroup_id) wg_id_1: vec3<u32>) {
    var local_sum_1: f32 = 0f;
    var stride_1: u32 = 32u;

    let _e3 = get_global_index(global_id_8);
    let lid_1 = local_id_1.x;
    let _e7 = get_workgroup_index(wg_id_1);
    let _e10 = params.n;
    if (_e3 < _e10) {
        let val_1 = vec_x[_e3];
        local_sum_1 = (val_1 * val_1);
    }
    let _e19 = local_sum_1;
    partial_sums[lid_1] = _e19;
    workgroupBarrier();
    loop {
        let _e21 = stride_1;
        if (_e21 > 0u) {
        } else {
            break;
        }
        {
            let _e24 = stride_1;
            if (lid_1 < _e24) {
                let _e29 = stride_1;
                let _e32 = partial_sums[(lid_1 + _e29)];
                let _e33 = partial_sums[lid_1];
                partial_sums[lid_1] = (_e33 + _e32);
            }
            workgroupBarrier();
        }
        continuing {
            let _e36 = stride_1;
            stride_1 = (_e36 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e44 = partial_sums[0];
        vec_z[_e7] = _e44;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn orthogonalize(@builtin(global_invocation_id) global_id_9: vec3<u32>) {
    let _e1 = get_global_index(global_id_9);
    let _e4 = params.n;
    if (_e1 >= _e4) {
        return;
    }
    let h = scalars[0];
    let _e13 = vec_y[_e1];
    let _e16 = vec_x[_e1];
    vec_y[_e1] = (_e13 - (h * _e16));
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final(@builtin(global_invocation_id) global_id_10: vec3<u32>) {
    var total_sum: f32 = 0f;
    var i: u32 = 0u;

    let num_partials = params.n;
    loop {
        let _e6 = i;
        if (_e6 < num_partials) {
        } else {
            break;
        }
        {
            let _e10 = i;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum;
            total_sum = (_e13 + _e12);
        }
        continuing {
            let _e16 = i;
            i = (_e16 + 1u);
        }
    }
    let _e20 = total_sum;
    scalars[0] = _e20;
    let _e24 = iter_params.current_idx;
    let _e26 = total_sum;
    hessenberg[_e24] = _e26;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn reduce_final_and_finish_norm(@builtin(global_invocation_id) global_id_11: vec3<u32>) {
    var total_sum_1: f32 = 0f;
    var i_1: u32 = 0u;

    let num_partials_1 = params.n;
    loop {
        let _e6 = i_1;
        if (_e6 < num_partials_1) {
        } else {
            break;
        }
        {
            let _e10 = i_1;
            let _e12 = vec_x[_e10];
            let _e13 = total_sum_1;
            total_sum_1 = (_e13 + _e12);
        }
        continuing {
            let _e16 = i_1;
            i_1 = (_e16 + 1u);
        }
    }
    let _e18 = total_sum_1;
    let norm = sqrt(_e18);
    let _e23 = iter_params.current_idx;
    hessenberg[_e23] = norm;
    if (norm > 0.00000000000000000001f) {
        scalars[0] = (1f / norm);
        return;
    } else {
        scalars[0] = 0f;
        return;
    }
}
"#;
}
pub mod linear_solver {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 24, size: 4, type: `f32`"]
        pub t_s: f32,
        #[doc = "offset: 28, size: 4, type: `f32`"]
        pub t_t: f32,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            omega: f32,
            r0_v: f32,
            t_s: f32,
            t_t: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                omega,
                r0_v,
                t_s,
                t_t,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const SPMV_P_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_p_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_p_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_p_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SPMV_S_T_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_s_t_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_s_t"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_s_t"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const BICGSTAB_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_bicgstab_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline bicgstab_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("bicgstab_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const BICGSTAB_UPDATE_S_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_bicgstab_update_s_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline bicgstab_update_s"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("bicgstab_update_s"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const BICGSTAB_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_bicgstab_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline bicgstab_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("bicgstab_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_X_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_x_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_x_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_x_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CG_UPDATE_P_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_cg_update_p_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline cg_update_p"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("cg_update_p"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_SPMV_P_V: &str = "spmv_p_v";
    pub const ENTRY_SPMV_S_T: &str = "spmv_s_t";
    pub const ENTRY_BICGSTAB_UPDATE_P: &str = "bicgstab_update_p";
    pub const ENTRY_BICGSTAB_UPDATE_S: &str = "bicgstab_update_s";
    pub const ENTRY_BICGSTAB_UPDATE_X_R: &str = "bicgstab_update_x_r";
    pub const ENTRY_CG_UPDATE_X_R: &str = "cg_update_x_r";
    pub const ENTRY_CG_UPDATE_P: &str = "cg_update_p";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
        pub s: wgpu::BufferBinding<'a>,
        pub t: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
        pub s: wgpu::BindGroupEntry<'a>,
        pub t: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
                s: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.s),
                },
                t: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.t),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [self.x, self.r, self.p, self.v, self.s, self.t]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"s\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"t\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("LinearSolver::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::linear_solver::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("LinearSolver::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("LinearSolver::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("linear_solver.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    omega: f32,
    r0_v: f32,
    t_s: f32,
    t_t: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> s: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> t: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;

@compute @workgroup_size(64, 1, 1) 
fn spmv_p_v(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sum: f32 = 0f;
    var k: u32;

    let row = global_id.x;
    let _e5 = params.n;
    if (row >= _e5) {
        return;
    }
    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col = col_indices[_e19];
            let _e23 = k;
            let val = matrix_values[_e23];
            let _e29 = p[col];
            let _e31 = sum;
            sum = (_e31 + (val * _e29));
        }
        continuing {
            let _e34 = k;
            k = (_e34 + 1u);
        }
    }
    let _e38 = sum;
    v[row] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_s_t(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var sum_1: f32 = 0f;
    var k_1: u32;

    let row_1 = global_id_1.x;
    let _e5 = params.n;
    if (row_1 >= _e5) {
        return;
    }
    let start_1 = row_offsets[row_1];
    let end_1 = row_offsets[(row_1 + 1u)];
    k_1 = start_1;
    loop {
        let _e16 = k_1;
        if (_e16 < end_1) {
        } else {
            break;
        }
        {
            let _e19 = k_1;
            let col_1 = col_indices[_e19];
            let _e23 = k_1;
            let val_1 = matrix_values[_e23];
            let _e29 = s[col_1];
            let _e31 = sum_1;
            sum_1 = (_e31 + (val_1 * _e29));
        }
        continuing {
            let _e34 = k_1;
            k_1 = (_e34 + 1u);
        }
    }
    let _e38 = sum_1;
    t[row_1] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn bicgstab_update_p(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var beta: f32 = 0f;

    let idx = global_id_2.x;
    let _e5 = scalars.omega;
    let _e11 = scalars.rho_old;
    if ((abs(_e5) >= 0.00000000000000000001f) && (abs(_e11) >= 0.00000000000000000001f)) {
        let _e18 = scalars.rho_new;
        let _e21 = scalars.rho_old;
        let _e25 = scalars.alpha;
        let _e28 = scalars.omega;
        beta = ((_e18 / _e21) * (_e25 / _e28));
    }
    if (global_id_2.x == 0u) {
        let _e37 = beta;
        scalars.beta = _e37;
    }
    let _e40 = params.n;
    if (idx >= _e40) {
        return;
    }
    let _e46 = r[idx];
    let _e47 = beta;
    let _e50 = p[idx];
    let _e53 = scalars.omega;
    let _e56 = v[idx];
    p[idx] = (_e46 + (_e47 * (_e50 - (_e53 * _e56))));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn bicgstab_update_s(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    var alpha: f32 = 0f;

    let idx_1 = global_id_3.x;
    let _e5 = scalars.r0_v;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.rho_new;
        let _e14 = scalars.r0_v;
        alpha = (_e11 / _e14);
    }
    if (global_id_3.x == 0u) {
        let _e22 = alpha;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (idx_1 >= _e25) {
        return;
    }
    let _e31 = r[idx_1];
    let _e32 = alpha;
    let _e35 = v[idx_1];
    s[idx_1] = (_e31 - (_e32 * _e35));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn bicgstab_update_x_r(@builtin(global_invocation_id) global_id_4: vec3<u32>) {
    var omega: f32 = 0f;

    let idx_2 = global_id_4.x;
    let _e5 = scalars.t_t;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.t_s;
        let _e14 = scalars.t_t;
        omega = (_e11 / _e14);
    }
    if (global_id_4.x == 0u) {
        let _e22 = omega;
        scalars.omega = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (idx_2 >= _e30) {
        return;
    }
    let alpha_2 = scalars.alpha;
    let _e39 = p[idx_2];
    let _e41 = omega;
    let _e44 = s[idx_2];
    let _e47 = x[idx_2];
    x[idx_2] = (_e47 + ((alpha_2 * _e39) + (_e41 * _e44)));
    let _e53 = s[idx_2];
    let _e54 = omega;
    let _e57 = t[idx_2];
    r[idx_2] = (_e53 - (_e54 * _e57));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_x_r(@builtin(global_invocation_id) global_id_5: vec3<u32>) {
    var alpha_1: f32 = 0f;

    let idx_3 = global_id_5.x;
    let _e5 = scalars.r0_v;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.rho_old;
        let _e14 = scalars.r0_v;
        alpha_1 = (_e11 / _e14);
    }
    if (global_id_5.x == 0u) {
        let _e22 = alpha_1;
        scalars.alpha = _e22;
    }
    let _e25 = params.n;
    if (idx_3 >= _e25) {
        return;
    }
    let _e29 = alpha_1;
    let _e32 = p[idx_3];
    let _e34 = x[idx_3];
    x[idx_3] = (_e34 + (_e29 * _e32));
    let _e38 = alpha_1;
    let _e41 = v[idx_3];
    let _e43 = r[idx_3];
    r[idx_3] = (_e43 - (_e38 * _e41));
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn cg_update_p(@builtin(global_invocation_id) global_id_6: vec3<u32>) {
    var beta_1: f32 = 0f;

    let idx_4 = global_id_6.x;
    let _e5 = scalars.rho_old;
    if (abs(_e5) >= 0.00000000000000000001f) {
        let _e11 = scalars.rho_new;
        let _e14 = scalars.rho_old;
        beta_1 = (_e11 / _e14);
    }
    if (global_id_6.x == 0u) {
        let _e22 = beta_1;
        scalars.beta = _e22;
        let _e27 = scalars.rho_new;
        scalars.rho_old = _e27;
    }
    let _e30 = params.n;
    if (idx_4 >= _e30) {
        return;
    }
    let _e36 = r[idx_4];
    let _e37 = beta_1;
    let _e40 = p[idx_4];
    p[idx_4] = (_e36 + (_e37 * _e40));
    return;
}
"#;
}
pub mod preconditioner {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 24, size: 4, type: `f32`"]
        pub t_s: f32,
        #[doc = "offset: 28, size: 4, type: `f32`"]
        pub t_t: f32,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            omega: f32,
            r0_v: f32,
            t_s: f32,
            t_t: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                omega,
                r0_v,
                t_s,
                t_t,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct SolverParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
    }
    impl SolverParams {
        pub const fn new(n: u32) -> Self {
            Self { n }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub mode: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 8, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub _pad2: u32,
    }
    impl PrecondParams {
        pub const fn new(mode: u32, _pad0: u32, _pad1: u32, _pad2: u32) -> Self {
            Self {
                mode,
                _pad0,
                _pad1,
                _pad2,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const BUILD_SCHUR_RHS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_build_schur_rhs_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline build_schur_rhs"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("build_schur_rhs"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const FINALIZE_PRECOND_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_finalize_precond_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline finalize_precond"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("finalize_precond"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SPMV_PHAT_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_phat_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_phat_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_phat_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const SPMV_SHAT_T_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_spmv_shat_t_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline spmv_shat_t"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("spmv_shat_t"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_BUILD_SCHUR_RHS: &str = "build_schur_rhs";
    pub const ENTRY_FINALIZE_PRECOND: &str = "finalize_precond";
    pub const ENTRY_SPMV_PHAT_V: &str = "spmv_phat_v";
    pub const ENTRY_SPMV_SHAT_T: &str = "spmv_shat_t";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub x: wgpu::BufferBinding<'a>,
        pub r: wgpu::BufferBinding<'a>,
        pub p: wgpu::BufferBinding<'a>,
        pub v: wgpu::BufferBinding<'a>,
        pub s: wgpu::BufferBinding<'a>,
        pub t: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub x: wgpu::BindGroupEntry<'a>,
        pub r: wgpu::BindGroupEntry<'a>,
        pub p: wgpu::BindGroupEntry<'a>,
        pub v: wgpu::BindGroupEntry<'a>,
        pub s: wgpu::BindGroupEntry<'a>,
        pub t: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                x: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.x),
                },
                r: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.r),
                },
                p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p),
                },
                v: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.v),
                },
                s: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.s),
                },
                t: wgpu::BindGroupEntry {
                    binding: 5,
                    resource: wgpu::BindingResource::Buffer(params.t),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 6] {
            [self.x, self.r, self.p, self.v, self.s, self.t]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Preconditioner::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"x\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"r\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"v\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"s\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(5): \"t\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 5,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Preconditioner::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
        pub scalars: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
                scalars: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.row_offsets,
                self.col_indices,
                self.matrix_values,
                self.scalars,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Preconditioner::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::preconditioner::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::preconditioner::SolverParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Preconditioner::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub block_inv: wgpu::BufferBinding<'a>,
        pub p_hat: wgpu::BufferBinding<'a>,
        pub s_hat: wgpu::BufferBinding<'a>,
        pub precond_rhs: wgpu::BufferBinding<'a>,
        pub precond_params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub block_inv: wgpu::BindGroupEntry<'a>,
        pub p_hat: wgpu::BindGroupEntry<'a>,
        pub s_hat: wgpu::BindGroupEntry<'a>,
        pub precond_rhs: wgpu::BindGroupEntry<'a>,
        pub precond_params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                block_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.block_inv),
                },
                p_hat: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_hat),
                },
                s_hat: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.s_hat),
                },
                precond_rhs: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.precond_rhs),
                },
                precond_params: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.precond_params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [
                self.block_inv,
                self.p_hat,
                self.s_hat,
                self.precond_rhs,
                self.precond_params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Preconditioner::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"block_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_hat\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"s_hat\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"precond_rhs\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"precond_params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::preconditioner::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Preconditioner::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 3],
        ) -> [wgpu::BindGroupLayout; 3] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Preconditioner::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("preconditioner.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    omega: f32,
    r0_v: f32,
    t_s: f32,
    t_t: f32,
    r_r: f32,
}

struct SolverParams {
    n: u32,
}

struct PrecondParams {
    mode: u32,
    _pad0_: u32,
    _pad1_: u32,
    _pad2_: u32,
}

@group(0) @binding(0) 
var<storage, read_write> x: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> r: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> v: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> s: array<f32>;
@group(0) @binding(5) 
var<storage, read_write> t: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(1) @binding(3) 
var<storage, read_write> scalars: GpuScalars;
@group(1) @binding(4) 
var<uniform> params: SolverParams;
@group(2) @binding(0) 
var<storage, read_write> block_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> p_hat: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> s_hat: array<f32>;
@group(2) @binding(3) 
var<storage, read_write> precond_rhs: array<f32>;
@group(2) @binding(4) 
var<uniform> precond_params: PrecondParams;

fn use_s_mode() -> bool {
    let _e2 = precond_params.mode;
    return (_e2 == 1u);
}

fn read_search_vector(idx: u32) -> f32 {
    let _e0 = use_s_mode();
    if _e0 {
        let _e4 = s[idx];
        return _e4;
    }
    let _e7 = p[idx];
    return _e7;
}

fn write_hat(idx_1: u32, value: f32) {
    let _e0 = use_s_mode();
    if _e0 {
        s_hat[idx_1] = value;
        return;
    } else {
        p_hat[idx_1] = value;
        return;
    }
}

fn read_hat(idx_2: u32) -> f32 {
    let _e0 = use_s_mode();
    if _e0 {
        let _e4 = s_hat[idx_2];
        return _e4;
    }
    let _e7 = p_hat[idx_2];
    return _e7;
}

fn write_rhs(idx_3: u32, value_1: f32) {
    precond_rhs[idx_3] = value_1;
    return;
}

fn get_matrix_value(row: u32, col: u32) -> f32 {
    var value_2: f32 = 0f;
    var k_5: u32;

    let start = row_offsets[row];
    let end = row_offsets[(row + 1u)];
    k_5 = start;
    loop {
        let _e11 = k_5;
        if (_e11 < end) {
        } else {
            break;
        }
        {
            let _e15 = k_5;
            let _e17 = col_indices[_e15];
            if (_e17 == col) {
                let _e20 = k_5;
                let _e22 = matrix_values[_e20];
                value_2 = _e22;
                break;
            }
        }
        continuing {
            let _e25 = k_5;
            k_5 = (_e25 + 1u);
        }
    }
    let _e27 = value_2;
    return _e27;
}

fn safe_inverse(val: f32) -> f32 {
    let abs_val = abs(val);
    if (abs_val > 0.000000000001f) {
        return (1f / val);
    }
    if (abs_val > 0f) {
        return (sign(val) * 10000000000f);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn build_schur_rhs(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var rhs: f32;
    var k: u32;

    let total_unknowns = params.n;
    if (total_unknowns < 3u) {
        return;
    }
    let num_cells = (total_unknowns / 3u);
    let cell = global_id.x;
    if (cell >= num_cells) {
        return;
    }
    let base = (cell * 3u);
    let row_1 = (base + 2u);
    let _e14 = read_search_vector(row_1);
    rhs = _e14;
    let start_1 = row_offsets[row_1];
    let end_1 = row_offsets[(row_1 + 1u)];
    k = start_1;
    loop {
        let _e25 = k;
        if (_e25 < end_1) {
        } else {
            break;
        }
        {
            let _e28 = k;
            let col_1 = col_indices[_e28];
            if ((col_1 % 3u) != 2u) {
                let _e36 = k;
                let _e38 = matrix_values[_e36];
                let _e39 = read_hat(col_1);
                let _e41 = rhs;
                rhs = (_e41 - (_e38 * _e39));
            }
        }
        continuing {
            let _e44 = k;
            k = (_e44 + 1u);
        }
    }
    write_rhs((base + 0u), 0f);
    write_rhs((base + 1u), 0f);
    let _e54 = rhs;
    write_rhs((base + 2u), _e54);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn finalize_precond(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var vel_u: f32;
    var vel_v: f32;
    var k_1: u32;
    var k_2: u32;

    let total_unknowns_1 = params.n;
    if (total_unknowns_1 < 3u) {
        return;
    }
    let num_cells_1 = (total_unknowns_1 / 3u);
    let cell_1 = global_id_1.x;
    if (cell_1 >= num_cells_1) {
        return;
    }
    let base_1 = (cell_1 * 3u);
    let offset = (cell_1 * 9u);
    let row_u = (base_1 + 0u);
    let row_v = (base_1 + 1u);
    let _e18 = read_hat(row_u);
    vel_u = _e18;
    let _e20 = read_hat(row_v);
    vel_v = _e20;
    let inv_u = block_inv[(offset + 0u)];
    let inv_v = block_inv[(offset + 4u)];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e41 = k_1;
        if (_e41 < end_u) {
        } else {
            break;
        }
        {
            let _e44 = k_1;
            let col_2 = col_indices[_e44];
            if ((col_2 % 3u) == 2u) {
                let _e52 = k_1;
                let _e54 = matrix_values[_e52];
                let _e56 = read_hat(col_2);
                let _e58 = vel_u;
                vel_u = (_e58 - ((inv_u * _e54) * _e56));
            }
        }
        continuing {
            let _e61 = k_1;
            k_1 = (_e61 + 1u);
        }
    }
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e72 = k_2;
        if (_e72 < end_v) {
        } else {
            break;
        }
        {
            let _e75 = k_2;
            let col_3 = col_indices[_e75];
            if ((col_3 % 3u) == 2u) {
                let _e83 = k_2;
                let _e85 = matrix_values[_e83];
                let _e87 = read_hat(col_3);
                let _e89 = vel_v;
                vel_v = (_e89 - ((inv_v * _e85) * _e87));
            }
        }
        continuing {
            let _e92 = k_2;
            k_2 = (_e92 + 1u);
        }
    }
    let _e94 = vel_u;
    write_hat(row_u, _e94);
    let _e95 = vel_v;
    write_hat(row_v, _e95);
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_phat_v(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var sum: f32 = 0f;
    var k_3: u32;

    let row_2 = global_id_2.x;
    let _e5 = params.n;
    if (row_2 >= _e5) {
        return;
    }
    let start_2 = row_offsets[row_2];
    let end_2 = row_offsets[(row_2 + 1u)];
    k_3 = start_2;
    loop {
        let _e16 = k_3;
        if (_e16 < end_2) {
        } else {
            break;
        }
        {
            let _e19 = k_3;
            let col_4 = col_indices[_e19];
            let _e23 = k_3;
            let val_1 = matrix_values[_e23];
            let _e29 = p_hat[col_4];
            let _e31 = sum;
            sum = (_e31 + (val_1 * _e29));
        }
        continuing {
            let _e34 = k_3;
            k_3 = (_e34 + 1u);
        }
    }
    let _e38 = sum;
    v[row_2] = _e38;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn spmv_shat_t(@builtin(global_invocation_id) global_id_3: vec3<u32>) {
    var sum_1: f32 = 0f;
    var k_4: u32;

    let row_3 = global_id_3.x;
    let _e5 = params.n;
    if (row_3 >= _e5) {
        return;
    }
    let start_3 = row_offsets[row_3];
    let end_3 = row_offsets[(row_3 + 1u)];
    k_4 = start_3;
    loop {
        let _e16 = k_4;
        if (_e16 < end_3) {
        } else {
            break;
        }
        {
            let _e19 = k_4;
            let col_5 = col_indices[_e19];
            let _e23 = k_4;
            let val_2 = matrix_values[_e23];
            let _e29 = s_hat[col_5];
            let _e31 = sum_1;
            sum_1 = (_e31 + (val_2 * _e29));
        }
        continuing {
            let _e34 = k_4;
            k_4 = (_e34 + 1u);
        }
    }
    let _e38 = sum_1;
    t[row_3] = _e38;
    return;
}
"#;
}
pub mod scalars {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct GpuScalars {
        #[doc = "offset: 0, size: 4, type: `f32`"]
        pub rho_old: f32,
        #[doc = "offset: 4, size: 4, type: `f32`"]
        pub rho_new: f32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub alpha: f32,
        #[doc = "offset: 12, size: 4, type: `f32`"]
        pub beta: f32,
        #[doc = "offset: 16, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 20, size: 4, type: `f32`"]
        pub r0_v: f32,
        #[doc = "offset: 24, size: 4, type: `f32`"]
        pub t_s: f32,
        #[doc = "offset: 28, size: 4, type: `f32`"]
        pub t_t: f32,
        #[doc = "offset: 32, size: 4, type: `f32`"]
        pub r_r: f32,
    }
    impl GpuScalars {
        pub const fn new(
            rho_old: f32,
            rho_new: f32,
            alpha: f32,
            beta: f32,
            omega: f32,
            r0_v: f32,
            t_s: f32,
            t_t: f32,
            r_r: f32,
        ) -> Self {
            Self {
                rho_old,
                rho_new,
                alpha,
                beta,
                omega,
                r0_v,
                t_s,
                t_t,
                r_r,
            }
        }
    }
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ReduceParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_groups: u32,
    }
    impl ReduceParams {
        pub const fn new(n: u32, num_groups: u32) -> Self {
            Self { n, num_groups }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const REDUCE_RHO_NEW_R_R_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_rho_new_r_r_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_rho_new_r_r"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_rho_new_r_r"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_R0_V_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_r0_v_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_r0_v"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_r0_v"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const REDUCE_T_S_T_T_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_reduce_t_s_t_t_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline reduce_t_s_t_t"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("reduce_t_s_t_t"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_SCALARS_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_init_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_RHO_OLD_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_rho_old_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_rho_old"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_rho_old"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const INIT_CG_SCALARS_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_init_cg_scalars_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline init_cg_scalars"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("init_cg_scalars"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_CG_ALPHA_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_cg_alpha_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_cg_alpha"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_cg_alpha"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const UPDATE_CG_BETA_WORKGROUP_SIZE: [u32; 3] = [1, 1, 1];
        pub fn create_update_cg_beta_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline update_cg_beta"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("update_cg_beta"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_REDUCE_RHO_NEW_R_R: &str = "reduce_rho_new_r_r";
    pub const ENTRY_REDUCE_R0_V: &str = "reduce_r0_v";
    pub const ENTRY_REDUCE_T_S_T_T: &str = "reduce_t_s_t_t";
    pub const ENTRY_INIT_SCALARS: &str = "init_scalars";
    pub const ENTRY_UPDATE_RHO_OLD: &str = "update_rho_old";
    pub const ENTRY_INIT_CG_SCALARS: &str = "init_cg_scalars";
    pub const ENTRY_UPDATE_CG_ALPHA: &str = "update_cg_alpha";
    pub const ENTRY_UPDATE_CG_BETA: &str = "update_cg_beta";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub scalars: wgpu::BufferBinding<'a>,
        pub dot_result_1: wgpu::BufferBinding<'a>,
        pub dot_result_2: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub scalars: wgpu::BindGroupEntry<'a>,
        pub dot_result_1: wgpu::BindGroupEntry<'a>,
        pub dot_result_2: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                scalars: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.scalars),
                },
                dot_result_1: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_1),
                },
                dot_result_2: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.dot_result_2),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.scalars,
                self.dot_result_1,
                self.dot_result_2,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scalars::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"scalars\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::GpuScalars,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"dot_result_1\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"dot_result_2\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scalars::ReduceParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scalars::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 1],
        ) -> [wgpu::BindGroupLayout; 1] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scalars::PipelineLayout"),
            bind_group_layouts: &[&WgpuBindGroup0::get_bind_group_layout(device)],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scalars.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct GpuScalars {
    rho_old: f32,
    rho_new: f32,
    alpha: f32,
    beta: f32,
    omega: f32,
    r0_v: f32,
    t_s: f32,
    t_t: f32,
    r_r: f32,
}

struct ReduceParams {
    n: u32,
    num_groups: u32,
}

@group(0) @binding(0) 
var<storage, read_write> scalars: GpuScalars;
@group(0) @binding(1) 
var<storage> dot_result_1_: array<f32>;
@group(0) @binding(2) 
var<storage> dot_result_2_: array<f32>;
@group(0) @binding(3) 
var<uniform> params: ReduceParams;
var<workgroup> scratch1_: array<f32, 64>;
var<workgroup> scratch2_: array<f32, 64>;

@compute @workgroup_size(64, 1, 1) 
fn reduce_rho_new_r_r(@builtin(local_invocation_id) local_id: vec3<u32>) {
    var sum1_: f32 = 0f;
    var sum2_: f32 = 0f;
    var i: u32;
    var i_1: u32 = 32u;

    let n = params.num_groups;
    let lid = local_id.x;
    i = lid;
    loop {
        let _e8 = i;
        if (_e8 < n) {
        } else {
            break;
        }
        {
            let _e12 = i;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_;
            sum1_ = (_e15 + _e14);
            let _e19 = i;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_;
            sum2_ = (_e22 + _e21);
        }
        continuing {
            let _e25 = i;
            i = (_e25 + 64u);
        }
    }
    let _e29 = sum1_;
    scratch1_[lid] = _e29;
    let _e32 = sum2_;
    scratch2_[lid] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_1;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_1;
            if (lid < _e37) {
                let _e42 = i_1;
                let _e45 = scratch1_[(lid + _e42)];
                let _e46 = scratch1_[lid];
                scratch1_[lid] = (_e46 + _e45);
                let _e51 = i_1;
                let _e54 = scratch2_[(lid + _e51)];
                let _e55 = scratch2_[lid];
                scratch2_[lid] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 >> 1u);
        }
    }
    if (lid == 0u) {
        let _e66 = scratch1_[0];
        scalars.rho_new = _e66;
        let _e71 = scratch2_[0];
        scalars.r_r = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_r0_v(@builtin(local_invocation_id) local_id_1: vec3<u32>) {
    var sum: f32 = 0f;
    var i_2: u32;
    var i_3: u32 = 32u;

    let n_1 = params.num_groups;
    let lid_1 = local_id_1.x;
    i_2 = lid_1;
    loop {
        let _e8 = i_2;
        if (_e8 < n_1) {
        } else {
            break;
        }
        {
            let _e12 = i_2;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum;
            sum = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_2;
            i_2 = (_e18 + 64u);
        }
    }
    let _e22 = sum;
    scratch1_[lid_1] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_3;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_3;
            if (lid_1 < _e27) {
                let _e32 = i_3;
                let _e35 = scratch1_[(lid_1 + _e32)];
                let _e36 = scratch1_[lid_1];
                scratch1_[lid_1] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_3;
            i_3 = (_e39 >> 1u);
        }
    }
    if (lid_1 == 0u) {
        let _e47 = scratch1_[0];
        scalars.r0_v = _e47;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(64, 1, 1) 
fn reduce_t_s_t_t(@builtin(local_invocation_id) local_id_2: vec3<u32>) {
    var sum1_1: f32 = 0f;
    var sum2_1: f32 = 0f;
    var i_4: u32;
    var i_5: u32 = 32u;

    let n_2 = params.num_groups;
    let lid_2 = local_id_2.x;
    i_4 = lid_2;
    loop {
        let _e8 = i_4;
        if (_e8 < n_2) {
        } else {
            break;
        }
        {
            let _e12 = i_4;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum1_1;
            sum1_1 = (_e15 + _e14);
            let _e19 = i_4;
            let _e21 = dot_result_2_[_e19];
            let _e22 = sum2_1;
            sum2_1 = (_e22 + _e21);
        }
        continuing {
            let _e25 = i_4;
            i_4 = (_e25 + 64u);
        }
    }
    let _e29 = sum1_1;
    scratch1_[lid_2] = _e29;
    let _e32 = sum2_1;
    scratch2_[lid_2] = _e32;
    workgroupBarrier();
    loop {
        let _e34 = i_5;
        if (_e34 > 0u) {
        } else {
            break;
        }
        {
            let _e37 = i_5;
            if (lid_2 < _e37) {
                let _e42 = i_5;
                let _e45 = scratch1_[(lid_2 + _e42)];
                let _e46 = scratch1_[lid_2];
                scratch1_[lid_2] = (_e46 + _e45);
                let _e51 = i_5;
                let _e54 = scratch2_[(lid_2 + _e51)];
                let _e55 = scratch2_[lid_2];
                scratch2_[lid_2] = (_e55 + _e54);
            }
            workgroupBarrier();
        }
        continuing {
            let _e58 = i_5;
            i_5 = (_e58 >> 1u);
        }
    }
    if (lid_2 == 0u) {
        let _e66 = scratch1_[0];
        scalars.t_s = _e66;
        let _e71 = scratch2_[0];
        scalars.t_t = _e71;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn init_scalars() {
    scalars.rho_old = 1f;
    scalars.alpha = 1f;
    scalars.omega = 1f;
    scalars.beta = 0f;
    return;
}

@compute @workgroup_size(1, 1, 1) 
fn update_rho_old() {
    let _e4 = scalars.rho_new;
    scalars.rho_old = _e4;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn init_cg_scalars(@builtin(local_invocation_id) local_id_3: vec3<u32>) {
    var sum_1: f32 = 0f;
    var i_6: u32;
    var i_7: u32 = 32u;

    let n_3 = params.num_groups;
    let lid_3 = local_id_3.x;
    i_6 = lid_3;
    loop {
        let _e8 = i_6;
        if (_e8 < n_3) {
        } else {
            break;
        }
        {
            let _e12 = i_6;
            let _e14 = dot_result_1_[_e12];
            let _e15 = sum_1;
            sum_1 = (_e15 + _e14);
        }
        continuing {
            let _e18 = i_6;
            i_6 = (_e18 + 64u);
        }
    }
    let _e22 = sum_1;
    scratch1_[lid_3] = _e22;
    workgroupBarrier();
    loop {
        let _e24 = i_7;
        if (_e24 > 0u) {
        } else {
            break;
        }
        {
            let _e27 = i_7;
            if (lid_3 < _e27) {
                let _e32 = i_7;
                let _e35 = scratch1_[(lid_3 + _e32)];
                let _e36 = scratch1_[lid_3];
                scratch1_[lid_3] = (_e36 + _e35);
            }
            workgroupBarrier();
        }
        continuing {
            let _e39 = i_7;
            i_7 = (_e39 >> 1u);
        }
    }
    if (lid_3 == 0u) {
        let _e47 = scratch1_[0];
        scalars.rho_old = _e47;
        scalars.alpha = 0f;
        scalars.beta = 0f;
        return;
    } else {
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn update_cg_alpha() {
    let _e2 = scalars.r0_v;
    if (abs(_e2) < 0.00000000000000000001f) {
        scalars.alpha = 0f;
        return;
    } else {
        let _e13 = scalars.rho_old;
        let _e16 = scalars.r0_v;
        scalars.alpha = (_e13 / _e16);
        return;
    }
}

@compute @workgroup_size(1, 1, 1) 
fn update_cg_beta() {
    let _e2 = scalars.rho_old;
    if (abs(_e2) < 0.00000000000000000001f) {
        scalars.beta = 0f;
        return;
    } else {
        let _e13 = scalars.rho_new;
        let _e16 = scalars.rho_old;
        scalars.beta = (_e13 / _e16);
        return;
    }
}
"#;
}
pub mod schur_precond {
    use super::{_root, _root::*};
    #[repr(C, align(4))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub u0: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u1: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad0: u32,
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            u0: u32,
            u1: u32,
            p: u32,
            _pad0: u32,
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                u0,
                u1,
                p,
                _pad0,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_v_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_v_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_v_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_v_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 4] {
            [
                self.diag_u_inv,
                self.diag_v_inv,
                self.diag_p_inv,
                self.params,
            ]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_v_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecond::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecond::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecond::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    u0_: u32,
    u1_: u32,
    p: u32,
    _pad0_: u32,
}

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_v_inv: array<f32>;
@group(2) @binding(2) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(3) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let cell = global_id.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let start = p_row_offsets[cell];
    let end = p_row_offsets[(cell + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col_cell = p_col_indices[_e19];
            if (col_cell != cell) {
                let _e24 = k;
                let _e26 = p_matrix_values[_e24];
                let _e30 = p_sol[col_cell];
                let _e32 = sigma;
                sigma = (_e32 + (_e26 * _e30));
            }
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let d_inv = diag_p_inv[cell];
    let rhs = temp_p[cell];
    let _e43 = sigma;
    let hat_x = (d_inv * (rhs - _e43));
    let x_prev = p_prev[cell];
    let _e51 = params.omega;
    let x_new = mix(x_prev, hat_x, _e51);
    p_prev[cell] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var correction_u: f32 = 0f;
    var k_1: u32;
    var correction_v: f32 = 0f;
    var k_2: u32;

    let cell_1 = global_id_1.x;
    let _e5 = params.num_cells;
    if (cell_1 >= _e5) {
        return;
    }
    let _e9 = params.unknowns_per_cell;
    let base = (cell_1 * _e9);
    let _e13 = params.u0_;
    let row_u = (base + _e13);
    let _e17 = params.u1_;
    let row_v = (base + _e17);
    let p_val = p_sol[cell_1];
    let start_u = row_offsets[row_u];
    let end_u = row_offsets[(row_u + 1u)];
    k_1 = start_u;
    loop {
        let _e31 = k_1;
        if (_e31 < end_u) {
        } else {
            break;
        }
        {
            let _e34 = k_1;
            let col = col_indices[_e34];
            let _e39 = params.unknowns_per_cell;
            let _e43 = params.p;
            if ((col % _e39) == _e43) {
                let _e47 = params.unknowns_per_cell;
                let p_cell = (col / _e47);
                let _e50 = k_1;
                let _e52 = matrix_values[_e50];
                let _e56 = p_sol[p_cell];
                let _e58 = correction_u;
                correction_u = (_e58 + (_e52 * _e56));
            }
        }
        continuing {
            let _e61 = k_1;
            k_1 = (_e61 + 1u);
        }
    }
    let _e67 = diag_u_inv[cell_1];
    let _e68 = correction_u;
    let _e70 = z_out[row_u];
    z_out[row_u] = (_e70 - (_e67 * _e68));
    let start_v = row_offsets[row_v];
    let end_v = row_offsets[(row_v + 1u)];
    k_2 = start_v;
    loop {
        let _e81 = k_2;
        if (_e81 < end_v) {
        } else {
            break;
        }
        {
            let _e84 = k_2;
            let col_1 = col_indices[_e84];
            let _e89 = params.unknowns_per_cell;
            let _e93 = params.p;
            if ((col_1 % _e89) == _e93) {
                let _e97 = params.unknowns_per_cell;
                let p_cell_1 = (col_1 / _e97);
                let _e100 = k_2;
                let _e102 = matrix_values[_e100];
                let _e106 = p_sol[p_cell_1];
                let _e108 = correction_v;
                correction_v = (_e108 + (_e102 * _e106));
            }
        }
        continuing {
            let _e111 = k_2;
            k_2 = (_e111 + 1u);
        }
    }
    let _e117 = diag_v_inv[cell_1];
    let _e118 = correction_v;
    let _e120 = z_out[row_v];
    z_out[row_v] = (_e120 - (_e117 * _e118));
    let _e125 = params.p;
    z_out[(base + _e125)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var c: u32 = 0u;
    var rhs_p: f32;
    var k_3: u32;
    var z_val: f32;

    let cell_2 = global_id_2.x;
    let _e5 = params.num_cells;
    if (cell_2 >= _e5) {
        return;
    }
    let _e9 = params.unknowns_per_cell;
    let base_1 = (cell_2 * _e9);
    let _e13 = params.u0_;
    let row_u_1 = (base_1 + _e13);
    let _e17 = params.u1_;
    let row_v_1 = (base_1 + _e17);
    let _e21 = params.p;
    let row_p = (base_1 + _e21);
    loop {
        let _e24 = c;
        let _e27 = params.unknowns_per_cell;
        if (_e24 < _e27) {
        } else {
            break;
        }
        {
            let _e30 = c;
            let _e34 = c;
            let _e37 = r_in[(base_1 + _e34)];
            z_out[(base_1 + _e30)] = _e37;
        }
        continuing {
            let _e39 = c;
            c = (_e39 + 1u);
        }
    }
    let r_u = r_in[row_u_1];
    let r_v = r_in[row_v_1];
    let _e51 = diag_u_inv[cell_2];
    z_out[row_u_1] = (_e51 * r_u);
    let _e57 = diag_v_inv[cell_2];
    z_out[row_v_1] = (_e57 * r_v);
    z_out[row_p] = 0f;
    let _e64 = r_in[row_p];
    rhs_p = _e64;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_3 = start_1;
    loop {
        let _e75 = k_3;
        if (_e75 < end_1) {
        } else {
            break;
        }
        {
            let _e78 = k_3;
            let col_2 = col_indices[_e78];
            let _e83 = params.unknowns_per_cell;
            let rem = (col_2 % _e83);
            z_val = 0f;
            let _e89 = params.u0_;
            if (rem == _e89) {
                let _e93 = params.unknowns_per_cell;
                let c_1 = (col_2 / _e93);
                let _e97 = r_in[col_2];
                let _e100 = diag_u_inv[c_1];
                z_val = (_e97 * _e100);
            } else {
                let _e104 = params.u1_;
                if (rem == _e104) {
                    let _e108 = params.unknowns_per_cell;
                    let c_2 = (col_2 / _e108);
                    let _e112 = r_in[col_2];
                    let _e115 = diag_v_inv[c_2];
                    z_val = (_e112 * _e115);
                }
            }
            let _e118 = k_3;
            let _e120 = matrix_values[_e118];
            let _e121 = z_val;
            let _e123 = rhs_p;
            rhs_p = (_e123 - (_e120 * _e121));
        }
        continuing {
            let _e126 = k_3;
            k_3 = (_e126 + 1u);
        }
    }
    let _e130 = rhs_p;
    temp_p[cell_2] = _e130;
    let _e135 = diag_p_inv[cell_2];
    let _e136 = rhs_p;
    p_sol[cell_2] = (_e135 * _e136);
    p_prev[cell_2] = 0f;
    return;
}
"#;
}
pub mod schur_precond_generic {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct PrecondParams {
        #[doc = "offset: 0, size: 4, type: `u32`"]
        pub n: u32,
        #[doc = "offset: 4, size: 4, type: `u32`"]
        pub num_cells: u32,
        #[doc = "offset: 8, size: 4, type: `f32`"]
        pub omega: f32,
        #[doc = "offset: 12, size: 4, type: `u32`"]
        pub unknowns_per_cell: u32,
        #[doc = "offset: 16, size: 4, type: `u32`"]
        pub p: u32,
        #[doc = "offset: 20, size: 4, type: `u32`"]
        pub u_len: u32,
        #[doc = "offset: 24, size: 4, type: `u32`"]
        pub _pad0: u32,
        #[doc = "offset: 28, size: 4, type: `u32`"]
        pub _pad1: u32,
        #[doc = "offset: 32, size: 16, type: `vec4<u32>`"]
        pub u0123: [u32; 4],
        #[doc = "offset: 48, size: 16, type: `vec4<u32>`"]
        pub u4567: [u32; 4],
    }
    impl PrecondParams {
        pub const fn new(
            n: u32,
            num_cells: u32,
            omega: f32,
            unknowns_per_cell: u32,
            p: u32,
            u_len: u32,
            _pad0: u32,
            _pad1: u32,
            u0123: [u32; 4],
            u4567: [u32; 4],
        ) -> Self {
            Self {
                n,
                num_cells,
                omega,
                unknowns_per_cell,
                p,
                u_len,
                _pad0,
                _pad1,
                u0123,
                u4567,
            }
        }
    }
    pub mod compute {
        use super::{_root, _root::*};
        pub const RELAX_PRESSURE_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_relax_pressure_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline relax_pressure"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("relax_pressure"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const CORRECT_VELOCITY_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_correct_velocity_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline correct_velocity"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("correct_velocity"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
        pub const PREDICT_AND_FORM_SCHUR_WORKGROUP_SIZE: [u32; 3] = [64, 1, 1];
        pub fn create_predict_and_form_schur_pipeline_embed_source(
            device: &wgpu::Device,
        ) -> wgpu::ComputePipeline {
            let module = super::create_shader_module_embed_source(device);
            let layout = super::create_pipeline_layout(device);
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some("Compute Pipeline predict_and_form_schur"),
                layout: Some(&layout),
                module: &module,
                entry_point: Some("predict_and_form_schur"),
                compilation_options: Default::default(),
                cache: None,
            })
        }
    }
    pub const ENTRY_RELAX_PRESSURE: &str = "relax_pressure";
    pub const ENTRY_CORRECT_VELOCITY: &str = "correct_velocity";
    pub const ENTRY_PREDICT_AND_FORM_SCHUR: &str = "predict_and_form_schur";
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub r_in: wgpu::BufferBinding<'a>,
        pub z_out: wgpu::BufferBinding<'a>,
        pub temp_p: wgpu::BufferBinding<'a>,
        pub p_sol: wgpu::BufferBinding<'a>,
        pub p_prev: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub r_in: wgpu::BindGroupEntry<'a>,
        pub z_out: wgpu::BindGroupEntry<'a>,
        pub temp_p: wgpu::BindGroupEntry<'a>,
        pub p_sol: wgpu::BindGroupEntry<'a>,
        pub p_prev: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                r_in: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.r_in),
                },
                z_out: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.z_out),
                },
                temp_p: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.temp_p),
                },
                p_sol: wgpu::BindGroupEntry {
                    binding: 3,
                    resource: wgpu::BindingResource::Buffer(params.p_sol),
                },
                p_prev: wgpu::BindGroupEntry {
                    binding: 4,
                    resource: wgpu::BindingResource::Buffer(params.p_prev),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 5] {
            [self.r_in, self.z_out, self.temp_p, self.p_sol, self.p_prev]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"r_in\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"z_out\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"temp_p\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(3): \"p_sol\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 3,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(4): \"p_prev\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 4,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub row_offsets: wgpu::BufferBinding<'a>,
        pub col_indices: wgpu::BufferBinding<'a>,
        pub matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub row_offsets: wgpu::BindGroupEntry<'a>,
        pub col_indices: wgpu::BindGroupEntry<'a>,
        pub matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.row_offsets),
                },
                col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.col_indices),
                },
                matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.row_offsets, self.col_indices, self.matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub diag_u_inv: wgpu::BufferBinding<'a>,
        pub diag_p_inv: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub diag_u_inv: wgpu::BindGroupEntry<'a>,
        pub diag_p_inv: wgpu::BindGroupEntry<'a>,
        pub params: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                diag_u_inv: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.diag_u_inv),
                },
                diag_p_inv: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.diag_p_inv),
                },
                params: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.params),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.diag_u_inv, self.diag_p_inv, self.params]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"diag_u_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"diag_p_inv\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: false },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"params\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::schur_precond_generic::PrecondParams,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup2Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup2"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3EntriesParams<'a> {
        pub p_row_offsets: wgpu::BufferBinding<'a>,
        pub p_col_indices: wgpu::BufferBinding<'a>,
        pub p_matrix_values: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup3Entries<'a> {
        pub p_row_offsets: wgpu::BindGroupEntry<'a>,
        pub p_col_indices: wgpu::BindGroupEntry<'a>,
        pub p_matrix_values: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup3Entries<'a> {
        pub fn new(params: WgpuBindGroup3EntriesParams<'a>) -> Self {
            Self {
                p_row_offsets: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.p_row_offsets),
                },
                p_col_indices: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Buffer(params.p_col_indices),
                },
                p_matrix_values: wgpu::BindGroupEntry {
                    binding: 2,
                    resource: wgpu::BindingResource::Buffer(params.p_matrix_values),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 3] {
            [self.p_row_offsets, self.p_col_indices, self.p_matrix_values]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup3(wgpu::BindGroup);
    impl WgpuBindGroup3 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"p_row_offsets\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"p_col_indices\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                    #[doc = " @binding(2): \"p_matrix_values\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 2,
                        visibility: wgpu::ShaderStages::COMPUTE,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Storage { read_only: true },
                            has_dynamic_offset: false,
                            min_binding_size: None,
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup3Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("SchurPrecondGeneric::BindGroup3"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(3, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
        pub bind_group3: &'a WgpuBindGroup3,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
            self.bind_group3.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 4],
        ) -> [wgpu::BindGroupLayout; 4] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("SchurPrecondGeneric::PipelineLayout"),
            bind_group_layouts: &[
                &WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
                &WgpuBindGroup2::get_bind_group_layout(device),
                &WgpuBindGroup3::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("schur_precond_generic.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct PrecondParams {
    n: u32,
    num_cells: u32,
    omega: f32,
    unknowns_per_cell: u32,
    p: u32,
    u_len: u32,
    _pad0_: u32,
    _pad1_: u32,
    u0123_: vec4<u32>,
    u4567_: vec4<u32>,
}

@group(0) @binding(0) 
var<storage> r_in: array<f32>;
@group(0) @binding(1) 
var<storage, read_write> z_out: array<f32>;
@group(0) @binding(2) 
var<storage, read_write> temp_p: array<f32>;
@group(0) @binding(3) 
var<storage, read_write> p_sol: array<f32>;
@group(0) @binding(4) 
var<storage, read_write> p_prev: array<f32>;
@group(1) @binding(0) 
var<storage> row_offsets: array<u32>;
@group(1) @binding(1) 
var<storage> col_indices: array<u32>;
@group(1) @binding(2) 
var<storage> matrix_values: array<f32>;
@group(2) @binding(0) 
var<storage, read_write> diag_u_inv: array<f32>;
@group(2) @binding(1) 
var<storage, read_write> diag_p_inv: array<f32>;
@group(2) @binding(2) 
var<uniform> params: PrecondParams;
@group(3) @binding(0) 
var<storage> p_row_offsets: array<u32>;
@group(3) @binding(1) 
var<storage> p_col_indices: array<u32>;
@group(3) @binding(2) 
var<storage> p_matrix_values: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 0.00000000000001f) {
        return (1f / val);
    }
    return 0f;
}

fn u_index(i_3: u32) -> u32 {
    if (i_3 < 4u) {
        let _e6 = params.u0123_[i_3];
        return _e6;
    }
    let _e12 = params.u4567_[(i_3 - 4u)];
    return _e12;
}

@compute @workgroup_size(64, 1, 1) 
fn relax_pressure(@builtin(global_invocation_id) global_id: vec3<u32>) {
    var sigma: f32 = 0f;
    var k: u32;

    let cell = global_id.x;
    let _e5 = params.num_cells;
    if (cell >= _e5) {
        return;
    }
    let start = p_row_offsets[cell];
    let end = p_row_offsets[(cell + 1u)];
    k = start;
    loop {
        let _e16 = k;
        if (_e16 < end) {
        } else {
            break;
        }
        {
            let _e19 = k;
            let col_cell = p_col_indices[_e19];
            if (col_cell != cell) {
                let _e24 = k;
                let _e26 = p_matrix_values[_e24];
                let _e30 = p_sol[col_cell];
                let _e32 = sigma;
                sigma = (_e32 + (_e26 * _e30));
            }
        }
        continuing {
            let _e35 = k;
            k = (_e35 + 1u);
        }
    }
    let d_inv = diag_p_inv[cell];
    let rhs = temp_p[cell];
    let _e43 = sigma;
    let hat_x = (d_inv * (rhs - _e43));
    let x_prev = p_prev[cell];
    let _e51 = params.omega;
    let x_new = mix(x_prev, hat_x, _e51);
    p_prev[cell] = x_new;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn correct_velocity(@builtin(global_invocation_id) global_id_1: vec3<u32>) {
    var i: u32 = 0u;
    var correction_u: f32;
    var k_1: u32;

    let cell_1 = global_id_1.x;
    let _e5 = params.num_cells;
    if (cell_1 >= _e5) {
        return;
    }
    let _e9 = params.unknowns_per_cell;
    let base = (cell_1 * _e9);
    let p_val = p_sol[cell_1];
    loop {
        let _e15 = i;
        let _e18 = params.u_len;
        if (_e15 < _e18) {
        } else {
            break;
        }
        {
            let _e20 = i;
            let _e21 = u_index(_e20);
            let row_u = (base + _e21);
            let start_u = row_offsets[row_u];
            let end_u = row_offsets[(row_u + 1u)];
            correction_u = 0f;
            k_1 = start_u;
            loop {
                let _e34 = k_1;
                if (_e34 < end_u) {
                } else {
                    break;
                }
                {
                    let _e37 = k_1;
                    let col = col_indices[_e37];
                    let _e42 = params.unknowns_per_cell;
                    let _e46 = params.p;
                    if ((col % _e42) == _e46) {
                        let _e50 = params.unknowns_per_cell;
                        let p_cell = (col / _e50);
                        let _e53 = k_1;
                        let _e55 = matrix_values[_e53];
                        let _e58 = p_sol[p_cell];
                        let _e60 = correction_u;
                        correction_u = (_e60 + (_e55 * _e58));
                    }
                }
                continuing {
                    let _e63 = k_1;
                    k_1 = (_e63 + 1u);
                }
            }
            let _e70 = params.u_len;
            let _e72 = i;
            let _e75 = diag_u_inv[((cell_1 * _e70) + _e72)];
            let _e76 = correction_u;
            let _e78 = z_out[row_u];
            z_out[row_u] = (_e78 - (_e75 * _e76));
        }
        continuing {
            let _e81 = i;
            i = (_e81 + 1u);
        }
    }
    let _e86 = params.p;
    z_out[(base + _e86)] = p_val;
    return;
}

@compute @workgroup_size(64, 1, 1) 
fn predict_and_form_schur(@builtin(global_invocation_id) global_id_2: vec3<u32>) {
    var c: u32 = 0u;
    var i_1: u32 = 0u;
    var rhs_p: f32;
    var k_2: u32;
    var z_val: f32;
    var i_2: u32;

    let cell_2 = global_id_2.x;
    let _e5 = params.num_cells;
    if (cell_2 >= _e5) {
        return;
    }
    let _e9 = params.unknowns_per_cell;
    let base_1 = (cell_2 * _e9);
    let _e13 = params.p;
    let row_p = (base_1 + _e13);
    loop {
        let _e16 = c;
        let _e19 = params.unknowns_per_cell;
        if (_e16 < _e19) {
        } else {
            break;
        }
        {
            let _e22 = c;
            let _e26 = c;
            let _e29 = r_in[(base_1 + _e26)];
            z_out[(base_1 + _e22)] = _e29;
        }
        continuing {
            let _e31 = c;
            c = (_e31 + 1u);
        }
    }
    loop {
        let _e34 = i_1;
        let _e37 = params.u_len;
        if (_e34 < _e37) {
        } else {
            break;
        }
        {
            let _e39 = i_1;
            let _e40 = u_index(_e39);
            let row_u_1 = (base_1 + _e40);
            let _e47 = params.u_len;
            let _e49 = i_1;
            let _e52 = diag_u_inv[((cell_2 * _e47) + _e49)];
            let _e55 = r_in[row_u_1];
            z_out[row_u_1] = (_e52 * _e55);
        }
        continuing {
            let _e58 = i_1;
            i_1 = (_e58 + 1u);
        }
    }
    z_out[row_p] = 0f;
    let _e65 = r_in[row_p];
    rhs_p = _e65;
    let start_1 = row_offsets[row_p];
    let end_1 = row_offsets[(row_p + 1u)];
    k_2 = start_1;
    loop {
        let _e76 = k_2;
        if (_e76 < end_1) {
        } else {
            break;
        }
        {
            let _e79 = k_2;
            let col_1 = col_indices[_e79];
            let _e84 = params.unknowns_per_cell;
            let rem = (col_1 % _e84);
            z_val = 0f;
            i_2 = 0u;
            loop {
                let _e90 = i_2;
                let _e93 = params.u_len;
                if (_e90 < _e93) {
                } else {
                    break;
                }
                {
                    let _e95 = i_2;
                    let _e96 = u_index(_e95);
                    if (rem == _e96) {
                        let _e100 = params.unknowns_per_cell;
                        let c_1 = (col_1 / _e100);
                        let _e104 = r_in[col_1];
                        let _e108 = params.u_len;
                        let _e110 = i_2;
                        let _e113 = diag_u_inv[((c_1 * _e108) + _e110)];
                        z_val = (_e104 * _e113);
                        break;
                    }
                }
                continuing {
                    let _e116 = i_2;
                    i_2 = (_e116 + 1u);
                }
            }
            let _e119 = k_2;
            let _e121 = matrix_values[_e119];
            let _e122 = z_val;
            let _e124 = rhs_p;
            rhs_p = (_e124 - (_e121 * _e122));
        }
        continuing {
            let _e127 = k_2;
            k_2 = (_e127 + 1u);
        }
    }
    let _e131 = rhs_p;
    temp_p[cell_2] = _e131;
    let _e136 = diag_p_inv[cell_2];
    let _e137 = rhs_p;
    p_sol[cell_2] = (_e136 * _e137);
    p_prev[cell_2] = 0f;
    return;
}
"#;
}
