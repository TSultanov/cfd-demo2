// GENERATED BY CFD2 CODEGEN (prepare_coupled)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

// Group 2: Solver (Coupled) - Must match coupled_assembly_merged.wgsl layout

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

@group(2) @binding(3) 
var<storage, read_write> grad_u: array<Vector2>;

@group(2) @binding(4) 
var<storage, read_write> grad_v: array<Vector2>;

@group(2) @binding(5) 
var<storage, read_write> scalar_matrix_values: array<f32>;

@group(2) @binding(6) 
var<storage, read_write> diag_u_inv: array<f32>;

@group(2) @binding(7) 
var<storage, read_write> diag_v_inv: array<f32>;

@group(2) @binding(8) 
var<storage, read_write> diag_p_inv: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let center_vec: vec2<f32> = vec2<f32>(center.x, center.y);
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1];
    var diag_coeff: f32 = 0.0;
    let u_n_val = vec2<f32>(state_old[idx * 8u + 0u], state_old[idx * 8u + 1u]);
    let rho_cell = constants.density;
    var time_coeff = vol * rho_cell / constants.dt;
    if (constants.time_scheme == 1u) {
        let dt = constants.dt;
        let dt_old = constants.dt_old;
        let r = dt / dt_old;
        time_coeff = vol * rho_cell / dt * (1.0 + 2.0 * r) / (1.0 + r);
    }
    diag_coeff += time_coeff;
    let val_c_p = state[idx * 8u + 2u];
    var grad_p_accum: vec2<f32> = vec2<f32>(0.0, 0.0);
    let u_val = vec2<f32>(state[idx * 8u + 0u], state[idx * 8u + 1u]);
    var g_u: vec2<f32> = vec2<f32>(0.0, 0.0);
    var g_v: vec2<f32> = vec2<f32>(0.0, 0.0);
    for (var k = start; k < end; k++) {
        let face_idx = cell_faces[k];
        let owner = face_owner[face_idx];
        let neigh_idx = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        let f_center = face_centers[face_idx];
        let c_owner = cell_centers[owner];
        let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
        let f_center_vec: vec2<f32> = vec2<f32>(f_center.x, f_center.y);
        var normal_vec: vec2<f32> = vec2<f32>(face_normals[face_idx].x, face_normals[face_idx].y);
        if (owner != idx) {
            normal_vec = -normal_vec;
        }
        let face_vec: vec2<f32> = normal_vec * area;
        var normal_flux_vec: vec2<f32> = vec2<f32>(face_normals[face_idx].x, face_normals[face_idx].y);
        if (dot(f_center_vec - c_owner_vec, normal_flux_vec) < 0.0) {
            normal_flux_vec = -normal_flux_vec;
        }
        var flux: f32 = 0.0;
        var rho_face: f32 = rho_cell;
        if (neigh_idx != -1) {
            let n_idx = u32(neigh_idx);
            let c_neigh = cell_centers[n_idx];
            let c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
            let u_own = vec2<f32>(state[owner * 8u + 0u], state[owner * 8u + 1u]);
            let u_ngh = vec2<f32>(state[n_idx * 8u + 0u], state[n_idx * 8u + 1u]);
            let dp_own = state[owner * 8u + 3u];
            let dp_ngh = state[n_idx * 8u + 3u];
            let gp_own = vec2<f32>(state[owner * 8u + 4u], state[owner * 8u + 5u]);
            let gp_ngh = vec2<f32>(state[n_idx * 8u + 4u], state[n_idx * 8u + 5u]);
            let p_own = state[owner * 8u + 2u];
            let p_ngh = state[n_idx * 8u + 2u];
            let d_own = distance(c_owner_vec, f_center_vec);
            let d_ngh = distance(c_neigh_vec, f_center_vec);
            let total_dist = d_own + d_ngh;
            var lambda = 0.5;
            if (total_dist > 1e-6) {
                lambda = d_ngh / total_dist;
            }
            let lambda_other = 1.0 - lambda;
            rho_face = constants.density;
            let u_face: vec2<f32> = u_own * lambda + u_ngh * lambda_other;
            let dp_face = lambda * dp_own + (1.0 - lambda) * dp_ngh;
            let gp_face: vec2<f32> = gp_own * lambda + gp_ngh * lambda_other;
            let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
            let dist_proj = abs(dot(d_vec, normal_flux_vec));
            let dist = max(dist_proj, 1e-6);
            let grad_p_n = dot(gp_face, normal_flux_vec);
            let p_grad_f = (p_ngh - p_own) / dist;
            let rc_term = dp_face * area * (grad_p_n - p_grad_f);
            let u_n = dot(u_face, normal_flux_vec);
            flux = rho_face * (u_n * area + rc_term);
        } else {
            if (boundary_type == 1u) {
                let ramp = smoothstep(0.0, constants.ramp_time, constants.time);
                let u_bc: vec2<f32> = vec2<f32>(constants.inlet_velocity * ramp, 0.0);
                flux = rho_face * dot(u_bc, normal_flux_vec) * area;
            } else {
                if (boundary_type == 3u) {
                    flux = 0.0;
                } else {
                    if (boundary_type == 2u) {
                        let u_own = vec2<f32>(state[owner * 8u + 0u], state[owner * 8u + 1u]);
                        let u_n = dot(u_own, normal_flux_vec);
                        let raw_flux = rho_face * u_n * area;
                        flux = max(0.0, raw_flux);
                    }
                }
            }
        }
        if (owner == idx) {
            fluxes[face_idx] = flux;
        }
        var flux_out = flux;
        if (owner != idx) {
            flux_out = -flux;
        }
        var other_center: Vector2;
        var is_boundary = false;
        var other_idx = 0u;
        if (neigh_idx != -1) {
            other_idx = u32(neigh_idx);
            if (owner != idx) {
                other_idx = owner;
            }
            other_center = cell_centers[other_idx];
        } else {
            is_boundary = true;
            other_center = f_center;
        }
        let other_center_vec: vec2<f32> = vec2<f32>(other_center.x, other_center.y);
        let d_vec: vec2<f32> = other_center_vec - center_vec;
        let dist = length(d_vec);
        let diff_coeff = constants.viscosity * area / dist;
        var conv_coeff_diag: f32 = 0.0;
        if (flux_out > 0.0) {
            conv_coeff_diag = flux_out;
        }
        if (!is_boundary) {
            diag_coeff += diff_coeff + conv_coeff_diag;
        } else {
            if (boundary_type == 1u) {
                diag_coeff += diff_coeff;
                if (flux_out > 0.0) {
                    diag_coeff += flux_out;
                }
            } else {
                if (boundary_type == 3u) {
                    diag_coeff += diff_coeff;
                    if (flux_out > 0.0) {
                        diag_coeff += flux_out;
                    }
                } else {
                    if (boundary_type == 2u) {
                        if (flux_out > 0.0) {
                            diag_coeff += flux_out;
                        }
                    }
                }
            }
        }
        if (!is_boundary) {
            let d_c = distance(center_vec, f_center_vec);
            let d_o = distance(other_center_vec, f_center_vec);
            let total_dist_p = d_c + d_o;
            var lambda_p = 0.5;
            if (total_dist_p > 1e-6) {
                lambda_p = d_o / total_dist_p;
            }
            let val_other_p = state[other_idx * 8u + 2u];
            let val_f_p = lambda_p * val_c_p + (1.0 - lambda_p) * val_other_p;
            grad_p_accum += face_vec * val_f_p;
        } else {
            var val_f_p = val_c_p;
            if (boundary_type == 2u) {
                val_f_p = 0.0;
            }
            grad_p_accum += face_vec * val_f_p;
        }
        var u_face_vel: vec2<f32> = vec2<f32>(0.0, 0.0);
        if (!is_boundary) {
            let u_other = vec2<f32>(state[other_idx * 8u + 0u], state[other_idx * 8u + 1u]);
            let d_c = distance(center_vec, f_center_vec);
            let d_o = distance(other_center_vec, f_center_vec);
            let total_dist = d_c + d_o;
            if (total_dist > 1e-6) {
                let lambda = d_o / total_dist;
                let lambda_other = 1.0 - lambda;
                u_face_vel = u_val * lambda + u_other * lambda_other;
            } else {
                u_face_vel = (u_val + u_other) * 0.5;
            }
        } else {
            if (boundary_type == 1u) {
                let ramp = smoothstep(0.0, constants.ramp_time, constants.time);
                u_face_vel = vec2<f32>(constants.inlet_velocity * ramp, 0.0);
            } else {
                if (boundary_type == 3u) {
                    u_face_vel = vec2<f32>(0.0, 0.0);
                } else {
                    u_face_vel = u_val;
                }
            }
        }
        g_u += face_vec * u_face_vel.x;
        g_v += face_vec * u_face_vel.y;
    }
    if (abs(diag_coeff) > 1e-20) {
        state[idx * 8u + 3u] = vol / diag_coeff;
    } else {
        state[idx * 8u + 3u] = 0.0;
    }
    grad_p_accum = grad_p_accum / vol;
    state[idx * 8u + 4u] = grad_p_accum.x;
    state[idx * 8u + 5u] = grad_p_accum.y;
    g_u = g_u / vol;
    g_v = g_v / vol;
    grad_u[idx] = Vector2(g_u.x, g_u.y);
    grad_v[idx] = Vector2(g_v.x, g_v.y);
}
