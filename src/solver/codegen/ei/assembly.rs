use super::super::dsl as typed;
use super::super::reconstruction::limited_linear_reconstruct_face;
use super::super::state_access::{state_component, state_scalar, state_vec2};
use super::super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StructDef, StructField, Type,
};
use super::super::wgsl_dsl as dsl;
use crate::solver::gpu::enums::{GpuBcKind, GpuLowMachPrecondModel, TimeScheme};
use crate::solver::model::backend::{EquationSystem, FieldKind, StateLayout};
use crate::solver::model::EosSpec;
use crate::solver::scheme::Scheme;

pub fn generate_ei_assembly_wgsl(
    layout: &StateLayout,
    system: &EquationSystem,
    eos: &EosSpec,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (ei_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, system, eos)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Struct(low_mach_params_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver".to_string()));
    items.extend(solver_bindings());
    items.push(Item::Comment(
        "Group 3: Boundary conditions (per boundary type × unknown)".to_string(),
    ));
    items.push(storage_var(
        "bc_kind",
        Type::array(Type::U32),
        3,
        0,
        AccessMode::Read,
    ));
    items.push(storage_var(
        "bc_value",
        Type::array(Type::F32),
        3,
        1,
        AccessMode::Read,
    ));
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var("state_iter", Type::array(Type::F32), 1, 9, AccessMode::Read),
        uniform_var("low_mach", Type::Custom("LowMachParams".to_string()), 1, 10),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, system: &EquationSystem, eos: &EosSpec) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, system, eos),
    )
}

fn main_body(layout: &StateLayout, system: &EquationSystem, eos: &EosSpec) -> Block {
    let mut stmts = Vec::new();
    let rho_field = "rho";
    let rho_u_field = "rho_u";
    let rho_e_field = "rho_e";

    // EI assembly computes the Euler conservative (rho, rho_u_x, rho_u_y, rho_e) Jacobian.
    // This kernel can embed that 4x4 block into a larger system by constraining any extra
    // unknowns (diag=1, rhs=state, no face coupling).
    let unknowns_per_cell = system.unknowns_per_cell();
    if unknowns_per_cell < 4 {
        panic!(
            "EI assembly requires at least 4 unknown components per cell for (rho, rho_u_x, rho_u_y, rho_e); got unknowns_per_cell={unknowns_per_cell}"
        );
    }
    if unknowns_per_cell > u8::MAX as u32 {
        panic!(
            "EI assembly supports up to {} unknown components per cell; got unknowns_per_cell={unknowns_per_cell}",
            u8::MAX
        );
    }

    let offset_for = |field_name: &str, component: u32| -> Option<u32> {
        let mut offset = 0u32;
        for eqn in system.equations() {
            let target = eqn.target();
            if target.name() == field_name {
                return match target.kind() {
                    FieldKind::Scalar => (component == 0).then_some(offset),
                    FieldKind::Vector2 => (component < 2).then_some(offset + component),
                };
            }
            offset += target.kind().component_count() as u32;
        }
        None
    };

    let idx_rho = offset_for(rho_field, 0)
        .unwrap_or_else(|| panic!("EI assembly missing scalar '{}' in EquationSystem", rho_field));
    let idx_ru = offset_for(rho_u_field, 0).unwrap_or_else(|| {
        panic!(
            "EI assembly missing vector2 '{}'(x) in EquationSystem",
            rho_u_field
        )
    });
    let idx_rv = offset_for(rho_u_field, 1).unwrap_or_else(|| {
        panic!(
            "EI assembly missing vector2 '{}'(y) in EquationSystem",
            rho_u_field
        )
    });
    let idx_re = offset_for(rho_e_field, 0)
        .unwrap_or_else(|| panic!("EI assembly missing scalar '{}' in EquationSystem", rho_e_field));

    // Map from Euler component order [rho, ru, rv, re] -> EquationSystem packed component index.
    let euler_to_sys = [idx_rho, idx_ru, idx_rv, idx_re];
    for idx in euler_to_sys {
        if idx >= unknowns_per_cell {
            panic!(
                "EI assembly Euler component index out of bounds (idx={idx}, unknowns_per_cell={unknowns_per_cell})"
            );
        }
    }
    if idx_rho == idx_ru || idx_rho == idx_rv || idx_rho == idx_re || idx_ru == idx_rv || idx_ru == idx_re || idx_rv == idx_re {
        panic!(
            "EI assembly requires distinct indices for (rho, rho_u_x, rho_u_y, rho_e); got rho={idx_rho}, rho_u_x={idx_ru}, rho_u_y={idx_rv}, rho_e={idx_re}"
        );
    }

    let mut unknown_components: Vec<(&str, u32)> = Vec::new();
    for eqn in system.equations() {
        let target = eqn.target();
        match target.kind() {
            FieldKind::Scalar => unknown_components.push((target.name(), 0)),
            FieldKind::Vector2 => {
                unknown_components.push((target.name(), 0));
                unknown_components.push((target.name(), 1));
            }
        }
    }
    if unknown_components.len() != unknowns_per_cell as usize {
        panic!(
            "EI assembly internal error: unknown_components length mismatch (len={}, unknowns_per_cell={unknowns_per_cell})",
            unknown_components.len()
        );
    }

    let gamma_value = eos
        .ideal_gas_gamma()
        .unwrap_or_else(|| panic!("EI assembly requires IdealGas EOS; got {eos:?}"));
    let gamma_minus_1 = gamma_value - 1.0;
    let block_size = unknowns_per_cell;
    let block_stride = block_size * block_size;
    let block_shape = typed::BlockShape::new(block_size as u8, block_size as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "center",
        Expr::ident("cell_centers").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        Expr::ident("cell_vols").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        Expr::ident("scalar_row_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        Expr::ident("scalar_row_offsets").index(Expr::ident("idx") + 1u32)
            - Expr::ident("scalar_offset"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::ident("scalar_offset") * block_stride,
    ));
    for row in 1..(block_size as usize) {
        let row_stride = block_size * row as u32;
        stmts.push(dsl::let_expr(
            &format!("start_row_{row}"),
            Expr::ident("start_row_0")
                + Expr::ident("num_neighbors") * Expr::from(row_stride),
        ));
    }

    // Diagonal block entry for this cell (write directly into matrix_values).
    stmts.push(dsl::let_expr(
        "scalar_diag_idx",
        dsl::array_access("diagonal_indices", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "diag_rank",
        Expr::ident("scalar_diag_idx") - Expr::ident("scalar_offset"),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));

    // Initialize diagonal block: zero everything, then identity constraints for non-Euler unknowns.
    for row in 0..(block_size as usize) {
        for col in 0..(block_size as usize) {
            stmts.push(dsl::assign_expr(
                diag_entry.entry(row as u8, col as u8).expr,
                0.0,
            ));
        }
    }
    let euler_sys_indices = [idx_rho as usize, idx_ru as usize, idx_rv as usize, idx_re as usize];
    for sys_i in 0..(block_size as usize) {
        if !euler_sys_indices.contains(&sys_i) {
            stmts.push(dsl::assign_expr(
                diag_entry.entry(sys_i as u8, sys_i as u8).expr,
                1.0,
            ));
        }
    }
    stmts.push(dsl::let_expr(
        "scheme_id",
        Expr::ident("constants").field("scheme"),
    ));

    stmts.push(dsl::comment(
        "Jacobian rows/cols: EquationSystem packed component order (Euler 4x4 embedded; extra unknowns constrained)",
    ));

    stmts.push(dsl::var_typed_expr("sum_rho", Type::F32, Some(0.0.into())));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_u_x",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_u_y",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_e",
        Type::F32,
        Some(0.0.into()),
    ));

    let rho_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_expr = state_scalar(layout, "state", "idx", rho_e_field);
    let rho_old_expr = state_scalar(layout, "state_old", "idx", rho_field);
    let rho_u_old_expr = state_vec2(layout, "state_old", "idx", rho_u_field);
    let rho_e_old_expr = state_scalar(layout, "state_old", "idx", rho_e_field);
    let rho_iter_expr = state_scalar(layout, "state_iter", "idx", rho_field);
    let rho_u_iter_expr = state_vec2(layout, "state_iter", "idx", rho_u_field);
    let rho_e_iter_expr = state_scalar(layout, "state_iter", "idx", rho_e_field);
    stmts.push(dsl::let_expr("rho", rho_expr));
    stmts.push(dsl::let_typed_expr("rho_u", Type::vec2_f32(), rho_u_expr));
    stmts.push(dsl::let_expr("rho_e", rho_e_expr));
    stmts.push(dsl::let_expr("rho_old", rho_old_expr));
    stmts.push(dsl::let_typed_expr(
        "rho_u_old",
        Type::vec2_f32(),
        rho_u_old_expr,
    ));
    stmts.push(dsl::let_expr("rho_e_old", rho_e_old_expr));

    stmts.push(dsl::var_typed_expr(
        "coeff_time",
        Type::F32,
        Some(Expr::ident("vol") / Expr::ident("constants").field("dt")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_old")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_u_x",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_u_old").field("x")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_u_y",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_u_old").field("y")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_e",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_e_old")),
    ));
    stmts.push(dsl::var_typed_expr(
        "coeff_pseudo",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_u_x",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_u_y",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_e",
        Type::F32,
        Some(0.0.into()),
    ));

    let pseudo_block = dsl::block(vec![
        dsl::let_expr("rho_iter", rho_iter_expr),
        dsl::let_typed_expr("rho_u_iter", Type::vec2_f32(), rho_u_iter_expr),
        dsl::let_expr("rho_e_iter", rho_e_iter_expr),
        dsl::assign_expr(
            Expr::ident("coeff_pseudo"),
            Expr::ident("vol") / Expr::ident("constants").field("dtau"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_iter"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_u_x"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_u_iter").field("x"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_u_y"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_u_iter").field("y"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_e"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_e_iter"),
        ),
    ]);
    stmts.push(dsl::if_block_expr(
        Expr::ident("constants").field("dtau").gt(0.0),
        pseudo_block,
        None,
    ));

    let rho_old_old_expr = state_scalar(layout, "state_old_old", "idx", rho_field);
    let rho_u_old_old_expr = state_vec2(layout, "state_old_old", "idx", rho_u_field);
    let rho_e_old_old_expr = state_scalar(layout, "state_old_old", "idx", rho_e_field);
    let bdf2_block = dsl::block(vec![
        dsl::let_expr("dt", Expr::ident("constants").field("dt")),
        dsl::let_expr("dt_old", Expr::ident("constants").field("dt_old")),
        dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
        dsl::let_expr("rho_old_old", rho_old_old_expr),
        dsl::let_typed_expr("rho_u_old_old", Type::vec2_f32(), rho_u_old_old_expr),
        dsl::let_expr("rho_e_old_old", rho_e_old_old_expr),
        dsl::assign_expr(
            Expr::ident("coeff_time"),
            Expr::ident("vol") / Expr::ident("dt") * (Expr::ident("r") * 2.0 + 1.0)
                / (Expr::ident("r") + 1.0),
        ),
        dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
        dsl::let_expr(
            "factor_nm1",
            (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
        ),
        dsl::let_expr("coeff_base", Expr::ident("vol") / Expr::ident("dt")),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_old")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_old_old")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_u_x"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_u_old").field("x")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_u_old_old").field("x")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_u_y"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_u_old").field("y")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_u_old_old").field("y")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_e"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_e_old")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_e_old_old")),
        ),
    ]);

    stmts.push(dsl::if_block_expr(
        typed::EnumExpr::<TimeScheme>::from_expr(Expr::ident("constants").field("time_scheme"))
            .eq(TimeScheme::BDF2),
        bdf2_block,
        None,
    ));

    let rho_r_expr = state_scalar(layout, "state", "other_idx", rho_field);
    let rho_u_r_expr = state_vec2(layout, "state", "other_idx", rho_u_field);
    let rho_e_r_expr = state_scalar(layout, "state", "other_idx", rho_e_field);

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_expr(
        "face_idx",
        Expr::ident("cell_faces").index(Expr::ident("face_offset")),
    ));
    loop_body.push(dsl::let_expr(
        "owner",
        Expr::ident("face_owner").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "neighbor",
        Expr::ident("face_neighbor").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "boundary_type",
        Expr::ident("face_boundary").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "area",
        Expr::ident("face_areas").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "normal",
        Type::Custom("Vector2".to_string()),
        Some(Expr::ident("face_normals").index(Expr::ident("face_idx"))),
    ));
    loop_body.push(dsl::let_expr(
        "f_center",
        Expr::ident("face_centers").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "is_boundary",
        Type::Bool,
        Some(false.into()),
    ));
    loop_body.push(dsl::var_typed_expr(
        "other_idx",
        Type::U32,
        Some(0u32.into()),
    ));
    loop_body.push(dsl::var_typed_expr(
        "center_r",
        Type::Custom("Vector2".to_string()),
        None,
    ));

    loop_body.push(dsl::if_block_expr(
        Expr::ident("owner").ne(Expr::ident("idx")),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("normal").field("x"),
                -Expr::ident("normal").field("x"),
            ),
            dsl::assign_expr(
                Expr::ident("normal").field("y"),
                -Expr::ident("normal").field("y"),
            ),
        ]),
        None,
    ));

    let interior_block = dsl::block(vec![
        dsl::let_typed_expr(
            "neigh_idx",
            Type::U32,
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        ),
        dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neigh_idx")),
        dsl::if_block_expr(
            Expr::ident("owner").ne(Expr::ident("idx")),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("other_idx"),
                Expr::ident("owner"),
            )]),
            None,
        ),
        dsl::assign_expr(
            Expr::ident("center_r"),
            Expr::ident("cell_centers").index(Expr::ident("other_idx")),
        ),
        dsl::let_expr("rho_neigh", rho_r_expr),
        dsl::let_typed_expr("rho_u_neigh", Type::vec2_f32(), rho_u_r_expr),
        dsl::let_expr("rho_e_neigh", rho_e_r_expr),
        dsl::assign_expr(Expr::ident("rho_r"), Expr::ident("rho_neigh")),
        dsl::assign_expr(Expr::ident("rho_u_r"), Expr::ident("rho_u_neigh")),
        dsl::assign_expr(Expr::ident("rho_e_r"), Expr::ident("rho_e_neigh")),
    ]);

    let boundary_block = dsl::block(vec![
        dsl::assign_expr(Expr::ident("is_boundary"), true),
        dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("idx")),
        dsl::assign_expr(Expr::ident("center_r"), Expr::ident("f_center")),
    ]);

    let rho_l_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_l_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_l_expr = state_scalar(layout, "state", "idx", rho_e_field);
    loop_body.push(dsl::let_expr("rho_l_cell", rho_l_expr));
    loop_body.push(dsl::let_typed_expr(
        "rho_u_l_cell",
        Type::vec2_f32(),
        rho_u_l_expr,
    ));
    loop_body.push(dsl::let_expr("rho_e_l_cell", rho_e_l_expr));
    loop_body.push(dsl::var_typed_expr(
        "rho_l",
        Type::F32,
        Some(Expr::ident("rho_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_l",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_e_l",
        Type::F32,
        Some(Expr::ident("rho_e_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_r",
        Type::F32,
        Some(Expr::ident("rho_l")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_r",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_e_r",
        Type::F32,
        Some(Expr::ident("rho_e_l")),
    ));

    loop_body.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        interior_block,
        Some(boundary_block),
    ));

    let boundary_state = dsl::block(vec![
        // Conservative BCs via bc_kind/bc_value tables.
        // Indices are derived from EquationSystem packed component order.
        dsl::let_expr(
            "bc_idx_rho",
            Expr::ident("boundary_type") * Expr::from(unknowns_per_cell) + idx_rho,
        ),
        dsl::let_expr(
            "bc_idx_rho_u_x",
            Expr::ident("boundary_type") * Expr::from(unknowns_per_cell) + idx_ru,
        ),
        dsl::let_expr(
            "bc_idx_rho_u_y",
            Expr::ident("boundary_type") * Expr::from(unknowns_per_cell) + idx_rv,
        ),
        dsl::let_expr(
            "bc_idx_rho_e",
            Expr::ident("boundary_type") * Expr::from(unknowns_per_cell) + idx_re,
        ),
        dsl::let_expr(
            "bc_rho",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho")),
        ),
        dsl::let_expr(
            "bc_rho_u_x",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho_u_x")),
        ),
        dsl::let_expr(
            "bc_rho_u_y",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho_u_y")),
        ),
        dsl::let_expr(
            "bc_rho_e",
            Expr::ident("bc_value").index(Expr::ident("bc_idx_rho_e")),
        ),
        dsl::assign_expr(
            Expr::ident("rho_r"),
            dsl::select(
                Expr::ident("rho_l"),
                Expr::ident("bc_rho"),
                typed::EnumExpr::<GpuBcKind>::from_expr(
                    Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho")),
                )
                .eq(GpuBcKind::Dirichlet),
            ),
        ),
        dsl::let_expr(
            "rho_u_r_x",
            dsl::select(
                Expr::ident("rho_u_l").field("x"),
                Expr::ident("bc_rho_u_x"),
                typed::EnumExpr::<GpuBcKind>::from_expr(
                    Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho_u_x")),
                )
                .eq(GpuBcKind::Dirichlet),
            ),
        ),
        dsl::let_expr(
            "rho_u_r_y",
            dsl::select(
                Expr::ident("rho_u_l").field("y"),
                Expr::ident("bc_rho_u_y"),
                typed::EnumExpr::<GpuBcKind>::from_expr(
                    Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho_u_y")),
                )
                .eq(GpuBcKind::Dirichlet),
            ),
        ),
        dsl::assign_expr(
            Expr::ident("rho_u_r"),
            typed::VecExpr::<2>::from_components([
                Expr::ident("rho_u_r_x"),
                Expr::ident("rho_u_r_y"),
            ])
            .expr(),
        ),
        dsl::assign_expr(
            Expr::ident("rho_e_r"),
            dsl::select(
                Expr::ident("rho_e_l"),
                Expr::ident("bc_rho_e"),
                typed::EnumExpr::<GpuBcKind>::from_expr(
                    Expr::ident("bc_kind").index(Expr::ident("bc_idx_rho_e")),
                )
                .eq(GpuBcKind::Dirichlet),
            ),
        ),
    ]);

    loop_body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        boundary_state,
        None,
    ));

    loop_body.push(dsl::let_expr("rho_r_cell", Expr::ident("rho_r")));
    loop_body.push(dsl::let_typed_expr(
        "rho_u_r_cell",
        Type::vec2_f32(),
        Expr::ident("rho_u_r"),
    ));
    loop_body.push(dsl::let_expr("rho_e_r_cell", Expr::ident("rho_e_r")));

    let reconstruct_block = {
        let mut block = Vec::new();
        block.push(dsl::let_expr(
            "r_l_x",
            Expr::ident("f_center").field("x") - Expr::ident("center").field("x"),
        ));
        block.push(dsl::let_expr(
            "r_l_y",
            Expr::ident("f_center").field("y") - Expr::ident("center").field("y"),
        ));
        block.push(dsl::let_expr(
            "r_r_x",
            Expr::ident("f_center").field("x") - Expr::ident("center_r").field("x"),
        ));
        block.push(dsl::let_expr(
            "r_r_y",
            Expr::ident("f_center").field("y") - Expr::ident("center_r").field("y"),
        ));

        // Reconstruct conservative variables directly for robustness.
        block.push(dsl::let_expr(
            "grad_rho_l",
            Expr::ident("grad_rho").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_l",
            Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_l",
            Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_l",
            Expr::ident("grad_rho_e").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_r",
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_r",
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_r",
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_r",
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        ));

        let (rho_l_stmts, rho_l_face) = limited_linear_reconstruct_face(
            "rho",
            "l",
            Expr::ident("rho_l_cell"),
            Expr::ident("rho_r_cell"),
            Expr::ident("grad_rho_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_l_stmts);
        let (rho_u_x_l_stmts, rho_u_x_l_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "l",
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("grad_rho_u_x_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_x_l_stmts);
        let (rho_u_y_l_stmts, rho_u_y_l_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "l",
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("grad_rho_u_y_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_y_l_stmts);
        let (rho_e_l_stmts, rho_e_l_face) = limited_linear_reconstruct_face(
            "rho_e",
            "l",
            Expr::ident("rho_e_l_cell"),
            Expr::ident("rho_e_r_cell"),
            Expr::ident("grad_rho_e_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_e_l_stmts);

        let (rho_r_stmts, rho_r_face) = limited_linear_reconstruct_face(
            "rho",
            "r",
            Expr::ident("rho_r_cell"),
            Expr::ident("rho_l_cell"),
            Expr::ident("grad_rho_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_r_stmts);
        let (rho_u_x_r_stmts, rho_u_x_r_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "r",
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("grad_rho_u_x_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_x_r_stmts);
        let (rho_u_y_r_stmts, rho_u_y_r_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "r",
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("grad_rho_u_y_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_y_r_stmts);
        let (rho_e_r_stmts, rho_e_r_face) = limited_linear_reconstruct_face(
            "rho_e",
            "r",
            Expr::ident("rho_e_r_cell"),
            Expr::ident("rho_e_l_cell"),
            Expr::ident("grad_rho_e_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_e_r_stmts);

        block.push(dsl::assign_expr(Expr::ident("rho_l"), rho_l_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_l"),
            dsl::vec2_f32(rho_u_x_l_face, rho_u_y_l_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_l"), rho_e_l_face));
        block.push(dsl::assign_expr(Expr::ident("rho_r"), rho_r_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_r"),
            dsl::vec2_f32(rho_u_x_r_face, rho_u_y_r_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_r"), rho_e_r_face));

        dsl::block(block)
    };

    // For compressible KT fluxes, keep reconstruction conservative and stable:
    // - `scheme=0` and `scheme=2` default to piecewise-constant states.
    // - `scheme=1` enables limited linear reconstruction.
    loop_body.push(dsl::if_block_expr(
        (!Expr::ident("is_boundary"))
            & typed::EnumExpr::<Scheme>::from_expr(Expr::ident("scheme_id"))
                .eq(Scheme::SecondOrderUpwind),
        reconstruct_block,
        None,
    ));

    loop_body.push(dsl::let_expr(
        "inv_rho_l",
        Expr::from(1.0) / dsl::max("rho_l", 1e-8),
    ));
    loop_body.push(dsl::let_expr(
        "u_l_x",
        Expr::ident("rho_u_l").field("x") * Expr::ident("inv_rho_l"),
    ));
    loop_body.push(dsl::let_expr(
        "u_l_y",
        Expr::ident("rho_u_l").field("y") * Expr::ident("inv_rho_l"),
    ));
    loop_body.push(dsl::let_expr(
        "ke_l",
        Expr::ident("rho_l")
            * (Expr::ident("u_l_x") * Expr::ident("u_l_x")
                + Expr::ident("u_l_y") * Expr::ident("u_l_y"))
            * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "p_l",
        dsl::max(
            0.0,
            (Expr::ident("rho_e_l") - Expr::ident("ke_l")) * gamma_minus_1,
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_n_l",
        Expr::ident("u_l_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_l_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_l",
        dsl::sqrt(Expr::ident("p_l") * Expr::ident("inv_rho_l") * gamma_value),
    ));

    loop_body.push(dsl::let_expr(
        "inv_rho_r",
        Expr::from(1.0) / dsl::max("rho_r", 1e-8),
    ));
    loop_body.push(dsl::let_expr(
        "u_r_x",
        Expr::ident("rho_u_r").field("x") * Expr::ident("inv_rho_r"),
    ));
    loop_body.push(dsl::let_expr(
        "u_r_y",
        Expr::ident("rho_u_r").field("y") * Expr::ident("inv_rho_r"),
    ));
    loop_body.push(dsl::let_expr(
        "ke_r",
        Expr::ident("rho_r")
            * (Expr::ident("u_r_x") * Expr::ident("u_r_x")
                + Expr::ident("u_r_y") * Expr::ident("u_r_y"))
            * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "p_r",
        dsl::max(
            0.0,
            (Expr::ident("rho_e_r") - Expr::ident("ke_r")) * gamma_minus_1,
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_n_r",
        Expr::ident("u_r_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_r_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_r",
        dsl::sqrt(Expr::ident("p_r") * Expr::ident("inv_rho_r") * gamma_value),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_x",
        (Expr::ident("u_l_x") + Expr::ident("u_r_x")) * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "u_face_y",
        (Expr::ident("u_l_y") + Expr::ident("u_r_y")) * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "u_face_n",
        Expr::ident("u_face_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_face_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_bar",
        (Expr::ident("c_l") + Expr::ident("c_r")) * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "mach",
        dsl::abs("u_face_n") / dsl::max("c_bar", 1e-6),
    ));
    loop_body.push(dsl::let_expr(
        "mach2",
        Expr::ident("mach") * Expr::ident("mach"),
    ));
    // Low-Mach preconditioning (optional). Default is `model=2` (off) for
    // rhoCentralFoam-like transient behavior (e.g., acoustics).
    loop_body.push(dsl::var_typed_expr(
        "c_l_eff",
        Type::F32,
        Some(Expr::ident("c_l")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "c_r_eff",
        Type::F32,
        Some(Expr::ident("c_r")),
    ));

    let precond_legacy_block = dsl::block(vec![
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            Expr::ident("c_l") * Expr::ident("mach"),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            Expr::ident("c_r") * Expr::ident("mach"),
        ),
    ]);
    let precond_weiss_smith_block = dsl::block(vec![
        dsl::let_expr(
            "theta",
            dsl::min(
                1.0,
                dsl::max(
                    Expr::ident("mach2"),
                    Expr::ident("low_mach").field("theta_floor"),
                ),
            ),
        ),
        dsl::let_expr("one_minus_theta", Expr::from(1.0) - Expr::ident("theta")),
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            dsl::sqrt(
                Expr::ident("theta") * Expr::ident("c_l") * Expr::ident("c_l")
                    + Expr::ident("one_minus_theta") * Expr::ident("u_n_l") * Expr::ident("u_n_l"),
            ),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            dsl::sqrt(
                Expr::ident("theta") * Expr::ident("c_r") * Expr::ident("c_r")
                    + Expr::ident("one_minus_theta") * Expr::ident("u_n_r") * Expr::ident("u_n_r"),
            ),
        ),
    ]);
    let precond_model = typed::EnumExpr::<GpuLowMachPrecondModel>::from_expr(
        Expr::ident("low_mach").field("model"),
    );
    let precond_else_block = dsl::block(vec![dsl::if_block_expr(
        precond_model.eq(GpuLowMachPrecondModel::WeissSmith),
        precond_weiss_smith_block,
        None,
    )]);
    loop_body.push(dsl::if_block_expr(
        precond_model.eq(GpuLowMachPrecondModel::Legacy),
        precond_legacy_block,
        Some(precond_else_block),
    ));
    loop_body.push(dsl::let_expr(
        "flux_adv",
        Expr::ident("u_face_n") * Expr::ident("area"),
    ));
    loop_body.push(dsl::let_expr(
        "dx",
        Expr::ident("center_r").field("x") - Expr::ident("center").field("x"),
    ));
    loop_body.push(dsl::let_expr(
        "dy",
        Expr::ident("center_r").field("y") - Expr::ident("center").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "dist",
        dsl::max(
            dsl::sqrt(
                Expr::ident("dx") * Expr::ident("dx") + Expr::ident("dy") * Expr::ident("dy"),
            ),
            1e-6,
        ),
    ));
    loop_body.push(dsl::let_expr(
        "mu",
        Expr::ident("constants").field("viscosity"),
    ));

    loop_body.push(dsl::let_expr(
        "a_plus",
        dsl::max(
            0.0,
            dsl::max(
                Expr::ident("u_n_l") + Expr::ident("c_l_eff"),
                Expr::ident("u_n_r") + Expr::ident("c_r_eff"),
            ),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "a_minus",
        dsl::min(
            0.0,
            dsl::min(
                Expr::ident("u_n_l") - Expr::ident("c_l_eff"),
                Expr::ident("u_n_r") - Expr::ident("c_r_eff"),
            ),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "denom",
        dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
    ));
    loop_body.push(dsl::let_expr(
        "a_prod",
        Expr::ident("a_plus") * Expr::ident("a_minus"),
    ));
    loop_body.push(dsl::let_expr(
        "a_pos",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    loop_body.push(dsl::let_expr(
        "a_neg",
        Expr::from(1.0) - Expr::ident("a_pos"),
    ));
    loop_body.push(dsl::let_expr(
        "a_prod_scaled",
        Expr::ident("a_prod") / Expr::ident("denom"),
    ));

    loop_body.push(dsl::let_expr(
        "flux_rho_l",
        Expr::ident("rho_l") * Expr::ident("u_n_l"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_r",
        Expr::ident("rho_r") * Expr::ident("u_n_r"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_r") - Expr::ident("rho_l")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_x_l",
        Expr::ident("rho_u_l").field("x") * Expr::ident("u_n_l")
            + Expr::ident("p_l") * Expr::ident("normal").field("x"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_x_r",
        Expr::ident("rho_u_r").field("x") * Expr::ident("u_n_r")
            + Expr::ident("p_r") * Expr::ident("normal").field("x"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_u_x",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_u_x_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_u_x_r")
                + Expr::ident("a_prod_scaled")
                    * (Expr::ident("rho_u_r").field("x") - Expr::ident("rho_u_l").field("x")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_y_l",
        Expr::ident("rho_u_l").field("y") * Expr::ident("u_n_l")
            + Expr::ident("p_l") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_y_r",
        Expr::ident("rho_u_r").field("y") * Expr::ident("u_n_r")
            + Expr::ident("p_r") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_u_y",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_u_y_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_u_y_r")
                + Expr::ident("a_prod_scaled")
                    * (Expr::ident("rho_u_r").field("y") - Expr::ident("rho_u_l").field("y")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_x",
        (-Expr::ident("mu")) * (Expr::ident("u_r_x") - Expr::ident("u_l_x")) / Expr::ident("dist"),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_y",
        (-Expr::ident("mu")) * (Expr::ident("u_r_y") - Expr::ident("u_l_y")) / Expr::ident("dist"),
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_u_x"),
        Expr::ident("flux_rho_u_x") + Expr::ident("diff_u_x"),
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_u_y"),
        Expr::ident("flux_rho_u_y") + Expr::ident("diff_u_y"),
    ));

    loop_body.push(dsl::let_expr(
        "flux_rho_e_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("u_n_l"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_e_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("u_n_r"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_e",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_e_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_e_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_e_r") - Expr::ident("rho_e_l")),
        ),
    ));

    // Rhie–Chow-style pressure flux coupling is only used with low-Mach preconditioning.
    // (In the pure KT mode it can introduce dispersive/odd-even pressure ringing.)
    let pressure_coupling_block = dsl::block(vec![
        dsl::let_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("normal")).expr(),
        ),
        dsl::let_expr(
            "inv_rho_l_cell",
            Expr::from(1.0) / dsl::max("rho_l_cell", 1e-8),
        ),
        dsl::let_expr(
            "inv_rho_r_cell",
            Expr::from(1.0) / dsl::max("rho_r_cell", 1e-8),
        ),
        dsl::let_typed_expr(
            "u_l_cell",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l_cell"))
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "u_r_cell",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r_cell"))
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_expr(
            "u2_l_cell",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))),
        ),
        dsl::let_expr(
            "u2_r_cell",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))),
        ),
        dsl::let_typed_expr(
            "grad_rho_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho").index(Expr::ident("idx")))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_x_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_y_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_e_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_e").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_x_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_y_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_e_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_x_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("x")),
                )
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_y_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("y")),
                )
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_x_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("x")),
                )
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_y_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("y")),
                )
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u2_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_l_vec"))
                .mul_scalar(Expr::ident("u_l_cell").field("x") * 2.0)
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("y") * 2.0),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u2_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_r_vec"))
                .mul_scalar(Expr::ident("u_r_cell").field("x") * 2.0)
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("y") * 2.0),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u2_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                .mul_scalar(Expr::ident("u2_l_cell"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_l_vec"))
                        .mul_scalar(Expr::ident("rho_l_cell")),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u2_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                .mul_scalar(Expr::ident("u2_r_cell"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_r_vec"))
                        .mul_scalar(Expr::ident("rho_r_cell")),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_p_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_l_vec"))
                        .mul_scalar(0.5.into()),
                )
                .mul_scalar(gamma_minus_1.into())
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_p_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_r_vec"))
                        .mul_scalar(0.5.into()),
                )
                .mul_scalar(gamma_minus_1.into())
                .expr(),
        ),
        dsl::let_expr(
            "grad_p_l_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_l_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::let_expr(
            "grad_p_r_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_r_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::let_expr(
            "grad_p_face_n",
            (Expr::ident("grad_p_l_n") + Expr::ident("grad_p_r_n")) * 0.5,
        ),
        dsl::let_expr(
            "grad_p_jump_n",
            (Expr::ident("p_r") - Expr::ident("p_l")) / Expr::ident("dist"),
        ),
        dsl::let_expr(
            "rho_face",
            (Expr::ident("rho_l") + Expr::ident("rho_r")) * 0.5,
        ),
        dsl::let_expr("p_bar", (Expr::ident("p_l") + Expr::ident("p_r")) * 0.5),
        dsl::let_expr(
            "dp_rel",
            dsl::abs(Expr::ident("p_r") - Expr::ident("p_l")) / dsl::max("p_bar", 1e-6),
        ),
        dsl::let_expr(
            "pc_theta",
            dsl::min(
                1.0,
                dsl::max(
                    Expr::ident("mach2"),
                    Expr::ident("low_mach").field("theta_floor"),
                ),
            ),
        ),
        dsl::let_expr("pc_low_mach", Expr::from(1.0) - Expr::ident("pc_theta")),
        dsl::let_expr(
            "pc_smooth",
            Expr::from(1.0) / ((Expr::ident("dp_rel") / 0.2) * (Expr::ident("dp_rel") / 0.2) + 1.0),
        ),
        dsl::let_expr(
            "pc_alpha",
            Expr::ident("low_mach").field("pressure_coupling_alpha")
                * Expr::ident("pc_low_mach")
                * Expr::ident("pc_smooth"),
        ),
        dsl::let_expr(
            "m_corr",
            Expr::ident("pc_alpha") * Expr::ident("constants").field("dt")
                / dsl::max("rho_face", 1e-8)
                * (Expr::ident("grad_p_face_n") - Expr::ident("grad_p_jump_n")),
        ),
        dsl::let_expr(
            "h_l",
            (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
        ),
        dsl::let_expr(
            "h_r",
            (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
        ),
        dsl::let_expr("h_face", (Expr::ident("h_l") + Expr::ident("h_r")) * 0.5),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho"),
            Expr::ident("m_corr"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_u_x"),
            Expr::ident("m_corr") * Expr::ident("u_face_x"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_u_y"),
            Expr::ident("m_corr") * Expr::ident("u_face_y"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_e"),
            Expr::ident("m_corr") * Expr::ident("h_face"),
        ),
    ]);
    loop_body.push(dsl::if_block_expr(
        (!Expr::ident("is_boundary"))
            & precond_model.ne(GpuLowMachPrecondModel::Off)
            & Expr::ident("low_mach")
                .field("pressure_coupling_alpha")
                .gt(0.0),
        pressure_coupling_block,
        None,
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_e"),
        Expr::ident("flux_rho_e")
            + Expr::ident("diff_u_x") * Expr::ident("u_face_x")
            + Expr::ident("diff_u_y") * Expr::ident("u_face_y"),
    ));

    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho"),
        Expr::ident("flux_rho") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_u_x"),
        Expr::ident("flux_rho_u_x") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_u_y"),
        Expr::ident("flux_rho_u_y") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_e"),
        Expr::ident("flux_rho_e") * Expr::ident("area"),
    ));

    loop_body.push(dsl::let_expr(
        "q_l",
        Expr::ident("u_l_x") * Expr::ident("u_l_x") + Expr::ident("u_l_y") * Expr::ident("u_l_y"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drho_l",
        Expr::from(gamma_minus_1) * Expr::ident("q_l") * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "dp_dru_l",
        Expr::from(-gamma_minus_1) * Expr::ident("u_l_x"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drv_l",
        Expr::from(-gamma_minus_1) * Expr::ident("u_l_y"),
    ));
    loop_body.push(dsl::let_expr("dp_dre_l", gamma_minus_1));
    loop_body.push(dsl::let_expr(
        "H_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
    ));

    loop_body.push(dsl::let_expr(
        "q_r",
        Expr::ident("u_r_x") * Expr::ident("u_r_x") + Expr::ident("u_r_y") * Expr::ident("u_r_y"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drho_r",
        Expr::from(gamma_minus_1) * Expr::ident("q_r") * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "dp_dru_r",
        Expr::from(-gamma_minus_1) * Expr::ident("u_r_x"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drv_r",
        Expr::from(-gamma_minus_1) * Expr::ident("u_r_y"),
    ));
    loop_body.push(dsl::let_expr("dp_dre_r", gamma_minus_1));
    loop_body.push(dsl::let_expr(
        "H_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
    ));

    loop_body.push(dsl::let_expr(
        "a_l",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    loop_body.push(dsl::let_expr(
        "a_r",
        (-Expr::ident("a_minus")) / Expr::ident("denom"),
    ));

    loop_body.push(dsl::let_expr(
        "mu_over_dist",
        Expr::ident("mu") / Expr::ident("dist"),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_vec",
        Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("u_face_x"), Expr::ident("u_face_y")],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_vec",
        Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("diff_u_x"), Expr::ident("diff_u_y")],
        ),
    ));

    let a_prod_scaled = Expr::ident("a_prod_scaled");
    let a_l = Expr::ident("a_l");
    let a_r = Expr::ident("a_r");
    let normal = Expr::ident("normal");
    let nx = normal.field("x");
    let ny = normal.field("y");
    let zero: Expr = 0.0.into();
    let one: Expr = 1.0.into();
    let gamma: Expr = Expr::from(gamma_value);
    let u_n_l = Expr::ident("u_n_l");
    let u_n_r = Expr::ident("u_n_r");
    let u_l_x = Expr::ident("u_l_x");
    let u_l_y = Expr::ident("u_l_y");
    let u_r_x = Expr::ident("u_r_x");
    let u_r_y = Expr::ident("u_r_y");
    let dp_drho_l = Expr::ident("dp_drho_l");
    let dp_dru_l = Expr::ident("dp_dru_l");
    let dp_drv_l = Expr::ident("dp_drv_l");
    let dp_dre_l = Expr::ident("dp_dre_l");
    let dp_drho_r = Expr::ident("dp_drho_r");
    let dp_dru_r = Expr::ident("dp_dru_r");
    let dp_drv_r = Expr::ident("dp_drv_r");
    let dp_dre_r = Expr::ident("dp_dre_r");
    let h_l = Expr::ident("H_l");
    let h_r = Expr::ident("H_r");
    let mu_over_dist = Expr::ident("mu_over_dist");

    let u_face = typed::NamedVecExpr::<2, typed::AxisXY>::from_expr(Expr::ident("u_face_vec"));
    let diff_u = typed::NamedVecExpr::<2, typed::AxisXY>::from_expr(Expr::ident("diff_u_vec"));

    let a_l_mat = typed::MatExpr::<4, 4>::from_entries([
        [zero, nx, ny, zero],
        [
            dp_drho_l * nx - u_l_x * u_n_l,
            u_n_l + nx * (u_l_x + dp_dru_l),
            u_l_x * ny + dp_drv_l * nx,
            dp_dre_l * nx,
        ],
        [
            dp_drho_l * ny - u_l_y * u_n_l,
            u_l_y * nx + dp_dru_l * ny,
            u_n_l + ny * (u_l_y + dp_drv_l),
            dp_dre_l * ny,
        ],
        [
            u_n_l * (dp_drho_l - h_l),
            h_l * nx + dp_dru_l * u_n_l,
            h_l * ny + dp_drv_l * u_n_l,
            gamma * u_n_l,
        ],
    ]);

    let a_r_mat = typed::MatExpr::<4, 4>::from_entries([
        [zero, nx, ny, zero],
        [
            dp_drho_r * nx - u_r_x * u_n_r,
            u_n_r + nx * (u_r_x + dp_dru_r),
            u_r_x * ny + dp_drv_r * nx,
            dp_dre_r * nx,
        ],
        [
            dp_drho_r * ny - u_r_y * u_n_r,
            u_r_y * nx + dp_dru_r * ny,
            u_n_r + ny * (u_r_y + dp_drv_r),
            dp_dre_r * ny,
        ],
        [
            u_n_r * (dp_drho_r - h_r),
            h_r * nx + dp_dru_r * u_n_r,
            h_r * ny + dp_drv_r * u_n_r,
            gamma * u_n_r,
        ],
    ]);

    let velocity_jacobian = |u_x: Expr, u_y: Expr, inv_rho: Expr| {
        typed::NamedMatExpr::<2, 4, typed::AxisXY, typed::AxisCons>::from_entries([
            [(-u_x) * inv_rho, inv_rho, zero, zero],
            [(-u_y) * inv_rho, zero, inv_rho, zero],
        ])
    };

    let du_l_d_cons = velocity_jacobian(u_l_x, u_l_y, Expr::ident("inv_rho_l"));
    let du_r_d_cons = velocity_jacobian(u_r_x, u_r_y, Expr::ident("inv_rho_r"));

    let d_diff_l = du_l_d_cons.mul_scalar(mu_over_dist);
    let d_diff_r = du_r_d_cons.mul_scalar(-mu_over_dist);

    let du_face_l = du_l_d_cons.mul_scalar(0.5.into());
    let du_face_r = du_r_d_cons.mul_scalar(0.5.into());

    let d_e_visc_l = d_diff_l
        .contract_rows(&u_face)
        .add(&du_face_l.contract_rows(&diff_u));
    let d_e_visc_r = d_diff_r
        .contract_rows(&u_face)
        .add(&du_face_r.contract_rows(&diff_u));

    let visc_l = typed::MatExpr::<4, 4>::from_entries([
        [zero, zero, zero, zero],
        [
            d_diff_l.at(typed::XY::X, typed::Cons::Rho),
            d_diff_l.at(typed::XY::X, typed::Cons::Ru),
            d_diff_l.at(typed::XY::X, typed::Cons::Rv),
            d_diff_l.at(typed::XY::X, typed::Cons::Re),
        ],
        [
            d_diff_l.at(typed::XY::Y, typed::Cons::Rho),
            d_diff_l.at(typed::XY::Y, typed::Cons::Ru),
            d_diff_l.at(typed::XY::Y, typed::Cons::Rv),
            d_diff_l.at(typed::XY::Y, typed::Cons::Re),
        ],
        [
            d_e_visc_l.at(typed::Cons::Rho),
            d_e_visc_l.at(typed::Cons::Ru),
            d_e_visc_l.at(typed::Cons::Rv),
            d_e_visc_l.at(typed::Cons::Re),
        ],
    ]);
    let visc_r = typed::MatExpr::<4, 4>::from_entries([
        [zero, zero, zero, zero],
        [
            d_diff_r.at(typed::XY::X, typed::Cons::Rho),
            d_diff_r.at(typed::XY::X, typed::Cons::Ru),
            d_diff_r.at(typed::XY::X, typed::Cons::Rv),
            d_diff_r.at(typed::XY::X, typed::Cons::Re),
        ],
        [
            d_diff_r.at(typed::XY::Y, typed::Cons::Rho),
            d_diff_r.at(typed::XY::Y, typed::Cons::Ru),
            d_diff_r.at(typed::XY::Y, typed::Cons::Rv),
            d_diff_r.at(typed::XY::Y, typed::Cons::Re),
        ],
        [
            d_e_visc_r.at(typed::Cons::Rho),
            d_e_visc_r.at(typed::Cons::Ru),
            d_e_visc_r.at(typed::Cons::Rv),
            d_e_visc_r.at(typed::Cons::Re),
        ],
    ]);

    let diag_term = typed::MatExpr::<4, 4>::identity().mul_scalar(a_prod_scaled);
    let jac_l = a_l_mat.mul_scalar(a_l).add(&visc_l).sub(&diag_term);
    let jac_r = a_r_mat.mul_scalar(a_r).add(&visc_r).add(&diag_term);

    let mut interior_matrix_stmts = vec![
        dsl::let_expr(
            "scalar_mat_idx",
            Expr::ident("cell_face_matrix_indices").index(Expr::ident("face_offset")),
        ),
        dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ),
    ];

    let neighbor_entry = block_matrix.row_entry(&Expr::ident("neighbor_rank"));
    // Write full neighbor block to avoid stale values.
    for row in 0..(block_size as usize) {
        for col in 0..(block_size as usize) {
            interior_matrix_stmts.push(dsl::assign_expr(
                neighbor_entry.entry(row as u8, col as u8).expr,
                0.0,
            ));
        }
    }
    // Scatter the Euler 4x4 off-diagonal block into system indices.
    for e_r in 0..4usize {
        for e_c in 0..4usize {
            let sys_r = euler_sys_indices[e_r];
            let sys_c = euler_sys_indices[e_c];
            interior_matrix_stmts.push(dsl::assign_expr(
                neighbor_entry.entry(sys_r as u8, sys_c as u8).expr,
                jac_r.entry(e_r, e_c) * Expr::ident("area"),
            ));
        }
    }
    // Add Euler 4x4 contribution to the diagonal block.
    for e_r in 0..4usize {
        for e_c in 0..4usize {
            let sys_r = euler_sys_indices[e_r];
            let sys_c = euler_sys_indices[e_c];
            interior_matrix_stmts.push(dsl::assign_op_expr(
                AssignOp::Add,
                diag_entry.entry(sys_r as u8, sys_c as u8).expr,
                jac_l.entry(e_r, e_c) * Expr::ident("area"),
            ));
        }
    }

    let interior_matrix = dsl::block(interior_matrix_stmts);

    let boundary_matrix = {
        let area = Expr::ident("area");

        // Dirichlet => 0, otherwise 1 (applied to columns of jac_r in Euler ordering).
        let bc_base = Expr::ident("boundary_type") * Expr::from(unknowns_per_cell);
        let t_rho = dsl::select(
            one,
            zero,
            typed::EnumExpr::<GpuBcKind>::from_expr(
                Expr::ident("bc_kind").index(bc_base + idx_rho),
            )
            .eq(GpuBcKind::Dirichlet),
        );
        let t_ru = dsl::select(
            one,
            zero,
            typed::EnumExpr::<GpuBcKind>::from_expr(
                Expr::ident("bc_kind").index(bc_base + idx_ru),
            )
            .eq(GpuBcKind::Dirichlet),
        );
        let t_rv = dsl::select(
            one,
            zero,
            typed::EnumExpr::<GpuBcKind>::from_expr(
                Expr::ident("bc_kind").index(bc_base + idx_rv),
            )
            .eq(GpuBcKind::Dirichlet),
        );
        let t_re = dsl::select(
            one,
            zero,
            typed::EnumExpr::<GpuBcKind>::from_expr(
                Expr::ident("bc_kind").index(bc_base + idx_re),
            )
            .eq(GpuBcKind::Dirichlet),
        );

        let t_bc = typed::MatExpr::<4, 4>::from_entries([
            [t_rho, zero, zero, zero],
            [zero, t_ru, zero, zero],
            [zero, zero, t_rv, zero],
            [zero, zero, zero, t_re],
        ]);
        let eff_bc = jac_l.add(&jac_r.mul_mat(&t_bc));

        let mut b_stmts = Vec::new();
        for e_r in 0..4usize {
            for e_c in 0..4usize {
                let sys_r = euler_sys_indices[e_r];
                let sys_c = euler_sys_indices[e_c];
                b_stmts.push(dsl::assign_op_expr(
                    AssignOp::Add,
                    diag_entry.entry(sys_r as u8, sys_c as u8).expr,
                    eff_bc.entry(e_r, e_c) * area,
                ));
            }
        }
        dsl::block(b_stmts)
    };

    loop_body.push(dsl::if_block_expr(
        !Expr::ident("is_boundary"),
        interior_matrix,
        Some(boundary_matrix),
    ));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("face_offset", Expr::ident("start")),
        Expr::ident("face_offset").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("face_offset")),
        dsl::block(loop_body),
    ));

    stmts.push(dsl::var_typed_expr(
        "rhs_rho",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho") + Expr::ident("rhs_pseudo_rho")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo")) * Expr::ident("rho")
                - Expr::ident("sum_rho"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_u_x",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_u_x") + Expr::ident("rhs_pseudo_rho_u_x")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo"))
                    * Expr::ident("rho_u").field("x")
                - Expr::ident("sum_rho_u_x"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_u_y",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_u_y") + Expr::ident("rhs_pseudo_rho_u_y")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo"))
                    * Expr::ident("rho_u").field("y")
                - Expr::ident("sum_rho_u_y"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_e",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_e") + Expr::ident("rhs_pseudo_rho_e")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo")) * Expr::ident("rho_e")
                - Expr::ident("sum_rho_e"),
        ),
    ));

    // Add time/pseudo diagonal terms for the Euler components.
    for &sys_i in &euler_sys_indices {
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            diag_entry.entry(sys_i as u8, sys_i as u8).expr,
            Expr::ident("coeff_time"),
        ));
        stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            diag_entry.entry(sys_i as u8, sys_i as u8).expr,
            Expr::ident("coeff_pseudo"),
        ));
    }

    // Write RHS for all system components.
    for sys_i in 0..(unknowns_per_cell as usize) {
        let rhs_value = if sys_i as u32 == idx_rho {
            Expr::ident("rhs_rho")
        } else if sys_i as u32 == idx_ru {
            Expr::ident("rhs_rho_u_x")
        } else if sys_i as u32 == idx_rv {
            Expr::ident("rhs_rho_u_y")
        } else if sys_i as u32 == idx_re {
            Expr::ident("rhs_rho_e")
        } else {
            let (field_name, component) = unknown_components[sys_i];
            state_component(layout, "state", "idx", field_name, component)
        };

        stmts.push(dsl::assign_array_access_linear(
            "rhs",
            Expr::ident("idx"),
            unknowns_per_cell,
            sys_i as u32,
            rhs_value,
        ));
    }

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_assembly_codegen_emits_bindings() {
        let model = compressible_model();
        let wgsl = generate_ei_assembly_wgsl(&model.state_layout, &model.system, &model.eos);
        assert!(wgsl.contains("matrix_values"));
        assert!(wgsl.contains("rhs"));
        assert!(wgsl.contains("scalar_row_offsets"));
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("sum_rho"));
        assert!(wgsl.contains("rhs_time_rho"));
        assert!(wgsl.contains("dp_drho_l"));
        assert!(!wgsl.contains("A_l_10"));
    }
}
