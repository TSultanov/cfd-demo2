// GENERATED BY CFD2 CODEGEN (compressible_flux_kt)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
    pressure_coupling_alpha: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(8) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(9) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@group(1) @binding(9) 
var<storage, read> state_iter: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    let center_owner = cell_centers[owner];
    let center_owner_vec: vec2<f32> = vec2<f32>(center_owner.x, center_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    if (dot(face_center_vec - center_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    var is_boundary = false;
    var other_idx = owner;
    let rho_l_cell = state_old[owner * 7u + 0u];
    let rho_u_l_cell = vec2<f32>(state_old[owner * 7u + 1u], state_old[owner * 7u + 2u]);
    let rho_e_l_cell = state_old[owner * 7u + 3u];
    var rho_l = rho_l_cell;
    var rho_u_l = rho_u_l_cell;
    var rho_e_l = rho_e_l_cell;
    var rho_r = rho_l;
    var rho_u_r = rho_u_l;
    var rho_e_r = rho_e_l;
    var center_r = face_center;
    if (neighbor != -1) {
        let neigh_idx = u32(neighbor);
        other_idx = neigh_idx;
        let rho_neigh = state_old[neigh_idx * 7u + 0u];
        let rho_u_neigh = vec2<f32>(state_old[neigh_idx * 7u + 1u], state_old[neigh_idx * 7u + 2u]);
        let rho_e_neigh = state_old[neigh_idx * 7u + 3u];
        rho_r = rho_neigh;
        rho_u_r = rho_u_neigh;
        rho_e_r = rho_e_neigh;
        center_r = cell_centers[neigh_idx];
    } else {
        is_boundary = true;
        if (boundary_type == 1u) {
            rho_u_r = vec2<f32>(rho_r * constants.inlet_velocity, 0.0);
        } else {
            if (boundary_type == 3u) {
                let m_dot_n = dot(rho_u_l, normal_vec);
                rho_u_r = rho_u_l - normal_vec * 2.0 * m_dot_n;
            }
        }
    }
    let rho_r_cell = rho_r;
    let rho_u_r_cell = rho_u_r;
    let rho_e_r_cell = rho_e_r;
    if (!is_boundary && constants.scheme == 1u) {
        let r_l_x = face_center.x - center_owner.x;
        let r_l_y = face_center.y - center_owner.y;
        let r_r_x = face_center.x - center_r.x;
        let r_r_y = face_center.y - center_r.y;
        let grad_rho_l = grad_rho[owner];
        let grad_rho_u_x_l = grad_rho_u_x[owner];
        let grad_rho_u_y_l = grad_rho_u_y[owner];
        let grad_rho_e_l = grad_rho_e[owner];
        let grad_rho_r = grad_rho[other_idx];
        let grad_rho_u_x_r = grad_rho_u_x[other_idx];
        let grad_rho_u_y_r = grad_rho_u_y[other_idx];
        let grad_rho_e_r = grad_rho_e[other_idx];
        let diff_rho_l = rho_r_cell - rho_l_cell;
        let min_diff_rho_l = min(diff_rho_l, 0.0);
        let max_diff_rho_l = max(diff_rho_l, 0.0);
        let delta_rho_l = dot(vec2<f32>(grad_rho_l.x, grad_rho_l.y), vec2<f32>(r_l_x, r_l_y));
        let delta_rho_l_limited = min(max(delta_rho_l, min_diff_rho_l), max_diff_rho_l);
        let rho_l_face = rho_l_cell + delta_rho_l_limited;
        let diff_rho_u_x_l = rho_u_r_cell.x - rho_u_l_cell.x;
        let min_diff_rho_u_x_l = min(diff_rho_u_x_l, 0.0);
        let max_diff_rho_u_x_l = max(diff_rho_u_x_l, 0.0);
        let delta_rho_u_x_l = dot(vec2<f32>(grad_rho_u_x_l.x, grad_rho_u_x_l.y), vec2<f32>(r_l_x, r_l_y));
        let delta_rho_u_x_l_limited = min(max(delta_rho_u_x_l, min_diff_rho_u_x_l), max_diff_rho_u_x_l);
        let rho_u_x_l_face = rho_u_l_cell.x + delta_rho_u_x_l_limited;
        let diff_rho_u_y_l = rho_u_r_cell.y - rho_u_l_cell.y;
        let min_diff_rho_u_y_l = min(diff_rho_u_y_l, 0.0);
        let max_diff_rho_u_y_l = max(diff_rho_u_y_l, 0.0);
        let delta_rho_u_y_l = dot(vec2<f32>(grad_rho_u_y_l.x, grad_rho_u_y_l.y), vec2<f32>(r_l_x, r_l_y));
        let delta_rho_u_y_l_limited = min(max(delta_rho_u_y_l, min_diff_rho_u_y_l), max_diff_rho_u_y_l);
        let rho_u_y_l_face = rho_u_l_cell.y + delta_rho_u_y_l_limited;
        let diff_rho_e_l = rho_e_r_cell - rho_e_l_cell;
        let min_diff_rho_e_l = min(diff_rho_e_l, 0.0);
        let max_diff_rho_e_l = max(diff_rho_e_l, 0.0);
        let delta_rho_e_l = dot(vec2<f32>(grad_rho_e_l.x, grad_rho_e_l.y), vec2<f32>(r_l_x, r_l_y));
        let delta_rho_e_l_limited = min(max(delta_rho_e_l, min_diff_rho_e_l), max_diff_rho_e_l);
        let rho_e_l_face = rho_e_l_cell + delta_rho_e_l_limited;
        let diff_rho_r = rho_l_cell - rho_r_cell;
        let min_diff_rho_r = min(diff_rho_r, 0.0);
        let max_diff_rho_r = max(diff_rho_r, 0.0);
        let delta_rho_r = dot(vec2<f32>(grad_rho_r.x, grad_rho_r.y), vec2<f32>(r_r_x, r_r_y));
        let delta_rho_r_limited = min(max(delta_rho_r, min_diff_rho_r), max_diff_rho_r);
        let rho_r_face = rho_r_cell + delta_rho_r_limited;
        let diff_rho_u_x_r = rho_u_l_cell.x - rho_u_r_cell.x;
        let min_diff_rho_u_x_r = min(diff_rho_u_x_r, 0.0);
        let max_diff_rho_u_x_r = max(diff_rho_u_x_r, 0.0);
        let delta_rho_u_x_r = dot(vec2<f32>(grad_rho_u_x_r.x, grad_rho_u_x_r.y), vec2<f32>(r_r_x, r_r_y));
        let delta_rho_u_x_r_limited = min(max(delta_rho_u_x_r, min_diff_rho_u_x_r), max_diff_rho_u_x_r);
        let rho_u_x_r_face = rho_u_r_cell.x + delta_rho_u_x_r_limited;
        let diff_rho_u_y_r = rho_u_l_cell.y - rho_u_r_cell.y;
        let min_diff_rho_u_y_r = min(diff_rho_u_y_r, 0.0);
        let max_diff_rho_u_y_r = max(diff_rho_u_y_r, 0.0);
        let delta_rho_u_y_r = dot(vec2<f32>(grad_rho_u_y_r.x, grad_rho_u_y_r.y), vec2<f32>(r_r_x, r_r_y));
        let delta_rho_u_y_r_limited = min(max(delta_rho_u_y_r, min_diff_rho_u_y_r), max_diff_rho_u_y_r);
        let rho_u_y_r_face = rho_u_r_cell.y + delta_rho_u_y_r_limited;
        let diff_rho_e_r = rho_e_l_cell - rho_e_r_cell;
        let min_diff_rho_e_r = min(diff_rho_e_r, 0.0);
        let max_diff_rho_e_r = max(diff_rho_e_r, 0.0);
        let delta_rho_e_r = dot(vec2<f32>(grad_rho_e_r.x, grad_rho_e_r.y), vec2<f32>(r_r_x, r_r_y));
        let delta_rho_e_r_limited = min(max(delta_rho_e_r, min_diff_rho_e_r), max_diff_rho_e_r);
        let rho_e_r_face = rho_e_r_cell + delta_rho_e_r_limited;
        rho_l = rho_l_face;
        rho_u_l = vec2<f32>(rho_u_x_l_face, rho_u_y_l_face);
        rho_e_l = rho_e_l_face;
        rho_r = rho_r_face;
        rho_u_r = vec2<f32>(rho_u_x_r_face, rho_u_y_r_face);
        rho_e_r = rho_e_r_face;
    }
    let inv_rho_l = 1.0 / max(rho_l, 1e-8);
    let u_l: vec2<f32> = rho_u_l * inv_rho_l;
    let ke_l = 0.5 * rho_l * dot(u_l, u_l);
    let p_l = max(0.0, (1.4 - 1.0) * (rho_e_l - ke_l));
    let u_n_l = dot(u_l, normal_vec);
    let c_l = sqrt(1.4 * p_l * inv_rho_l);
    let inv_rho_r = 1.0 / max(rho_r, 1e-8);
    let u_r: vec2<f32> = rho_u_r * inv_rho_r;
    let ke_r = 0.5 * rho_r * dot(u_r, u_r);
    let p_r = max(0.0, (1.4 - 1.0) * (rho_e_r - ke_r));
    let u_n_r = dot(u_r, normal_vec);
    let c_r = sqrt(1.4 * p_r * inv_rho_r);
    let u_face: vec2<f32> = (u_l + u_r) * 0.5;
    let u_face_n = dot(u_face, normal_vec);
    let c_bar = 0.5 * (c_l + c_r);
    let mach = abs(u_face_n) / max(c_bar, 1e-6);
    let mach2 = mach * mach;
    var c_l_eff = c_l;
    var c_r_eff = c_r;
    if (constants.precond_model == 0u) {
        c_l_eff = c_l * mach;
        c_r_eff = c_r * mach;
    } else {
        if (constants.precond_model == 1u) {
            let theta = min(1.0, max(mach2, constants.precond_theta_floor));
            let one_minus_theta = 1.0 - theta;
            c_l_eff = sqrt(theta * c_l * c_l + one_minus_theta * u_n_l * u_n_l);
            c_r_eff = sqrt(theta * c_r * c_r + one_minus_theta * u_n_r * u_n_r);
        }
    }
    let center_r_vec: vec2<f32> = vec2<f32>(center_r.x, center_r.y);
    let d_center: vec2<f32> = center_r_vec - center_owner_vec;
    let dist = max(length(d_center), 0.000001);
    let mu = constants.viscosity;
    let a_plus = max(0.0, max(u_n_l + c_l_eff, u_n_r + c_r_eff));
    let a_minus = min(0.0, min(u_n_l - c_l_eff, u_n_r - c_r_eff));
    let denom = max(a_plus - a_minus, 1e-6);
    let a_prod = a_plus * a_minus;
    let a_pos = a_plus / denom;
    let a_neg = 1.0 - a_pos;
    let a_prod_scaled = a_prod / denom;
    let flux_rho_l = rho_l * u_n_l;
    let flux_rho_r = rho_r * u_n_r;
    var flux_rho = a_pos * flux_rho_l + a_neg * flux_rho_r + a_prod_scaled * (rho_r - rho_l);
    let flux_rho_u_l: vec2<f32> = rho_u_l * u_n_l + normal_vec * p_l;
    let flux_rho_u_r: vec2<f32> = rho_u_r * u_n_r + normal_vec * p_r;
    let rho_u_jump: vec2<f32> = rho_u_r - rho_u_l;
    var flux_rho_u: vec2<f32> = flux_rho_u_l * a_pos + flux_rho_u_r * a_neg + rho_u_jump * a_prod_scaled;
    let visc_scale = -1.0 * mu / dist;
    let diff_u: vec2<f32> = (u_r - u_l) * visc_scale;
    flux_rho_u = flux_rho_u + diff_u;
    let flux_rho_e_l = (rho_e_l + p_l) * u_n_l;
    let flux_rho_e_r = (rho_e_r + p_r) * u_n_r;
    var flux_rho_e = a_pos * flux_rho_e_l + a_neg * flux_rho_e_r + a_prod_scaled * (rho_e_r - rho_e_l);
    let inv_rho_l_cell = 1.0 / max(rho_l_cell, 1e-8);
    let inv_rho_r_cell = 1.0 / max(rho_r_cell, 1e-8);
    let u_l_cell: vec2<f32> = rho_u_l_cell * inv_rho_l_cell;
    let u_r_cell: vec2<f32> = rho_u_r_cell * inv_rho_r_cell;
    let u2_l_cell = dot(u_l_cell, u_l_cell);
    let u2_r_cell = dot(u_r_cell, u_r_cell);
    let grad_rho_l_vec: vec2<f32> = vec2<f32>(grad_rho[owner].x, grad_rho[owner].y);
    let grad_rho_u_x_l_vec: vec2<f32> = vec2<f32>(grad_rho_u_x[owner].x, grad_rho_u_x[owner].y);
    let grad_rho_u_y_l_vec: vec2<f32> = vec2<f32>(grad_rho_u_y[owner].x, grad_rho_u_y[owner].y);
    let grad_rho_e_l_vec: vec2<f32> = vec2<f32>(grad_rho_e[owner].x, grad_rho_e[owner].y);
    let grad_rho_r_vec: vec2<f32> = vec2<f32>(grad_rho[other_idx].x, grad_rho[other_idx].y);
    let grad_rho_u_x_r_vec: vec2<f32> = vec2<f32>(grad_rho_u_x[other_idx].x, grad_rho_u_x[other_idx].y);
    let grad_rho_u_y_r_vec: vec2<f32> = vec2<f32>(grad_rho_u_y[other_idx].x, grad_rho_u_y[other_idx].y);
    let grad_rho_e_r_vec: vec2<f32> = vec2<f32>(grad_rho_e[other_idx].x, grad_rho_e[other_idx].y);
    let grad_u_x_l_vec: vec2<f32> = (grad_rho_u_x_l_vec - grad_rho_l_vec * u_l_cell.x) * inv_rho_l_cell;
    let grad_u_y_l_vec: vec2<f32> = (grad_rho_u_y_l_vec - grad_rho_l_vec * u_l_cell.y) * inv_rho_l_cell;
    let grad_u_x_r_vec: vec2<f32> = (grad_rho_u_x_r_vec - grad_rho_r_vec * u_r_cell.x) * inv_rho_r_cell;
    let grad_u_y_r_vec: vec2<f32> = (grad_rho_u_y_r_vec - grad_rho_r_vec * u_r_cell.y) * inv_rho_r_cell;
    let grad_u2_l_vec: vec2<f32> = grad_u_x_l_vec * 2.0 * u_l_cell.x + grad_u_y_l_vec * 2.0 * u_l_cell.y;
    let grad_u2_r_vec: vec2<f32> = grad_u_x_r_vec * 2.0 * u_r_cell.x + grad_u_y_r_vec * 2.0 * u_r_cell.y;
    let grad_rho_u2_l_vec: vec2<f32> = grad_rho_l_vec * u2_l_cell + grad_u2_l_vec * rho_l_cell;
    let grad_rho_u2_r_vec: vec2<f32> = grad_rho_r_vec * u2_r_cell + grad_u2_r_vec * rho_r_cell;
    let gamma_minus_1 = 1.4 - 1.0;
    let grad_p_l_vec: vec2<f32> = (grad_rho_e_l_vec - grad_rho_u2_l_vec * 0.5) * gamma_minus_1;
    let grad_p_r_vec: vec2<f32> = (grad_rho_e_r_vec - grad_rho_u2_r_vec * 0.5) * gamma_minus_1;
    let grad_p_l_n = dot(grad_p_l_vec, normal_vec);
    let grad_p_r_n = dot(grad_p_r_vec, normal_vec);
    let grad_p_face_n = 0.5 * (grad_p_l_n + grad_p_r_n);
    let grad_p_jump_n = (p_r - p_l) / dist;
    let rho_face = 0.5 * (rho_l + rho_r);
    let p_bar = 0.5 * (p_l + p_r);
    let dp_rel = abs(p_r - p_l) / max(p_bar, 1e-6);
    if (!is_boundary && constants.precond_model != 2u && constants.pressure_coupling_alpha > 0.0) {
        let pc_theta = min(1.0, max(mach2, constants.precond_theta_floor));
        let pc_low_mach = 1.0 - pc_theta;
        let pc_smooth = 1.0 / (1.0 + dp_rel / 0.2 * dp_rel / 0.2);
        let pc_alpha = constants.pressure_coupling_alpha * pc_low_mach * pc_smooth;
        let m_corr = pc_alpha * constants.dt / max(rho_face, 1e-8) * (grad_p_face_n - grad_p_jump_n);
        let h_l = (rho_e_l + p_l) * inv_rho_l;
        let h_r = (rho_e_r + p_r) * inv_rho_r;
        let h_face = 0.5 * (h_l + h_r);
        flux_rho = flux_rho + m_corr;
        flux_rho_u = flux_rho_u + u_face * m_corr;
        flux_rho_e = flux_rho_e + m_corr * h_face;
    }
    flux_rho_e = flux_rho_e + dot(diff_u, u_face);
    let base = idx * 4u;
    fluxes[base + 0u] = flux_rho * area;
    fluxes[base + 1u] = flux_rho_u.x * area;
    fluxes[base + 2u] = flux_rho_u.y * area;
    fluxes[base + 3u] = flux_rho_e * area;
}
