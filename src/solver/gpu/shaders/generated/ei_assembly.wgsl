// GENERATED BY CFD2 CODEGEN (ei_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(8) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(9) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@group(1) @binding(9) 
var<storage, read> state_iter: array<f32>;

@group(1) @binding(10) 
var<uniform> low_mach: LowMachParams;

// Group 2: Solver

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let vol = cell_vols[idx];
    let scalar_offset = scalar_row_offsets[idx];
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = scalar_offset * 16u;
    let start_row_1 = start_row_0 + num_neighbors * 4u;
    let start_row_2 = start_row_0 + num_neighbors * 8u;
    let start_row_3 = start_row_0 + num_neighbors * 12u;
    let scheme_id = constants.scheme;
    // Jacobian rows/cols: rho, rho_u_x, rho_u_y, rho_e
    var diag_00 = 0.0;
    var diag_01 = 0.0;
    var diag_02 = 0.0;
    var diag_03 = 0.0;
    var diag_10 = 0.0;
    var diag_11 = 0.0;
    var diag_12 = 0.0;
    var diag_13 = 0.0;
    var diag_20 = 0.0;
    var diag_21 = 0.0;
    var diag_22 = 0.0;
    var diag_23 = 0.0;
    var diag_30 = 0.0;
    var diag_31 = 0.0;
    var diag_32 = 0.0;
    var diag_33 = 0.0;
    var sum_rho: f32 = 0.0;
    var sum_rho_u_x: f32 = 0.0;
    var sum_rho_u_y: f32 = 0.0;
    var sum_rho_e: f32 = 0.0;
    let rho = state[idx * 7u + 0u];
    let rho_u: vec2<f32> = vec2<f32>(state[idx * 7u + 1u], state[idx * 7u + 2u]);
    let rho_e = state[idx * 7u + 3u];
    let rho_old = state_old[idx * 7u + 0u];
    let rho_u_old: vec2<f32> = vec2<f32>(state_old[idx * 7u + 1u], state_old[idx * 7u + 2u]);
    let rho_e_old = state_old[idx * 7u + 3u];
    var coeff_time: f32 = vol / constants.dt;
    var rhs_time_rho: f32 = coeff_time * rho_old;
    var rhs_time_rho_u_x: f32 = coeff_time * rho_u_old.x;
    var rhs_time_rho_u_y: f32 = coeff_time * rho_u_old.y;
    var rhs_time_rho_e: f32 = coeff_time * rho_e_old;
    var coeff_pseudo: f32 = 0.0;
    var rhs_pseudo_rho: f32 = 0.0;
    var rhs_pseudo_rho_u_x: f32 = 0.0;
    var rhs_pseudo_rho_u_y: f32 = 0.0;
    var rhs_pseudo_rho_e: f32 = 0.0;
    if (constants.dtau > 0.0) {
        let rho_iter = state_iter[idx * 7u + 0u];
        let rho_u_iter: vec2<f32> = vec2<f32>(state_iter[idx * 7u + 1u], state_iter[idx * 7u + 2u]);
        let rho_e_iter = state_iter[idx * 7u + 3u];
        coeff_pseudo = vol / constants.dtau;
        rhs_pseudo_rho = coeff_pseudo * rho_iter;
        rhs_pseudo_rho_u_x = coeff_pseudo * rho_u_iter.x;
        rhs_pseudo_rho_u_y = coeff_pseudo * rho_u_iter.y;
        rhs_pseudo_rho_e = coeff_pseudo * rho_e_iter;
    }
    if (constants.time_scheme == 1u) {
        let dt = constants.dt;
        let dt_old = constants.dt_old;
        let r = dt / dt_old;
        let rho_old_old = state_old_old[idx * 7u + 0u];
        let rho_u_old_old: vec2<f32> = vec2<f32>(state_old_old[idx * 7u + 1u], state_old_old[idx * 7u + 2u]);
        let rho_e_old_old = state_old_old[idx * 7u + 3u];
        coeff_time = vol / dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        let coeff_base = vol / dt;
        rhs_time_rho = coeff_base * (factor_n * rho_old - factor_nm1 * rho_old_old);
        rhs_time_rho_u_x = coeff_base * (factor_n * rho_u_old.x - factor_nm1 * rho_u_old_old.x);
        rhs_time_rho_u_y = coeff_base * (factor_n * rho_u_old.y - factor_nm1 * rho_u_old_old.y);
        rhs_time_rho_e = coeff_base * (factor_n * rho_e_old - factor_nm1 * rho_e_old_old);
    }
    for (var face_offset = start; face_offset < end; face_offset++) {
        let face_idx = cell_faces[face_offset];
        let owner = face_owner[face_idx];
        let neighbor = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        var normal: Vector2 = face_normals[face_idx];
        let f_center = face_centers[face_idx];
        var is_boundary: bool = false;
        var other_idx: u32 = 0u;
        var center_r: Vector2;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        let rho_l_cell = state[idx * 7u + 0u];
        let rho_u_l_cell: vec2<f32> = vec2<f32>(state[idx * 7u + 1u], state[idx * 7u + 2u]);
        let rho_e_l_cell = state[idx * 7u + 3u];
        var rho_l: f32 = rho_l_cell;
        var rho_u_l: vec2<f32> = rho_u_l_cell;
        var rho_e_l: f32 = rho_e_l_cell;
        var rho_r: f32 = rho_l;
        var rho_u_r: vec2<f32> = rho_u_l;
        var rho_e_r: f32 = rho_e_l;
        if (neighbor != -1) {
            let neigh_idx: u32 = u32(neighbor);
            other_idx = neigh_idx;
            if (owner != idx) {
                other_idx = owner;
            }
            center_r = cell_centers[other_idx];
            let rho_neigh = state[other_idx * 7u + 0u];
            let rho_u_neigh: vec2<f32> = vec2<f32>(state[other_idx * 7u + 1u], state[other_idx * 7u + 2u]);
            let rho_e_neigh = state[other_idx * 7u + 3u];
            rho_r = rho_neigh;
            rho_u_r = rho_u_neigh;
            rho_e_r = rho_e_neigh;
        } else {
            is_boundary = true;
            other_idx = idx;
            center_r = f_center;
        }
        if (is_boundary) {
            if (boundary_type == 1u) {
                rho_u_r = vec2<f32>(rho_r * constants.inlet_velocity, 0.0);
            } else {
                if (boundary_type == 3u) {
                    let normal_vec: vec2<f32> = vec2<f32>(normal.x, normal.y);
                    let m_dot_n = dot(rho_u_l, normal_vec);
                    rho_u_r = rho_u_l - normal_vec * m_dot_n * 2.0;
                }
            }
        }
        let rho_r_cell = rho_r;
        let rho_u_r_cell: vec2<f32> = rho_u_r;
        let rho_e_r_cell = rho_e_r;
        if (!is_boundary && scheme_id == 1u) {
            let r_l_x = f_center.x - center.x;
            let r_l_y = f_center.y - center.y;
            let r_r_x = f_center.x - center_r.x;
            let r_r_y = f_center.y - center_r.y;
            let grad_rho_l = grad_rho[idx];
            let grad_rho_u_x_l = grad_rho_u_x[idx];
            let grad_rho_u_y_l = grad_rho_u_y[idx];
            let grad_rho_e_l = grad_rho_e[idx];
            let grad_rho_r = grad_rho[other_idx];
            let grad_rho_u_x_r = grad_rho_u_x[other_idx];
            let grad_rho_u_y_r = grad_rho_u_y[other_idx];
            let grad_rho_e_r = grad_rho_e[other_idx];
            let diff_rho_l = rho_r_cell - rho_l_cell;
            let min_diff_rho_l = min(diff_rho_l, 0.0);
            let max_diff_rho_l = max(diff_rho_l, 0.0);
            let delta_rho_l = dot(vec2<f32>(grad_rho_l.x, grad_rho_l.y), vec2<f32>(r_l_x, r_l_y));
            let delta_rho_l_limited = min(max(delta_rho_l, min_diff_rho_l), max_diff_rho_l);
            let rho_l_face = rho_l_cell + delta_rho_l_limited;
            let diff_rho_u_x_l = rho_u_r_cell.x - rho_u_l_cell.x;
            let min_diff_rho_u_x_l = min(diff_rho_u_x_l, 0.0);
            let max_diff_rho_u_x_l = max(diff_rho_u_x_l, 0.0);
            let delta_rho_u_x_l = dot(vec2<f32>(grad_rho_u_x_l.x, grad_rho_u_x_l.y), vec2<f32>(r_l_x, r_l_y));
            let delta_rho_u_x_l_limited = min(max(delta_rho_u_x_l, min_diff_rho_u_x_l), max_diff_rho_u_x_l);
            let rho_u_x_l_face = rho_u_l_cell.x + delta_rho_u_x_l_limited;
            let diff_rho_u_y_l = rho_u_r_cell.y - rho_u_l_cell.y;
            let min_diff_rho_u_y_l = min(diff_rho_u_y_l, 0.0);
            let max_diff_rho_u_y_l = max(diff_rho_u_y_l, 0.0);
            let delta_rho_u_y_l = dot(vec2<f32>(grad_rho_u_y_l.x, grad_rho_u_y_l.y), vec2<f32>(r_l_x, r_l_y));
            let delta_rho_u_y_l_limited = min(max(delta_rho_u_y_l, min_diff_rho_u_y_l), max_diff_rho_u_y_l);
            let rho_u_y_l_face = rho_u_l_cell.y + delta_rho_u_y_l_limited;
            let diff_rho_e_l = rho_e_r_cell - rho_e_l_cell;
            let min_diff_rho_e_l = min(diff_rho_e_l, 0.0);
            let max_diff_rho_e_l = max(diff_rho_e_l, 0.0);
            let delta_rho_e_l = dot(vec2<f32>(grad_rho_e_l.x, grad_rho_e_l.y), vec2<f32>(r_l_x, r_l_y));
            let delta_rho_e_l_limited = min(max(delta_rho_e_l, min_diff_rho_e_l), max_diff_rho_e_l);
            let rho_e_l_face = rho_e_l_cell + delta_rho_e_l_limited;
            let diff_rho_r = rho_l_cell - rho_r_cell;
            let min_diff_rho_r = min(diff_rho_r, 0.0);
            let max_diff_rho_r = max(diff_rho_r, 0.0);
            let delta_rho_r = dot(vec2<f32>(grad_rho_r.x, grad_rho_r.y), vec2<f32>(r_r_x, r_r_y));
            let delta_rho_r_limited = min(max(delta_rho_r, min_diff_rho_r), max_diff_rho_r);
            let rho_r_face = rho_r_cell + delta_rho_r_limited;
            let diff_rho_u_x_r = rho_u_l_cell.x - rho_u_r_cell.x;
            let min_diff_rho_u_x_r = min(diff_rho_u_x_r, 0.0);
            let max_diff_rho_u_x_r = max(diff_rho_u_x_r, 0.0);
            let delta_rho_u_x_r = dot(vec2<f32>(grad_rho_u_x_r.x, grad_rho_u_x_r.y), vec2<f32>(r_r_x, r_r_y));
            let delta_rho_u_x_r_limited = min(max(delta_rho_u_x_r, min_diff_rho_u_x_r), max_diff_rho_u_x_r);
            let rho_u_x_r_face = rho_u_r_cell.x + delta_rho_u_x_r_limited;
            let diff_rho_u_y_r = rho_u_l_cell.y - rho_u_r_cell.y;
            let min_diff_rho_u_y_r = min(diff_rho_u_y_r, 0.0);
            let max_diff_rho_u_y_r = max(diff_rho_u_y_r, 0.0);
            let delta_rho_u_y_r = dot(vec2<f32>(grad_rho_u_y_r.x, grad_rho_u_y_r.y), vec2<f32>(r_r_x, r_r_y));
            let delta_rho_u_y_r_limited = min(max(delta_rho_u_y_r, min_diff_rho_u_y_r), max_diff_rho_u_y_r);
            let rho_u_y_r_face = rho_u_r_cell.y + delta_rho_u_y_r_limited;
            let diff_rho_e_r = rho_e_l_cell - rho_e_r_cell;
            let min_diff_rho_e_r = min(diff_rho_e_r, 0.0);
            let max_diff_rho_e_r = max(diff_rho_e_r, 0.0);
            let delta_rho_e_r = dot(vec2<f32>(grad_rho_e_r.x, grad_rho_e_r.y), vec2<f32>(r_r_x, r_r_y));
            let delta_rho_e_r_limited = min(max(delta_rho_e_r, min_diff_rho_e_r), max_diff_rho_e_r);
            let rho_e_r_face = rho_e_r_cell + delta_rho_e_r_limited;
            rho_l = rho_l_face;
            rho_u_l = vec2<f32>(rho_u_x_l_face, rho_u_y_l_face);
            rho_e_l = rho_e_l_face;
            rho_r = rho_r_face;
            rho_u_r = vec2<f32>(rho_u_x_r_face, rho_u_y_r_face);
            rho_e_r = rho_e_r_face;
        }
        let inv_rho_l = 1.0 / max(rho_l, 0.00000001);
        let u_l_x = rho_u_l.x * inv_rho_l;
        let u_l_y = rho_u_l.y * inv_rho_l;
        let ke_l = rho_l * (u_l_x * u_l_x + u_l_y * u_l_y) * 0.5;
        let p_l = max(0.0, (rho_e_l - ke_l) * 0.39999998);
        let u_n_l = u_l_x * normal.x + u_l_y * normal.y;
        let c_l = sqrt(p_l * inv_rho_l * 1.4);
        let inv_rho_r = 1.0 / max(rho_r, 0.00000001);
        let u_r_x = rho_u_r.x * inv_rho_r;
        let u_r_y = rho_u_r.y * inv_rho_r;
        let ke_r = rho_r * (u_r_x * u_r_x + u_r_y * u_r_y) * 0.5;
        let p_r = max(0.0, (rho_e_r - ke_r) * 0.39999998);
        let u_n_r = u_r_x * normal.x + u_r_y * normal.y;
        let c_r = sqrt(p_r * inv_rho_r * 1.4);
        let u_face_x = (u_l_x + u_r_x) * 0.5;
        let u_face_y = (u_l_y + u_r_y) * 0.5;
        let u_face_n = u_face_x * normal.x + u_face_y * normal.y;
        let c_bar = (c_l + c_r) * 0.5;
        let mach = abs(u_face_n) / max(c_bar, 0.000001);
        let mach2 = mach * mach;
        var c_l_eff: f32 = c_l;
        var c_r_eff: f32 = c_r;
        if (low_mach.model == 0u) {
            c_l_eff = c_l * mach;
            c_r_eff = c_r * mach;
        } else {
            if (low_mach.model == 1u) {
                let theta = min(1.0, max(mach2, low_mach.theta_floor));
                let one_minus_theta = 1.0 - theta;
                c_l_eff = sqrt(theta * c_l * c_l + one_minus_theta * u_n_l * u_n_l);
                c_r_eff = sqrt(theta * c_r * c_r + one_minus_theta * u_n_r * u_n_r);
            }
        }
        let flux_adv = u_face_n * area;
        let dx = center_r.x - center.x;
        let dy = center_r.y - center.y;
        let dist = max(sqrt(dx * dx + dy * dy), 0.000001);
        let mu = constants.viscosity;
        let a_plus = max(0.0, max(u_n_l + c_l_eff, u_n_r + c_r_eff));
        let a_minus = min(0.0, min(u_n_l - c_l_eff, u_n_r - c_r_eff));
        let denom = max(a_plus - a_minus, 0.000001);
        let a_prod = a_plus * a_minus;
        let a_pos = a_plus / denom;
        let a_neg = 1.0 - a_pos;
        let a_prod_scaled = a_prod / denom;
        let flux_rho_l = rho_l * u_n_l;
        let flux_rho_r = rho_r * u_n_r;
        var flux_rho: f32 = a_pos * flux_rho_l + a_neg * flux_rho_r + a_prod_scaled * (rho_r - rho_l);
        let flux_rho_u_x_l = rho_u_l.x * u_n_l + p_l * normal.x;
        let flux_rho_u_x_r = rho_u_r.x * u_n_r + p_r * normal.x;
        var flux_rho_u_x: f32 = a_pos * flux_rho_u_x_l + a_neg * flux_rho_u_x_r + a_prod_scaled * (rho_u_r.x - rho_u_l.x);
        let flux_rho_u_y_l = rho_u_l.y * u_n_l + p_l * normal.y;
        let flux_rho_u_y_r = rho_u_r.y * u_n_r + p_r * normal.y;
        var flux_rho_u_y: f32 = a_pos * flux_rho_u_y_l + a_neg * flux_rho_u_y_r + a_prod_scaled * (rho_u_r.y - rho_u_l.y);
        let diff_u_x = -mu * (u_r_x - u_l_x) / dist;
        let diff_u_y = -mu * (u_r_y - u_l_y) / dist;
        flux_rho_u_x = flux_rho_u_x + diff_u_x;
        flux_rho_u_y = flux_rho_u_y + diff_u_y;
        let flux_rho_e_l = (rho_e_l + p_l) * u_n_l;
        let flux_rho_e_r = (rho_e_r + p_r) * u_n_r;
        var flux_rho_e: f32 = a_pos * flux_rho_e_l + a_neg * flux_rho_e_r + a_prod_scaled * (rho_e_r - rho_e_l);
        if (!is_boundary && low_mach.model != 2u && low_mach.pressure_coupling_alpha > 0.0) {
            let normal_vec: vec2<f32> = vec2<f32>(normal.x, normal.y);
            let inv_rho_l_cell = 1.0 / max(rho_l_cell, 0.00000001);
            let inv_rho_r_cell = 1.0 / max(rho_r_cell, 0.00000001);
            let u_l_cell: vec2<f32> = rho_u_l_cell * inv_rho_l_cell;
            let u_r_cell: vec2<f32> = rho_u_r_cell * inv_rho_r_cell;
            let u2_l_cell = dot(u_l_cell, u_l_cell);
            let u2_r_cell = dot(u_r_cell, u_r_cell);
            let grad_rho_l_vec: vec2<f32> = vec2<f32>(grad_rho[idx].x, grad_rho[idx].y);
            let grad_rho_u_x_l_vec: vec2<f32> = vec2<f32>(grad_rho_u_x[idx].x, grad_rho_u_x[idx].y);
            let grad_rho_u_y_l_vec: vec2<f32> = vec2<f32>(grad_rho_u_y[idx].x, grad_rho_u_y[idx].y);
            let grad_rho_e_l_vec: vec2<f32> = vec2<f32>(grad_rho_e[idx].x, grad_rho_e[idx].y);
            let grad_rho_r_vec: vec2<f32> = vec2<f32>(grad_rho[other_idx].x, grad_rho[other_idx].y);
            let grad_rho_u_x_r_vec: vec2<f32> = vec2<f32>(grad_rho_u_x[other_idx].x, grad_rho_u_x[other_idx].y);
            let grad_rho_u_y_r_vec: vec2<f32> = vec2<f32>(grad_rho_u_y[other_idx].x, grad_rho_u_y[other_idx].y);
            let grad_rho_e_r_vec: vec2<f32> = vec2<f32>(grad_rho_e[other_idx].x, grad_rho_e[other_idx].y);
            let grad_u_x_l_vec: vec2<f32> = (grad_rho_u_x_l_vec - grad_rho_l_vec * u_l_cell.x) * inv_rho_l_cell;
            let grad_u_y_l_vec: vec2<f32> = (grad_rho_u_y_l_vec - grad_rho_l_vec * u_l_cell.y) * inv_rho_l_cell;
            let grad_u_x_r_vec: vec2<f32> = (grad_rho_u_x_r_vec - grad_rho_r_vec * u_r_cell.x) * inv_rho_r_cell;
            let grad_u_y_r_vec: vec2<f32> = (grad_rho_u_y_r_vec - grad_rho_r_vec * u_r_cell.y) * inv_rho_r_cell;
            let grad_u2_l_vec: vec2<f32> = grad_u_x_l_vec * u_l_cell.x * 2.0 + grad_u_y_l_vec * u_l_cell.y * 2.0;
            let grad_u2_r_vec: vec2<f32> = grad_u_x_r_vec * u_r_cell.x * 2.0 + grad_u_y_r_vec * u_r_cell.y * 2.0;
            let grad_rho_u2_l_vec: vec2<f32> = grad_rho_l_vec * u2_l_cell + grad_u2_l_vec * rho_l_cell;
            let grad_rho_u2_r_vec: vec2<f32> = grad_rho_r_vec * u2_r_cell + grad_u2_r_vec * rho_r_cell;
            let grad_p_l_vec: vec2<f32> = (grad_rho_e_l_vec - grad_rho_u2_l_vec * 0.5) * 0.39999998;
            let grad_p_r_vec: vec2<f32> = (grad_rho_e_r_vec - grad_rho_u2_r_vec * 0.5) * 0.39999998;
            let grad_p_l_n = dot(grad_p_l_vec, normal_vec);
            let grad_p_r_n = dot(grad_p_r_vec, normal_vec);
            let grad_p_face_n = (grad_p_l_n + grad_p_r_n) * 0.5;
            let grad_p_jump_n = (p_r - p_l) / dist;
            let rho_face = (rho_l + rho_r) * 0.5;
            let p_bar = (p_l + p_r) * 0.5;
            let dp_rel = abs(p_r - p_l) / max(p_bar, 0.000001);
            let pc_theta = min(1.0, max(mach2, low_mach.theta_floor));
            let pc_low_mach = 1.0 - pc_theta;
            let pc_smooth = 1.0 / (dp_rel / 0.2 * dp_rel / 0.2 + 1.0);
            let pc_alpha = low_mach.pressure_coupling_alpha * pc_low_mach * pc_smooth;
            let m_corr = pc_alpha * constants.dt / max(rho_face, 0.00000001) * (grad_p_face_n - grad_p_jump_n);
            let h_l = (rho_e_l + p_l) * inv_rho_l;
            let h_r = (rho_e_r + p_r) * inv_rho_r;
            let h_face = (h_l + h_r) * 0.5;
            flux_rho += m_corr;
            flux_rho_u_x += m_corr * u_face_x;
            flux_rho_u_y += m_corr * u_face_y;
            flux_rho_e += m_corr * h_face;
        }
        flux_rho_e = flux_rho_e + diff_u_x * u_face_x + diff_u_y * u_face_y;
        sum_rho += flux_rho * area;
        sum_rho_u_x += flux_rho_u_x * area;
        sum_rho_u_y += flux_rho_u_y * area;
        sum_rho_e += flux_rho_e * area;
        let q_l = u_l_x * u_l_x + u_l_y * u_l_y;
        let dp_drho_l = 0.39999998 * q_l * 0.5;
        let dp_dru_l = -0.39999998 * u_l_x;
        let dp_drv_l = -0.39999998 * u_l_y;
        let dp_dre_l = 0.39999998;
        let H_l = (rho_e_l + p_l) * inv_rho_l;
        let q_r = u_r_x * u_r_x + u_r_y * u_r_y;
        let dp_drho_r = 0.39999998 * q_r * 0.5;
        let dp_dru_r = -0.39999998 * u_r_x;
        let dp_drv_r = -0.39999998 * u_r_y;
        let dp_dre_r = 0.39999998;
        let H_r = (rho_e_r + p_r) * inv_rho_r;
        let a_l = a_plus / denom;
        let a_r = -a_minus / denom;
        let mu_over_dist = mu / dist;
        let u_face_vec = vec2<f32>(u_face_x, u_face_y);
        let diff_u_vec = vec2<f32>(diff_u_x, diff_u_y);
        if (!is_boundary) {
            let scalar_mat_idx = cell_face_matrix_indices[face_offset];
            let neighbor_rank = scalar_mat_idx - scalar_offset;
            matrix_values[start_row_0 + neighbor_rank * 4u + 0u] = a_prod_scaled * area;
            matrix_values[start_row_0 + neighbor_rank * 4u + 1u] = normal.x * a_r * area;
            matrix_values[start_row_0 + neighbor_rank * 4u + 2u] = normal.y * a_r * area;
            matrix_values[start_row_0 + neighbor_rank * 4u + 3u] = 0.0 * area;
            matrix_values[start_row_1 + neighbor_rank * 4u + 0u] = ((dp_drho_r * normal.x - u_r_x * u_n_r) * a_r + -u_r_x * inv_rho_r * -mu_over_dist) * area;
            matrix_values[start_row_1 + neighbor_rank * 4u + 1u] = ((u_n_r + normal.x * (u_r_x + dp_dru_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * area;
            matrix_values[start_row_1 + neighbor_rank * 4u + 2u] = (u_r_x * normal.y + dp_drv_r * normal.x) * a_r * area;
            matrix_values[start_row_1 + neighbor_rank * 4u + 3u] = dp_dre_r * normal.x * a_r * area;
            matrix_values[start_row_2 + neighbor_rank * 4u + 0u] = ((dp_drho_r * normal.y - u_r_y * u_n_r) * a_r + -u_r_y * inv_rho_r * -mu_over_dist) * area;
            matrix_values[start_row_2 + neighbor_rank * 4u + 1u] = (u_r_y * normal.x + dp_dru_r * normal.y) * a_r * area;
            matrix_values[start_row_2 + neighbor_rank * 4u + 2u] = ((u_n_r + normal.y * (u_r_y + dp_drv_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * area;
            matrix_values[start_row_2 + neighbor_rank * 4u + 3u] = dp_dre_r * normal.y * a_r * area;
            matrix_values[start_row_3 + neighbor_rank * 4u + 0u] = (u_n_r * (dp_drho_r - H_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).x) * area;
            matrix_values[start_row_3 + neighbor_rank * 4u + 1u] = ((H_r * normal.x + dp_dru_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).y) * area;
            matrix_values[start_row_3 + neighbor_rank * 4u + 2u] = ((H_r * normal.y + dp_drv_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).z) * area;
            matrix_values[start_row_3 + neighbor_rank * 4u + 3u] = (1.4 * u_n_r * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).w + a_prod_scaled) * area;
            diag_00 += (0.0 - a_prod_scaled) * area;
            diag_01 += normal.x * a_l * area;
            diag_02 += normal.y * a_l * area;
            diag_03 += 0.0 * area;
            diag_10 += ((dp_drho_l * normal.x - u_l_x * u_n_l) * a_l + -u_l_x * inv_rho_l * mu_over_dist) * area;
            diag_11 += ((u_n_l + normal.x * (u_l_x + dp_dru_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled) * area;
            diag_12 += (u_l_x * normal.y + dp_drv_l * normal.x) * a_l * area;
            diag_13 += dp_dre_l * normal.x * a_l * area;
            diag_20 += ((dp_drho_l * normal.y - u_l_y * u_n_l) * a_l + -u_l_y * inv_rho_l * mu_over_dist) * area;
            diag_21 += (u_l_y * normal.x + dp_dru_l * normal.y) * a_l * area;
            diag_22 += ((u_n_l + normal.y * (u_l_y + dp_drv_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled) * area;
            diag_23 += dp_dre_l * normal.y * a_l * area;
            diag_30 += (u_n_l * (dp_drho_l - H_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).x) * area;
            diag_31 += ((H_l * normal.x + dp_dru_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).y) * area;
            diag_32 += ((H_l * normal.y + dp_drv_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).z) * area;
            diag_33 += (1.4 * u_n_l * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).w - a_prod_scaled) * area;
        } else {
            if (boundary_type == 1u) {
                diag_00 += (0.0 - a_prod_scaled + a_prod_scaled + normal.x * a_r * constants.inlet_velocity) * area;
                diag_01 += normal.x * a_l * area;
                diag_02 += normal.y * a_l * area;
                diag_03 += 0.0 * area;
                diag_10 += ((dp_drho_l * normal.x - u_l_x * u_n_l) * a_l + -u_l_x * inv_rho_l * mu_over_dist + (dp_drho_r * normal.x - u_r_x * u_n_r) * a_r + -u_r_x * inv_rho_r * -mu_over_dist + ((u_n_r + normal.x * (u_r_x + dp_dru_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * constants.inlet_velocity) * area;
                diag_11 += ((u_n_l + normal.x * (u_l_x + dp_dru_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled) * area;
                diag_12 += (u_l_x * normal.y + dp_drv_l * normal.x) * a_l * area;
                diag_13 += (dp_dre_l * normal.x * a_l + dp_dre_r * normal.x * a_r) * area;
                diag_20 += ((dp_drho_l * normal.y - u_l_y * u_n_l) * a_l + -u_l_y * inv_rho_l * mu_over_dist + (dp_drho_r * normal.y - u_r_y * u_n_r) * a_r + -u_r_y * inv_rho_r * -mu_over_dist + (u_r_y * normal.x + dp_dru_r * normal.y) * a_r * constants.inlet_velocity) * area;
                diag_21 += (u_l_y * normal.x + dp_dru_l * normal.y) * a_l * area;
                diag_22 += ((u_n_l + normal.y * (u_l_y + dp_drv_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled) * area;
                diag_23 += (dp_dre_l * normal.y * a_l + dp_dre_r * normal.y * a_r) * area;
                diag_30 += (u_n_l * (dp_drho_l - H_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).x + u_n_r * (dp_drho_r - H_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).x + ((H_r * normal.x + dp_dru_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).y) * constants.inlet_velocity) * area;
                diag_31 += ((H_l * normal.x + dp_dru_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).y) * area;
                diag_32 += ((H_l * normal.y + dp_drv_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).z) * area;
                diag_33 += (1.4 * u_n_l * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).w - a_prod_scaled + 1.4 * u_n_r * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).w + a_prod_scaled) * area;
            } else {
                if (boundary_type == 3u) {
                    let r11 = 1.0 - normal.x * normal.x * 2.0;
                    let r12 = normal.x * normal.y * -2.0;
                    let r21 = normal.y * normal.x * -2.0;
                    let r22 = 1.0 - normal.y * normal.y * 2.0;
                    diag_00 += (0.0 - a_prod_scaled + a_prod_scaled) * area;
                    diag_01 += (normal.x * a_l + normal.x * a_r * r11 + normal.y * a_r * r21) * area;
                    diag_02 += (normal.y * a_l + normal.x * a_r * r12 + normal.y * a_r * r22) * area;
                    diag_03 += 0.0 * area;
                    diag_10 += ((dp_drho_l * normal.x - u_l_x * u_n_l) * a_l + -u_l_x * inv_rho_l * mu_over_dist + (dp_drho_r * normal.x - u_r_x * u_n_r) * a_r + -u_r_x * inv_rho_r * -mu_over_dist) * area;
                    diag_11 += ((u_n_l + normal.x * (u_l_x + dp_dru_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled + ((u_n_r + normal.x * (u_r_x + dp_dru_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * r11 + (u_r_x * normal.y + dp_drv_r * normal.x) * a_r * r21) * area;
                    diag_12 += ((u_l_x * normal.y + dp_drv_l * normal.x) * a_l + ((u_n_r + normal.x * (u_r_x + dp_dru_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * r12 + (u_r_x * normal.y + dp_drv_r * normal.x) * a_r * r22) * area;
                    diag_13 += (dp_dre_l * normal.x * a_l + dp_dre_r * normal.x * a_r) * area;
                    diag_20 += ((dp_drho_l * normal.y - u_l_y * u_n_l) * a_l + -u_l_y * inv_rho_l * mu_over_dist + (dp_drho_r * normal.y - u_r_y * u_n_r) * a_r + -u_r_y * inv_rho_r * -mu_over_dist) * area;
                    diag_21 += ((u_l_y * normal.x + dp_dru_l * normal.y) * a_l + (u_r_y * normal.x + dp_dru_r * normal.y) * a_r * r11 + ((u_n_r + normal.y * (u_r_y + dp_drv_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * r21) * area;
                    diag_22 += ((u_n_l + normal.y * (u_l_y + dp_drv_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled + (u_r_y * normal.x + dp_dru_r * normal.y) * a_r * r12 + ((u_n_r + normal.y * (u_r_y + dp_drv_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * r22) * area;
                    diag_23 += (dp_dre_l * normal.y * a_l + dp_dre_r * normal.y * a_r) * area;
                    diag_30 += (u_n_l * (dp_drho_l - H_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).x + u_n_r * (dp_drho_r - H_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).x) * area;
                    diag_31 += ((H_l * normal.x + dp_dru_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).y + ((H_r * normal.x + dp_dru_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).y) * r11 + ((H_r * normal.y + dp_drv_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).z) * r21) * area;
                    diag_32 += ((H_l * normal.y + dp_drv_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).z + ((H_r * normal.x + dp_dru_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).y) * r12 + ((H_r * normal.y + dp_drv_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).z) * r22) * area;
                    diag_33 += (1.4 * u_n_l * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).w - a_prod_scaled + 1.4 * u_n_r * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).w + a_prod_scaled) * area;
                } else {
                    diag_00 += (0.0 - a_prod_scaled + a_prod_scaled) * area;
                    diag_01 += (normal.x * a_l + normal.x * a_r) * area;
                    diag_02 += (normal.y * a_l + normal.y * a_r) * area;
                    diag_03 += 0.0 * area;
                    diag_10 += ((dp_drho_l * normal.x - u_l_x * u_n_l) * a_l + -u_l_x * inv_rho_l * mu_over_dist + (dp_drho_r * normal.x - u_r_x * u_n_r) * a_r + -u_r_x * inv_rho_r * -mu_over_dist) * area;
                    diag_11 += ((u_n_l + normal.x * (u_l_x + dp_dru_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled + (u_n_r + normal.x * (u_r_x + dp_dru_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * area;
                    diag_12 += ((u_l_x * normal.y + dp_drv_l * normal.x) * a_l + (u_r_x * normal.y + dp_drv_r * normal.x) * a_r) * area;
                    diag_13 += (dp_dre_l * normal.x * a_l + dp_dre_r * normal.x * a_r) * area;
                    diag_20 += ((dp_drho_l * normal.y - u_l_y * u_n_l) * a_l + -u_l_y * inv_rho_l * mu_over_dist + (dp_drho_r * normal.y - u_r_y * u_n_r) * a_r + -u_r_y * inv_rho_r * -mu_over_dist) * area;
                    diag_21 += ((u_l_y * normal.x + dp_dru_l * normal.y) * a_l + (u_r_y * normal.x + dp_dru_r * normal.y) * a_r) * area;
                    diag_22 += ((u_n_l + normal.y * (u_l_y + dp_drv_l)) * a_l + inv_rho_l * mu_over_dist - a_prod_scaled + (u_n_r + normal.y * (u_r_y + dp_drv_r)) * a_r + inv_rho_r * -mu_over_dist + a_prod_scaled) * area;
                    diag_23 += (dp_dre_l * normal.y * a_l + dp_dre_r * normal.y * a_r) * area;
                    diag_30 += (u_n_l * (dp_drho_l - H_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).x + u_n_r * (dp_drho_r - H_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).x) * area;
                    diag_31 += ((H_l * normal.x + dp_dru_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).y + (H_r * normal.x + dp_dru_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).y) * area;
                    diag_32 += ((H_l * normal.y + dp_drv_l * u_n_l) * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).z + (H_r * normal.y + dp_drv_r * u_n_r) * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).z) * area;
                    diag_33 += (1.4 * u_n_l * a_l + ((vec4<f32>(-u_l_x * inv_rho_l * mu_over_dist * u_face_vec.x + -u_l_y * inv_rho_l * mu_over_dist * u_face_vec.y, inv_rho_l * mu_over_dist * u_face_vec.x, inv_rho_l * mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_l_x * inv_rho_l * 0.5 * diff_u_vec.x + -u_l_y * inv_rho_l * 0.5 * diff_u_vec.y, inv_rho_l * 0.5 * diff_u_vec.x, inv_rho_l * 0.5 * diff_u_vec.y, 0.0))).w - a_prod_scaled + 1.4 * u_n_r * a_r + ((vec4<f32>(-u_r_x * inv_rho_r * -mu_over_dist * u_face_vec.x + -u_r_y * inv_rho_r * -mu_over_dist * u_face_vec.y, inv_rho_r * -mu_over_dist * u_face_vec.x, inv_rho_r * -mu_over_dist * u_face_vec.y, 0.0) + vec4<f32>(-u_r_x * inv_rho_r * 0.5 * diff_u_vec.x + -u_r_y * inv_rho_r * 0.5 * diff_u_vec.y, inv_rho_r * 0.5 * diff_u_vec.x, inv_rho_r * 0.5 * diff_u_vec.y, 0.0))).w + a_prod_scaled) * area;
                }
            }
        }
    }
    var rhs_rho: f32 = rhs_time_rho + rhs_pseudo_rho - (coeff_time + coeff_pseudo) * rho - sum_rho;
    var rhs_rho_u_x: f32 = rhs_time_rho_u_x + rhs_pseudo_rho_u_x - (coeff_time + coeff_pseudo) * rho_u.x - sum_rho_u_x;
    var rhs_rho_u_y: f32 = rhs_time_rho_u_y + rhs_pseudo_rho_u_y - (coeff_time + coeff_pseudo) * rho_u.y - sum_rho_u_y;
    var rhs_rho_e: f32 = rhs_time_rho_e + rhs_pseudo_rho_e - (coeff_time + coeff_pseudo) * rho_e - sum_rho_e;
    diag_00 += coeff_time;
    diag_11 += coeff_time;
    diag_22 += coeff_time;
    diag_33 += coeff_time;
    diag_00 += coeff_pseudo;
    diag_11 += coeff_pseudo;
    diag_22 += coeff_pseudo;
    diag_33 += coeff_pseudo;
    let scalar_diag_idx = diagonal_indices[idx];
    let diag_rank = scalar_diag_idx - scalar_offset;
    matrix_values[start_row_0 + diag_rank * 4u + 0u] = diag_00;
    matrix_values[start_row_0 + diag_rank * 4u + 1u] = diag_01;
    matrix_values[start_row_0 + diag_rank * 4u + 2u] = diag_02;
    matrix_values[start_row_0 + diag_rank * 4u + 3u] = diag_03;
    matrix_values[start_row_1 + diag_rank * 4u + 0u] = diag_10;
    matrix_values[start_row_1 + diag_rank * 4u + 1u] = diag_11;
    matrix_values[start_row_1 + diag_rank * 4u + 2u] = diag_12;
    matrix_values[start_row_1 + diag_rank * 4u + 3u] = diag_13;
    matrix_values[start_row_2 + diag_rank * 4u + 0u] = diag_20;
    matrix_values[start_row_2 + diag_rank * 4u + 1u] = diag_21;
    matrix_values[start_row_2 + diag_rank * 4u + 2u] = diag_22;
    matrix_values[start_row_2 + diag_rank * 4u + 3u] = diag_23;
    matrix_values[start_row_3 + diag_rank * 4u + 0u] = diag_30;
    matrix_values[start_row_3 + diag_rank * 4u + 1u] = diag_31;
    matrix_values[start_row_3 + diag_rank * 4u + 2u] = diag_32;
    matrix_values[start_row_3 + diag_rank * 4u + 3u] = diag_33;
    rhs[idx * 4u + 0u] = rhs_rho;
    rhs[idx * 4u + 1u] = rhs_rho_u_x;
    rhs[idx * 4u + 2u] = rhs_rho_u_y;
    rhs[idx * 4u + 3u] = rhs_rho_e;
}
