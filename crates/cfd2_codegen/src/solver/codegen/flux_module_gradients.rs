use super::dsl as typed;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::ir::{FieldKind, FluxLayout, StateLayout};

pub fn generate_flux_module_gradients_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
) -> Result<String, String> {
    let gradients = collect_gradients(layout)?;
    let specs = build_specs(layout, flux_layout, &gradients)?;

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module_gradients)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, flux_layout, &specs)));
    Ok(module.to_wgsl())
}

#[derive(Debug, Clone)]
struct GradientSpec {
    base: String,
    base_offset: u32,
    grad_x_offset: u32,
    grad_y_offset: u32,
    bc_unknown_offset: Option<u32>,
}

fn collect_gradients(layout: &StateLayout) -> Result<Vec<(String, String)>, String> {
    let mut out = Vec::new();
    for field in layout.fields() {
        let name = field.name();
        if !name.starts_with("grad_") {
            continue;
        }
        if field.kind() != FieldKind::Vector2 {
            continue;
        }
        let base = &name["grad_".len()..];
        if base.is_empty() {
            continue;
        }
        let Some(base_field) = layout.field(base) else {
            continue;
        };
        if base_field.kind() != FieldKind::Scalar {
            continue;
        }
        out.push((base.to_string(), name.to_string()));
    }

    if out.is_empty() {
        return Err("flux_module_gradients requested but no grad_<scalar> fields found in state layout".to_string());
    }

    Ok(out)
}

fn build_specs(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    gradients: &[(String, String)],
) -> Result<Vec<GradientSpec>, String> {
    let mut specs = Vec::new();
    for (base, grad) in gradients {
        let base_offset = layout
            .offset_for(base)
            .ok_or_else(|| format!("state layout missing scalar field '{base}'"))?;
        let grad_x_offset = layout
            .component_offset(grad, 0)
            .ok_or_else(|| format!("state layout missing vector field '{grad}[0]'"))?;
        let grad_y_offset = layout
            .component_offset(grad, 1)
            .ok_or_else(|| format!("state layout missing vector field '{grad}[1]'"))?;
        let bc_unknown_offset = flux_layout.offset_for(base).map(|v| v as u32);

        specs.push(GradientSpec {
            base: base.clone(),
            base_offset,
            grad_x_offset,
            grad_y_offset,
            bc_unknown_offset,
        });
    }
    Ok(specs)
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![storage_var(
        "state",
        Type::array(Type::F32),
        1,
        0,
        AccessMode::ReadWrite,
    )]
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(layout: &StateLayout, flux_layout: &FluxLayout, specs: &[GradientSpec]) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout, specs),
    )
}

fn main_body(layout: &StateLayout, flux_layout: &FluxLayout, specs: &[GradientSpec]) -> Block {
    let stride = layout.stride();
    let unknown_stride = flux_layout.stride;

    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "cell_center",
        dsl::array_access("cell_centers", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_typed_expr(
        "cell_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("cell_center")).expr(),
    ));

    stmts.push(dsl::let_expr(
        "vol",
        dsl::array_access("cell_vols", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        dsl::array_access("cell_face_offsets", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        dsl::array_access("cell_face_offsets", Expr::ident("idx") + 1u32),
    ));

    // Accumulators: one vec2 per gradient.
    for spec in specs {
        let var_name = format!("grad_acc_{}", spec.base);
        stmts.push(dsl::var_typed_expr(&var_name, Type::vec2_f32(), Some(dsl::vec2_f32(0.0, 0.0))));
    }

    // Face loop.
    let face_loop_body = {
        let mut body = Vec::new();
        body.push(dsl::let_expr(
            "face_idx",
            dsl::array_access("cell_faces", Expr::ident("k")),
        ));
        body.push(dsl::let_expr(
            "owner",
            dsl::array_access("face_owner", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "neighbor_raw",
            dsl::array_access("face_neighbor", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "is_boundary",
            Expr::ident("neighbor_raw").eq(-1),
        ));
        body.push(dsl::let_expr(
            "boundary_type",
            dsl::array_access("face_boundary", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "area",
            dsl::array_access("face_areas", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_expr(
            "face_center",
            dsl::array_access("face_centers", Expr::ident("face_idx")),
        ));
        body.push(dsl::let_typed_expr(
            "face_center_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
        ));
        body.push(dsl::var_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            Some(
                typed::VecExpr::<2>::from_xy_fields(
                    Expr::ident("face_normals").index(Expr::ident("face_idx")),
                )
                .expr(),
            ),
        ));
        let cell_to_face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
            .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("cell_center_vec")));
        body.push(dsl::if_block_expr(
            cell_to_face
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
                .lt(0.0),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("normal_vec"),
                typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                    .neg()
                    .expr(),
            )]),
            None,
        ));

        body.push(dsl::var_typed_expr(
            "other_idx",
            Type::U32,
            Some(Expr::ident("idx")),
        ));
        body.push(dsl::var_typed_expr(
            "other_center_vec",
            Type::vec2_f32(),
            Some(Expr::ident("face_center_vec")),
        ));
        body.push(dsl::if_block_expr(
            Expr::ident("neighbor_raw").ne(-1),
            dsl::block(vec![
                dsl::let_expr(
                    "neighbor",
                    Expr::call_named("u32", vec![Expr::ident("neighbor_raw")]),
                ),
                dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neighbor")),
                dsl::if_block_expr(
                    Expr::ident("owner").ne(Expr::ident("idx")),
                    dsl::block(vec![dsl::assign_expr(
                        Expr::ident("other_idx"),
                        Expr::ident("owner"),
                    )]),
                    None,
                ),
                dsl::let_expr(
                    "other_center",
                    dsl::array_access("cell_centers", Expr::ident("other_idx")),
                ),
                dsl::assign_expr(
                    Expr::ident("other_center_vec"),
                    typed::VecExpr::<2>::from_xy_fields(Expr::ident("other_center")).expr(),
                ),
            ]),
            None,
        ));

        body.push(dsl::let_expr(
            "d_own",
            dsl::distance(Expr::ident("cell_center_vec"), Expr::ident("face_center_vec")),
        ));
        body.push(dsl::let_expr(
            "d_neigh",
            dsl::distance(Expr::ident("other_center_vec"), Expr::ident("face_center_vec")),
        ));
        body.push(dsl::let_expr(
            "total_dist",
            Expr::ident("d_own") + Expr::ident("d_neigh"),
        ));
        body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
        body.push(dsl::if_block_expr(
            Expr::ident("total_dist").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("lambda"),
                Expr::ident("d_neigh") / Expr::ident("total_dist"),
            )]),
            None,
        ));
        body.push(dsl::let_expr(
            "lambda_other",
            Expr::from(1.0) - Expr::ident("lambda"),
        ));

        for spec in specs {
            let cell_val = Expr::ident("state").index(Expr::ident("idx") * stride + spec.base_offset);
            let interior_other = Expr::ident("state").index(Expr::ident("other_idx") * stride + spec.base_offset);

            let other_val = if let Some(off) = spec.bc_unknown_offset {
                let bc_table_idx = Expr::ident("face_idx") * Expr::from(unknown_stride) + Expr::from(off);
                let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
                let value = dsl::array_access("bc_value", bc_table_idx);
                let from_bc = dsl::select(
                    dsl::select(cell_val.clone(), value.clone(), kind.eq(Expr::from(1u32))),
                    cell_val.clone() + value * Expr::ident("d_own"),
                    kind.eq(Expr::from(2u32)),
                );
                dsl::select(interior_other, from_bc, Expr::ident("is_boundary"))
            } else {
                dsl::select(interior_other, cell_val.clone(), Expr::ident("is_boundary"))
            };

            let phi_face = cell_val * Expr::ident("lambda") + other_val * Expr::ident("lambda_other");

            let acc_name = format!("grad_acc_{}", spec.base);
            let contrib = typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .mul_scalar(phi_face * Expr::ident("area"))
                .expr();
            body.push(dsl::assign_op_expr(
                AssignOp::Add,
                Expr::ident(&acc_name),
                contrib,
            ));
        }

        dsl::block(body)
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        face_loop_body,
    ));

    // Write out gradients (divide by volume).
    for spec in specs {
        let acc_name = format!("grad_acc_{}", spec.base);
        let grad_vec = typed::VecExpr::<2>::from_expr(Expr::ident(&acc_name))
            .mul_scalar(Expr::from(1.0) / dsl::max(Expr::ident("vol"), 1e-12))
            .expr();
        stmts.push(dsl::let_typed_expr(
            &format!("grad_out_{}", spec.base),
            Type::vec2_f32(),
            grad_vec,
        ));

        let out = Expr::ident(&format!("grad_out_{}", spec.base));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + spec.grad_x_offset),
            out.clone().field("x"),
        ));
        stmts.push(dsl::assign_expr(
            Expr::ident("state").index(Expr::ident("idx") * stride + spec.grad_y_offset),
            out.field("y"),
        ));
    }

    Block::new(stmts)
}
