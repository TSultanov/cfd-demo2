use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use super::KernelWgsl;

pub fn generate_dp_update_from_diag_wgsl(
    state_stride: u32,
    d_p_offset: u32,
    unknowns_per_cell: u32,
    u_indices: &[u32],
) -> Result<KernelWgsl, String> {
    if unknowns_per_cell == 0 {
        return Err("dp_update_from_diag requires unknowns_per_cell > 0".to_string());
    }
    if u_indices.is_empty() {
        return Err("dp_update_from_diag requires at least one momentum component index".to_string());
    }
    if u_indices.len() > 8 {
        return Err("dp_update_from_diag supports at most 8 momentum components".to_string());
    }
    if u_indices.iter().any(|&u| u >= unknowns_per_cell) {
        return Err(format!(
            "dp_update_from_diag: momentum indices {:?} out of range for unknowns_per_cell={unknowns_per_cell}",
            u_indices
        ));
    }

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (dp_update_from_diag)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.push(Item::Struct(constants_struct()));
    module.push(storage_var(
        "scalar_row_offsets",
        Type::array(Type::U32),
        0,
        0,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "diagonal_indices",
        Type::array(Type::U32),
        0,
        1,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "matrix_values",
        Type::array(Type::F32),
        0,
        2,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        3,
        AccessMode::ReadWrite,
    ));
    module.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        4,
    ));
    module.push(Item::Function(main_fn(state_stride, d_p_offset)));
    Ok(KernelWgsl::from(module))
}

fn constants_struct() -> StructDef {
    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(state_stride: u32, d_p_offset: u32) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(state_stride, d_p_offset),
    )
}

fn main_body(state_stride: u32, d_p_offset: u32) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named(
            "arrayLength",
            vec![Expr::ident("scalar_row_offsets").addr_of()],
        ) - Expr::lit_u32(1),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::comment(
        "Transient-scale approximation: d_p ≈ alpha_u * dt / rho.",
    ));
    stmts.push(dsl::comment(
        "This is the mobility used by the Rhie–Chow flux and pressure correction equation for",
    ));
    stmts.push(dsl::comment("incompressible pseudo-time marching."));

    stmts.push(dsl::let_expr(
        "rho",
        dsl::max(
            Expr::ident("constants").field("density"),
            Expr::lit_f32(1e-12),
        ),
    ));
    stmts.push(dsl::let_expr(
        "dt",
        dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::let_expr(
        "d_p",
        Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "state",
        Expr::ident("idx"),
        state_stride,
        d_p_offset,
        Expr::ident("d_p"),
    ));

    Block::new(stmts)
}
