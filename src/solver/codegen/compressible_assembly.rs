use super::dsl as typed;
use super::reconstruction::limited_linear_reconstruct_face;
use super::state_access::{state_scalar, state_vec2};
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::gpu::enums::{GpuBoundaryType, GpuLowMachPrecondModel, TimeScheme};
use crate::solver::model::backend::StateLayout;
use crate::solver::model::CompressibleFields;
use crate::solver::scheme::Scheme;

pub fn generate_compressible_assembly_wgsl(
    layout: &StateLayout,
    fields: &CompressibleFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (compressible_assembly)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Struct(low_mach_params_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment("Group 2: Solver".to_string()));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var("state_iter", Type::array(Type::F32), 1, 9, AccessMode::Read),
        uniform_var("low_mach", Type::Custom("LowMachParams".to_string()), 1, 10),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CompressibleFields) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CompressibleFields) -> Block {
    let mut stmts = Vec::new();
    let rho_field = fields.rho.name();
    let rho_u_field = fields.rho_u.name();
    let rho_e_field = fields.rho_e.name();
    let gamma = 1.4_f32;
    let gamma_minus_1 = gamma - 1.0;
    let block_size = 4u32;
    let block_stride = block_size * block_size;
    let block_shape = typed::BlockShape::new(block_size as u8, block_size as u8);
    let block_matrix = typed::BlockCsrSoaMatrix::from_start_row_prefix(
        "matrix_values",
        "start_row",
        block_shape,
        typed::ScalarType::F32,
        typed::UnitDim::dimensionless(),
    );

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "center",
        Expr::ident("cell_centers").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx") + 1u32),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        Expr::ident("cell_vols").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "scalar_offset",
        Expr::ident("scalar_row_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "num_neighbors",
        Expr::ident("scalar_row_offsets").index(Expr::ident("idx") + 1u32)
            - Expr::ident("scalar_offset"),
    ));
    stmts.push(dsl::let_expr(
        "start_row_0",
        Expr::ident("scalar_offset") * block_stride,
    ));
    stmts.push(dsl::let_expr(
        "start_row_1",
        Expr::ident("start_row_0") + Expr::ident("num_neighbors") * block_size,
    ));
    stmts.push(dsl::let_expr(
        "start_row_2",
        Expr::ident("start_row_0") + Expr::ident("num_neighbors") * (block_size * 2),
    ));
    stmts.push(dsl::let_expr(
        "start_row_3",
        Expr::ident("start_row_0") + Expr::ident("num_neighbors") * (block_size * 3),
    ));
    stmts.push(dsl::let_expr(
        "scheme_id",
        Expr::ident("constants").field("scheme"),
    ));

    stmts.push(dsl::comment(
        "Jacobian rows/cols: rho, rho_u_x, rho_u_y, rho_e",
    ));
    stmts.extend(typed::MatExpr::<4, 4>::var_prefix("diag", 0.0.into()));
    let diag_mat = typed::MatExpr::<4, 4>::from_prefix("diag");

    stmts.push(dsl::var_typed_expr("sum_rho", Type::F32, Some(0.0.into())));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_u_x",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_u_y",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "sum_rho_e",
        Type::F32,
        Some(0.0.into()),
    ));

    let rho_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_expr = state_scalar(layout, "state", "idx", rho_e_field);
    let rho_old_expr = state_scalar(layout, "state_old", "idx", rho_field);
    let rho_u_old_expr = state_vec2(layout, "state_old", "idx", rho_u_field);
    let rho_e_old_expr = state_scalar(layout, "state_old", "idx", rho_e_field);
    let rho_iter_expr = state_scalar(layout, "state_iter", "idx", rho_field);
    let rho_u_iter_expr = state_vec2(layout, "state_iter", "idx", rho_u_field);
    let rho_e_iter_expr = state_scalar(layout, "state_iter", "idx", rho_e_field);
    stmts.push(dsl::let_expr("rho", rho_expr));
    stmts.push(dsl::let_typed_expr("rho_u", Type::vec2_f32(), rho_u_expr));
    stmts.push(dsl::let_expr("rho_e", rho_e_expr));
    stmts.push(dsl::let_expr("rho_old", rho_old_expr));
    stmts.push(dsl::let_typed_expr(
        "rho_u_old",
        Type::vec2_f32(),
        rho_u_old_expr,
    ));
    stmts.push(dsl::let_expr("rho_e_old", rho_e_old_expr));

    stmts.push(dsl::var_typed_expr(
        "coeff_time",
        Type::F32,
        Some(Expr::ident("vol") / Expr::ident("constants").field("dt")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_old")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_u_x",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_u_old").field("x")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_u_y",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_u_old").field("y")),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_time_rho_e",
        Type::F32,
        Some(Expr::ident("coeff_time") * Expr::ident("rho_e_old")),
    ));
    stmts.push(dsl::var_typed_expr(
        "coeff_pseudo",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_u_x",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_u_y",
        Type::F32,
        Some(0.0.into()),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_pseudo_rho_e",
        Type::F32,
        Some(0.0.into()),
    ));

    let pseudo_block = dsl::block(vec![
        dsl::let_expr("rho_iter", rho_iter_expr),
        dsl::let_typed_expr("rho_u_iter", Type::vec2_f32(), rho_u_iter_expr),
        dsl::let_expr("rho_e_iter", rho_e_iter_expr),
        dsl::assign_expr(
            Expr::ident("coeff_pseudo"),
            Expr::ident("vol") / Expr::ident("constants").field("dtau"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_iter"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_u_x"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_u_iter").field("x"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_u_y"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_u_iter").field("y"),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_pseudo_rho_e"),
            Expr::ident("coeff_pseudo") * Expr::ident("rho_e_iter"),
        ),
    ]);
    stmts.push(dsl::if_block_expr(
        Expr::ident("constants").field("dtau").gt(0.0),
        pseudo_block,
        None,
    ));

    let rho_old_old_expr = state_scalar(layout, "state_old_old", "idx", rho_field);
    let rho_u_old_old_expr = state_vec2(layout, "state_old_old", "idx", rho_u_field);
    let rho_e_old_old_expr = state_scalar(layout, "state_old_old", "idx", rho_e_field);
    let bdf2_block = dsl::block(vec![
        dsl::let_expr("dt", Expr::ident("constants").field("dt")),
        dsl::let_expr("dt_old", Expr::ident("constants").field("dt_old")),
        dsl::let_expr("r", Expr::ident("dt") / Expr::ident("dt_old")),
        dsl::let_expr("rho_old_old", rho_old_old_expr),
        dsl::let_typed_expr("rho_u_old_old", Type::vec2_f32(), rho_u_old_old_expr),
        dsl::let_expr("rho_e_old_old", rho_e_old_old_expr),
        dsl::assign_expr(
            Expr::ident("coeff_time"),
            Expr::ident("vol") / Expr::ident("dt") * (Expr::ident("r") * 2.0 + 1.0)
                / (Expr::ident("r") + 1.0),
        ),
        dsl::let_expr("factor_n", Expr::ident("r") + 1.0),
        dsl::let_expr(
            "factor_nm1",
            (Expr::ident("r") * Expr::ident("r")) / (Expr::ident("r") + 1.0),
        ),
        dsl::let_expr("coeff_base", Expr::ident("vol") / Expr::ident("dt")),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_old")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_old_old")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_u_x"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_u_old").field("x")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_u_old_old").field("x")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_u_y"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_u_old").field("y")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_u_old_old").field("y")),
        ),
        dsl::assign_expr(
            Expr::ident("rhs_time_rho_e"),
            Expr::ident("coeff_base")
                * (Expr::ident("factor_n") * Expr::ident("rho_e_old")
                    - Expr::ident("factor_nm1") * Expr::ident("rho_e_old_old")),
        ),
    ]);

    stmts.push(dsl::if_block_expr(
        typed::EnumExpr::<TimeScheme>::from_expr(Expr::ident("constants").field("time_scheme"))
            .eq(TimeScheme::BDF2),
        bdf2_block,
        None,
    ));

    let rho_r_expr = state_scalar(layout, "state", "other_idx", rho_field);
    let rho_u_r_expr = state_vec2(layout, "state", "other_idx", rho_u_field);
    let rho_e_r_expr = state_scalar(layout, "state", "other_idx", rho_e_field);

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_expr(
        "face_idx",
        Expr::ident("cell_faces").index(Expr::ident("face_offset")),
    ));
    loop_body.push(dsl::let_expr(
        "owner",
        Expr::ident("face_owner").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "neighbor",
        Expr::ident("face_neighbor").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "boundary_type",
        Expr::ident("face_boundary").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "area",
        Expr::ident("face_areas").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "normal",
        Type::Custom("Vector2".to_string()),
        Some(Expr::ident("face_normals").index(Expr::ident("face_idx"))),
    ));
    loop_body.push(dsl::let_expr(
        "f_center",
        Expr::ident("face_centers").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "is_boundary",
        Type::Bool,
        Some(false.into()),
    ));
    loop_body.push(dsl::var_typed_expr(
        "other_idx",
        Type::U32,
        Some(0u32.into()),
    ));
    loop_body.push(dsl::var_typed_expr(
        "center_r",
        Type::Custom("Vector2".to_string()),
        None,
    ));

    loop_body.push(dsl::if_block_expr(
        Expr::ident("owner").ne(Expr::ident("idx")),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("normal").field("x"),
                -Expr::ident("normal").field("x"),
            ),
            dsl::assign_expr(
                Expr::ident("normal").field("y"),
                -Expr::ident("normal").field("y"),
            ),
        ]),
        None,
    ));

    let interior_block = dsl::block(vec![
        dsl::let_typed_expr(
            "neigh_idx",
            Type::U32,
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        ),
        dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("neigh_idx")),
        dsl::if_block_expr(
            Expr::ident("owner").ne(Expr::ident("idx")),
            dsl::block(vec![dsl::assign_expr(
                Expr::ident("other_idx"),
                Expr::ident("owner"),
            )]),
            None,
        ),
        dsl::assign_expr(
            Expr::ident("center_r"),
            Expr::ident("cell_centers").index(Expr::ident("other_idx")),
        ),
        dsl::let_expr("rho_neigh", rho_r_expr),
        dsl::let_typed_expr("rho_u_neigh", Type::vec2_f32(), rho_u_r_expr),
        dsl::let_expr("rho_e_neigh", rho_e_r_expr),
        dsl::assign_expr(Expr::ident("rho_r"), Expr::ident("rho_neigh")),
        dsl::assign_expr(Expr::ident("rho_u_r"), Expr::ident("rho_u_neigh")),
        dsl::assign_expr(Expr::ident("rho_e_r"), Expr::ident("rho_e_neigh")),
    ]);

    let boundary_block = dsl::block(vec![
        dsl::assign_expr(Expr::ident("is_boundary"), true),
        dsl::assign_expr(Expr::ident("other_idx"), Expr::ident("idx")),
        dsl::assign_expr(Expr::ident("center_r"), Expr::ident("f_center")),
    ]);

    let rho_l_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_l_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_l_expr = state_scalar(layout, "state", "idx", rho_e_field);
    loop_body.push(dsl::let_expr("rho_l_cell", rho_l_expr));
    loop_body.push(dsl::let_typed_expr(
        "rho_u_l_cell",
        Type::vec2_f32(),
        rho_u_l_expr,
    ));
    loop_body.push(dsl::let_expr("rho_e_l_cell", rho_e_l_expr));
    loop_body.push(dsl::var_typed_expr(
        "rho_l",
        Type::F32,
        Some(Expr::ident("rho_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_l",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_e_l",
        Type::F32,
        Some(Expr::ident("rho_e_l_cell")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_r",
        Type::F32,
        Some(Expr::ident("rho_l")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_r",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "rho_e_r",
        Type::F32,
        Some(Expr::ident("rho_e_l")),
    ));

    loop_body.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        interior_block,
        Some(boundary_block),
    ));

    let inlet_block = dsl::block(vec![dsl::assign_expr(
        Expr::ident("rho_u_r"),
        typed::VecExpr::<2>::from_components([
            Expr::ident("rho_r") * Expr::ident("constants").field("inlet_velocity"),
            0.0.into(),
        ])
        .expr(),
    )]);

    let wall_block = dsl::block(vec![
        dsl::let_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("normal")).expr(),
        ),
        dsl::let_expr(
            "m_dot_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::assign_expr(
            Expr::ident("rho_u_r"),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                        .mul_scalar(Expr::ident("m_dot_n") * 2.0),
                )
                .expr(),
        ),
    ]);

    let boundary_type = typed::EnumExpr::<GpuBoundaryType>::from_expr(Expr::ident("boundary_type"));
    let boundary_state = dsl::block(vec![dsl::if_block_expr(
        boundary_type.eq(GpuBoundaryType::Inlet),
        inlet_block,
        Some(dsl::block(vec![dsl::if_block_expr(
            boundary_type.eq(GpuBoundaryType::Wall),
            wall_block,
            None,
        )])),
    )]);

    loop_body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        boundary_state,
        None,
    ));

    loop_body.push(dsl::let_expr("rho_r_cell", Expr::ident("rho_r")));
    loop_body.push(dsl::let_typed_expr(
        "rho_u_r_cell",
        Type::vec2_f32(),
        Expr::ident("rho_u_r"),
    ));
    loop_body.push(dsl::let_expr("rho_e_r_cell", Expr::ident("rho_e_r")));

    let reconstruct_block = {
        let mut block = Vec::new();
        block.push(dsl::let_expr(
            "r_l_x",
            Expr::ident("f_center").field("x") - Expr::ident("center").field("x"),
        ));
        block.push(dsl::let_expr(
            "r_l_y",
            Expr::ident("f_center").field("y") - Expr::ident("center").field("y"),
        ));
        block.push(dsl::let_expr(
            "r_r_x",
            Expr::ident("f_center").field("x") - Expr::ident("center_r").field("x"),
        ));
        block.push(dsl::let_expr(
            "r_r_y",
            Expr::ident("f_center").field("y") - Expr::ident("center_r").field("y"),
        ));

        // Reconstruct conservative variables directly for robustness.
        block.push(dsl::let_expr(
            "grad_rho_l",
            Expr::ident("grad_rho").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_l",
            Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_l",
            Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_l",
            Expr::ident("grad_rho_e").index(Expr::ident("idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_r",
            Expr::ident("grad_rho").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_x_r",
            Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_u_y_r",
            Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
        ));
        block.push(dsl::let_expr(
            "grad_rho_e_r",
            Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
        ));

        let (rho_l_stmts, rho_l_face) = limited_linear_reconstruct_face(
            "rho",
            "l",
            Expr::ident("rho_l_cell"),
            Expr::ident("rho_r_cell"),
            Expr::ident("grad_rho_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_l_stmts);
        let (rho_u_x_l_stmts, rho_u_x_l_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "l",
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("grad_rho_u_x_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_x_l_stmts);
        let (rho_u_y_l_stmts, rho_u_y_l_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "l",
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("grad_rho_u_y_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_u_y_l_stmts);
        let (rho_e_l_stmts, rho_e_l_face) = limited_linear_reconstruct_face(
            "rho_e",
            "l",
            Expr::ident("rho_e_l_cell"),
            Expr::ident("rho_e_r_cell"),
            Expr::ident("grad_rho_e_l"),
            Expr::ident("r_l_x"),
            Expr::ident("r_l_y"),
        );
        block.extend(rho_e_l_stmts);

        let (rho_r_stmts, rho_r_face) = limited_linear_reconstruct_face(
            "rho",
            "r",
            Expr::ident("rho_r_cell"),
            Expr::ident("rho_l_cell"),
            Expr::ident("grad_rho_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_r_stmts);
        let (rho_u_x_r_stmts, rho_u_x_r_face) = limited_linear_reconstruct_face(
            "rho_u_x",
            "r",
            Expr::ident("rho_u_r_cell").field("x"),
            Expr::ident("rho_u_l_cell").field("x"),
            Expr::ident("grad_rho_u_x_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_x_r_stmts);
        let (rho_u_y_r_stmts, rho_u_y_r_face) = limited_linear_reconstruct_face(
            "rho_u_y",
            "r",
            Expr::ident("rho_u_r_cell").field("y"),
            Expr::ident("rho_u_l_cell").field("y"),
            Expr::ident("grad_rho_u_y_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_u_y_r_stmts);
        let (rho_e_r_stmts, rho_e_r_face) = limited_linear_reconstruct_face(
            "rho_e",
            "r",
            Expr::ident("rho_e_r_cell"),
            Expr::ident("rho_e_l_cell"),
            Expr::ident("grad_rho_e_r"),
            Expr::ident("r_r_x"),
            Expr::ident("r_r_y"),
        );
        block.extend(rho_e_r_stmts);

        block.push(dsl::assign_expr(Expr::ident("rho_l"), rho_l_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_l"),
            dsl::vec2_f32(rho_u_x_l_face, rho_u_y_l_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_l"), rho_e_l_face));
        block.push(dsl::assign_expr(Expr::ident("rho_r"), rho_r_face));
        block.push(dsl::assign_expr(
            Expr::ident("rho_u_r"),
            dsl::vec2_f32(rho_u_x_r_face, rho_u_y_r_face),
        ));
        block.push(dsl::assign_expr(Expr::ident("rho_e_r"), rho_e_r_face));

        dsl::block(block)
    };

    // For compressible KT fluxes, keep reconstruction conservative and stable:
    // - `scheme=0` and `scheme=2` default to piecewise-constant states.
    // - `scheme=1` enables limited linear reconstruction.
    loop_body.push(dsl::if_block_expr(
        (!Expr::ident("is_boundary"))
            & typed::EnumExpr::<Scheme>::from_expr(Expr::ident("scheme_id"))
                .eq(Scheme::SecondOrderUpwind),
        reconstruct_block,
        None,
    ));

    loop_body.push(dsl::let_expr(
        "inv_rho_l",
        Expr::from(1.0) / dsl::max("rho_l", 1e-8),
    ));
    loop_body.push(dsl::let_expr(
        "u_l_x",
        Expr::ident("rho_u_l").field("x") * Expr::ident("inv_rho_l"),
    ));
    loop_body.push(dsl::let_expr(
        "u_l_y",
        Expr::ident("rho_u_l").field("y") * Expr::ident("inv_rho_l"),
    ));
    loop_body.push(dsl::let_expr(
        "ke_l",
        Expr::ident("rho_l")
            * (Expr::ident("u_l_x") * Expr::ident("u_l_x")
                + Expr::ident("u_l_y") * Expr::ident("u_l_y"))
            * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "p_l",
        dsl::max(
            0.0,
            (Expr::ident("rho_e_l") - Expr::ident("ke_l")) * gamma_minus_1,
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_n_l",
        Expr::ident("u_l_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_l_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_l",
        dsl::sqrt(Expr::ident("p_l") * Expr::ident("inv_rho_l") * gamma),
    ));

    loop_body.push(dsl::let_expr(
        "inv_rho_r",
        Expr::from(1.0) / dsl::max("rho_r", 1e-8),
    ));
    loop_body.push(dsl::let_expr(
        "u_r_x",
        Expr::ident("rho_u_r").field("x") * Expr::ident("inv_rho_r"),
    ));
    loop_body.push(dsl::let_expr(
        "u_r_y",
        Expr::ident("rho_u_r").field("y") * Expr::ident("inv_rho_r"),
    ));
    loop_body.push(dsl::let_expr(
        "ke_r",
        Expr::ident("rho_r")
            * (Expr::ident("u_r_x") * Expr::ident("u_r_x")
                + Expr::ident("u_r_y") * Expr::ident("u_r_y"))
            * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "p_r",
        dsl::max(
            0.0,
            (Expr::ident("rho_e_r") - Expr::ident("ke_r")) * gamma_minus_1,
        ),
    ));
    loop_body.push(dsl::let_expr(
        "u_n_r",
        Expr::ident("u_r_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_r_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_r",
        dsl::sqrt(Expr::ident("p_r") * Expr::ident("inv_rho_r") * gamma),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_x",
        (Expr::ident("u_l_x") + Expr::ident("u_r_x")) * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "u_face_y",
        (Expr::ident("u_l_y") + Expr::ident("u_r_y")) * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "u_face_n",
        Expr::ident("u_face_x") * Expr::ident("normal").field("x")
            + Expr::ident("u_face_y") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "c_bar",
        (Expr::ident("c_l") + Expr::ident("c_r")) * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "mach",
        dsl::abs("u_face_n") / dsl::max("c_bar", 1e-6),
    ));
    loop_body.push(dsl::let_expr(
        "mach2",
        Expr::ident("mach") * Expr::ident("mach"),
    ));
    // Low-Mach preconditioning (optional). Default is `model=2` (off) for
    // rhoCentralFoam-like transient behavior (e.g., acoustics).
    loop_body.push(dsl::var_typed_expr(
        "c_l_eff",
        Type::F32,
        Some(Expr::ident("c_l")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "c_r_eff",
        Type::F32,
        Some(Expr::ident("c_r")),
    ));

    let precond_legacy_block = dsl::block(vec![
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            Expr::ident("c_l") * Expr::ident("mach"),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            Expr::ident("c_r") * Expr::ident("mach"),
        ),
    ]);
    let precond_weiss_smith_block = dsl::block(vec![
        dsl::let_expr(
            "theta",
            dsl::min(
                1.0,
                dsl::max(
                    Expr::ident("mach2"),
                    Expr::ident("low_mach").field("theta_floor"),
                ),
            ),
        ),
        dsl::let_expr("one_minus_theta", Expr::from(1.0) - Expr::ident("theta")),
        dsl::assign_expr(
            Expr::ident("c_l_eff"),
            dsl::sqrt(
                Expr::ident("theta") * Expr::ident("c_l") * Expr::ident("c_l")
                    + Expr::ident("one_minus_theta") * Expr::ident("u_n_l") * Expr::ident("u_n_l"),
            ),
        ),
        dsl::assign_expr(
            Expr::ident("c_r_eff"),
            dsl::sqrt(
                Expr::ident("theta") * Expr::ident("c_r") * Expr::ident("c_r")
                    + Expr::ident("one_minus_theta") * Expr::ident("u_n_r") * Expr::ident("u_n_r"),
            ),
        ),
    ]);
    let precond_model = typed::EnumExpr::<GpuLowMachPrecondModel>::from_expr(
        Expr::ident("low_mach").field("model"),
    );
    let precond_else_block = dsl::block(vec![dsl::if_block_expr(
        precond_model.eq(GpuLowMachPrecondModel::WeissSmith),
        precond_weiss_smith_block,
        None,
    )]);
    loop_body.push(dsl::if_block_expr(
        precond_model.eq(GpuLowMachPrecondModel::Legacy),
        precond_legacy_block,
        Some(precond_else_block),
    ));
    loop_body.push(dsl::let_expr(
        "flux_adv",
        Expr::ident("u_face_n") * Expr::ident("area"),
    ));
    loop_body.push(dsl::let_expr(
        "dx",
        Expr::ident("center_r").field("x") - Expr::ident("center").field("x"),
    ));
    loop_body.push(dsl::let_expr(
        "dy",
        Expr::ident("center_r").field("y") - Expr::ident("center").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "dist",
        dsl::max(
            dsl::sqrt(
                Expr::ident("dx") * Expr::ident("dx") + Expr::ident("dy") * Expr::ident("dy"),
            ),
            1e-6,
        ),
    ));
    loop_body.push(dsl::let_expr(
        "mu",
        Expr::ident("constants").field("viscosity"),
    ));

    loop_body.push(dsl::let_expr(
        "a_plus",
        dsl::max(
            0.0,
            dsl::max(
                Expr::ident("u_n_l") + Expr::ident("c_l_eff"),
                Expr::ident("u_n_r") + Expr::ident("c_r_eff"),
            ),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "a_minus",
        dsl::min(
            0.0,
            dsl::min(
                Expr::ident("u_n_l") - Expr::ident("c_l_eff"),
                Expr::ident("u_n_r") - Expr::ident("c_r_eff"),
            ),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "denom",
        dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
    ));
    loop_body.push(dsl::let_expr(
        "a_prod",
        Expr::ident("a_plus") * Expr::ident("a_minus"),
    ));
    loop_body.push(dsl::let_expr(
        "a_pos",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    loop_body.push(dsl::let_expr(
        "a_neg",
        Expr::from(1.0) - Expr::ident("a_pos"),
    ));
    loop_body.push(dsl::let_expr(
        "a_prod_scaled",
        Expr::ident("a_prod") / Expr::ident("denom"),
    ));

    loop_body.push(dsl::let_expr(
        "flux_rho_l",
        Expr::ident("rho_l") * Expr::ident("u_n_l"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_r",
        Expr::ident("rho_r") * Expr::ident("u_n_r"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_r") - Expr::ident("rho_l")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_x_l",
        Expr::ident("rho_u_l").field("x") * Expr::ident("u_n_l")
            + Expr::ident("p_l") * Expr::ident("normal").field("x"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_x_r",
        Expr::ident("rho_u_r").field("x") * Expr::ident("u_n_r")
            + Expr::ident("p_r") * Expr::ident("normal").field("x"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_u_x",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_u_x_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_u_x_r")
                + Expr::ident("a_prod_scaled")
                    * (Expr::ident("rho_u_r").field("x") - Expr::ident("rho_u_l").field("x")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_y_l",
        Expr::ident("rho_u_l").field("y") * Expr::ident("u_n_l")
            + Expr::ident("p_l") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_u_y_r",
        Expr::ident("rho_u_r").field("y") * Expr::ident("u_n_r")
            + Expr::ident("p_r") * Expr::ident("normal").field("y"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_u_y",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_u_y_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_u_y_r")
                + Expr::ident("a_prod_scaled")
                    * (Expr::ident("rho_u_r").field("y") - Expr::ident("rho_u_l").field("y")),
        ),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_x",
        (-Expr::ident("mu")) * (Expr::ident("u_r_x") - Expr::ident("u_l_x")) / Expr::ident("dist"),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_y",
        (-Expr::ident("mu")) * (Expr::ident("u_r_y") - Expr::ident("u_l_y")) / Expr::ident("dist"),
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_u_x"),
        Expr::ident("flux_rho_u_x") + Expr::ident("diff_u_x"),
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_u_y"),
        Expr::ident("flux_rho_u_y") + Expr::ident("diff_u_y"),
    ));

    loop_body.push(dsl::let_expr(
        "flux_rho_e_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("u_n_l"),
    ));
    loop_body.push(dsl::let_expr(
        "flux_rho_e_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("u_n_r"),
    ));
    loop_body.push(dsl::var_typed_expr(
        "flux_rho_e",
        Type::F32,
        Some(
            Expr::ident("a_pos") * Expr::ident("flux_rho_e_l")
                + Expr::ident("a_neg") * Expr::ident("flux_rho_e_r")
                + Expr::ident("a_prod_scaled") * (Expr::ident("rho_e_r") - Expr::ident("rho_e_l")),
        ),
    ));

    // Rhieâ€“Chow-style pressure flux coupling is only used with low-Mach preconditioning.
    // (In the pure KT mode it can introduce dispersive/odd-even pressure ringing.)
    let pressure_coupling_block = dsl::block(vec![
        dsl::let_typed_expr(
            "normal_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("normal")).expr(),
        ),
        dsl::let_expr(
            "inv_rho_l_cell",
            Expr::from(1.0) / dsl::max("rho_l_cell", 1e-8),
        ),
        dsl::let_expr(
            "inv_rho_r_cell",
            Expr::from(1.0) / dsl::max("rho_r_cell", 1e-8),
        ),
        dsl::let_typed_expr(
            "u_l_cell",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_l_cell"))
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "u_r_cell",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("rho_u_r_cell"))
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_expr(
            "u2_l_cell",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_l_cell"))),
        ),
        dsl::let_expr(
            "u2_r_cell",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u_r_cell"))),
        ),
        dsl::let_typed_expr(
            "grad_rho_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(Expr::ident("grad_rho").index(Expr::ident("idx")))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_x_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_x").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_y_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_y").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_e_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_e").index(Expr::ident("idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_x_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_x").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u_y_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_u_y").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_e_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("grad_rho_e").index(Expr::ident("other_idx")),
            )
            .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_x_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("x")),
                )
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_y_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("y")),
                )
                .mul_scalar(Expr::ident("inv_rho_l_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_x_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_x_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("x")),
                )
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u_y_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u_y_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("y")),
                )
                .mul_scalar(Expr::ident("inv_rho_r_cell"))
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u2_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_l_vec"))
                .mul_scalar(Expr::ident("u_l_cell").field("x") * 2.0)
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_l_vec"))
                        .mul_scalar(Expr::ident("u_l_cell").field("y") * 2.0),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_u2_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_x_r_vec"))
                .mul_scalar(Expr::ident("u_r_cell").field("x") * 2.0)
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u_y_r_vec"))
                        .mul_scalar(Expr::ident("u_r_cell").field("y") * 2.0),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u2_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_l_vec"))
                .mul_scalar(Expr::ident("u2_l_cell"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_l_vec"))
                        .mul_scalar(Expr::ident("rho_l_cell")),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_rho_u2_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_r_vec"))
                .mul_scalar(Expr::ident("u2_r_cell"))
                .add(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_u2_r_vec"))
                        .mul_scalar(Expr::ident("rho_r_cell")),
                )
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_p_l_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_l_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_l_vec"))
                        .mul_scalar(0.5.into()),
                )
                .mul_scalar(gamma_minus_1.into())
                .expr(),
        ),
        dsl::let_typed_expr(
            "grad_p_r_vec",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_e_r_vec"))
                .sub(
                    &typed::VecExpr::<2>::from_expr(Expr::ident("grad_rho_u2_r_vec"))
                        .mul_scalar(0.5.into()),
                )
                .mul_scalar(gamma_minus_1.into())
                .expr(),
        ),
        dsl::let_expr(
            "grad_p_l_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_l_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::let_expr(
            "grad_p_r_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_r_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::let_expr(
            "grad_p_face_n",
            (Expr::ident("grad_p_l_n") + Expr::ident("grad_p_r_n")) * 0.5,
        ),
        dsl::let_expr(
            "grad_p_jump_n",
            (Expr::ident("p_r") - Expr::ident("p_l")) / Expr::ident("dist"),
        ),
        dsl::let_expr(
            "rho_face",
            (Expr::ident("rho_l") + Expr::ident("rho_r")) * 0.5,
        ),
        dsl::let_expr("p_bar", (Expr::ident("p_l") + Expr::ident("p_r")) * 0.5),
        dsl::let_expr(
            "dp_rel",
            dsl::abs(Expr::ident("p_r") - Expr::ident("p_l")) / dsl::max("p_bar", 1e-6),
        ),
        dsl::let_expr(
            "pc_theta",
            dsl::min(
                1.0,
                dsl::max(
                    Expr::ident("mach2"),
                    Expr::ident("low_mach").field("theta_floor"),
                ),
            ),
        ),
        dsl::let_expr("pc_low_mach", Expr::from(1.0) - Expr::ident("pc_theta")),
        dsl::let_expr(
            "pc_smooth",
            Expr::from(1.0) / ((Expr::ident("dp_rel") / 0.2) * (Expr::ident("dp_rel") / 0.2) + 1.0),
        ),
        dsl::let_expr(
            "pc_alpha",
            Expr::ident("low_mach").field("pressure_coupling_alpha")
                * Expr::ident("pc_low_mach")
                * Expr::ident("pc_smooth"),
        ),
        dsl::let_expr(
            "m_corr",
            Expr::ident("pc_alpha") * Expr::ident("constants").field("dt")
                / dsl::max("rho_face", 1e-8)
                * (Expr::ident("grad_p_face_n") - Expr::ident("grad_p_jump_n")),
        ),
        dsl::let_expr(
            "h_l",
            (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
        ),
        dsl::let_expr(
            "h_r",
            (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
        ),
        dsl::let_expr("h_face", (Expr::ident("h_l") + Expr::ident("h_r")) * 0.5),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho"),
            Expr::ident("m_corr"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_u_x"),
            Expr::ident("m_corr") * Expr::ident("u_face_x"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_u_y"),
            Expr::ident("m_corr") * Expr::ident("u_face_y"),
        ),
        dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("flux_rho_e"),
            Expr::ident("m_corr") * Expr::ident("h_face"),
        ),
    ]);
    loop_body.push(dsl::if_block_expr(
        (!Expr::ident("is_boundary"))
            & precond_model.ne(GpuLowMachPrecondModel::Off)
            & Expr::ident("low_mach")
                .field("pressure_coupling_alpha")
                .gt(0.0),
        pressure_coupling_block,
        None,
    ));
    loop_body.push(dsl::assign_expr(
        Expr::ident("flux_rho_e"),
        Expr::ident("flux_rho_e")
            + Expr::ident("diff_u_x") * Expr::ident("u_face_x")
            + Expr::ident("diff_u_y") * Expr::ident("u_face_y"),
    ));

    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho"),
        Expr::ident("flux_rho") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_u_x"),
        Expr::ident("flux_rho_u_x") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_u_y"),
        Expr::ident("flux_rho_u_y") * Expr::ident("area"),
    ));
    loop_body.push(dsl::assign_op_expr(
        AssignOp::Add,
        Expr::ident("sum_rho_e"),
        Expr::ident("flux_rho_e") * Expr::ident("area"),
    ));

    loop_body.push(dsl::let_expr(
        "q_l",
        Expr::ident("u_l_x") * Expr::ident("u_l_x") + Expr::ident("u_l_y") * Expr::ident("u_l_y"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drho_l",
        Expr::from(gamma_minus_1) * Expr::ident("q_l") * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "dp_dru_l",
        Expr::from(-gamma_minus_1) * Expr::ident("u_l_x"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drv_l",
        Expr::from(-gamma_minus_1) * Expr::ident("u_l_y"),
    ));
    loop_body.push(dsl::let_expr("dp_dre_l", gamma_minus_1));
    loop_body.push(dsl::let_expr(
        "H_l",
        (Expr::ident("rho_e_l") + Expr::ident("p_l")) * Expr::ident("inv_rho_l"),
    ));

    loop_body.push(dsl::let_expr(
        "q_r",
        Expr::ident("u_r_x") * Expr::ident("u_r_x") + Expr::ident("u_r_y") * Expr::ident("u_r_y"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drho_r",
        Expr::from(gamma_minus_1) * Expr::ident("q_r") * 0.5,
    ));
    loop_body.push(dsl::let_expr(
        "dp_dru_r",
        Expr::from(-gamma_minus_1) * Expr::ident("u_r_x"),
    ));
    loop_body.push(dsl::let_expr(
        "dp_drv_r",
        Expr::from(-gamma_minus_1) * Expr::ident("u_r_y"),
    ));
    loop_body.push(dsl::let_expr("dp_dre_r", gamma_minus_1));
    loop_body.push(dsl::let_expr(
        "H_r",
        (Expr::ident("rho_e_r") + Expr::ident("p_r")) * Expr::ident("inv_rho_r"),
    ));

    loop_body.push(dsl::let_expr(
        "a_l",
        Expr::ident("a_plus") / Expr::ident("denom"),
    ));
    loop_body.push(dsl::let_expr(
        "a_r",
        (-Expr::ident("a_minus")) / Expr::ident("denom"),
    ));

    loop_body.push(dsl::let_expr(
        "mu_over_dist",
        Expr::ident("mu") / Expr::ident("dist"),
    ));
    loop_body.push(dsl::let_expr(
        "u_face_vec",
        Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("u_face_x"), Expr::ident("u_face_y")],
        ),
    ));
    loop_body.push(dsl::let_expr(
        "diff_u_vec",
        Expr::call_named(
            "vec2<f32>",
            vec![Expr::ident("diff_u_x"), Expr::ident("diff_u_y")],
        ),
    ));

    let a_prod_scaled = Expr::ident("a_prod_scaled");
    let a_l = Expr::ident("a_l");
    let a_r = Expr::ident("a_r");
    let normal = Expr::ident("normal");
    let nx = normal.field("x");
    let ny = normal.field("y");
    let zero: Expr = 0.0.into();
    let one: Expr = 1.0.into();
    let gamma: Expr = 1.4.into();
    let u_n_l = Expr::ident("u_n_l");
    let u_n_r = Expr::ident("u_n_r");
    let u_l_x = Expr::ident("u_l_x");
    let u_l_y = Expr::ident("u_l_y");
    let u_r_x = Expr::ident("u_r_x");
    let u_r_y = Expr::ident("u_r_y");
    let dp_drho_l = Expr::ident("dp_drho_l");
    let dp_dru_l = Expr::ident("dp_dru_l");
    let dp_drv_l = Expr::ident("dp_drv_l");
    let dp_dre_l = Expr::ident("dp_dre_l");
    let dp_drho_r = Expr::ident("dp_drho_r");
    let dp_dru_r = Expr::ident("dp_dru_r");
    let dp_drv_r = Expr::ident("dp_drv_r");
    let dp_dre_r = Expr::ident("dp_dre_r");
    let h_l = Expr::ident("H_l");
    let h_r = Expr::ident("H_r");
    let mu_over_dist = Expr::ident("mu_over_dist");

    let u_face = typed::NamedVecExpr::<2, typed::AxisXY>::from_expr(Expr::ident("u_face_vec"));
    let diff_u = typed::NamedVecExpr::<2, typed::AxisXY>::from_expr(Expr::ident("diff_u_vec"));

    let a_l_mat = typed::MatExpr::<4, 4>::from_entries([
        [zero, nx, ny, zero],
        [
            dp_drho_l * nx - u_l_x * u_n_l,
            u_n_l + nx * (u_l_x + dp_dru_l),
            u_l_x * ny + dp_drv_l * nx,
            dp_dre_l * nx,
        ],
        [
            dp_drho_l * ny - u_l_y * u_n_l,
            u_l_y * nx + dp_dru_l * ny,
            u_n_l + ny * (u_l_y + dp_drv_l),
            dp_dre_l * ny,
        ],
        [
            u_n_l * (dp_drho_l - h_l),
            h_l * nx + dp_dru_l * u_n_l,
            h_l * ny + dp_drv_l * u_n_l,
            gamma * u_n_l,
        ],
    ]);

    let a_r_mat = typed::MatExpr::<4, 4>::from_entries([
        [zero, nx, ny, zero],
        [
            dp_drho_r * nx - u_r_x * u_n_r,
            u_n_r + nx * (u_r_x + dp_dru_r),
            u_r_x * ny + dp_drv_r * nx,
            dp_dre_r * nx,
        ],
        [
            dp_drho_r * ny - u_r_y * u_n_r,
            u_r_y * nx + dp_dru_r * ny,
            u_n_r + ny * (u_r_y + dp_drv_r),
            dp_dre_r * ny,
        ],
        [
            u_n_r * (dp_drho_r - h_r),
            h_r * nx + dp_dru_r * u_n_r,
            h_r * ny + dp_drv_r * u_n_r,
            gamma * u_n_r,
        ],
    ]);

    let velocity_jacobian = |u_x: Expr, u_y: Expr, inv_rho: Expr| {
        typed::NamedMatExpr::<2, 4, typed::AxisXY, typed::AxisCons>::from_entries([
            [(-u_x) * inv_rho, inv_rho, zero, zero],
            [(-u_y) * inv_rho, zero, inv_rho, zero],
        ])
    };

    let du_l_d_cons = velocity_jacobian(u_l_x, u_l_y, Expr::ident("inv_rho_l"));
    let du_r_d_cons = velocity_jacobian(u_r_x, u_r_y, Expr::ident("inv_rho_r"));

    let d_diff_l = du_l_d_cons.mul_scalar(mu_over_dist);
    let d_diff_r = du_r_d_cons.mul_scalar(-mu_over_dist);

    let du_face_l = du_l_d_cons.mul_scalar(0.5.into());
    let du_face_r = du_r_d_cons.mul_scalar(0.5.into());

    let d_e_visc_l = d_diff_l
        .contract_rows(&u_face)
        .add(&du_face_l.contract_rows(&diff_u));
    let d_e_visc_r = d_diff_r
        .contract_rows(&u_face)
        .add(&du_face_r.contract_rows(&diff_u));

    let visc_l = typed::MatExpr::<4, 4>::from_entries([
        [zero, zero, zero, zero],
        [
            d_diff_l.at(typed::XY::X, typed::Cons::Rho),
            d_diff_l.at(typed::XY::X, typed::Cons::Ru),
            d_diff_l.at(typed::XY::X, typed::Cons::Rv),
            d_diff_l.at(typed::XY::X, typed::Cons::Re),
        ],
        [
            d_diff_l.at(typed::XY::Y, typed::Cons::Rho),
            d_diff_l.at(typed::XY::Y, typed::Cons::Ru),
            d_diff_l.at(typed::XY::Y, typed::Cons::Rv),
            d_diff_l.at(typed::XY::Y, typed::Cons::Re),
        ],
        [
            d_e_visc_l.at(typed::Cons::Rho),
            d_e_visc_l.at(typed::Cons::Ru),
            d_e_visc_l.at(typed::Cons::Rv),
            d_e_visc_l.at(typed::Cons::Re),
        ],
    ]);
    let visc_r = typed::MatExpr::<4, 4>::from_entries([
        [zero, zero, zero, zero],
        [
            d_diff_r.at(typed::XY::X, typed::Cons::Rho),
            d_diff_r.at(typed::XY::X, typed::Cons::Ru),
            d_diff_r.at(typed::XY::X, typed::Cons::Rv),
            d_diff_r.at(typed::XY::X, typed::Cons::Re),
        ],
        [
            d_diff_r.at(typed::XY::Y, typed::Cons::Rho),
            d_diff_r.at(typed::XY::Y, typed::Cons::Ru),
            d_diff_r.at(typed::XY::Y, typed::Cons::Rv),
            d_diff_r.at(typed::XY::Y, typed::Cons::Re),
        ],
        [
            d_e_visc_r.at(typed::Cons::Rho),
            d_e_visc_r.at(typed::Cons::Ru),
            d_e_visc_r.at(typed::Cons::Rv),
            d_e_visc_r.at(typed::Cons::Re),
        ],
    ]);

    let diag_term = typed::MatExpr::<4, 4>::identity().mul_scalar(a_prod_scaled);
    let jac_l = a_l_mat.mul_scalar(a_l).add(&visc_l).sub(&diag_term);
    let jac_r = a_r_mat.mul_scalar(a_r).add(&visc_r).add(&diag_term);

    let mut interior_matrix_stmts = vec![
        dsl::let_expr(
            "scalar_mat_idx",
            Expr::ident("cell_face_matrix_indices").index(Expr::ident("face_offset")),
        ),
        dsl::let_expr(
            "neighbor_rank",
            Expr::ident("scalar_mat_idx") - Expr::ident("scalar_offset"),
        ),
    ];

    let neighbor_entry = block_matrix.row_entry(&Expr::ident("neighbor_rank"));
    interior_matrix_stmts.extend(
        jac_r.scatter_assign_to_block_entry_scaled(&neighbor_entry, Some(Expr::ident("area"))),
    );
    interior_matrix_stmts.extend(jac_l.assign_op_to_prefix_scaled(
        AssignOp::Add,
        "diag",
        Some(Expr::ident("area")),
    ));

    let interior_matrix = dsl::block(interior_matrix_stmts);

    let boundary_matrix = {
        let area = Expr::ident("area");
        let eff_default = jac_l.add(&jac_r);
        let default_block =
            dsl::block(eff_default.assign_op_to_prefix_scaled(AssignOp::Add, "diag", Some(area)));

        let inlet_velocity = Expr::ident("constants").field("inlet_velocity");
        let t_inlet = typed::MatExpr::<4, 4>::from_entries([
            [one, zero, zero, zero],
            [inlet_velocity, zero, zero, zero],
            [zero, zero, zero, zero],
            [zero, zero, zero, one],
        ]);
        let eff_inlet = jac_l.add(&jac_r.mul_mat(&t_inlet));
        let inlet_block =
            dsl::block(eff_inlet.assign_op_to_prefix_scaled(AssignOp::Add, "diag", Some(area)));

        let wall_block = {
            let mut wall = Vec::new();
            // Wall BC couples the right state to the left state:
            //   m_r = m_l - 2 (m_l Â· n) n
            // This requires applying the momentum reflection matrix to the right-state Jacobian.
            let normal = Expr::ident("normal");
            let nx = normal.field("x");
            let ny = normal.field("y");
            let nx_sq = nx * nx;
            let ny_sq = ny * ny;
            wall.extend([
                dsl::let_expr("r11", one - nx_sq * 2.0),
                dsl::let_expr("r12", (nx * ny) * -2.0),
                dsl::let_expr("r21", (ny * nx) * -2.0),
                dsl::let_expr("r22", one - ny_sq * 2.0),
            ]);

            let t_wall = typed::MatExpr::<4, 4>::from_entries([
                [one, zero, zero, zero],
                [zero, Expr::ident("r11"), Expr::ident("r12"), zero],
                [zero, Expr::ident("r21"), Expr::ident("r22"), zero],
                [zero, zero, zero, one],
            ]);
            let eff_wall = jac_l.add(&jac_r.mul_mat(&t_wall));
            wall.extend(eff_wall.assign_op_to_prefix_scaled(AssignOp::Add, "diag", Some(area)));
            dsl::block(wall)
        };

        let boundary_type =
            typed::EnumExpr::<GpuBoundaryType>::from_expr(Expr::ident("boundary_type"));
        let boundary_stmt = dsl::if_block_expr(
            boundary_type.eq(GpuBoundaryType::Inlet),
            inlet_block,
            Some(dsl::block(vec![dsl::if_block_expr(
                boundary_type.eq(GpuBoundaryType::Wall),
                wall_block,
                Some(default_block),
            )])),
        );

        dsl::block(vec![boundary_stmt])
    };

    loop_body.push(dsl::if_block_expr(
        !Expr::ident("is_boundary"),
        interior_matrix,
        Some(boundary_matrix),
    ));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("face_offset", Expr::ident("start")),
        Expr::ident("face_offset").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("face_offset")),
        dsl::block(loop_body),
    ));

    stmts.push(dsl::var_typed_expr(
        "rhs_rho",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho") + Expr::ident("rhs_pseudo_rho")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo")) * Expr::ident("rho")
                - Expr::ident("sum_rho"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_u_x",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_u_x") + Expr::ident("rhs_pseudo_rho_u_x")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo"))
                    * Expr::ident("rho_u").field("x")
                - Expr::ident("sum_rho_u_x"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_u_y",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_u_y") + Expr::ident("rhs_pseudo_rho_u_y")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo"))
                    * Expr::ident("rho_u").field("y")
                - Expr::ident("sum_rho_u_y"),
        ),
    ));
    stmts.push(dsl::var_typed_expr(
        "rhs_rho_e",
        Type::F32,
        Some(
            Expr::ident("rhs_time_rho_e") + Expr::ident("rhs_pseudo_rho_e")
                - (Expr::ident("coeff_time") + Expr::ident("coeff_pseudo")) * Expr::ident("rho_e")
                - Expr::ident("sum_rho_e"),
        ),
    ));

    stmts.extend(diag_mat.assign_op_diag(AssignOp::Add, Expr::ident("coeff_time")));
    stmts.extend(diag_mat.assign_op_diag(AssignOp::Add, Expr::ident("coeff_pseudo")));

    stmts.push(dsl::let_expr(
        "scalar_diag_idx",
        dsl::array_access("diagonal_indices", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "diag_rank",
        Expr::ident("scalar_diag_idx") - Expr::ident("scalar_offset"),
    ));
    let diag_entry = block_matrix.row_entry(&Expr::ident("diag_rank"));
    stmts.extend(diag_mat.scatter_assign_to_block_entry_scaled(&diag_entry, None));

    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        0,
        Expr::ident("rhs_rho"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        1,
        Expr::ident("rhs_rho_u_x"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        2,
        Expr::ident("rhs_rho_u_y"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "rhs",
        Expr::ident("idx"),
        4,
        3,
        Expr::ident("rhs_rho_e"),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_assembly_codegen_emits_bindings() {
        let model = compressible_model();
        let fields = model.fields.compressible().expect("compressible fields");
        let wgsl = generate_compressible_assembly_wgsl(&model.state_layout, fields);
        assert!(wgsl.contains("matrix_values"));
        assert!(wgsl.contains("rhs"));
        assert!(wgsl.contains("scalar_row_offsets"));
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("sum_rho"));
        assert!(wgsl.contains("rhs_time_rho"));
        assert!(wgsl.contains("dp_drho_l"));
        assert!(!wgsl.contains("A_l_10"));
    }
}
