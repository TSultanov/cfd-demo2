use cfd2_codegen::solver::codegen::{
    wgsl_ast::{
        AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
        StorageClass, StructDef, StructField, Type,
    },
    wgsl_dsl as dsl,
    KernelWgsl,
};

pub fn generate_dp_init_wgsl(state_stride: u32, d_p_offset: u32) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN (dp_init)".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.push(Item::Struct(constants_struct()));
    module.push(storage_var(
        "cell_vols",
        Type::array(Type::F32),
        0,
        0,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        1,
        AccessMode::ReadWrite,
    ));
    module.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        2,
    ));
    module.push(Item::Function(dp_init_main_fn(state_stride, d_p_offset)));
    KernelWgsl::from(module)
}

pub fn generate_dp_update_from_diag_wgsl(
    state_stride: u32,
    d_p_offset: u32,
    unknowns_per_cell: u32,
    u_indices: &[u32],
) -> Result<KernelWgsl, String> {
    if unknowns_per_cell == 0 {
        return Err("dp_update_from_diag requires unknowns_per_cell > 0".to_string());
    }
    if u_indices.is_empty() {
        return Err("dp_update_from_diag requires at least one momentum component index".to_string());
    }
    if u_indices.len() > 8 {
        return Err("dp_update_from_diag supports at most 8 momentum components".to_string());
    }
    if u_indices.iter().any(|&u| u >= unknowns_per_cell) {
        return Err(format!(
            "dp_update_from_diag: momentum indices {:?} out of range for unknowns_per_cell={unknowns_per_cell}",
            u_indices
        ));
    }

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (dp_update_from_diag)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.push(Item::Struct(constants_struct()));
    module.push(storage_var(
        "scalar_row_offsets",
        Type::array(Type::U32),
        0,
        0,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "diagonal_indices",
        Type::array(Type::U32),
        0,
        1,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "matrix_values",
        Type::array(Type::F32),
        0,
        2,
        AccessMode::Read,
    ));
    module.push(storage_var(
        "state",
        Type::array(Type::F32),
        0,
        3,
        AccessMode::ReadWrite,
    ));
    module.push(uniform_var(
        "constants",
        Type::Custom("Constants".to_string()),
        0,
        4,
    ));
    module.push(Item::Function(dp_update_main_fn(state_stride, d_p_offset)));
    Ok(KernelWgsl::from(module))
}

pub fn generate_rhie_chow_store_grad_p_wgsl(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_store_grad_p)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(rhie_chow_base_items());
    module.push(Item::Function(rhie_chow_store_grad_p_main_fn(
        state_stride,
        grad_p_x_offset,
        grad_p_y_offset,
        grad_old_x_offset,
        grad_old_y_offset,
    )));
    KernelWgsl::from(module)
}

pub fn generate_rhie_chow_correct_velocity_delta_wgsl(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> KernelWgsl {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (rhie_chow_correct_velocity_delta)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(rhie_chow_base_items());
    module.push(Item::Function(rhie_chow_correct_velocity_delta_main_fn(
        state_stride,
        u_x_offset,
        u_y_offset,
        d_p_offset,
        grad_p_x_offset,
        grad_p_y_offset,
        grad_old_x_offset,
        grad_old_y_offset,
    )));
    KernelWgsl::from(module)
}

fn constants_struct() -> StructDef {
    // Match the shared `GpuConstants` layout used by generated kernels so we can bind the
    // common `constants` uniform buffer without a dedicated params struct.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
        ],
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn dp_init_main_fn(state_stride: u32, d_p_offset: u32) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        dp_init_main_body(state_stride, d_p_offset),
    )
}

fn dp_init_main_body(state_stride: u32, d_p_offset: u32) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));

    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()])
            / dsl::max(Expr::lit_u32(state_stride), Expr::lit_u32(1)),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "rho",
        dsl::max(
            Expr::ident("constants").field("density"),
            Expr::lit_f32(1e-12),
        ),
    ));
    stmts.push(dsl::let_expr(
        "dt",
        dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
    ));

    // Kept for parity with the historical shader output (even though not currently used).
    stmts.push(dsl::let_expr(
        "vol",
        dsl::max(
            dsl::array_access("cell_vols", Expr::ident("idx")),
            Expr::lit_f32(1e-12),
        ),
    ));

    stmts.push(dsl::comment(
        "Seed Rhie–Chow mobility with a transient-scale approximation.",
    ));
    stmts.push(dsl::comment(
        "For integrated momentum diagonals A_U ~ rho*vol/dt (units: kg/s), a good first guess for",
    ));
    stmts.push(dsl::comment("the mobility-like coefficient is:"));
    stmts.push(dsl::comment("  d_p ≈ vol / A_U ≈ dt / rho"));
    stmts.push(dsl::comment(
        "Note: the solver applies velocity under-relaxation in the update stage rather than",
    ));
    stmts.push(dsl::comment(
        "modifying the assembled momentum diagonal. Match SIMPLE-like behavior by folding the",
    ));
    stmts.push(dsl::comment(
        "relaxation factor into the mobility: d_p ≈ alpha_u / A_U.",
    ));

    stmts.push(dsl::let_expr(
        "d_p",
        Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
    ));

    stmts.push(dsl::assign_array_access_linear(
        "state",
        Expr::ident("idx"),
        state_stride,
        d_p_offset,
        Expr::ident("d_p"),
    ));

    Block::new(stmts)
}

fn dp_update_main_fn(state_stride: u32, d_p_offset: u32) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        dp_update_main_body(state_stride, d_p_offset),
    )
}

fn dp_update_main_body(state_stride: u32, d_p_offset: u32) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named(
            "arrayLength",
            vec![Expr::ident("scalar_row_offsets").addr_of()],
        ) - Expr::lit_u32(1),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::comment(
        "Transient-scale approximation: d_p ≈ alpha_u * dt / rho.",
    ));
    stmts.push(dsl::comment(
        "This is the mobility used by the Rhie–Chow flux and pressure correction equation for",
    ));
    stmts.push(dsl::comment("incompressible pseudo-time marching."));

    stmts.push(dsl::let_expr(
        "rho",
        dsl::max(
            Expr::ident("constants").field("density"),
            Expr::lit_f32(1e-12),
        ),
    ));
    stmts.push(dsl::let_expr(
        "dt",
        dsl::max(Expr::ident("constants").field("dt"), Expr::lit_f32(0.0)),
    ));
    stmts.push(dsl::let_expr(
        "d_p",
        Expr::ident("constants").field("alpha_u") * Expr::ident("dt") / Expr::ident("rho"),
    ));
    stmts.push(dsl::assign_array_access_linear(
        "state",
        Expr::ident("idx"),
        state_stride,
        d_p_offset,
        Expr::ident("d_p"),
    ));

    Block::new(stmts)
}

fn rhie_chow_base_items() -> Vec<Item> {
    vec![
        Item::Struct(constants_struct()),
        storage_var(
            "state",
            Type::array(Type::F32),
            0,
            0,
            AccessMode::ReadWrite,
        ),
        uniform_var(
            "constants",
            Type::Custom("Constants".to_string()),
            0,
            1,
        ),
    ]
}

fn rhie_chow_store_grad_p_main_fn(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        rhie_chow_store_grad_p_main_body(
            state_stride,
            grad_p_x_offset,
            grad_p_y_offset,
            grad_old_x_offset,
            grad_old_y_offset,
        ),
    )
}

fn rhie_chow_store_grad_p_main_body(
    state_stride: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Block {
    let mut stmts = rhie_chow_main_preamble(state_stride);

    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_x_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_y_offset),
        ),
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));

    Block::new(stmts)
}

fn rhie_chow_correct_velocity_delta_main_fn(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Function {
    Function::new(
        "main",
        main_params(),
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        rhie_chow_correct_velocity_delta_main_body(
            state_stride,
            u_x_offset,
            u_y_offset,
            d_p_offset,
            grad_p_x_offset,
            grad_p_y_offset,
            grad_old_x_offset,
            grad_old_y_offset,
        ),
    )
}

fn rhie_chow_correct_velocity_delta_main_body(
    state_stride: u32,
    u_x_offset: u32,
    u_y_offset: u32,
    d_p_offset: u32,
    grad_p_x_offset: u32,
    grad_p_y_offset: u32,
    grad_old_x_offset: u32,
    grad_old_y_offset: u32,
) -> Block {
    let mut stmts = rhie_chow_main_preamble(state_stride);

    stmts.push(dsl::let_expr(
        "d_p",
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(d_p_offset)),
    ));
    stmts.push(dsl::let_expr(
        "grad_px",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_py",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_p_y_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_old_x",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_x_offset),
        ),
    ));
    stmts.push(dsl::let_expr(
        "grad_old_y",
        dsl::array_access(
            "state",
            Expr::ident("base") + Expr::lit_u32(grad_old_y_offset),
        ),
    ));

    stmts.push(dsl::comment(
        "Apply SIMPLE-style velocity correction using the change in pressure gradient:",
    ));
    stmts.push(dsl::comment("  U_new = HbyA - d_p * grad(p_new)"));
    stmts.push(dsl::comment("  U_old = HbyA - d_p * grad(p_old)"));
    stmts.push(dsl::comment("=> U_new = U_old - d_p * (grad(p_new) - grad(p_old))"));

    stmts.push(dsl::let_expr(
        "corr_x",
        Expr::ident("d_p") * (Expr::ident("grad_px") - Expr::ident("grad_old_x")),
    ));
    stmts.push(dsl::let_expr(
        "corr_y",
        Expr::ident("d_p") * (Expr::ident("grad_py") - Expr::ident("grad_old_y")),
    ));

    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_x_offset)),
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_x_offset))
            - Expr::ident("corr_x"),
    ));
    stmts.push(dsl::assign_expr(
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_y_offset)),
        dsl::array_access("state", Expr::ident("base") + Expr::lit_u32(u_y_offset))
            - Expr::ident("corr_y"),
    ));

    Block::new(stmts)
}

fn main_params() -> Vec<Param> {
    vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )]
}

fn rhie_chow_main_preamble(state_stride: u32) -> Vec<Stmt> {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()])
            / dsl::max(Expr::lit_u32(state_stride), Expr::lit_u32(1)),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::ident("num_cells")),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "base",
        Expr::ident("idx") * Expr::lit_u32(state_stride),
    ));

    stmts
}

