use super::coeff_expr::{coeff_cell_expr, coeff_face_expr};
use super::ir::DiscreteSystem;
use super::plan::{momentum_plan, MomentumPlan};
use super::state_access::{state_component_expr, state_scalar_expr, state_vec2_expr};
use crate::solver::model::IncompressibleMomentumFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_prepare_coupled_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (prepare_coupled)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    let plan = momentum_plan(system, fields.u.name(), fields.p.name());
    module.push(Item::Function(main_fn(layout, &plan, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items.push(Item::Comment(
        "Group 2: Solver (Coupled) - Must match coupled_assembly_merged.wgsl layout".to_string(),
    ));
    items.extend(solver_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn solver_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "matrix_values",
            Type::array(Type::F32),
            2,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var("rhs", Type::array(Type::F32), 2, 1, AccessMode::ReadWrite),
        storage_var(
            "scalar_row_offsets",
            Type::array(Type::U32),
            2,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "grad_u",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            3,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_v",
            Type::array(Type::Custom("Vector2".to_string())),
            2,
            4,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "scalar_matrix_values",
            Type::array(Type::F32),
            2,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_u_inv",
            Type::array(Type::F32),
            2,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_v_inv",
            Type::array(Type::F32),
            2,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "diag_p_inv",
            Type::array(Type::F32),
            2,
            8,
            AccessMode::ReadWrite,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, plan, fields),
    )
}

fn main_body(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Block {
    let mut stmts = Vec::new();
    let u_field = fields.u.name();
    let p_field = fields.p.name();
    let d_p_field = fields.d_p.name();
    let grad_p_field = fields.grad_p.name();
    let u_old_expr = state_vec2_expr(layout, "state_old", "idx", u_field);
    let u_idx_expr = state_vec2_expr(layout, "state", "idx", u_field);
    let p_idx_expr = state_scalar_expr(layout, "state", "idx", p_field);
    let rho_cell_expr = coeff_cell_expr(
        layout,
        plan.ddt.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        "constants.density",
    );
    let rho_face_expr = coeff_face_expr(
        layout,
        plan.ddt.as_ref().and_then(|op| op.coeff.as_ref()),
        "owner",
        "n_idx",
        "lambda",
        "rho_cell",
    );
    let diff_coeff_cell_expr = coeff_cell_expr(
        layout,
        plan.diffusion.as_ref().and_then(|op| op.coeff.as_ref()),
        "idx",
        "0.0",
    );
    let diff_coeff_expr = format!("({diff_coeff_cell_expr}) * area / dist");

    stmts.push(dsl::let_("idx", "global_id.x"));
    stmts.push(dsl::if_block(
        "idx >= arrayLength(&cell_vols)",
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_("center", "cell_centers[idx]"));
    stmts.push(dsl::let_("vol", "cell_vols[idx]"));
    stmts.push(dsl::let_("start", "cell_face_offsets[idx]"));
    stmts.push(dsl::let_("end", "cell_face_offsets[idx + 1]"));

    stmts.push(dsl::var_typed("diag_coeff", Type::F32, Some("0.0")));
    stmts.push(dsl::let_("u_n_val", &u_old_expr));
    stmts.push(dsl::let_("rho_cell", &rho_cell_expr));
    if plan.ddt.is_some() {
        stmts.push(dsl::var("time_coeff", "vol * rho_cell / constants.dt"));
        stmts.push(dsl::if_block(
            "constants.time_scheme == 1u",
            dsl::block(vec![
                dsl::let_("dt", "constants.dt"),
                dsl::let_("dt_old", "constants.dt_old"),
                dsl::let_("r", "dt / dt_old"),
                dsl::assign(
                    "time_coeff",
                    "vol * rho_cell / dt * (1.0 + 2.0 * r) / (1.0 + r)",
                ),
            ]),
            None,
        ));
        stmts.push(dsl::assign_op(AssignOp::Add, "diag_coeff", "time_coeff"));
    }

    stmts.push(dsl::let_("val_c_p", &p_idx_expr));
    stmts.push(dsl::var("grad_p_accum", "Vector2(0.0, 0.0)"));

    stmts.push(dsl::let_("u_val", &u_idx_expr));
    stmts.push(dsl::let_("val_c_u", "u_val.x"));
    stmts.push(dsl::let_("val_c_v", "u_val.y"));
    stmts.push(dsl::var("g_u", "Vector2(0.0, 0.0)"));
    stmts.push(dsl::var("g_v", "Vector2(0.0, 0.0)"));

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_("face_idx", "cell_faces[k]"));
    loop_body.push(dsl::let_("owner", "face_owner[face_idx]"));
    loop_body.push(dsl::let_("neigh_idx", "face_neighbor[face_idx]"));
    loop_body.push(dsl::let_("boundary_type", "face_boundary[face_idx]"));
    loop_body.push(dsl::var("normal", "face_normals[face_idx]"));
    loop_body.push(dsl::let_("area", "face_areas[face_idx]"));
    loop_body.push(dsl::let_("f_center", "face_centers[face_idx]"));
    loop_body.push(dsl::var_typed("normal_sign", Type::F32, Some("1.0")));
    loop_body.push(dsl::if_block(
        "owner != idx",
        dsl::block(vec![
            dsl::assign("normal.x", "-normal.x"),
            dsl::assign("normal.y", "-normal.y"),
            dsl::assign("normal_sign", "-1.0"),
        ]),
        None,
    ));

    loop_body.push(dsl::let_("c_owner", "cell_centers[owner]"));
    loop_body.push(dsl::var("normal_flux", "face_normals[face_idx]"));
    loop_body.push(dsl::let_("dx_vec", "f_center.x - c_owner.x"));
    loop_body.push(dsl::let_("dy_vec", "f_center.y - c_owner.y"));
    loop_body.push(dsl::if_block(
        "dx_vec * normal_flux.x + dy_vec * normal_flux.y < 0.0",
        dsl::block(vec![
            dsl::assign("normal_flux.x", "-normal_flux.x"),
            dsl::assign("normal_flux.y", "-normal_flux.y"),
        ]),
        None,
    ));

    loop_body.push(dsl::var_typed("flux", Type::F32, Some("0.0")));
    loop_body.push(dsl::var_typed("rho_face", Type::F32, Some("rho_cell")));

    let u_owner_expr = state_vec2_expr(layout, "state", "owner", u_field);
    let u_neigh_expr = state_vec2_expr(layout, "state", "n_idx", u_field);
    let dp_owner_expr = state_scalar_expr(layout, "state", "owner", d_p_field);
    let dp_neigh_expr = state_scalar_expr(layout, "state", "n_idx", d_p_field);
    let gp_owner_expr = state_vec2_expr(layout, "state", "owner", grad_p_field);
    let gp_neigh_expr = state_vec2_expr(layout, "state", "n_idx", grad_p_field);
    let p_owner_expr = state_scalar_expr(layout, "state", "owner", p_field);
    let p_neigh_expr = state_scalar_expr(layout, "state", "n_idx", p_field);

    let inlet_block = dsl::block(vec![
        dsl::let_(
            "ramp",
            "smoothstep(0.0, constants.ramp_time, constants.time)",
        ),
        dsl::let_("u_bc", "Vector2(constants.inlet_velocity * ramp, 0.0)"),
        dsl::assign(
            "flux",
            "rho_face * (u_bc.x * normal_flux.x + u_bc.y * normal_flux.y) * area",
        ),
    ]);

    let wall_block = dsl::block(vec![dsl::assign("flux", "0.0")]);

    let outlet_block = dsl::block(vec![
        dsl::let_("u_own", &u_owner_expr),
        dsl::let_("u_n", "u_own.x * normal_flux.x + u_own.y * normal_flux.y"),
        dsl::let_("raw_flux", "rho_face * u_n * area"),
        dsl::assign("flux", "max(0.0, raw_flux)"),
    ]);

    loop_body.push(dsl::if_block(
        "neigh_idx != -1",
        dsl::block(vec![
            dsl::let_("n_idx", "u32(neigh_idx)"),
            dsl::let_("c_neigh", "cell_centers[n_idx]"),
            dsl::let_("u_own", &u_owner_expr),
            dsl::let_("u_ngh", &u_neigh_expr),
            dsl::let_("dp_own", &dp_owner_expr),
            dsl::let_("dp_ngh", &dp_neigh_expr),
            dsl::let_("gp_own", &gp_owner_expr),
            dsl::let_("gp_ngh", &gp_neigh_expr),
            dsl::let_("p_own", &p_owner_expr),
            dsl::let_("p_ngh", &p_neigh_expr),
            dsl::let_(
                "d_own",
                "distance(vec2<f32>(c_owner.x, c_owner.y), vec2<f32>(f_center.x, f_center.y))",
            ),
            dsl::let_(
                "d_ngh",
                "distance(vec2<f32>(c_neigh.x, c_neigh.y), vec2<f32>(f_center.x, f_center.y))",
            ),
            dsl::let_("total_dist", "d_own + d_ngh"),
            dsl::var("lambda", "0.5"),
            dsl::if_block(
                "total_dist > 1e-6",
                dsl::block(vec![dsl::assign("lambda", "d_ngh / total_dist")]),
                None,
            ),
            dsl::assign("rho_face", &rho_face_expr),
            dsl::let_(
                "u_face_x",
                "lambda * u_own.x + (1.0 - lambda) * u_ngh.x",
            ),
            dsl::let_(
                "u_face_y",
                "lambda * u_own.y + (1.0 - lambda) * u_ngh.y",
            ),
            dsl::let_("dp_face", "lambda * dp_own + (1.0 - lambda) * dp_ngh"),
            dsl::let_(
                "gp_face_x",
                "lambda * gp_own.x + (1.0 - lambda) * gp_ngh.x",
            ),
            dsl::let_(
                "gp_face_y",
                "lambda * gp_own.y + (1.0 - lambda) * gp_ngh.y",
            ),
            dsl::let_("dx", "c_neigh.x - c_owner.x"),
            dsl::let_("dy", "c_neigh.y - c_owner.y"),
            dsl::let_(
                "dist_proj",
                "abs(dx * normal_flux.x + dy * normal_flux.y)",
            ),
            dsl::let_("dist", "max(dist_proj, 1e-6)"),
            dsl::let_(
                "grad_p_n",
                "gp_face_x * normal_flux.x + gp_face_y * normal_flux.y",
            ),
            dsl::let_("p_grad_f", "(p_ngh - p_own) / dist"),
            dsl::let_("rc_term", "dp_face * area * (grad_p_n - p_grad_f)"),
            dsl::let_("u_n", "u_face_x * normal_flux.x + u_face_y * normal_flux.y"),
            dsl::assign("flux", "rho_face * (u_n * area + rc_term)"),
        ]),
        Some(dsl::block(vec![dsl::if_block(
            "boundary_type == 1u",
            inlet_block,
            Some(dsl::block(vec![dsl::if_block(
                "boundary_type == 3u",
                wall_block,
                Some(dsl::block(vec![dsl::if_block(
                    "boundary_type == 2u",
                    outlet_block,
                    None,
                )])),
            )])),
        )])),
    ));

    loop_body.push(dsl::if_block(
        "owner == idx",
        dsl::block(vec![dsl::assign("fluxes[face_idx]", "flux")]),
        None,
    ));

    loop_body.push(dsl::var("flux_out", "flux"));
    loop_body.push(dsl::if_block(
        "owner != idx",
        dsl::block(vec![dsl::assign("flux_out", "-flux")]),
        None,
    ));

    loop_body.push(dsl::var_typed(
        "other_center",
        Type::Custom("Vector2".to_string()),
        None,
    ));
    loop_body.push(dsl::var("is_boundary", "false"));
    loop_body.push(dsl::var("other_idx", "0u"));
    loop_body.push(dsl::if_block(
        "neigh_idx != -1",
        dsl::block(vec![
            dsl::assign("other_idx", "u32(neigh_idx)"),
            dsl::if_block(
                "owner != idx",
                dsl::block(vec![dsl::assign("other_idx", "owner")]),
                None,
            ),
            dsl::assign("other_center", "cell_centers[other_idx]"),
        ]),
        Some(dsl::block(vec![
            dsl::assign("is_boundary", "true"),
            dsl::assign("other_center", "f_center"),
        ])),
    ));

    loop_body.push(dsl::let_("d_vec_x", "other_center.x - center.x"));
    loop_body.push(dsl::let_("d_vec_y", "other_center.y - center.y"));
    loop_body.push(dsl::let_("dist", "sqrt(d_vec_x*d_vec_x + d_vec_y*d_vec_y)"));
    loop_body.push(dsl::let_("diff_coeff", &diff_coeff_expr));
    loop_body.push(dsl::var_typed("conv_coeff_diag", Type::F32, Some("0.0")));
    loop_body.push(dsl::if_block(
        "flux_out > 0.0",
        dsl::block(vec![dsl::assign("conv_coeff_diag", "flux_out")]),
        None,
    ));

    let inlet_diag = dsl::block(vec![
        dsl::assign_op(AssignOp::Add, "diag_coeff", "diff_coeff"),
        dsl::if_block(
            "flux_out > 0.0",
            dsl::block(vec![dsl::assign_op(AssignOp::Add, "diag_coeff", "flux_out")]),
            None,
        ),
    ]);
    let wall_diag = inlet_diag.clone();
    let outlet_diag = dsl::block(vec![dsl::if_block(
        "flux_out > 0.0",
        dsl::block(vec![dsl::assign_op(AssignOp::Add, "diag_coeff", "flux_out")]),
        None,
    )]);

    loop_body.push(dsl::if_block(
        "!is_boundary",
        dsl::block(vec![dsl::assign_op(
            AssignOp::Add,
            "diag_coeff",
            "diff_coeff + conv_coeff_diag",
        )]),
        Some(dsl::block(vec![dsl::if_block(
            "boundary_type == 1u",
            inlet_diag,
            Some(dsl::block(vec![dsl::if_block(
                "boundary_type == 3u",
                wall_diag,
                Some(dsl::block(vec![dsl::if_block(
                    "boundary_type == 2u",
                    outlet_diag,
                    None,
                )])),
            )])),
        )])),
    ));

    let val_other_p_expr = state_scalar_expr(layout, "state", "other_idx", p_field);
    let grad_internal = dsl::block(vec![
        dsl::let_(
            "d_c",
            "distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y))",
        ),
        dsl::let_(
            "d_o",
            "distance(vec2<f32>(other_center.x, other_center.y), vec2<f32>(f_center.x, f_center.y))",
        ),
        dsl::let_("total_dist_p", "d_c + d_o"),
        dsl::var("lambda_p", "0.5"),
        dsl::if_block(
            "total_dist_p > 1e-6",
            dsl::block(vec![dsl::assign("lambda_p", "d_o / total_dist_p")]),
            None,
        ),
        dsl::let_("val_other_p", &val_other_p_expr),
        dsl::let_(
            "val_f_p",
            "lambda_p * val_c_p + (1.0 - lambda_p) * val_other_p",
        ),
        dsl::assign_op(AssignOp::Add, "grad_p_accum.x", "val_f_p * normal.x * area"),
        dsl::assign_op(AssignOp::Add, "grad_p_accum.y", "val_f_p * normal.y * area"),
    ]);
    let grad_boundary = dsl::block(vec![
        dsl::var("val_f_p", "val_c_p"),
        dsl::if_block(
            "boundary_type == 2u",
            dsl::block(vec![dsl::assign("val_f_p", "0.0")]),
            None,
        ),
        dsl::assign_op(AssignOp::Add, "grad_p_accum.x", "val_f_p * normal.x * area"),
        dsl::assign_op(AssignOp::Add, "grad_p_accum.y", "val_f_p * normal.y * area"),
    ]);
    loop_body.push(dsl::if_block(
        "!is_boundary",
        grad_internal,
        Some(grad_boundary),
    ));

    loop_body.push(dsl::var_typed("val_f_u", Type::F32, Some("0.0")));
    loop_body.push(dsl::var_typed("val_f_v", Type::F32, Some("0.0")));

    let u_other_expr = state_vec2_expr(layout, "state", "other_idx", u_field);
    let internal_vel = dsl::block(vec![
        dsl::let_("u_other", &u_other_expr),
        dsl::let_("val_other_u", "u_other.x"),
        dsl::let_("val_other_v", "u_other.y"),
        dsl::let_(
            "d_c",
            "distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y))",
        ),
        dsl::let_(
            "d_o",
            "distance(vec2<f32>(other_center.x, other_center.y), vec2<f32>(f_center.x, f_center.y))",
        ),
        dsl::let_("total_dist", "d_c + d_o"),
        dsl::if_block(
            "total_dist > 1e-6",
            dsl::block(vec![
                dsl::let_("lambda", "d_o / total_dist"),
                dsl::assign(
                    "val_f_u",
                    "lambda * val_c_u + (1.0 - lambda) * val_other_u",
                ),
                dsl::assign(
                    "val_f_v",
                    "lambda * val_c_v + (1.0 - lambda) * val_other_v",
                ),
            ]),
            Some(dsl::block(vec![
                dsl::assign("val_f_u", "0.5 * (val_c_u + val_other_u)"),
                dsl::assign("val_f_v", "0.5 * (val_c_v + val_other_v)"),
            ])),
        ),
    ]);

    let inlet_vel = dsl::block(vec![
        dsl::let_(
            "ramp",
            "smoothstep(0.0, constants.ramp_time, constants.time)",
        ),
        dsl::assign("val_f_u", "constants.inlet_velocity * ramp"),
        dsl::assign("val_f_v", "0.0"),
    ]);
    let wall_vel = dsl::block(vec![
        dsl::assign("val_f_u", "0.0"),
        dsl::assign("val_f_v", "0.0"),
    ]);
    let outlet_vel = dsl::block(vec![
        dsl::assign("val_f_u", "val_c_u"),
        dsl::assign("val_f_v", "val_c_v"),
    ]);

    let boundary_vel = dsl::block(vec![dsl::if_block(
        "boundary_type == 1u",
        inlet_vel,
        Some(dsl::block(vec![dsl::if_block(
            "boundary_type == 3u",
            wall_vel,
            Some(outlet_vel),
        )])),
    )]);

    loop_body.push(dsl::if_block(
        "!is_boundary",
        internal_vel,
        Some(boundary_vel),
    ));

    loop_body.push(dsl::assign_op(AssignOp::Add, "g_u.x", "val_f_u * normal.x * area"));
    loop_body.push(dsl::assign_op(AssignOp::Add, "g_u.y", "val_f_u * normal.y * area"));
    loop_body.push(dsl::assign_op(AssignOp::Add, "g_v.x", "val_f_v * normal.x * area"));
    loop_body.push(dsl::assign_op(AssignOp::Add, "g_v.y", "val_f_v * normal.y * area"));

    stmts.push(dsl::for_loop(
        dsl::for_init_var("k", "start"),
        "k < end",
        dsl::for_step_increment("k"),
        dsl::block(loop_body),
    ));

    let d_p_target = state_component_expr(layout, "state", "idx", d_p_field, 0);
    stmts.push(dsl::if_block(
        "abs(diag_coeff) > 1e-20",
        dsl::block(vec![dsl::assign(&d_p_target, "vol / diag_coeff")]),
        Some(dsl::block(vec![dsl::assign(&d_p_target, "0.0")])),
    ));

    stmts.push(dsl::assign("grad_p_accum.x", "grad_p_accum.x / vol"));
    stmts.push(dsl::assign("grad_p_accum.y", "grad_p_accum.y / vol"));

    let grad_p_x = state_component_expr(layout, "state", "idx", grad_p_field, 0);
    let grad_p_y = state_component_expr(layout, "state", "idx", grad_p_field, 1);
    stmts.push(dsl::assign(&grad_p_x, "grad_p_accum.x"));
    stmts.push(dsl::assign(&grad_p_y, "grad_p_accum.y"));

    stmts.push(dsl::assign("g_u.x", "g_u.x / vol"));
    stmts.push(dsl::assign("g_u.y", "g_u.y / vol"));
    stmts.push(dsl::assign("g_v.x", "g_v.x / vol"));
    stmts.push(dsl::assign("g_v.y", "g_v.y / vol"));
    stmts.push(dsl::assign("grad_u[idx]", "g_u"));
    stmts.push(dsl::assign("grad_v[idx]", "g_v"));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::lower_system;
    use crate::solver::model::incompressible_momentum_model;
    use crate::solver::model::backend::SchemeRegistry;
    use crate::solver::scheme::Scheme;

    #[test]
    fn prepare_coupled_codegen_emits_state_arrays() {
        let model = incompressible_momentum_model();
        let schemes = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&model.system, &schemes);
        let fields = model.fields.incompressible().expect("incompressible fields");
        let wgsl = generate_prepare_coupled_wgsl(&discrete, &model.state_layout, fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("grad_u"));
        assert!(wgsl.contains("grad_v"));
    }
}
