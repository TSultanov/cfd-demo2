use super::coeff_expr::{coeff_cell_expr, coeff_face_expr};
use super::dsl as typed;
use super::ir::DiscreteSystem;
use super::plan::{momentum_plan, MomentumPlan};
use super::state_access::{state_scalar, state_vec2};
use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt, StructDef,
    StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::gpu::enums::GpuBoundaryType;
use crate::solver::ir::StateLayout;
use crate::solver::model::IncompressibleMomentumFields;

pub fn generate_flux_rhie_chow_wgsl(
    system: &DiscreteSystem,
    layout: &StateLayout,
    fields: &IncompressibleMomentumFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_rhie_chow)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    let plan = momentum_plan(system, fields.u.name(), fields.p.name());
    module.push(Item::Function(main_fn(layout, &plan, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            10,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            11,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, plan, fields),
    )
}

fn main_body(
    layout: &StateLayout,
    plan: &MomentumPlan,
    fields: &IncompressibleMomentumFields,
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        dsl::array_access("face_neighbor", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        dsl::array_access("face_centers", Expr::ident("idx")),
    ));

    stmts.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));
    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    let u_field = fields.u.name();
    let p_field = fields.p.name();
    let d_p_field = fields.d_p.name();
    let grad_p_field = fields.grad_p.name();
    let u_owner_expr = state_vec2(layout, "state", "owner", u_field);
    let dp_owner_expr = state_scalar(layout, "state", "owner", d_p_field);
    let grad_p_owner_expr = state_vec2(layout, "state", "owner", grad_p_field);
    let rho_owner_expr = coeff_cell_expr(
        layout,
        plan.ddt.as_ref().and_then(|op| op.coeff.as_ref()),
        "owner",
        Expr::ident("constants").field("density"),
    );
    let rho_face_expr = coeff_face_expr(
        layout,
        plan.ddt.as_ref().and_then(|op| op.coeff.as_ref()),
        "owner",
        "neigh_idx",
        Expr::ident("lambda"),
        Expr::ident("rho_face"),
    );

    stmts.push(dsl::var_typed_expr(
        "u_face",
        Type::vec2_f32(),
        Some(u_owner_expr),
    ));
    stmts.push(dsl::var_typed_expr(
        "d_p_face",
        Type::F32,
        Some(dp_owner_expr),
    ));
    stmts.push(dsl::var_typed_expr(
        "grad_p_avg",
        Type::vec2_f32(),
        Some(grad_p_owner_expr),
    ));
    stmts.push(dsl::var_typed_expr(
        "rho_face",
        Type::F32,
        Some(rho_owner_expr),
    ));

    let interior_block = {
        let u_neigh_expr = state_vec2(layout, "state", "neigh_idx", u_field);
        let dp_neigh_expr = state_scalar(layout, "state", "neigh_idx", d_p_field);
        let grad_p_neigh_expr = state_vec2(layout, "state", "neigh_idx", grad_p_field);
        let p_owner_expr = state_scalar(layout, "state", "owner", p_field);
        let p_neigh_expr = state_scalar(layout, "state", "neigh_idx", p_field);

        dsl::block(vec![
            dsl::let_expr(
                "neigh_idx",
                Expr::call_named("u32", vec![Expr::ident("neighbor")]),
            ),
            dsl::let_typed_expr("u_neigh", Type::vec2_f32(), u_neigh_expr),
            dsl::let_expr("d_p_neigh", dp_neigh_expr),
            dsl::let_typed_expr("grad_p_neigh", Type::vec2_f32(), grad_p_neigh_expr),
            dsl::let_expr(
                "c_neigh",
                dsl::array_access("cell_centers", Expr::ident("neigh_idx")),
            ),
            dsl::let_typed_expr(
                "c_neigh_vec",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr(),
            ),
            dsl::let_expr("d_own", dsl::distance("c_owner_vec", "face_center_vec")),
            dsl::let_expr("d_neigh", dsl::distance("c_neigh_vec", "face_center_vec")),
            dsl::let_expr("total_dist", Expr::ident("d_own") + Expr::ident("d_neigh")),
            dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())),
            dsl::if_block_expr(
                Expr::ident("total_dist").gt(1e-6),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("lambda"),
                    Expr::ident("d_neigh") / Expr::ident("total_dist"),
                )]),
                None,
            ),
            dsl::let_expr("lambda_other", Expr::from(1.0) - Expr::ident("lambda")),
            dsl::assign_expr(Expr::ident("rho_face"), rho_face_expr),
            dsl::let_typed_expr(
                "u_central",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
                    .mul_scalar(Expr::ident("lambda"))
                    .add(
                        &typed::VecExpr::<2>::from_expr(Expr::ident("u_neigh"))
                            .mul_scalar(Expr::ident("lambda_other")),
                    )
                    .expr(),
            ),
            dsl::assign_expr(Expr::ident("u_face"), Expr::ident("u_central")),
            dsl::assign_expr(
                Expr::ident("d_p_face"),
                Expr::ident("lambda") * Expr::ident("d_p_face")
                    + Expr::ident("lambda_other") * Expr::ident("d_p_neigh"),
            ),
            dsl::assign_expr(
                Expr::ident("grad_p_avg"),
                typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_avg"))
                    .mul_scalar(Expr::ident("lambda"))
                    .add(
                        &typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_neigh"))
                            .mul_scalar(Expr::ident("lambda_other")),
                    )
                    .expr(),
            ),
            dsl::let_typed_expr(
                "d_vec",
                Type::vec2_f32(),
                typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
                    .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
                    .expr(),
            ),
            dsl::let_expr(
                "dist_proj",
                dsl::abs(
                    typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                        .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
                ),
            ),
            dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)),
            dsl::let_expr("p_own", p_owner_expr),
            dsl::let_expr("p_neigh", p_neigh_expr),
            dsl::let_expr(
                "grad_p_n",
                typed::VecExpr::<2>::from_expr(Expr::ident("grad_p_avg"))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            ),
            dsl::let_expr(
                "p_grad_f",
                (Expr::ident("p_neigh") - Expr::ident("p_own")) / Expr::ident("dist"),
            ),
            dsl::let_expr(
                "rc_term",
                Expr::ident("d_p_face")
                    * Expr::ident("area")
                    * (Expr::ident("grad_p_n") - Expr::ident("p_grad_f")),
            ),
            dsl::let_expr(
                "u_n",
                typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
                    .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
            ),
            dsl::assign_expr(
                Expr::ident("fluxes").index(Expr::ident("idx")),
                Expr::ident("rho_face")
                    * (Expr::ident("u_n") * Expr::ident("area") + Expr::ident("rc_term")),
            ),
        ])
    };

    let inlet_block = dsl::block(vec![
        dsl::let_expr(
            "ramp",
            dsl::smoothstep(
                0.0,
                Expr::ident("constants").field("ramp_time"),
                Expr::ident("constants").field("time"),
            ),
        ),
        dsl::let_typed_expr(
            "u_bc",
            Type::vec2_f32(),
            typed::VecExpr::<2>::from_components([
                Expr::ident("constants").field("inlet_velocity") * Expr::ident("ramp"),
                0.0.into(),
            ])
            .expr(),
        ),
        dsl::assign_expr(
            Expr::ident("fluxes").index(Expr::ident("idx")),
            Expr::ident("rho_face") * dsl::dot("u_bc", "normal_vec") * Expr::ident("area"),
        ),
    ]);

    let wall_block = dsl::block(vec![dsl::assign_expr(
        Expr::ident("fluxes").index(Expr::ident("idx")),
        0.0,
    )]);

    let outlet_block = dsl::block(vec![
        dsl::let_expr(
            "u_n",
            typed::VecExpr::<2>::from_expr(Expr::ident("u_face"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
        dsl::var_typed_expr("rc_term", Type::F32, Some(0.0.into())),
        dsl::let_expr("dist_face", dsl::distance("c_owner_vec", "face_center_vec")),
        dsl::if_block_expr(
            Expr::ident("dist_face").gt(1e-6),
            dsl::block(vec![dsl::assign_expr(Expr::ident("rc_term"), 0.0)]),
            None,
        ),
        dsl::let_expr(
            "raw_flux",
            Expr::ident("rho_face")
                * (Expr::ident("u_n") * Expr::ident("area") + Expr::ident("rc_term")),
        ),
        dsl::assign_expr(
            Expr::ident("fluxes").index(Expr::ident("idx")),
            dsl::max(0.0, "raw_flux"),
        ),
    ]);

    let bc_type = typed::EnumExpr::<GpuBoundaryType>::from_expr(Expr::ident("boundary_type"));
    let boundary_block = dsl::block(vec![dsl::if_block_expr(
        bc_type.eq(GpuBoundaryType::Inlet),
        inlet_block,
        Some(dsl::block(vec![dsl::if_block_expr(
            bc_type.eq(GpuBoundaryType::Wall),
            wall_block,
            Some(dsl::block(vec![dsl::if_block_expr(
                bc_type.eq(GpuBoundaryType::Outlet),
                outlet_block,
                Some(dsl::block(vec![dsl::assign_expr(
                    Expr::ident("fluxes").index(Expr::ident("idx")),
                    0.0,
                )])),
            )])),
        )])),
    )]);

    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        interior_block,
        Some(boundary_block),
    ));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::codegen::lower_system;
    use crate::solver::ir::SchemeRegistry;
    use crate::solver::model::incompressible_momentum_model;
    use crate::solver::model::IncompressibleMomentumFields;
    use crate::solver::scheme::Scheme;

    #[test]
    fn flux_rhie_chow_codegen_emits_state_arrays() {
        let model = incompressible_momentum_model();
        let schemes = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&model.system, &schemes).unwrap();
        let fields = IncompressibleMomentumFields::new();
        let wgsl = generate_flux_rhie_chow_wgsl(&discrete, &model.state_layout, &fields);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("face_owner"));
        assert!(wgsl.contains("smoothstep"));
    }
}
