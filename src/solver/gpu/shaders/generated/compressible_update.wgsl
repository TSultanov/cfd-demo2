// GENERATED BY CFD2 CODEGEN (compressible_update)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
    pressure_coupling_alpha: f32,
}

// Group 0: Fields (consolidated state buffers)

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(0) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(0) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(0) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(0) @binding(4) 
var<uniform> constants: Constants;

@group(0) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(0) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(0) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(0) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@group(0) @binding(9) 
var<storage, read> state_iter: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let num_cells = arrayLength(&state);
    let stride = 7u;
    if (idx * stride >= num_cells) {
        return;
    }
    let rho = state[idx * 7u + 0u];
    let rho_u = vec2<f32>(state[idx * 7u + 1u], state[idx * 7u + 2u]);
    let rho_e = state[idx * 7u + 3u];
    let inv_rho = 1.0 / max(rho, 1e-8);
    let u_x = rho_u.x * inv_rho;
    let u_y = rho_u.y * inv_rho;
    let ke = 0.5 * rho * (u_x * u_x + u_y * u_y);
    let p_val = max(0.0, (1.4 - 1.0) * (rho_e - ke));
    state[idx * 7u + 5u] = u_x;
    state[idx * 7u + 6u] = u_y;
    state[idx * 7u + 4u] = p_val;
}
