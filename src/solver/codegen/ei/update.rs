use super::super::dsl as typed;
use super::super::state_access::{state_component, state_scalar, state_vec2};
use super::super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt, StructDef,
    StructField, Type,
};
use super::super::wgsl_dsl as dsl;
use crate::solver::model::backend::StateLayout;
use crate::solver::model::EosSpec;

pub fn generate_ei_update_wgsl(layout: &StateLayout, eos: &EosSpec) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (ei_update)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, eos)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Struct(low_mach_params_struct()));
    items.push(Item::Comment(
        "Group 0: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 0, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 0, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            0,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 0, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var("state_iter", Type::array(Type::F32), 0, 9, AccessMode::Read),
        uniform_var("low_mach", Type::Custom("LowMachParams".to_string()), 0, 10),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, eos: &EosSpec) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, eos),
    )
}

fn main_body(layout: &StateLayout, eos: &EosSpec) -> Block {
    let mut stmts = Vec::new();
    let rho_field = "rho";
    let rho_u_field = "rho_u";
    let rho_e_field = "rho_e";
    let p_field = "p";
    let u_field = "u";
    let gamma = eos
        .ideal_gas_gamma()
        .unwrap_or_else(|| panic!("EI update requires IdealGas EOS; got {eos:?}"));
    let gamma_minus_1 = gamma - 1.0;

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::let_expr(
        "num_cells",
        Expr::call_named("arrayLength", vec![Expr::ident("state").addr_of()]),
    ));
    stmts.push(dsl::if_block_expr(
        (Expr::ident("idx") * layout.stride()).ge("num_cells"),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "rho",
        state_scalar(layout, "state", "idx", rho_field),
    ));
    stmts.push(dsl::let_typed_expr(
        "rho_u",
        Type::vec2_f32(),
        state_vec2(layout, "state", "idx", rho_u_field),
    ));
    stmts.push(dsl::let_expr(
        "rho_e",
        state_scalar(layout, "state", "idx", rho_e_field),
    ));

    stmts.push(dsl::let_expr(
        "inv_rho",
        Expr::from(1.0) / dsl::max("rho", 1e-8),
    ));
    stmts.push(dsl::let_typed_expr(
        "u",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_expr(Expr::ident("rho_u"))
            .mul_scalar(Expr::ident("inv_rho"))
            .expr(),
    ));
    stmts.push(dsl::let_expr(
        "u2",
        typed::VecExpr::<2>::from_expr(Expr::ident("u"))
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("u"))),
    ));
    stmts.push(dsl::let_expr(
        "ke",
        Expr::ident("rho") * Expr::ident("u2") * 0.5,
    ));
    stmts.push(dsl::let_expr(
        "p_val",
        dsl::max(
            0.0,
            (Expr::ident("rho_e") - Expr::ident("ke")) * gamma_minus_1,
        ),
    ));

    let u_x_target = state_component(layout, "state", "idx", u_field, 0);
    let u_y_target = state_component(layout, "state", "idx", u_field, 1);
    let p_target = state_component(layout, "state", "idx", p_field, 0);
    stmts.push(dsl::assign_expr(u_x_target, Expr::ident("u").field("x")));
    stmts.push(dsl::assign_expr(u_y_target, Expr::ident("u").field("y")));
    stmts.push(dsl::assign_expr(p_target, Expr::ident("p_val")));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_update_codegen_emits_state_arrays() {
        let model = compressible_model();
        let wgsl = generate_ei_update_wgsl(&model.state_layout, &model.eos);
        assert!(wgsl.contains("state: array<f32>"));
        assert!(wgsl.contains("rho_e"));
        assert!(wgsl.contains("p_val"));
    }
}
