use std::collections::HashMap;

use super::dsl as typed;
use super::wgsl_ast::{
    AccessMode, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StorageClass, StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;
use crate::solver::ir::{
    FaceScalarBuiltin, FaceScalarExpr, FaceSide, FaceVec2Builtin, FaceVec2Expr, FieldKind,
    FluxLayout, FluxModuleKernelSpec, LowMachParam, StateLayout,
};
use crate::solver::scheme::Scheme;
use crate::solver::shared::PrimitiveExpr;

pub fn generate_flux_module_wgsl(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &[(String, PrimitiveExpr)],
    spec: &FluxModuleKernelSpec,
) -> String {
    assert!(flux_stride > 0, "flux_module requires flux_stride > 0");
    assert_eq!(
        flux_stride, flux_layout.stride,
        "flux_stride must match FluxLayout.stride"
    );

    let primitive_map: HashMap<&str, &PrimitiveExpr> =
        primitives.iter().map(|(k, v)| (k.as_str(), v)).collect();

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items(flux_spec_uses_low_mach(spec)));
    module.push(Item::Function(main_fn(
        layout,
        flux_layout,
        flux_stride,
        &primitive_map,
        spec,
    )));
    module.to_wgsl()
}

/// Generate a flux module WGSL kernel that selects reconstruction at runtime via
/// `constants.scheme`.
///
/// The per-`Scheme` variants are provided as IR specs. This emits a single WGSL entrypoint that
/// selects between the variants per face invocation, while guarding boundary faces to remain
/// first-order.
pub fn generate_flux_module_wgsl_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &[(String, PrimitiveExpr)],
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> String {
    assert!(flux_stride > 0, "flux_module requires flux_stride > 0");
    assert_eq!(
        flux_stride, flux_layout.stride,
        "flux_stride must match FluxLayout.stride"
    );

    let primitive_map: HashMap<&str, &PrimitiveExpr> =
        primitives.iter().map(|(k, v)| (k.as_str(), v)).collect();

    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (flux_module)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items(
        variants
            .iter()
            .any(|(_, spec)| flux_spec_uses_low_mach(spec)),
    ));
    module.push(Item::Function(main_fn_runtime_scheme(
        layout,
        flux_layout,
        flux_stride,
        &primitive_map,
        variants,
    )));
    module.to_wgsl()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::ir::{vol_scalar, vol_vector, FaceSide, FluxComponent};
    use crate::solver::scheme::Scheme;
    use crate::solver::units::si;

    #[test]
    fn flux_module_codegen_accepts_cell_to_face_reconstruction_exprs() {
        let phi = vol_scalar("phi", si::DIMENSIONLESS);
        let grad_phi = vol_vector("grad_phi", si::DIMENSIONLESS);
        let layout = StateLayout::new(vec![phi, grad_phi]);
        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "phi".to_string(),
                offset: 0,
            }],
        };

        let reconstruct = |side: FaceSide, other: FaceSide| -> FaceScalarExpr {
            let phi_cell = FaceScalarExpr::state(side, "phi");
            let phi_other = FaceScalarExpr::state(other, "phi");
            let grad = FaceVec2Expr::state_vec2(side, "grad_phi");
            let r = FaceVec2Expr::cell_to_face(side);
            let delta = FaceScalarExpr::Dot(Box::new(grad), Box::new(r));
            let diff = FaceScalarExpr::Sub(Box::new(phi_other), Box::new(phi_cell.clone()));
            let min_diff = FaceScalarExpr::Min(Box::new(diff.clone()), Box::new(FaceScalarExpr::lit(0.0)));
            let max_diff = FaceScalarExpr::Max(Box::new(diff), Box::new(FaceScalarExpr::lit(0.0)));
            let delta_limited = FaceScalarExpr::Min(
                Box::new(FaceScalarExpr::Max(Box::new(delta), Box::new(min_diff))),
                Box::new(max_diff),
            );
            FaceScalarExpr::Add(Box::new(phi_cell), Box::new(delta_limited))
        };

        let left = reconstruct(FaceSide::Owner, FaceSide::Neighbor);
        let right = reconstruct(FaceSide::Neighbor, FaceSide::Owner);

        let spec = FluxModuleKernelSpec::CentralUpwind {
            reconstruction: Scheme::SecondOrderUpwindMinMod,
            components: vec!["phi".to_string()],
            u_left: vec![left.clone()],
            u_right: vec![right.clone()],
            flux_left: vec![left],
            flux_right: vec![right],
            a_plus: FaceScalarExpr::lit(1.0),
            a_minus: FaceScalarExpr::lit(-1.0),
        };

        let wgsl = generate_flux_module_wgsl(&layout, &flux_layout, 1, &[], &spec);
        assert!(wgsl.contains("cell_centers"));
        assert!(wgsl.contains("face_centers"));
    }

    #[test]
    fn muscl_does_not_reconstruct_boundary_neighbor_state() {
        // Regression test: when MUSCL reconstruction is enabled, the boundary neighbor value
        // (Dirichlet/Neumann ghost) must not be modified by reconstruction.
        //
        // The simplest way to ensure this in codegen is to force neighbor-side gradients to
        // zero on boundary faces, so `phi_cell + dot(grad, r)` collapses to `phi_cell`.
        let phi = vol_scalar("phi", si::DIMENSIONLESS);
        let grad_phi = vol_vector("grad_phi", si::DIMENSIONLESS);
        let layout = StateLayout::new(vec![phi, grad_phi]);
        let flux_layout = FluxLayout {
            stride: 1,
            components: vec![FluxComponent {
                name: "phi".to_string(),
                offset: 0,
            }],
        };

        // Force the kernel to read neighbor-side gradients (which previously used the owner
        // gradient on boundary faces), so we can assert boundary-specific zeroing exists.
        let phi_expr = FaceScalarExpr::Dot(
            Box::new(FaceVec2Expr::state_vec2(FaceSide::Neighbor, "grad_phi")),
            Box::new(FaceVec2Expr::normal()),
        );
        let spec = FluxModuleKernelSpec::ScalarReplicated { phi: phi_expr };

        let wgsl = generate_flux_module_wgsl(&layout, &flux_layout, 1, &[], &spec);

        // `phi`(scalar) + `grad_phi`(vec2) => stride=3; grad_phi.x is at offset 1.
        assert!(wgsl.contains("state[neigh_idx * 3u + 1u]"));
        assert!(
            wgsl.contains(", 0.0, is_boundary)"),
            "expected boundary neighbor gradient to be zeroed via select(..., 0.0, is_boundary)"
        );
    }
}

fn base_items(include_low_mach_params: bool) -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    if include_low_mach_params {
        items.push(Item::Struct(low_mach_params_struct()));
    }
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings(include_low_mach_params));
    items.push(Item::Comment(
        "Group 2: Boundary conditions (per face x unknown)".to_string(),
    ));
    items.extend(boundary_bindings());
    items.push(Item::Function(bc_neighbor_scalar_fn()));
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    // Keep the same layout as other generated kernels for now.
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("eos_gamma", Type::F32),
            StructField::new("eos_gm1", Type::F32),
            StructField::new("eos_r", Type::F32),
            StructField::new("eos_dp_drho", Type::F32),
            StructField::new("eos_p_offset", Type::F32),
            StructField::new("eos_theta_ref", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn bc_neighbor_scalar_fn() -> Function {
    Function::new(
        "bc_neighbor_scalar",
        vec![
            Param::new("interior", Type::F32, Vec::new()),
            Param::new("owner", Type::F32, Vec::new()),
            Param::new("kind", Type::U32, Vec::new()),
            Param::new("value", Type::F32, Vec::new()),
            Param::new("d_own", Type::F32, Vec::new()),
            Param::new("is_boundary", Type::Bool, Vec::new()),
        ],
        Some(Type::F32),
        Vec::new(),
        Block::new(vec![
            dsl::var_typed_expr("boundary", Type::F32, Some(Expr::ident("owner"))),
            dsl::if_block_expr(
                Expr::ident("kind").eq(Expr::from(1u32)),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("boundary"),
                    Expr::ident("value"),
                )]),
                None,
            ),
            dsl::if_block_expr(
                Expr::ident("kind").eq(Expr::from(2u32)),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("boundary"),
                    Expr::ident("owner") + Expr::ident("value") * Expr::ident("d_own"),
                )]),
                None,
            ),
            Stmt::Return(Some(dsl::select(
                Expr::ident("interior"),
                Expr::ident("boundary"),
                Expr::ident("is_boundary"),
            ))),
        ]),
    )
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings(include_low_mach_params: bool) -> Vec<Item> {
    let mut bindings = vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
    ];
    if include_low_mach_params {
        bindings.push(uniform_var(
            "low_mach_params",
            Type::Custom("LowMachParams".to_string()),
            1,
            5,
        ));
    }
    bindings
}

fn boundary_bindings() -> Vec<Item> {
    vec![
        storage_var("bc_kind", Type::array(Type::U32), 2, 0, AccessMode::Read),
        storage_var("bc_value", Type::array(Type::F32), 2, 1, AccessMode::Read),
    ]
}

fn main_fn(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout, flux_stride, primitives, spec),
    )
}

fn main_fn_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];

    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body_runtime_scheme(layout, flux_layout, flux_stride, primitives, variants),
    )
}

fn main_body(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        dsl::array_access("face_neighbor", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr("is_boundary", Expr::ident("neighbor").eq(-1)));
    // For boundary faces, we treat the "neighbor" side as the owner cell (zero-gradient
    // extrapolation). Boundary-aware flux formulas can still use `boundary_type`.
    stmts.push(dsl::var_typed_expr(
        "neigh_idx",
        Type::U32,
        Some(Expr::ident("owner")),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("neigh_idx"),
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        )]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        dsl::array_access("face_centers", Expr::ident("idx")),
    ));

    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));

    stmts.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));

    // Ensure the face normal is oriented outward from the owner cell.
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    stmts.extend(face_stmts(
        layout,
        flux_layout,
        flux_stride,
        primitives,
        spec,
    ));

    Block::new(stmts)
}

fn main_body_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> Block {
    let mut stmts = Vec::new();

    stmts.push(dsl::let_expr(
        "idx",
        Expr::ident("global_id").field("y") * Expr::ident("constants").field("stride_x")
            + Expr::ident("global_id").field("x"),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("face_areas").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    stmts.push(dsl::let_expr(
        "owner",
        dsl::array_access("face_owner", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "neighbor",
        dsl::array_access("face_neighbor", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr("is_boundary", Expr::ident("neighbor").eq(-1)));
    // For boundary faces, we treat the "neighbor" side as the owner cell (zero-gradient
    // extrapolation). Boundary-aware flux formulas can still use `boundary_type`.
    stmts.push(dsl::var_typed_expr(
        "neigh_idx",
        Type::U32,
        Some(Expr::ident("owner")),
    ));
    stmts.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("neigh_idx"),
            Expr::call_named("u32", vec![Expr::ident("neighbor")]),
        )]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "area",
        dsl::array_access("face_areas", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "boundary_type",
        dsl::array_access("face_boundary", Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "face_center",
        dsl::array_access("face_centers", Expr::ident("idx")),
    ));

    stmts.push(dsl::var_typed_expr(
        "normal_vec",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("idx")),
            )
            .expr(),
        ),
    ));

    stmts.push(dsl::let_expr(
        "c_owner",
        dsl::array_access("cell_centers", Expr::ident("owner")),
    ));
    stmts.push(dsl::let_typed_expr(
        "c_owner_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_owner")).expr(),
    ));
    stmts.push(dsl::let_typed_expr(
        "face_center_vec",
        Type::vec2_f32(),
        typed::VecExpr::<2>::from_xy_fields(Expr::ident("face_center")).expr(),
    ));

    // Ensure the face normal is oriented outward from the owner cell.
    let owner_face_d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")));
    stmts.push(dsl::if_block_expr(
        owner_face_d_vec
            .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec")))
            .lt(0.0),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal_vec"),
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
                .neg()
                .expr(),
        )]),
        None,
    ));

    stmts.extend(face_stmts_runtime_scheme(
        layout,
        flux_layout,
        flux_stride,
        primitives,
        variants,
    ));

    Block::new(stmts)
}

fn face_stmts(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    spec: &FluxModuleKernelSpec,
) -> Vec<Stmt> {
    let mut body = Vec::new();

    body.push(dsl::let_expr(
        "c_neigh",
        dsl::array_access("cell_centers", Expr::ident("neigh_idx")),
    ));
    body.push(dsl::var_typed_expr(
        "c_neigh_vec",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr()),
    ));

    // Preserve the true neighbor-cell center even on boundary faces.
    //
    // For boundary faces, we sometimes override `c_neigh_vec` for interpolation convenience,
    // but geometry builtins (e.g. `CellToFace{Neighbor}`) should still reference the neighbor
    // cell center (which degenerates to the owner cell for boundary faces).
    body.push(dsl::let_typed_expr(
        "c_neigh_cell_vec",
        Type::vec2_f32(),
        Expr::ident("c_neigh_vec"),
    ));
    body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("c_neigh_vec"),
            Expr::ident("face_center_vec"),
        )]),
        None,
    ));

    body.push(dsl::let_expr(
        "d_own",
        dsl::distance("c_owner_vec", "face_center_vec"),
    ));
    body.push(dsl::let_expr(
        "d_neigh",
        dsl::distance("c_neigh_vec", "face_center_vec"),
    ));
    body.push(dsl::let_expr(
        "total_dist",
        Expr::ident("d_own") + Expr::ident("d_neigh"),
    ));
    body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
    body.push(dsl::if_block_expr(
        Expr::ident("total_dist").gt(1e-6),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("lambda"),
            Expr::ident("d_neigh") / Expr::ident("total_dist"),
        )]),
        None,
    ));
    body.push(dsl::let_expr(
        "lambda_other",
        Expr::from(1.0) - Expr::ident("lambda"),
    ));

    let d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
        .expr();
    body.push(dsl::let_typed_expr("d_vec", Type::vec2_f32(), d_vec));
    body.push(dsl::let_expr(
        "dist_proj",
        dsl::abs(
            typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
    ));
    body.push(dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)));

    match spec {
        FluxModuleKernelSpec::ScalarReplicated { phi } => {
            let phi_expr = lower_scalar(phi, layout, primitives, flux_layout);
            body.push(dsl::var_typed_expr("phi", Type::F32, Some(phi_expr)));

            for u_idx in 0..flux_stride {
                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, u_idx),
                    Expr::ident("phi"),
                ));
            }
        }
        FluxModuleKernelSpec::CentralUpwind {
            reconstruction: _,
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
        } => {
            if components.len() != flux_layout.components.len() {
                panic!("CentralUpwind spec component count does not match FluxLayout");
            }
            if u_left.len() != components.len()
                || u_right.len() != components.len()
                || flux_left.len() != components.len()
                || flux_right.len() != components.len()
            {
                panic!("CentralUpwind spec arrays must match component count");
            }

            let a_p = lower_scalar(a_plus, layout, primitives, flux_layout);
            let a_m = lower_scalar(a_minus, layout, primitives, flux_layout);
            body.push(dsl::let_expr("a_plus", a_p));
            body.push(dsl::let_expr("a_minus", a_m));
            body.push(dsl::let_expr(
                "denom",
                dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
            ));

            for (i, comp_name) in components.iter().enumerate() {
                let off = flux_layout
                    .offset_for(comp_name)
                    .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));
                let u_l = lower_scalar(&u_left[i], layout, primitives, flux_layout);
                let u_r = lower_scalar(&u_right[i], layout, primitives, flux_layout);
                let f_l = lower_scalar(&flux_left[i], layout, primitives, flux_layout);
                let f_r = lower_scalar(&flux_right[i], layout, primitives, flux_layout);

                let num = Expr::ident("a_plus") * f_l - Expr::ident("a_minus") * f_r
                    + (Expr::ident("a_plus") * Expr::ident("a_minus")) * (u_r - u_l);
                let flux = num / Expr::ident("denom");

                body.push(dsl::assign_expr(
                    dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
                    flux * Expr::ident("area"),
                ));
            }
        }
    }

    body
}

fn face_stmts_runtime_scheme(
    layout: &StateLayout,
    flux_layout: &FluxLayout,
    flux_stride: u32,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    variants: &[(Scheme, FluxModuleKernelSpec)],
) -> Vec<Stmt> {
    #[derive(Clone, Copy)]
    struct CentralUpwindVariant<'a> {
        components: &'a [String],
        u_left: &'a [FaceScalarExpr],
        u_right: &'a [FaceScalarExpr],
        flux_left: &'a [FaceScalarExpr],
        flux_right: &'a [FaceScalarExpr],
        a_plus: &'a FaceScalarExpr,
        a_minus: &'a FaceScalarExpr,
    }

    let mut body = Vec::new();

    // --- Geometry preamble (kept in sync with `face_stmts`) ---
    body.push(dsl::let_expr(
        "c_neigh",
        dsl::array_access("cell_centers", Expr::ident("neigh_idx")),
    ));
    body.push(dsl::var_typed_expr(
        "c_neigh_vec",
        Type::vec2_f32(),
        Some(typed::VecExpr::<2>::from_xy_fields(Expr::ident("c_neigh")).expr()),
    ));
    body.push(dsl::let_typed_expr(
        "c_neigh_cell_vec",
        Type::vec2_f32(),
        Expr::ident("c_neigh_vec"),
    ));
    body.push(dsl::if_block_expr(
        Expr::ident("is_boundary"),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("c_neigh_vec"),
            Expr::ident("face_center_vec"),
        )]),
        None,
    ));

    body.push(dsl::let_expr(
        "d_own",
        dsl::distance("c_owner_vec", "face_center_vec"),
    ));
    body.push(dsl::let_expr(
        "d_neigh",
        dsl::distance("c_neigh_vec", "face_center_vec"),
    ));
    body.push(dsl::let_expr(
        "total_dist",
        Expr::ident("d_own") + Expr::ident("d_neigh"),
    ));
    body.push(dsl::var_typed_expr("lambda", Type::F32, Some(0.5.into())));
    body.push(dsl::if_block_expr(
        Expr::ident("total_dist").gt(1e-6),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("lambda"),
            Expr::ident("d_neigh") / Expr::ident("total_dist"),
        )]),
        None,
    ));
    body.push(dsl::let_expr(
        "lambda_other",
        Expr::from(1.0) - Expr::ident("lambda"),
    ));

    let d_vec = typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_vec"))
        .sub(&typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")))
        .expr();
    body.push(dsl::let_typed_expr("d_vec", Type::vec2_f32(), d_vec));
    body.push(dsl::let_expr(
        "dist_proj",
        dsl::abs(
            typed::VecExpr::<2>::from_expr(Expr::ident("d_vec"))
                .dot(&typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))),
        ),
    ));
    body.push(dsl::let_expr("dist", dsl::max("dist_proj", 1e-6)));

    // --- Runtime scheme selection ---
    if variants.is_empty() {
        panic!("runtime scheme flux module requires at least one variant spec");
    }

    let mut by_gpu_id: Vec<Option<CentralUpwindVariant<'_>>> = vec![None; 7];
    for (scheme, spec) in variants {
        let FluxModuleKernelSpec::CentralUpwind {
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
            ..
        } = spec
        else {
            panic!("runtime scheme flux module requires CentralUpwind variants");
        };

        let idx = scheme.gpu_id() as usize;
        if idx >= by_gpu_id.len() {
            continue;
        }
        if by_gpu_id[idx].is_some() {
            panic!("duplicate CentralUpwind variant for scheme {scheme:?}");
        }
        by_gpu_id[idx] = Some(CentralUpwindVariant {
            components,
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
        });
    }

    let upwind = by_gpu_id[Scheme::Upwind.gpu_id() as usize]
        .unwrap_or_else(|| panic!("runtime scheme flux module requires an Upwind variant"));

    if upwind.components.len() != flux_layout.components.len() {
        panic!("CentralUpwind spec component count does not match FluxLayout");
    }
    if upwind.u_left.len() != upwind.components.len()
        || upwind.u_right.len() != upwind.components.len()
        || upwind.flux_left.len() != upwind.components.len()
        || upwind.flux_right.len() != upwind.components.len()
    {
        panic!("CentralUpwind spec arrays must match component count");
    }

    // Ensure all variants share the same component list/order.
    for v in by_gpu_id.iter().flatten() {
        if v.components != upwind.components {
            panic!("CentralUpwind variant components must match across schemes");
        }
    }

    let scheme_lit =
        typed::EnumExpr::<Scheme>::from_expr(Expr::ident("constants").field("scheme"));
    let is_interior = !Expr::ident("is_boundary");
    let cond_for = |scheme: Scheme| scheme_lit.eq(scheme) & is_interior;

    // Wave speed selection.
    body.push(dsl::var_typed_expr(
        "a_plus",
        Type::F32,
        Some(lower_scalar(
            upwind.a_plus,
            layout,
            primitives,
            flux_layout,
        )),
    ));
    body.push(dsl::var_typed_expr(
        "a_minus",
        Type::F32,
        Some(lower_scalar(
            upwind.a_minus,
            layout,
            primitives,
            flux_layout,
        )),
    ));

    for scheme in [
        Scheme::SecondOrderUpwind,
        Scheme::QUICK,
        Scheme::SecondOrderUpwindMinMod,
        Scheme::SecondOrderUpwindVanLeer,
        Scheme::QUICKMinMod,
        Scheme::QUICKVanLeer,
    ] {
        let Some(v) = by_gpu_id.get(scheme.gpu_id() as usize).and_then(|v| *v) else {
            continue;
        };

        let cond = cond_for(scheme);
        let a_p = lower_scalar(v.a_plus, layout, primitives, flux_layout);
        let a_m = lower_scalar(v.a_minus, layout, primitives, flux_layout);

        body.push(dsl::assign_expr(
            Expr::ident("a_plus"),
            dsl::select(Expr::ident("a_plus"), a_p, cond.clone()),
        ));
        body.push(dsl::assign_expr(
            Expr::ident("a_minus"),
            dsl::select(Expr::ident("a_minus"), a_m, cond),
        ));
    }

    body.push(dsl::let_expr(
        "denom",
        dsl::max(Expr::ident("a_plus") - Expr::ident("a_minus"), 1e-6),
    ));

    for (i, comp_name) in upwind.components.iter().enumerate() {
        let off = flux_layout
            .offset_for(comp_name)
            .unwrap_or_else(|| panic!("missing flux layout component '{comp_name}'"));

        let u_l = format!("u_l_{off}");
        let u_r = format!("u_r_{off}");
        let f_l = format!("f_l_{off}");
        let f_r = format!("f_r_{off}");

        body.push(dsl::var_typed_expr(
            &u_l,
            Type::F32,
            Some(lower_scalar(
                &upwind.u_left[i],
                layout,
                primitives,
                flux_layout,
            )),
        ));
        body.push(dsl::var_typed_expr(
            &u_r,
            Type::F32,
            Some(lower_scalar(
                &upwind.u_right[i],
                layout,
                primitives,
                flux_layout,
            )),
        ));
        body.push(dsl::var_typed_expr(
            &f_l,
            Type::F32,
            Some(lower_scalar(
                &upwind.flux_left[i],
                layout,
                primitives,
                flux_layout,
            )),
        ));
        body.push(dsl::var_typed_expr(
            &f_r,
            Type::F32,
            Some(lower_scalar(
                &upwind.flux_right[i],
                layout,
                primitives,
                flux_layout,
            )),
        ));

        for scheme in [
            Scheme::SecondOrderUpwind,
            Scheme::QUICK,
            Scheme::SecondOrderUpwindMinMod,
            Scheme::SecondOrderUpwindVanLeer,
            Scheme::QUICKMinMod,
            Scheme::QUICKVanLeer,
        ] {
            let Some(v) = by_gpu_id.get(scheme.gpu_id() as usize).and_then(|v| *v) else {
                continue;
            };

            let cond = cond_for(scheme);

            body.push(dsl::assign_expr(
                Expr::ident(&u_l),
                dsl::select(
                    Expr::ident(&u_l),
                    lower_scalar(&v.u_left[i], layout, primitives, flux_layout),
                    cond.clone(),
                ),
            ));
            body.push(dsl::assign_expr(
                Expr::ident(&u_r),
                dsl::select(
                    Expr::ident(&u_r),
                    lower_scalar(&v.u_right[i], layout, primitives, flux_layout),
                    cond.clone(),
                ),
            ));
            body.push(dsl::assign_expr(
                Expr::ident(&f_l),
                dsl::select(
                    Expr::ident(&f_l),
                    lower_scalar(&v.flux_left[i], layout, primitives, flux_layout),
                    cond.clone(),
                ),
            ));
            body.push(dsl::assign_expr(
                Expr::ident(&f_r),
                dsl::select(
                    Expr::ident(&f_r),
                    lower_scalar(&v.flux_right[i], layout, primitives, flux_layout),
                    cond,
                ),
            ));
        }

        let num = Expr::ident("a_plus") * Expr::ident(&f_l) - Expr::ident("a_minus") * Expr::ident(&f_r)
            + (Expr::ident("a_plus") * Expr::ident("a_minus"))
                * (Expr::ident(&u_r) - Expr::ident(&u_l));
        let flux = num / Expr::ident("denom");

        body.push(dsl::assign_expr(
            dsl::array_access_linear("fluxes", Expr::ident("idx"), flux_stride, off),
            flux * Expr::ident("area"),
        ));
    }

    body
}

fn lower_vec2(
    expr: &FaceVec2Expr,
    layout: &StateLayout,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    flux_layout: &FluxLayout,
) -> typed::VecExpr<2> {
    match expr {
        FaceVec2Expr::Builtin(FaceVec2Builtin::Normal) => {
            typed::VecExpr::<2>::from_expr(Expr::ident("normal_vec"))
        }
        FaceVec2Expr::Builtin(FaceVec2Builtin::CellToFace { side }) => {
            let face = typed::VecExpr::<2>::from_expr(Expr::ident("face_center_vec"));
            let center = match side {
                FaceSide::Owner => typed::VecExpr::<2>::from_expr(Expr::ident("c_owner_vec")),
                FaceSide::Neighbor => {
                    typed::VecExpr::<2>::from_expr(Expr::ident("c_neigh_cell_vec"))
                }
            };
            face.sub(&center)
        }
        FaceVec2Expr::Vec2(x, y) => typed::VecExpr::<2>::from_components([
            lower_scalar(x, layout, primitives, flux_layout),
            lower_scalar(y, layout, primitives, flux_layout),
        ]),
        FaceVec2Expr::StateVec2 { side, field } => {
            let x = state_component_at_side(layout, "state", *side, field, 0, flux_layout);
            let y = state_component_at_side(layout, "state", *side, field, 1, flux_layout);

            // Boundary regression guard for MUSCL reconstruction:
            //
            // When higher-order reconstruction is enabled, models conventionally use `grad_*`
            // state fields to reconstruct face states. On boundary faces, neighbor-side
            // state reads are replaced with Dirichlet/Neumann "ghost" values via `bc_kind/bc_value`.
            // If we also use non-zero neighbor-side gradients, the reconstruction step can modify
            // those ghost values and violate boundary semantics.
            //
            // To keep the IR PDE-agnostic and preserve existing BC semantics, treat neighbor-side
            // `grad_*` vectors as zero on boundary faces.
            if *side == FaceSide::Neighbor && field.starts_with("grad_") {
                let is_boundary = Expr::ident("is_boundary");
                return typed::VecExpr::<2>::from_components([
                    dsl::select(x, Expr::from(0.0), is_boundary.clone()),
                    dsl::select(y, Expr::from(0.0), is_boundary),
                ]);
            }

            typed::VecExpr::<2>::from_components([x, y])
        }
        FaceVec2Expr::Add(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            a.add(&b)
        }
        FaceVec2Expr::Sub(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            a.sub(&b)
        }
        FaceVec2Expr::Neg(a) => lower_vec2(a, layout, primitives, flux_layout).neg(),
        FaceVec2Expr::MulScalar(v, s) => lower_vec2(v, layout, primitives, flux_layout)
            .mul_scalar(lower_scalar(s, layout, primitives, flux_layout)),
        FaceVec2Expr::Lerp(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            let l = Expr::ident("lambda");
            let lo = Expr::ident("lambda_other");
            a.mul_scalar(l).add(&b.mul_scalar(lo))
        }
    }
}

fn state_component_at(
    layout: &StateLayout,
    buffer: &str,
    idx: Expr,
    field: &str,
    component: u32,
) -> Expr {
    let offset = layout
        .component_offset(field, component)
        .unwrap_or_else(|| {
            panic!(
                "missing field '{}' component {} in state layout",
                field, component
            )
        });
    let stride = layout.stride();
    Expr::ident(buffer).index(idx * stride + offset)
}

fn state_component_at_side(
    layout: &StateLayout,
    buffer: &str,
    side: FaceSide,
    field: &str,
    component: u32,
    flux_layout: &FluxLayout,
) -> Expr {
    if side == FaceSide::Owner {
        return state_component_at(layout, buffer, Expr::ident("owner"), field, component);
    }

    // Interior neighbor value.
    let interior = state_component_at(layout, buffer, Expr::ident("neigh_idx"), field, component);

    // Boundary neighbor uses BC tables (if the field is an unknown); otherwise fall back to owner.
    //
    // Important: for *interior* faces, we always want the true neighbor cell value, even for
    // auxiliary state fields (e.g. `d_p`, `grad_p`) that are not part of the solved-for unknown
    // set. Only boundary faces need special handling.
    let owner = state_component_at(layout, buffer, Expr::ident("owner"), field, component);

    let Some(state_field) = layout.field(field) else {
        panic!("missing field '{field}' in state layout");
    };
    let comp_name = match state_field.kind() {
        FieldKind::Scalar => {
            if component != 0 {
                return owner;
            }
            field.to_string()
        }
        FieldKind::Vector2 => {
            let suffix = match component {
                0 => "x",
                1 => "y",
                _ => return owner,
            };
            format!("{field}_{suffix}")
        }
        FieldKind::Vector3 => {
            let suffix = match component {
                0 => "x",
                1 => "y",
                2 => "z",
                _ => return owner,
            };
            format!("{field}_{suffix}")
        }
    };

    if let Some(unknown_offset) = flux_layout.offset_for(&comp_name) {
        let bc_table_idx =
            Expr::ident("idx") * Expr::from(flux_layout.stride) + Expr::from(unknown_offset);
        let kind = dsl::array_access("bc_kind", bc_table_idx.clone());
        let value = dsl::array_access("bc_value", bc_table_idx);
        return Expr::call_named(
            "bc_neighbor_scalar",
            vec![
                interior,
                owner,
                kind,
                value,
                Expr::ident("d_own"),
                Expr::ident("is_boundary"),
            ],
        );
    }

    dsl::select(interior, owner, Expr::ident("is_boundary"))
}

fn lower_scalar(
    expr: &FaceScalarExpr,
    layout: &StateLayout,
    primitives: &HashMap<&str, &PrimitiveExpr>,
    flux_layout: &FluxLayout,
) -> Expr {
    match expr {
        FaceScalarExpr::Literal(v) => Expr::lit_f32(*v),
        FaceScalarExpr::Builtin(b) => match b {
            FaceScalarBuiltin::Area => Expr::ident("area"),
            FaceScalarBuiltin::Dist => Expr::ident("dist"),
            FaceScalarBuiltin::Lambda => Expr::ident("lambda"),
            FaceScalarBuiltin::LambdaOther => Expr::ident("lambda_other"),
        },
        FaceScalarExpr::Constant { name } => Expr::ident("constants").field(name.clone()),
        FaceScalarExpr::LowMachParam(param) => match param {
            LowMachParam::Model => Expr::call_named(
                "f32",
                vec![Expr::ident("low_mach_params").field("model")],
            ),
            LowMachParam::ThetaFloor => Expr::ident("low_mach_params").field("theta_floor"),
            LowMachParam::PressureCouplingAlpha => Expr::ident("low_mach_params")
                .field("pressure_coupling_alpha"),
        },
        FaceScalarExpr::State { side, name } => {
            state_component_at_side(layout, "state", *side, name, 0, flux_layout)
        }
        FaceScalarExpr::Primitive { side, name } => {
            let prim = primitives.get(name.as_str()).unwrap_or_else(|| {
                panic!("primitive '{}' not found in PrimitiveDerivations", name)
            });
            lower_primitive_expr_at_side(prim, layout, *side, flux_layout)
        }
        FaceScalarExpr::Add(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                + lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Sub(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                - lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Mul(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                * lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Div(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout)
                / lower_scalar(b, layout, primitives, flux_layout)
        }
        FaceScalarExpr::Neg(a) => -lower_scalar(a, layout, primitives, flux_layout),
        FaceScalarExpr::Abs(a) => dsl::abs(lower_scalar(a, layout, primitives, flux_layout)),
        FaceScalarExpr::Sqrt(a) => Expr::call_named(
            "sqrt",
            vec![lower_scalar(a, layout, primitives, flux_layout)],
        ),
        FaceScalarExpr::Max(a, b) => dsl::max(
            lower_scalar(a, layout, primitives, flux_layout),
            lower_scalar(b, layout, primitives, flux_layout),
        ),
        FaceScalarExpr::Min(a, b) => Expr::call_named(
            "min",
            vec![
                lower_scalar(a, layout, primitives, flux_layout),
                lower_scalar(b, layout, primitives, flux_layout),
            ],
        ),
        FaceScalarExpr::Lerp(a, b) => {
            lower_scalar(a, layout, primitives, flux_layout) * Expr::ident("lambda")
                + lower_scalar(b, layout, primitives, flux_layout) * Expr::ident("lambda_other")
        }
        FaceScalarExpr::Dot(a, b) => {
            let a = lower_vec2(a, layout, primitives, flux_layout);
            let b = lower_vec2(b, layout, primitives, flux_layout);
            a.dot(&b)
        }
    }
}

fn flux_spec_uses_low_mach(spec: &FluxModuleKernelSpec) -> bool {
    match spec {
        FluxModuleKernelSpec::ScalarReplicated { phi } => scalar_uses_low_mach(phi),
        FluxModuleKernelSpec::CentralUpwind {
            u_left,
            u_right,
            flux_left,
            flux_right,
            a_plus,
            a_minus,
            ..
        } => {
            u_left.iter().any(scalar_uses_low_mach)
                || u_right.iter().any(scalar_uses_low_mach)
                || flux_left.iter().any(scalar_uses_low_mach)
                || flux_right.iter().any(scalar_uses_low_mach)
                || scalar_uses_low_mach(a_plus)
                || scalar_uses_low_mach(a_minus)
        }
    }
}

fn vec2_uses_low_mach(expr: &FaceVec2Expr) -> bool {
    match expr {
        FaceVec2Expr::Builtin(_)
        | FaceVec2Expr::StateVec2 { .. } => false,
        FaceVec2Expr::Vec2(x, y) => scalar_uses_low_mach(x) || scalar_uses_low_mach(y),
        FaceVec2Expr::Add(a, b)
        | FaceVec2Expr::Sub(a, b)
        | FaceVec2Expr::Lerp(a, b) => vec2_uses_low_mach(a) || vec2_uses_low_mach(b),
        FaceVec2Expr::Neg(a) => vec2_uses_low_mach(a),
        FaceVec2Expr::MulScalar(a, b) => vec2_uses_low_mach(a) || scalar_uses_low_mach(b),
    }
}

fn scalar_uses_low_mach(expr: &FaceScalarExpr) -> bool {
    match expr {
        FaceScalarExpr::LowMachParam(_) => true,
        FaceScalarExpr::Literal(_)
        | FaceScalarExpr::Builtin(_)
        | FaceScalarExpr::Constant { .. }
        | FaceScalarExpr::State { .. }
        | FaceScalarExpr::Primitive { .. } => false,
        FaceScalarExpr::Add(a, b)
        | FaceScalarExpr::Sub(a, b)
        | FaceScalarExpr::Mul(a, b)
        | FaceScalarExpr::Div(a, b)
        | FaceScalarExpr::Max(a, b)
        | FaceScalarExpr::Min(a, b)
        | FaceScalarExpr::Lerp(a, b) => scalar_uses_low_mach(a) || scalar_uses_low_mach(b),
        FaceScalarExpr::Neg(a) | FaceScalarExpr::Abs(a) | FaceScalarExpr::Sqrt(a) => {
            scalar_uses_low_mach(a)
        }
        FaceScalarExpr::Dot(a, b) => vec2_uses_low_mach(a) || vec2_uses_low_mach(b),
    }
}

fn lower_primitive_expr_at_side(
    expr: &PrimitiveExpr,
    state_layout: &StateLayout,
    side: FaceSide,
    flux_layout: &FluxLayout,
) -> Expr {
    match expr {
        PrimitiveExpr::Literal(val) => Expr::lit_f32(*val),

        PrimitiveExpr::Field(name) => {
            let (base, component) = resolve_state_field_component(state_layout, name);
            state_component_at_side(state_layout, "state", side, base, component, flux_layout)
        }

        PrimitiveExpr::Add(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                + lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }
        PrimitiveExpr::Sub(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                - lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }
        PrimitiveExpr::Mul(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                * lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }
        PrimitiveExpr::Div(lhs, rhs) => {
            lower_primitive_expr_at_side(lhs, state_layout, side, flux_layout)
                / lower_primitive_expr_at_side(rhs, state_layout, side, flux_layout)
        }

        PrimitiveExpr::Sqrt(inner) => Expr::call_named(
            "sqrt",
            vec![lower_primitive_expr_at_side(inner, state_layout, side, flux_layout)],
        ),
        PrimitiveExpr::Neg(inner) => -lower_primitive_expr_at_side(inner, state_layout, side, flux_layout),
    }
}

fn resolve_state_field_component<'a>(
    state_layout: &StateLayout,
    name: &'a str,
) -> (&'a str, u32) {
    if state_layout.offset_for(name).is_some() {
        return (name, 0);
    }

    let (base, component) = name
        .rsplit_once('_')
        .unwrap_or_else(|| panic!("primitive field '{}' not found in state layout", name));

    let component = match component {
        "x" => 0,
        "y" => 1,
        "z" => 2,
        _ => panic!("primitive field '{}' not found in state layout", name),
    };

    if state_layout.component_offset(base, component).is_none() {
        panic!("primitive field '{}' not found in state layout", name);
    }

    (base, component)
}
