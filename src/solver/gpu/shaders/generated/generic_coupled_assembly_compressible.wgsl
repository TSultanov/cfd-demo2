// GENERATED BY CFD2 CODEGEN (unified_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<storage, read_write> fluxes: array<f32>;

// Group 2: Solver (block CSR values + RHS)

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

// Group 3: Boundary conditions (per boundary type x unknown)

@group(3) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(3) @binding(1) 
var<storage, read> bc_value: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let scalar_offset = scalar_row_offsets[idx];
    let diag_rank = diagonal_indices[idx] - scalar_offset;
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = scalar_offset * 16u;
    let start_row_1 = start_row_0 + num_neighbors * 4u * 1u;
    let start_row_2 = start_row_0 + num_neighbors * 4u * 2u;
    let start_row_3 = start_row_0 + num_neighbors * 4u * 3u;
    for (var rank = 0u; rank < num_neighbors; rank++) {
        matrix_values[start_row_0 + rank * 4u + 0u] = 0.0;
        matrix_values[start_row_0 + rank * 4u + 1u] = 0.0;
        matrix_values[start_row_0 + rank * 4u + 2u] = 0.0;
        matrix_values[start_row_0 + rank * 4u + 3u] = 0.0;
        matrix_values[start_row_1 + rank * 4u + 0u] = 0.0;
        matrix_values[start_row_1 + rank * 4u + 1u] = 0.0;
        matrix_values[start_row_1 + rank * 4u + 2u] = 0.0;
        matrix_values[start_row_1 + rank * 4u + 3u] = 0.0;
        matrix_values[start_row_2 + rank * 4u + 0u] = 0.0;
        matrix_values[start_row_2 + rank * 4u + 1u] = 0.0;
        matrix_values[start_row_2 + rank * 4u + 2u] = 0.0;
        matrix_values[start_row_2 + rank * 4u + 3u] = 0.0;
        matrix_values[start_row_3 + rank * 4u + 0u] = 0.0;
        matrix_values[start_row_3 + rank * 4u + 1u] = 0.0;
        matrix_values[start_row_3 + rank * 4u + 2u] = 0.0;
        matrix_values[start_row_3 + rank * 4u + 3u] = 0.0;
    }
    var diag_0: f32 = 0.0;
    var rhs_0: f32 = 0.0;
    var diag_1: f32 = 0.0;
    var rhs_1: f32 = 0.0;
    var diag_2: f32 = 0.0;
    var rhs_2: f32 = 0.0;
    var diag_3: f32 = 0.0;
    var rhs_3: f32 = 0.0;
    diag_0 += vol * 1.0 / constants.dt;
    rhs_0 += vol * 1.0 / constants.dt * state_old[idx * 7u + 0u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * 1.0 / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_0 = diag_0 - vol * 1.0 / constants.dt + diag_bdf2;
        rhs_0 = rhs_0 - vol * 1.0 / constants.dt * state_old[idx * 7u + 0u] + vol * 1.0 / constants.dt * (factor_n * state_old[idx * 7u + 0u] - factor_nm1 * state_old_old[idx * 7u + 0u]);
    }
    diag_1 += vol * 1.0 / constants.dt;
    rhs_1 += vol * 1.0 / constants.dt * state_old[idx * 7u + 1u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * 1.0 / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_1 = diag_1 - vol * 1.0 / constants.dt + diag_bdf2;
        rhs_1 = rhs_1 - vol * 1.0 / constants.dt * state_old[idx * 7u + 1u] + vol * 1.0 / constants.dt * (factor_n * state_old[idx * 7u + 1u] - factor_nm1 * state_old_old[idx * 7u + 1u]);
    }
    diag_2 += vol * 1.0 / constants.dt;
    rhs_2 += vol * 1.0 / constants.dt * state_old[idx * 7u + 2u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * 1.0 / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_2 = diag_2 - vol * 1.0 / constants.dt + diag_bdf2;
        rhs_2 = rhs_2 - vol * 1.0 / constants.dt * state_old[idx * 7u + 2u] + vol * 1.0 / constants.dt * (factor_n * state_old[idx * 7u + 2u] - factor_nm1 * state_old_old[idx * 7u + 2u]);
    }
    diag_3 += vol * 1.0 / constants.dt;
    rhs_3 += vol * 1.0 / constants.dt * state_old[idx * 7u + 3u];
    if (constants.time_scheme == 1u) {
        let r = constants.dt / constants.dt_old;
        let diag_bdf2 = vol * 1.0 / constants.dt * (r * 2.0 + 1.0) / (r + 1.0);
        let factor_n = r + 1.0;
        let factor_nm1 = r * r / (r + 1.0);
        diag_3 = diag_3 - vol * 1.0 / constants.dt + diag_bdf2;
        rhs_3 = rhs_3 - vol * 1.0 / constants.dt * state_old[idx * 7u + 3u] + vol * 1.0 / constants.dt * (factor_n * state_old[idx * 7u + 3u] - factor_nm1 * state_old_old[idx * 7u + 3u]);
    }
    for (var k = start; k < end; k++) {
        let face_idx = cell_faces[k];
        let owner = face_owner[face_idx];
        let neighbor_raw = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        let f_center = face_centers[face_idx];
        var normal: Vector2 = face_normals[face_idx];
        var is_boundary: bool = false;
        var other_idx: u32 = idx;
        var other_center: Vector2;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        if (neighbor_raw != -1) {
            let neighbor = u32(neighbor_raw);
            other_idx = neighbor;
            if (owner != idx) {
                other_idx = owner;
            }
            other_center = cell_centers[other_idx];
        } else {
            is_boundary = true;
            other_idx = idx;
            other_center = f_center;
        }
        let dx = other_center.x - center.x;
        let dy = other_center.y - center.y;
        let dist_proj = abs(dx * normal.x + dy * normal.y);
        let dist_euc = sqrt(dx * dx + dy * dy);
        var dist: f32 = max(dist_euc, 0.000001);
        if (dist_proj > 0.000001) {
            dist = dist_proj;
        }
        let scalar_mat_idx = cell_face_matrix_indices[k];
        let neighbor_rank = scalar_mat_idx - scalar_offset;
        var phi_0: f32 = fluxes[face_idx * 4u + 0u];
        if (owner != idx) {
            phi_0 -= phi_0 * 2.0;
        }
        if (!is_boundary) {
            diag_0 += max(phi_0, 0.0);
            matrix_values[start_row_0 + neighbor_rank * 4u + 0u] += min(phi_0, 0.0);
            rhs_0 -= phi_0 * (select(select(select(state[idx * 7u + 0u], state[other_idx * 7u + 0u], phi_0 < 0.0), select(state[other_idx * 7u + 0u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), state[idx * 7u + 0u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), phi_0 > 0.0), 0u == 1u), select(state[other_idx * 7u + 0u] * 0.625 + state[idx * 7u + 0u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125, state[idx * 7u + 0u] * 0.625 + state[other_idx * 7u + 0u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125, phi_0 > 0.0), 0u == 2u) - select(state[idx * 7u + 0u], state[other_idx * 7u + 0u], phi_0 < 0.0));
        } else {
            if (bc_kind[boundary_type * 4u + 0u] == 1u) {
                diag_0 += max(phi_0, 0.0);
                rhs_0 -= min(phi_0, 0.0) * bc_value[boundary_type * 4u + 0u];
            } else {
                diag_0 += phi_0;
            }
        }
        var phi_1: f32 = fluxes[face_idx * 4u + 1u];
        if (owner != idx) {
            phi_1 -= phi_1 * 2.0;
        }
        if (!is_boundary) {
            diag_1 += max(phi_1, 0.0);
            matrix_values[start_row_1 + neighbor_rank * 4u + 1u] += min(phi_1, 0.0);
            rhs_1 -= phi_1 * (select(select(select(state[idx * 7u + 1u], state[other_idx * 7u + 1u], phi_1 < 0.0), select(state[other_idx * 7u + 1u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), state[idx * 7u + 1u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), phi_1 > 0.0), 0u == 1u), select(state[other_idx * 7u + 1u] * 0.625 + state[idx * 7u + 1u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125, state[idx * 7u + 1u] * 0.625 + state[other_idx * 7u + 1u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125, phi_1 > 0.0), 0u == 2u) - select(state[idx * 7u + 1u], state[other_idx * 7u + 1u], phi_1 < 0.0));
        } else {
            if (bc_kind[boundary_type * 4u + 1u] == 1u) {
                diag_1 += max(phi_1, 0.0);
                rhs_1 -= min(phi_1, 0.0) * bc_value[boundary_type * 4u + 1u];
            } else {
                diag_1 += phi_1;
            }
        }
        var phi_2: f32 = fluxes[face_idx * 4u + 2u];
        if (owner != idx) {
            phi_2 -= phi_2 * 2.0;
        }
        if (!is_boundary) {
            diag_2 += max(phi_2, 0.0);
            matrix_values[start_row_2 + neighbor_rank * 4u + 2u] += min(phi_2, 0.0);
            rhs_2 -= phi_2 * (select(select(select(state[idx * 7u + 2u], state[other_idx * 7u + 2u], phi_2 < 0.0), select(state[other_idx * 7u + 2u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), state[idx * 7u + 2u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), phi_2 > 0.0), 0u == 1u), select(state[other_idx * 7u + 2u] * 0.625 + state[idx * 7u + 2u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125, state[idx * 7u + 2u] * 0.625 + state[other_idx * 7u + 2u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125, phi_2 > 0.0), 0u == 2u) - select(state[idx * 7u + 2u], state[other_idx * 7u + 2u], phi_2 < 0.0));
        } else {
            if (bc_kind[boundary_type * 4u + 2u] == 1u) {
                diag_2 += max(phi_2, 0.0);
                rhs_2 -= min(phi_2, 0.0) * bc_value[boundary_type * 4u + 2u];
            } else {
                diag_2 += phi_2;
            }
        }
        var phi_3: f32 = fluxes[face_idx * 4u + 3u];
        if (owner != idx) {
            phi_3 -= phi_3 * 2.0;
        }
        if (!is_boundary) {
            diag_3 += max(phi_3, 0.0);
            matrix_values[start_row_3 + neighbor_rank * 4u + 3u] += min(phi_3, 0.0);
            rhs_3 -= phi_3 * (select(select(select(state[idx * 7u + 3u], state[other_idx * 7u + 3u], phi_3 < 0.0), select(state[other_idx * 7u + 3u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(other_center.x, other_center.y)), state[idx * 7u + 3u] + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(f_center.x, f_center.y) - vec2<f32>(center.x, center.y)), phi_3 > 0.0), 0u == 1u), select(state[other_idx * 7u + 3u] * 0.625 + state[idx * 7u + 3u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(center.x, center.y) - vec2<f32>(other_center.x, other_center.y)) * 0.125, state[idx * 7u + 3u] * 0.625 + state[other_idx * 7u + 3u] * 0.375 + dot(vec2<f32>(vec2<f32>(0.0, 0.0).x, vec2<f32>(0.0, 0.0).y), vec2<f32>(other_center.x, other_center.y) - vec2<f32>(center.x, center.y)) * 0.125, phi_3 > 0.0), 0u == 2u) - select(state[idx * 7u + 3u], state[other_idx * 7u + 3u], phi_3 < 0.0));
        } else {
            if (bc_kind[boundary_type * 4u + 3u] == 1u) {
                diag_3 += max(phi_3, 0.0);
                rhs_3 -= min(phi_3, 0.0) * bc_value[boundary_type * 4u + 3u];
            } else {
                diag_3 += phi_3;
            }
        }
    }
    matrix_values[start_row_0 + diag_rank * 4u + 0u] += diag_0;
    rhs[idx * 4u + 0u] = rhs_0;
    matrix_values[start_row_1 + diag_rank * 4u + 1u] += diag_1;
    rhs[idx * 4u + 1u] = rhs_1;
    matrix_values[start_row_2 + diag_rank * 4u + 2u] += diag_2;
    rhs[idx * 4u + 2u] = rhs_2;
    matrix_values[start_row_3 + diag_rank * 4u + 3u] += diag_3;
    rhs[idx * 4u + 3u] = rhs_3;
}
