use crate::solver::scheme::Scheme;

use crate::solver::model::ast::{Coefficient, Discretization, FieldKind};
use super::ir::{DiscreteOp, DiscreteOpKind, DiscreteSystem};
use super::wgsl_ast::{Block, Function, Item, Module, Param, Stmt, Type};
use super::wgsl_dsl as dsl;

pub fn generate_wgsl(system: &DiscreteSystem) -> String {
    generate_wgsl_module(system).to_wgsl()
}

pub fn generate_wgsl_library(system: &DiscreteSystem) -> String {
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN (library)".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(generate_wgsl_library_items(system));
    module.to_wgsl()
}

pub fn generate_wgsl_library_items(system: &DiscreteSystem) -> Vec<Item> {
    let mut items = Vec::new();

    for equation in &system.equations {
        items.push(Item::Comment(format!(
            "equation: {} ({})",
            equation.target.name(),
            equation.target.kind().as_str()
        )));
        for op in &equation.ops {
            items.push(Item::Comment(term_comment(op)));
            items.push(Item::Function(term_function(op)));
        }
        items.push(Item::Function(codegen_assemble_fn(equation)));
    }

    if has_convection(system) {
        items.push(Item::Function(codegen_conv_coeff_fn()));
    }
    if has_diffusion(system) {
        items.push(Item::Function(codegen_diff_coeff_fn()));
    }

    items
}

fn generate_wgsl_module(system: &DiscreteSystem) -> Module {
    let mut module = Module::new();
    module.push(Item::Comment("GENERATED BY CFD2 CODEGEN".to_string()));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));

    for equation in &system.equations {
        module.push(Item::Comment(format!(
            "equation: {} ({})",
            equation.target.name(),
            equation.target.kind().as_str()
        )));
        for op in &equation.ops {
            module.push(Item::Comment(term_comment(op)));
            module.push(Item::Function(term_function(op)));
        }
        module.push(Item::Function(equation_assemble_fn(equation)));
    }

    module.push(Item::Function(main_fn(system)));

    if has_convection(system) {
        module.push(Item::Function(codegen_conv_coeff_fn()));
    }
    if has_diffusion(system) {
        module.push(Item::Function(codegen_diff_coeff_fn()));
    }

    module
}

fn term_comment(op: &DiscreteOp) -> String {
    let mut line = format!(
        "term: {} target={} field={} discretization={} scheme={}",
        op.kind.as_str(),
        op.target.name(),
        op.field.name(),
        op.discretization.as_str(),
        scheme_name(op.scheme),
    );

    if let Some(flux) = &op.flux {
        line.push_str(&format!(" flux={}", flux.name()));
    }

    if let Some(coeff) = &op.coeff {
        line.push(' ');
        line.push_str("coeff=");
        line.push_str(&format_coeff(coeff));
    }

    line
}

fn term_function(op: &DiscreteOp) -> Function {
    match op.kind {
        DiscreteOpKind::TimeDerivative => term_ddt_fn(op),
        DiscreteOpKind::Convection => term_div_fn(op),
        DiscreteOpKind::Diffusion => term_laplacian_fn(op),
        DiscreteOpKind::Gradient => term_grad_fn(op),
        DiscreteOpKind::Source => term_source_fn(op),
    }
}

fn term_ddt_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let params = match op.target.kind() {
        FieldKind::Vector2 => vec![
            Param::new("vol", Type::F32, Vec::new()),
            Param::new("rho", Type::F32, Vec::new()),
            Param::new("dt", Type::F32, Vec::new()),
            Param::new("dt_old", Type::F32, Vec::new()),
            Param::new("time_scheme", Type::U32, Vec::new()),
            Param::new("phi_n", Type::vec2_f32(), Vec::new()),
            Param::new("phi_nm1", Type::vec2_f32(), Vec::new()),
        ],
        FieldKind::Scalar => vec![
            Param::new("vol", Type::F32, Vec::new()),
            Param::new("rho", Type::F32, Vec::new()),
            Param::new("dt", Type::F32, Vec::new()),
            Param::new("dt_old", Type::F32, Vec::new()),
            Param::new("time_scheme", Type::U32, Vec::new()),
            Param::new("phi_n", Type::F32, Vec::new()),
            Param::new("phi_nm1", Type::F32, Vec::new()),
        ],
    };

    let mut body = Vec::new();
    body.push(Stmt::Comment(
        "implicit time derivative (BDF1/BDF2)".to_string(),
    ));
    body.push(dsl::let_("base_coeff", "rho * vol / dt"));
    body.push(dsl::var_typed("diag", Type::F32, Some("base_coeff")));

    match op.target.kind() {
        FieldKind::Vector2 => {
            body.push(dsl::var_typed("rhs_x", Type::F32, Some("base_coeff * phi_n.x")));
            body.push(dsl::var_typed("rhs_y", Type::F32, Some("base_coeff * phi_n.y")));
            body.push(dsl::if_block(
                "time_scheme == 1u",
                dsl::block(vec![
                    dsl::let_("r", "dt / dt_old"),
                    dsl::assign(
                        "diag",
                        "rho * vol / dt * (1.0 + 2.0 * r) / (1.0 + r)",
                    ),
                    dsl::let_("factor_n", "1.0 + r"),
                    dsl::let_("factor_nm1", "(r * r) / (1.0 + r)"),
                    dsl::assign(
                        "rhs_x",
                        "rho * vol / dt * (factor_n * phi_n.x - factor_nm1 * phi_nm1.x)",
                    ),
                    dsl::assign(
                        "rhs_y",
                        "rho * vol / dt * (factor_n * phi_n.y - factor_nm1 * phi_nm1.y)",
                    ),
                ]),
                None,
            ));
            body.push(Stmt::Return(Some(dsl::expr(
                "vec3<f32>(diag, rhs_x, rhs_y)",
            ))));
            Function::new(name, params, Some(Type::Vec3(Box::new(Type::F32))), Vec::new(), Block::new(body))
        }
        FieldKind::Scalar => {
            body.push(dsl::var_typed("rhs", Type::F32, Some("base_coeff * phi_n")));
            body.push(dsl::if_block(
                "time_scheme == 1u",
                dsl::block(vec![
                    dsl::let_("r", "dt / dt_old"),
                    dsl::assign(
                        "diag",
                        "rho * vol / dt * (1.0 + 2.0 * r) / (1.0 + r)",
                    ),
                    dsl::let_("factor_n", "1.0 + r"),
                    dsl::let_("factor_nm1", "(r * r) / (1.0 + r)"),
                    dsl::assign(
                        "rhs",
                        "rho * vol / dt * (factor_n * phi_n - factor_nm1 * phi_nm1)",
                    ),
                ]),
                None,
            ));
            body.push(Stmt::Return(Some(dsl::expr("vec2<f32>(diag, rhs)"))));
            Function::new(name, params, Some(Type::Vec2(Box::new(Type::F32))), Vec::new(), Block::new(body))
        }
    }
}

fn term_div_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let mut body = Vec::new();
    body.push(Stmt::Comment(
        "finite-volume convection with optional higher-order correction".to_string(),
    ));
    body.push(dsl::let_("conv_coeff", "codegen_conv_coeff(flux)"));
    body.push(dsl::let_("diag_coeff", "conv_coeff.x"));
    body.push(dsl::let_("off_coeff", "conv_coeff.y"));

    match op.target.kind() {
        FieldKind::Vector2 => {
            let params = vec![
                Param::new("flux", Type::F32, Vec::new()),
                Param::new("phi_own", Type::vec2_f32(), Vec::new()),
                Param::new("phi_neigh", Type::vec2_f32(), Vec::new()),
                Param::new("grad_own_u", Type::vec2_f32(), Vec::new()),
                Param::new("grad_own_v", Type::vec2_f32(), Vec::new()),
                Param::new("grad_neigh_u", Type::vec2_f32(), Vec::new()),
                Param::new("grad_neigh_v", Type::vec2_f32(), Vec::new()),
                Param::new("r_upwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_downwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_cd", Type::vec2_f32(), Vec::new()),
            ];

            body.push(dsl::var_typed("phi_upwind", Type::vec2_f32(), Some("phi_own")));
            body.push(dsl::var_typed("phi_ho", Type::vec2_f32(), Some("phi_own")));
            body.push(dsl::if_block(
                "flux <= 0.0",
                dsl::block(vec![
                    dsl::assign("phi_upwind", "phi_neigh"),
                    dsl::assign("phi_ho", "phi_neigh"),
                ]),
                None,
            ));

            match op.scheme {
                Scheme::SecondOrderUpwind => {
                    body.push(dsl::if_block(
                        "flux > 0.0",
                        dsl::block(vec![
                            dsl::assign(
                                "phi_ho.x",
                                "phi_own.x + (grad_own_u.x * r_upwind.x + grad_own_u.y * r_upwind.y)",
                            ),
                            dsl::assign(
                                "phi_ho.y",
                                "phi_own.y + (grad_own_v.x * r_upwind.x + grad_own_v.y * r_upwind.y)",
                            ),
                        ]),
                        Some(dsl::block(vec![
                            dsl::assign(
                                "phi_ho.x",
                                "phi_neigh.x + (grad_neigh_u.x * r_downwind.x + grad_neigh_u.y * r_downwind.y)",
                            ),
                            dsl::assign(
                                "phi_ho.y",
                                "phi_neigh.y + (grad_neigh_v.x * r_downwind.x + grad_neigh_v.y * r_downwind.y)",
                            ),
                        ])),
                    ));
                }
                Scheme::QUICK => {
                    body.push(dsl::if_block(
                        "flux > 0.0",
                        dsl::block(vec![
                            dsl::assign(
                                "phi_ho.x",
                                "0.625 * phi_own.x + 0.375 * phi_neigh.x + 0.125 * (grad_own_u.x * r_cd.x + grad_own_u.y * r_cd.y)",
                            ),
                            dsl::assign(
                                "phi_ho.y",
                                "0.625 * phi_own.y + 0.375 * phi_neigh.y + 0.125 * (grad_own_v.x * r_cd.x + grad_own_v.y * r_cd.y)",
                            ),
                        ]),
                        Some(dsl::block(vec![
                            dsl::assign(
                                "phi_ho.x",
                                "0.625 * phi_neigh.x + 0.375 * phi_own.x + 0.125 * (grad_neigh_u.x * r_cd.x + grad_neigh_u.y * r_cd.y)",
                            ),
                            dsl::assign(
                                "phi_ho.y",
                                "0.625 * phi_neigh.y + 0.375 * phi_own.y + 0.125 * (grad_neigh_v.x * r_cd.x + grad_neigh_v.y * r_cd.y)",
                            ),
                        ])),
                    ));
                }
                Scheme::Upwind => {}
            }

            body.push(dsl::let_("rhs_corr_x", "flux * (phi_ho.x - phi_upwind.x)"));
            body.push(dsl::let_("rhs_corr_y", "flux * (phi_ho.y - phi_upwind.y)"));
            body.push(Stmt::Return(Some(dsl::expr(
                "vec4<f32>(diag_coeff, off_coeff, rhs_corr_x, rhs_corr_y)",
            ))));
            Function::new(
                name,
                params,
                Some(Type::Vec4(Box::new(Type::F32))),
                Vec::new(),
                Block::new(body),
            )
        }
        FieldKind::Scalar => {
            let params = vec![
                Param::new("flux", Type::F32, Vec::new()),
                Param::new("phi_own", Type::F32, Vec::new()),
                Param::new("phi_neigh", Type::F32, Vec::new()),
                Param::new("grad_own", Type::vec2_f32(), Vec::new()),
                Param::new("grad_neigh", Type::vec2_f32(), Vec::new()),
                Param::new("r_upwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_downwind", Type::vec2_f32(), Vec::new()),
                Param::new("r_cd", Type::vec2_f32(), Vec::new()),
            ];

            body.push(dsl::var_typed("phi_upwind", Type::F32, Some("phi_own")));
            body.push(dsl::var_typed("phi_ho", Type::F32, Some("phi_own")));
            body.push(dsl::if_block(
                "flux <= 0.0",
                dsl::block(vec![
                    dsl::assign("phi_upwind", "phi_neigh"),
                    dsl::assign("phi_ho", "phi_neigh"),
                ]),
                None,
            ));

            match op.scheme {
                Scheme::SecondOrderUpwind => {
                    body.push(dsl::if_block(
                        "flux > 0.0",
                        dsl::block(vec![dsl::assign(
                            "phi_ho",
                            "phi_own + (grad_own.x * r_upwind.x + grad_own.y * r_upwind.y)",
                        )]),
                        Some(dsl::block(vec![dsl::assign(
                            "phi_ho",
                            "phi_neigh + (grad_neigh.x * r_downwind.x + grad_neigh.y * r_downwind.y)",
                        )])),
                    ));
                }
                Scheme::QUICK => {
                    body.push(dsl::if_block(
                        "flux > 0.0",
                        dsl::block(vec![dsl::assign(
                            "phi_ho",
                            "0.625 * phi_own + 0.375 * phi_neigh + 0.125 * (grad_own.x * r_cd.x + grad_own.y * r_cd.y)",
                        )]),
                        Some(dsl::block(vec![dsl::assign(
                            "phi_ho",
                            "0.625 * phi_neigh + 0.375 * phi_own + 0.125 * (grad_neigh.x * r_cd.x + grad_neigh.y * r_cd.y)",
                        )])),
                    ));
                }
                Scheme::Upwind => {}
            }

            body.push(dsl::let_("rhs_corr", "flux * (phi_ho - phi_upwind)"));
            body.push(Stmt::Return(Some(dsl::expr(
                "vec3<f32>(diag_coeff, off_coeff, rhs_corr)",
            ))));
            Function::new(
                name,
                params,
                Some(Type::Vec3(Box::new(Type::F32))),
                Vec::new(),
                Block::new(body),
            )
        }
    }
}

fn term_laplacian_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let params = vec![
        Param::new("mu", Type::F32, Vec::new()),
        Param::new("area", Type::F32, Vec::new()),
        Param::new("dist", Type::F32, Vec::new()),
    ];
    let body = Block::new(vec![
        Stmt::Comment("diffusion coefficient from mu * area / dist".to_string()),
        dsl::let_("coeff", "mu * area / dist"),
        Stmt::Return(Some(dsl::expr("vec2<f32>(coeff, -coeff)"))),
    ]);
    Function::new(name, params, Some(Type::Vec2(Box::new(Type::F32))), Vec::new(), body)
}

fn term_grad_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let params = vec![
        Param::new("area", Type::F32, Vec::new()),
        Param::new("normal", Type::vec2_f32(), Vec::new()),
        Param::new("lambda", Type::F32, Vec::new()),
    ];
    let body = match op.target.kind() {
        FieldKind::Vector2 => Block::new(vec![
            Stmt::Comment("pressure gradient coupling weights".to_string()),
            dsl::let_("force_x", "area * normal.x"),
            dsl::let_("force_y", "area * normal.y"),
            dsl::let_("off_u", "(1.0 - lambda) * force_x"),
            dsl::let_("off_v", "(1.0 - lambda) * force_y"),
            dsl::let_("diag_u", "lambda * force_x"),
            dsl::let_("diag_v", "lambda * force_y"),
            Stmt::Return(Some(dsl::expr(
                "vec4<f32>(off_u, off_v, diag_u, diag_v)",
            ))),
        ]),
        FieldKind::Scalar => Block::new(vec![
            Stmt::Comment("gradient term not used for scalar targets".to_string()),
            Stmt::Return(Some(dsl::expr("vec2<f32>(0.0, 0.0)"))),
        ]),
    };
    let return_type = match op.target.kind() {
        FieldKind::Vector2 => Type::Vec4(Box::new(Type::F32)),
        FieldKind::Scalar => Type::Vec2(Box::new(Type::F32)),
    };
    Function::new(name, params, Some(return_type), Vec::new(), body)
}

fn term_source_fn(op: &DiscreteOp) -> Function {
    let name = term_function_name(op);
    let body = match op.target.kind() {
        FieldKind::Vector2 => Block::new(vec![
            Stmt::Comment("source term placeholder".to_string()),
            Stmt::Return(Some(dsl::expr("vec2<f32>(0.0, 0.0)"))),
        ]),
        FieldKind::Scalar => Block::new(vec![
            Stmt::Comment("source term placeholder".to_string()),
            Stmt::Return(Some(dsl::expr("0.0"))),
        ]),
    };
    let return_type = match op.target.kind() {
        FieldKind::Vector2 => Type::Vec2(Box::new(Type::F32)),
        FieldKind::Scalar => Type::F32,
    };
    Function::new(name, Vec::new(), Some(return_type), Vec::new(), body)
}

fn equation_assemble_fn(equation: &super::ir::DiscreteEquation) -> Function {
    let name = equation_function_name(&equation.target);
    let mut stmts = Vec::new();
    for op in &equation.ops {
        stmts.push(dsl::call_stmt(&term_call_expr(op)));
    }
    Function::new(name, Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn codegen_assemble_fn(equation: &super::ir::DiscreteEquation) -> Function {
    let name = codegen_assemble_function_name(&equation.target);
    let mut stmts = Vec::new();
    for op in &equation.ops {
        stmts.push(dsl::call_stmt(&term_call_expr(op)));
    }
    Function::new(name, Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn term_call_expr(op: &DiscreteOp) -> String {
    let name = term_function_name(op);
    let args: Vec<&'static str> = match op.kind {
        DiscreteOpKind::TimeDerivative => match op.target.kind() {
            FieldKind::Vector2 => vec![
                "1.0",
                "1.0",
                "1.0",
                "1.0",
                "0u",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
            ],
            FieldKind::Scalar => vec!["1.0", "1.0", "1.0", "1.0", "0u", "0.0", "0.0"],
        },
        DiscreteOpKind::Convection => match op.target.kind() {
            FieldKind::Vector2 => vec![
                "0.0",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
            ],
            FieldKind::Scalar => vec![
                "0.0",
                "0.0",
                "0.0",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
                "vec2<f32>(0.0, 0.0)",
            ],
        },
        DiscreteOpKind::Diffusion => vec!["1.0", "1.0", "1.0"],
        DiscreteOpKind::Gradient => vec!["1.0", "vec2<f32>(0.0, 0.0)", "0.5"],
        DiscreteOpKind::Source => Vec::new(),
    };
    if args.is_empty() {
        format!("{}()", name)
    } else {
        format!("{}({})", name, args.join(", "))
    }
}

fn main_fn(system: &DiscreteSystem) -> Function {
    let mut stmts = Vec::new();
    for equation in &system.equations {
        let name = equation_function_name(&equation.target);
        stmts.push(dsl::call_stmt(&format!("{}()", name)));
    }
    Function::new("main", Vec::new(), None, Vec::new(), Block::new(stmts))
}

fn codegen_conv_coeff_fn() -> Function {
    let params = vec![Param::new("flux", Type::F32, Vec::new())];
    let body = Block::new(vec![
        dsl::var_typed("conv_coeff_diag", Type::F32, Some("0.0")),
        dsl::var_typed("conv_coeff_off", Type::F32, Some("0.0")),
        dsl::if_block(
            "flux > 0.0",
            dsl::block(vec![dsl::assign("conv_coeff_diag", "flux")]),
            Some(dsl::block(vec![dsl::assign("conv_coeff_off", "flux")])),
        ),
        Stmt::Return(Some(dsl::expr("vec2<f32>(conv_coeff_diag, conv_coeff_off)"))),
    ]);
    Function::new(
        "codegen_conv_coeff",
        params,
        Some(Type::Vec2(Box::new(Type::F32))),
        Vec::new(),
        body,
    )
}

fn codegen_diff_coeff_fn() -> Function {
    let params = vec![
        Param::new("mu", Type::F32, Vec::new()),
        Param::new("area", Type::F32, Vec::new()),
        Param::new("dist", Type::F32, Vec::new()),
    ];
    let body = Block::new(vec![Stmt::Return(Some(dsl::expr(
        "mu * area / dist",
    )))]);
    Function::new(
        "codegen_diff_coeff",
        params,
        Some(Type::F32),
        Vec::new(),
        body,
    )
}

fn format_coeff(coeff: &Coefficient) -> String {
    match coeff {
        Coefficient::Constant(value) => format!("const({})", value),
        Coefficient::Field(field) => format!("field({})", field.name()),
    }
}

fn scheme_name(scheme: Scheme) -> &'static str {
    match scheme {
        Scheme::Upwind => "upwind",
        Scheme::SecondOrderUpwind => "sou",
        Scheme::QUICK => "quick",
    }
}

#[allow(dead_code)]
fn scheme_id(scheme: Scheme) -> u32 {
    match scheme {
        Scheme::Upwind => 0,
        Scheme::SecondOrderUpwind => 1,
        Scheme::QUICK => 2,
    }
}

#[allow(dead_code)]
fn discretization_id(discretization: Discretization) -> u32 {
    match discretization {
        Discretization::Implicit => 0,
        Discretization::Explicit => 1,
    }
}

fn sanitize_ident(value: &str) -> String {
    let mut output = String::with_capacity(value.len());
    for ch in value.chars() {
        if ch.is_ascii_alphanumeric() || ch == '_' {
            output.push(ch);
        } else {
            output.push('_');
        }
    }
    if output.is_empty() {
        "_".to_string()
    } else {
        output
    }
}

fn term_function_name(op: &DiscreteOp) -> String {
    let mut name = String::new();
    name.push_str("term_");
    name.push_str(op.kind.as_str());
    name.push('_');
    if let Some(flux) = &op.flux {
        name.push_str(&sanitize_ident(flux.name()));
        name.push('_');
    }
    name.push_str(&sanitize_ident(op.field.name()));
    name.push('_');
    name.push_str(scheme_name(op.scheme));
    name
}

fn equation_function_name(field: &crate::solver::model::ast::FieldRef) -> String {
    format!("assemble_{}", sanitize_ident(field.name()))
}

fn codegen_assemble_function_name(field: &crate::solver::model::ast::FieldRef) -> String {
    format!("codegen_assemble_{}", sanitize_ident(field.name()))
}

fn has_convection(system: &DiscreteSystem) -> bool {
    system
        .equations
        .iter()
        .flat_map(|eq| eq.ops.iter())
        .any(|op| op.kind == super::ir::DiscreteOpKind::Convection)
}

fn has_diffusion(system: &DiscreteSystem) -> bool {
    system
        .equations
        .iter()
        .flat_map(|eq| eq.ops.iter())
        .any(|op| op.kind == super::ir::DiscreteOpKind::Diffusion)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::ast::{fvc, fvm, surface_scalar, vol_scalar, vol_vector};
    use crate::solver::codegen::ir::lower_system;
    use crate::solver::model::SchemeRegistry;

    #[test]
    fn generate_wgsl_emits_terms_and_metadata() {
        let u = vol_vector("U");
        let p = vol_scalar("p");
        let phi = surface_scalar("phi");
        let mu = vol_scalar("mu");

        let mut eqn = crate::solver::model::ast::Equation::new(u.clone());
        eqn.add_term(fvm::div(phi.clone(), u.clone()));
        eqn.add_term(fvc::grad(p.clone()));
        eqn.add_term(fvm::laplacian(
            Coefficient::field(mu).unwrap(),
            u.clone(),
        ));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::model::ast::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("// equation: U (vector2)"));
        assert!(wgsl.contains("term: div"));
        assert!(wgsl.contains("scheme=quick"));
        assert!(wgsl.contains("flux=phi"));
        assert!(wgsl.contains("term: grad"));
        assert!(wgsl.contains("term: laplacian"));
        assert!(wgsl.contains("coeff=field(mu)"));
        assert!(wgsl.contains("fn main()"));
    }

    #[test]
    fn format_helpers_cover_constant_coeff_and_schemes() {
        let coeff = Coefficient::constant(1.5);
        assert_eq!(format_coeff(&coeff), "const(1.5)");

        assert_eq!(scheme_name(Scheme::Upwind), "upwind");
        assert_eq!(scheme_name(Scheme::SecondOrderUpwind), "sou");
        assert_eq!(scheme_name(Scheme::QUICK), "quick");
        assert_eq!(scheme_id(Scheme::Upwind), 0);
        assert_eq!(scheme_id(Scheme::SecondOrderUpwind), 1);
        assert_eq!(scheme_id(Scheme::QUICK), 2);
        assert_eq!(discretization_id(Discretization::Implicit), 0);
        assert_eq!(discretization_id(Discretization::Explicit), 1);
    }

    #[test]
    fn generated_line_omits_optional_fields_when_absent() {
        let u = vol_vector("U");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvc::grad(u.clone()));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("term: grad"));
        assert!(!wgsl.contains("flux="));
        assert!(!wgsl.contains("coeff="));
    }

    #[test]
    fn generate_wgsl_includes_ddt_and_source_terms() {
        let u = vol_vector("U");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()))
            .with_term(fvc::source(u.clone()));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("term: ddt"));
        assert!(wgsl.contains("term: source"));
    }

    #[test]
    fn sanitize_ident_replaces_non_alnum() {
        assert_eq!(sanitize_ident("phi"), "phi");
        assert_eq!(sanitize_ident("phi.face"), "phi_face");
        assert_eq!(sanitize_ident("U[0]"), "U_0_");
        assert_eq!(sanitize_ident(""), "_");
    }

    #[test]
    fn term_function_name_includes_flux_and_scheme() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi.face");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi.clone(), u.clone()));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let mut registry = SchemeRegistry::new(Scheme::Upwind);
        registry.set_for_term(
            crate::solver::model::ast::TermOp::Div,
            Some(&phi),
            &u,
            Scheme::QUICK,
        );

        let discrete = lower_system(&system, &registry);
        let name = term_function_name(&discrete.equations[0].ops[0]);
        assert_eq!(name, "term_div_phi_face_U_quick");
    }

    #[test]
    fn generate_wgsl_emits_term_math() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()))
            .with_term(fvm::div(phi, u.clone()))
            .with_term(fvc::grad(vol_scalar("p")))
            .with_term(fvm::laplacian(Coefficient::constant(0.1), u.clone()));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl(&discrete);

        assert!(wgsl.contains("fn term_ddt_U_upwind"));
        assert!(wgsl.contains("time_scheme == 1u"));
        assert!(wgsl.contains("codegen_conv_coeff(flux)"));
        assert!(wgsl.contains("mu * area / dist"));
        assert!(!wgsl.contains("TODO"));
        assert!(wgsl.contains("fn assemble_U()"));
        assert!(wgsl.contains("assemble_U();"));
    }

    #[test]
    fn equation_function_name_is_sanitized() {
        let field = vol_vector("U-1");
        let name = equation_function_name(&field);
        assert_eq!(name, "assemble_U_1");
    }

    #[test]
    fn generate_wgsl_library_emits_codegen_assemble() {
        let u = vol_vector("U");
        let phi = surface_scalar("phi");
        let nu = vol_scalar("nu");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvm::div(phi, u.clone()))
            .with_term(fvm::laplacian(
                Coefficient::field(nu).unwrap(),
                u.clone(),
            ));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl_library(&discrete);

        assert!(wgsl.contains("codegen_assemble_U"));
        assert!(!wgsl.contains("fn main()"));
        assert!(wgsl.contains("codegen_conv_coeff"));
        assert!(wgsl.contains("codegen_diff_coeff"));
    }

    #[test]
    fn generate_wgsl_library_omits_conv_coeff_when_no_convection() {
        let u = vol_vector("U");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvm::ddt(u.clone()));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl_library(&discrete);

        assert!(!wgsl.contains("codegen_conv_coeff"));
        assert!(!wgsl.contains("codegen_diff_coeff"));
    }

    #[test]
    fn generate_wgsl_library_emits_diff_coeff_for_laplacian() {
        let u = vol_vector("U");
        let nu = vol_scalar("nu");
        let eqn = crate::solver::model::ast::Equation::new(u.clone())
            .with_term(fvm::laplacian(
                Coefficient::field(nu).unwrap(),
                u.clone(),
            ));

        let mut system = crate::solver::model::ast::EquationSystem::new();
        system.add_equation(eqn);

        let registry = SchemeRegistry::new(Scheme::Upwind);
        let discrete = lower_system(&system, &registry);
        let wgsl = generate_wgsl_library(&discrete);

        assert!(wgsl.contains("codegen_diff_coeff"));
    }
}
