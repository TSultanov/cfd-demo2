// GENERATED BY CFD2 CODEGEN (coupled assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(10) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(11) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

// Group 2: Solver (Coupled)

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

@group(2) @binding(3) 
var<storage, read_write> grad_u: array<Vector2>;

@group(2) @binding(4) 
var<storage, read_write> grad_v: array<Vector2>;

@group(2) @binding(5) 
var<storage, read_write> scalar_matrix_values: array<f32>;

@group(2) @binding(6) 
var<storage, read_write> diag_u_inv: array<f32>;

@group(2) @binding(7) 
var<storage, read_write> diag_v_inv: array<f32>;

@group(2) @binding(8) 
var<storage, read_write> diag_p_inv: array<f32>;

fn safe_inverse(val: f32) -> f32 {
    if (abs(val) > 1e-14) {
        return 1.0 / val;
    }
    return 0.0;
}

// equation: U (vector2)

// term: ddt target=U field=U discretization=implicit scheme=upwind coeff=field(rho)

fn term_ddt_U_upwind(vol: f32, rho: f32, dt: f32, dt_old: f32, time_scheme: u32, phi_n: vec2<f32>, phi_nm1: vec2<f32>) -> vec3<f32> {
    // implicit time derivative (BDF1/BDF2)
    let base_coeff = rho * vol / dt;
    var diag: f32 = base_coeff;
    var rhs_x: f32 = base_coeff * phi_n.x;
    var rhs_y: f32 = base_coeff * phi_n.y;
    if (time_scheme == 1u) {
        let r = dt / dt_old;
        diag = rho * vol / dt * (1.0 + 2.0 * r) / (1.0 + r);
        let factor_n = 1.0 + r;
        let factor_nm1 = r * r / (1.0 + r);
        rhs_x = rho * vol / dt * (factor_n * phi_n.x - factor_nm1 * phi_nm1.x);
        rhs_y = rho * vol / dt * (factor_n * phi_n.y - factor_nm1 * phi_nm1.y);
    }
    return vec3<f32>(diag, rhs_x, rhs_y);
}

// term: div target=U field=U discretization=implicit scheme=upwind flux=phi

fn term_div_phi_U_upwind(flux: f32, phi_own: vec2<f32>, phi_neigh: vec2<f32>, grad_own_u: vec2<f32>, grad_own_v: vec2<f32>, grad_neigh_u: vec2<f32>, grad_neigh_v: vec2<f32>, r_upwind: vec2<f32>, r_downwind: vec2<f32>, r_cd: vec2<f32>) -> vec4<f32> {
    // finite-volume convection with optional higher-order correction
    let conv_coeff = codegen_conv_coeff(flux);
    let diag_coeff = conv_coeff.x;
    let off_coeff = conv_coeff.y;
    var phi_upwind: vec2<f32> = phi_own;
    var phi_ho: vec2<f32> = phi_own;
    if (flux <= 0.0) {
        phi_upwind = phi_neigh;
        phi_ho = phi_neigh;
    }
    let rhs_corr_x = flux * (phi_ho.x - phi_upwind.x);
    let rhs_corr_y = flux * (phi_ho.y - phi_upwind.y);
    return vec4<f32>(diag_coeff, off_coeff, rhs_corr_x, rhs_corr_y);
}

// term: laplacian target=U field=U discretization=implicit scheme=upwind coeff=field(nu)

fn term_laplacian_U_upwind(mu: f32, area: f32, dist: f32) -> vec2<f32> {
    // diffusion coefficient from mu * area / dist
    let coeff = mu * area / dist;
    return vec2<f32>(coeff, -coeff);
}

// term: grad target=U field=p discretization=explicit scheme=upwind

fn term_grad_p_upwind(area: f32, normal: vec2<f32>, lambda: f32) -> vec4<f32> {
    // pressure gradient coupling weights
    let force_x = area * normal.x;
    let force_y = area * normal.y;
    let off_u = (1.0 - lambda) * force_x;
    let off_v = (1.0 - lambda) * force_y;
    let diag_u = lambda * force_x;
    let diag_v = lambda * force_y;
    return vec4<f32>(off_u, off_v, diag_u, diag_v);
}

fn codegen_assemble_U() {
    term_ddt_U_upwind(1.0, 1.0, 1.0, 1.0, 0u, vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    term_div_phi_U_upwind(0.0, vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0), vec2<f32>(0.0, 0.0));
    term_laplacian_U_upwind(1.0, 1.0, 1.0);
    term_grad_p_upwind(1.0, vec2<f32>(0.0, 0.0), 0.5);
}

// equation: p (scalar)

// term: laplacian target=p field=p discretization=implicit scheme=upwind coeff=product(field(rho), field(d_p))

fn term_laplacian_p_upwind(mu: f32, area: f32, dist: f32) -> vec2<f32> {
    // diffusion coefficient from mu * area / dist
    let coeff = mu * area / dist;
    return vec2<f32>(coeff, -coeff);
}

fn codegen_assemble_p() {
    term_laplacian_p_upwind(1.0, 1.0, 1.0);
}

fn codegen_conv_coeff(flux: f32) -> vec2<f32> {
    var conv_coeff_diag: f32 = 0.0;
    var conv_coeff_off: f32 = 0.0;
    if (flux > 0.0) {
        conv_coeff_diag = flux;
    } else {
        conv_coeff_off = flux;
    }
    return vec2<f32>(conv_coeff_diag, conv_coeff_off);
}

fn codegen_diff_coeff(mu: f32, area: f32, dist: f32) -> f32 {
    return mu * area / dist;
}

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let vol = cell_vols[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1];
    let scalar_offset = scalar_row_offsets[idx];
    let num_neighbors = scalar_row_offsets[idx + 1] - scalar_offset;
    let start_row_0 = 9u * scalar_offset;
    let start_row_1 = start_row_0 + 3u * num_neighbors;
    let start_row_2 = start_row_0 + 6u * num_neighbors;
    var diag_u: f32 = 0.0;
    var diag_v: f32 = 0.0;
    var diag_p: f32 = 0.0;
    var sum_diag_up: f32 = 0.0;
    var sum_diag_vp: f32 = 0.0;
    var sum_diag_pu: f32 = 0.0;
    var sum_diag_pv: f32 = 0.0;
    var sum_diag_pp: f32 = 0.0;
    var rhs_u: f32 = 0.0;
    var rhs_v: f32 = 0.0;
    var rhs_p: f32 = 0.0;
    var scalar_diag_p: f32 = 0.0;
    let u_n = vec2<f32>(state_old[idx * 8u + 0u], state_old[idx * 8u + 1u]);
    let rho = constants.density;
    var coeff_time = vol * rho / constants.dt;
    var rhs_time_u = coeff_time * u_n.x;
    var rhs_time_v = coeff_time * u_n.y;
    if (constants.time_scheme == 1u) {
        let dt = constants.dt;
        let dt_old = constants.dt_old;
        let r = dt / dt_old;
        let u_nm1 = vec2<f32>(state_old_old[idx * 8u + 0u], state_old_old[idx * 8u + 1u]);
        coeff_time = vol * rho / dt * (1.0 + 2.0 * r) / (1.0 + r);
        let factor_n = 1.0 + r;
        let factor_nm1 = r * r / (1.0 + r);
        rhs_time_u = vol * rho / dt * (factor_n * u_n.x - factor_nm1 * u_nm1.x);
        rhs_time_v = vol * rho / dt * (factor_n * u_n.y - factor_nm1 * u_nm1.y);
    }
    diag_u += coeff_time;
    diag_v += coeff_time;
    rhs_u += rhs_time_u;
    rhs_v += rhs_time_v;
    for (var k = start; k < end; k++) {
        let face_idx = cell_faces[k];
        let owner = face_owner[face_idx];
        let neigh_idx = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        var normal = face_normals[face_idx];
        let area = face_areas[face_idx];
        let f_center = face_centers[face_idx];
        var normal_sign: f32 = 1.0;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
            normal_sign = -1.0;
        }
        let flux = fluxes[face_idx] * normal_sign;
        var other_center: Vector2;
        var is_boundary = false;
        var other_idx = 0u;
        var d_p_neigh: f32 = 0.0;
        if (neigh_idx != -1) {
            other_idx = u32(neigh_idx);
            if (owner != idx) {
                other_idx = owner;
            }
            other_center = cell_centers[other_idx];
            d_p_neigh = state[other_idx * 8u + 3u];
        } else {
            is_boundary = true;
            other_idx = idx;
            other_center = f_center;
            d_p_neigh = state[idx * 8u + 3u];
        }
        let d_vec_x = other_center.x - center.x;
        let d_vec_y = other_center.y - center.y;
        let dist_proj = abs(d_vec_x * normal.x + d_vec_y * normal.y);
        let dist = max(dist_proj, 1e-6);
        let diff_coeff = codegen_diff_coeff(constants.viscosity, area, dist);
        let conv_coeff = codegen_conv_coeff(flux);
        let conv_coeff_diag = conv_coeff.x;
        let conv_coeff_off = conv_coeff.y;
        let scalar_mat_idx = cell_face_matrix_indices[k];
        var neighbor_rank = 0u;
        if (scalar_mat_idx != 4294967295u) {
            neighbor_rank = scalar_mat_idx - scalar_offset;
        } else {
            neighbor_rank = scalar_mat_idx - scalar_offset;
        }
        let idx_0_0 = start_row_0 + 3u * neighbor_rank + 0u;
        let idx_0_1 = start_row_0 + 3u * neighbor_rank + 1u;
        let idx_0_2 = start_row_0 + 3u * neighbor_rank + 2u;
        let idx_1_0 = start_row_1 + 3u * neighbor_rank + 0u;
        let idx_1_1 = start_row_1 + 3u * neighbor_rank + 1u;
        let idx_1_2 = start_row_1 + 3u * neighbor_rank + 2u;
        let idx_2_0 = start_row_2 + 3u * neighbor_rank + 0u;
        let idx_2_1 = start_row_2 + 3u * neighbor_rank + 1u;
        let idx_2_2 = start_row_2 + 3u * neighbor_rank + 2u;
        if (!is_boundary) {
            let coeff = -diff_coeff + conv_coeff_off;
            matrix_values[idx_0_0] = coeff;
            matrix_values[idx_0_1] = 0.0;
            matrix_values[idx_1_0] = 0.0;
            matrix_values[idx_1_1] = coeff;
            diag_u += diff_coeff + conv_coeff_diag;
            diag_v += diff_coeff + conv_coeff_diag;
            let scheme_id: u32 = 0u;
            if (scheme_id != 0u) {
                let u_own = vec2<f32>(state[idx * 8u + 0u], state[idx * 8u + 1u]);
                let u_neigh = vec2<f32>(state[other_idx * 8u + 0u], state[other_idx * 8u + 1u]);
                var phi_upwind_u = u_own.x;
                var phi_upwind_v = u_own.y;
                if (flux < 0.0) {
                    phi_upwind_u = u_neigh.x;
                    phi_upwind_v = u_neigh.y;
                }
                var phi_ho_u = phi_upwind_u;
                var phi_ho_v = phi_upwind_v;
                if (scheme_id == 1u) {
                    if (flux > 0.0) {
                        let grad_u_own = grad_u[idx];
                        let grad_v_own = grad_v[idx];
                        let r_x = f_center.x - center.x;
                        let r_y = f_center.y - center.y;
                        phi_ho_u = u_own.x + grad_u_own.x * r_x + grad_u_own.y * r_y;
                        phi_ho_v = u_own.y + grad_v_own.x * r_x + grad_v_own.y * r_y;
                    } else {
                        let grad_u_neigh = grad_u[other_idx];
                        let grad_v_neigh = grad_v[other_idx];
                        let r_x = f_center.x - other_center.x;
                        let r_y = f_center.y - other_center.y;
                        phi_ho_u = u_neigh.x + grad_u_neigh.x * r_x + grad_u_neigh.y * r_y;
                        phi_ho_v = u_neigh.y + grad_v_neigh.x * r_x + grad_v_neigh.y * r_y;
                    }
                } else {
                    if (scheme_id == 2u) {
                        if (flux > 0.0) {
                            let grad_u_own = grad_u[idx];
                            let grad_v_own = grad_v[idx];
                            let d_cd_x = other_center.x - center.x;
                            let d_cd_y = other_center.y - center.y;
                            let grad_term_u = grad_u_own.x * d_cd_x + grad_u_own.y * d_cd_y;
                            let grad_term_v = grad_v_own.x * d_cd_x + grad_v_own.y * d_cd_y;
                            phi_ho_u = 0.625 * u_own.x + 0.375 * u_neigh.x + 0.125 * grad_term_u;
                            phi_ho_v = 0.625 * u_own.y + 0.375 * u_neigh.y + 0.125 * grad_term_v;
                        } else {
                            let grad_u_neigh = grad_u[other_idx];
                            let grad_v_neigh = grad_v[other_idx];
                            let d_cd_x = center.x - other_center.x;
                            let d_cd_y = center.y - other_center.y;
                            let grad_term_u = grad_u_neigh.x * d_cd_x + grad_u_neigh.y * d_cd_y;
                            let grad_term_v = grad_v_neigh.x * d_cd_x + grad_v_neigh.y * d_cd_y;
                            phi_ho_u = 0.625 * u_neigh.x + 0.375 * u_own.x + 0.125 * grad_term_u;
                            phi_ho_v = 0.625 * u_neigh.y + 0.375 * u_own.y + 0.125 * grad_term_v;
                        }
                    }
                }
                let correction_u = flux * (phi_ho_u - phi_upwind_u);
                let correction_v = flux * (phi_ho_v - phi_upwind_v);
                rhs_u -= correction_u;
                rhs_v -= correction_v;
            }
            let d_own = distance(vec2<f32>(center.x, center.y), vec2<f32>(f_center.x, f_center.y));
            let d_neigh = distance(vec2<f32>(other_center.x, other_center.y), vec2<f32>(f_center.x, f_center.y));
            let total_dist = d_own + d_neigh;
            var lambda = 0.5;
            if (total_dist > 1e-6) {
                lambda = d_neigh / total_dist;
            }
            let pg_force_x = area * normal.x;
            let pg_force_y = area * normal.y;
            matrix_values[idx_0_2] = (1.0 - lambda) * pg_force_x;
            matrix_values[idx_1_2] = (1.0 - lambda) * pg_force_y;
            sum_diag_up += lambda * pg_force_x;
            sum_diag_vp += lambda * pg_force_y;
            let div_coeff_x = normal.x * area;
            let div_coeff_y = normal.y * area;
            matrix_values[idx_2_0] = (1.0 - lambda) * div_coeff_x;
            matrix_values[idx_2_1] = (1.0 - lambda) * div_coeff_y;
            sum_diag_pu += lambda * div_coeff_x;
            sum_diag_pv += lambda * div_coeff_y;
            let d_p_own = state[idx * 8u + 3u];
            let d_p_face = lambda * d_p_own + (1.0 - lambda) * d_p_neigh;
            let pressure_coeff_face = constants.density * (lambda * state[idx * 8u + 3u] + (1.0 - lambda) * state[other_idx * 8u + 3u]);
            let lapl_coeff = pressure_coeff_face * area / dist;
            matrix_values[idx_2_2] = -lapl_coeff;
            sum_diag_pp += lapl_coeff;
            let scalar_coeff = pressure_coeff_face * area / dist;
            if (scalar_mat_idx != 4294967295u) {
                scalar_matrix_values[scalar_mat_idx] = -scalar_coeff;
            }
            scalar_diag_p += scalar_coeff;
        } else {
            if (boundary_type == 1u) {
                let ramp = smoothstep(0.0, constants.ramp_time, constants.time);
                let u_bc_x = constants.inlet_velocity * ramp;
                let u_bc_y = 0.0;
                diag_u += diff_coeff;
                diag_v += diff_coeff;
                rhs_u += diff_coeff * u_bc_x;
                rhs_v += diff_coeff * u_bc_y;
                if (flux > 0.0) {
                    diag_u += flux;
                    diag_v += flux;
                } else {
                    rhs_u -= flux * u_bc_x;
                    rhs_v -= flux * u_bc_y;
                }
                let pg_force_x = area * normal.x;
                let pg_force_y = area * normal.y;
                sum_diag_up += pg_force_x;
                sum_diag_vp += pg_force_y;
                let flux_bc = (u_bc_x * normal.x + u_bc_y * normal.y) * area;
                rhs_p -= flux_bc;
            } else {
                if (boundary_type == 3u) {
                    diag_u += diff_coeff;
                    diag_v += diff_coeff;
                    let pg_force_x = area * normal.x;
                    let pg_force_y = area * normal.y;
                    sum_diag_up += pg_force_x;
                    sum_diag_vp += pg_force_y;
                } else {
                    if (boundary_type == 2u) {
                        if (flux > 0.0) {
                            diag_u += flux;
                            diag_v += flux;
                        }
                        let div_coeff_x = normal.x * area;
                        let div_coeff_y = normal.y * area;
                        sum_diag_pu += div_coeff_x;
                        sum_diag_pv += div_coeff_y;
                        let d_p_own = state[idx * 8u + 3u];
                        let pressure_coeff_cell = constants.density * state[idx * 8u + 3u];
                        let lapl_coeff = pressure_coeff_cell * area / dist;
                        sum_diag_pp += lapl_coeff;
                        let scalar_coeff = pressure_coeff_cell * area / dist;
                        scalar_diag_p += scalar_coeff;
                    }
                }
            }
        }
    }
    let scalar_diag_idx = diagonal_indices[idx];
    let diag_rank = scalar_diag_idx - scalar_offset;
    let d_0_0 = start_row_0 + 3u * diag_rank + 0u;
    let d_0_1 = start_row_0 + 3u * diag_rank + 1u;
    let d_0_2 = start_row_0 + 3u * diag_rank + 2u;
    let d_1_0 = start_row_1 + 3u * diag_rank + 0u;
    let d_1_1 = start_row_1 + 3u * diag_rank + 1u;
    let d_1_2 = start_row_1 + 3u * diag_rank + 2u;
    let d_2_0 = start_row_2 + 3u * diag_rank + 0u;
    let d_2_1 = start_row_2 + 3u * diag_rank + 1u;
    let d_2_2 = start_row_2 + 3u * diag_rank + 2u;
    matrix_values[d_0_0] = diag_u;
    matrix_values[d_0_1] = 0.0;
    matrix_values[d_0_2] = sum_diag_up;
    matrix_values[d_1_0] = 0.0;
    matrix_values[d_1_1] = diag_v;
    matrix_values[d_1_2] = sum_diag_vp;
    matrix_values[d_2_0] = sum_diag_pu;
    matrix_values[d_2_1] = sum_diag_pv;
    matrix_values[d_2_2] = diag_p + sum_diag_pp;
    rhs[3u * idx + 0u] = rhs_u;
    rhs[3u * idx + 1u] = rhs_v;
    rhs[3u * idx + 2u] = rhs_p;
    scalar_matrix_values[scalar_diag_idx] = scalar_diag_p;
    diag_u_inv[idx] = safe_inverse(diag_u);
    diag_v_inv[idx] = safe_inverse(diag_v);
    diag_p_inv[idx] = safe_inverse(scalar_diag_p);
}
