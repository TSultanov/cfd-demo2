// GENERATED BY CFD2 DSL FUSION (rhie_chow/dp_init_dp_update_store_grad_p_grad_p_update_correct_velocity_delta_fused)
// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}


@group(0) @binding(0) var<storage, read_write> state: array<f32>;
@group(0) @binding(1) var<uniform> constants: Constants;
@group(1) @binding(0) var<storage, read> face_owner: array<u32>;
@group(1) @binding(1) var<storage, read> face_neighbor: array<i32>;
@group(1) @binding(2) var<storage, read> face_areas: array<f32>;
@group(1) @binding(3) var<storage, read> face_normals: array<Vector2>;
@group(1) @binding(4) var<storage, read> cell_centers: array<Vector2>;
@group(1) @binding(5) var<storage, read> cell_vols: array<f32>;
@group(1) @binding(6) var<storage, read> cell_face_offsets: array<u32>;
@group(1) @binding(7) var<storage, read> cell_faces: array<u32>;
@group(1) @binding(12) var<storage, read> face_boundary: array<u32>;
@group(1) @binding(13) var<storage, read> face_centers: array<Vector2>;
@group(2) @binding(0) var<storage, read> bc_kind: array<u32>;
@group(2) @binding(1) var<storage, read> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= (arrayLength(&state) / 8u)) { return; }
    let base = idx * 8u;
    // synthesized by fusion rule: rhie_chow:dp_init_dp_update_store_grad_p_grad_p_update_correct_velocity_delta_v1
    // begin fused segment: dp_init
    state[base + 3u] = 0.0;
    // end fused segment: dp_init
    // begin fused segment: dp_update_from_diag
    let k1_rho = max(constants.density, 0.000000000001);
    let k1_dt = max(constants.dt, 0.0);
    let k1_d_p = constants.alpha_u * k1_dt / k1_rho;
    state[base + 3u] = k1_d_p;
    // end fused segment: dp_update_from_diag
    // begin fused segment: rhie_chow/store_grad_p
    state[base + 6u] = state[base + 4u];
    state[base + 7u] = state[base + 5u];
    // end fused segment: rhie_chow/store_grad_p
    // begin fused segment: rhie_chow/grad_p_update
    let k3_cell_center = cell_centers[idx];
    let k3_cell_center_vec: vec2<f32> = vec2<f32>(k3_cell_center.x, k3_cell_center.y);
    let k3_vol = cell_vols[idx];
    let k3_start = cell_face_offsets[idx];
    let k3_end = cell_face_offsets[idx + 1u];
    var k3_grad_acc_p: vec2<f32> = vec2<f32>(0.0, 0.0);
    for (var k3_k = k3_start; k3_k < k3_end; k3_k++) {
        let k3_face_idx = cell_faces[k3_k];
        let k3_owner = face_owner[k3_face_idx];
        let k3_neighbor_raw = face_neighbor[k3_face_idx];
        let k3_is_boundary = k3_neighbor_raw == -1;
        let k3_boundary_type = face_boundary[k3_face_idx];
        let k3_area = face_areas[k3_face_idx];
        let k3_face_center = face_centers[k3_face_idx];
        let k3_face_center_vec: vec2<f32> = vec2<f32>(k3_face_center.x, k3_face_center.y);
        var k3_normal_vec: vec2<f32> = vec2<f32>(face_normals[k3_face_idx].x, face_normals[k3_face_idx].y);
        if (dot(k3_face_center_vec - k3_cell_center_vec, k3_normal_vec) < 0.0) {
            k3_normal_vec = -k3_normal_vec;
        }
        var k3_other_idx: u32 = idx;
        var k3_other_center_vec: vec2<f32> = k3_face_center_vec;
        if (k3_neighbor_raw != -1) {
            let k3_neighbor = u32(k3_neighbor_raw);
            k3_other_idx = k3_neighbor;
            if (k3_owner != idx) {
                k3_other_idx = k3_owner;
            }
            let k3_other_center = cell_centers[k3_other_idx];
            k3_other_center_vec = vec2<f32>(k3_other_center.x, k3_other_center.y);
        }
        let k3_d_own = abs(dot(k3_face_center_vec - k3_cell_center_vec, k3_normal_vec));
        let k3_d_neigh = abs(dot(k3_other_center_vec - k3_face_center_vec, k3_normal_vec));
        let k3_total_dist = k3_d_own + k3_d_neigh;
        var k3_lambda: f32 = 0.5;
        if (k3_total_dist > 0.000001) {
            k3_lambda = k3_d_neigh / k3_total_dist;
        }
        let k3_lambda_other = 1.0 - k3_lambda;
        let k3__unused_boundary_type = k3_boundary_type;
        k3_grad_acc_p += k3_normal_vec * (state[base + 2u] * k3_lambda + select(state[k3_other_idx * 8u + 2u], select(select(state[base + 2u], bc_value[k3_face_idx * 3u + 2u], bc_kind[k3_face_idx * 3u + 2u] == 1u), state[base + 2u] + bc_value[k3_face_idx * 3u + 2u] * k3_d_own, bc_kind[k3_face_idx * 3u + 2u] == 2u), k3_is_boundary) * k3_lambda_other) * k3_area;
    }
    let k3_grad_out_p: vec2<f32> = k3_grad_acc_p / max(k3_vol, 0.000000000001);
    state[base + 4u] = k3_grad_out_p.x;
    state[base + 5u] = k3_grad_out_p.y;
    // end fused segment: rhie_chow/grad_p_update
    // begin fused segment: rhie_chow/correct_velocity_delta
    let k4_d_p = state[base + 3u];
    let k4_grad_px = state[base + 4u];
    let k4_grad_py = state[base + 5u];
    let k4_grad_old_x = state[base + 6u];
    let k4_grad_old_y = state[base + 7u];
    let k4_corr_x = k4_d_p * (k4_grad_px - k4_grad_old_x);
    let k4_corr_y = k4_d_p * (k4_grad_py - k4_grad_old_y);
    state[base + 0u] = state[base + 0u] - k4_corr_x;
    state[base + 1u] = state[base + 1u] - k4_corr_y;
    // end fused segment: rhie_chow/correct_velocity_delta
}
