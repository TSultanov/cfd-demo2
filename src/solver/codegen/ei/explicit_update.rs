use super::super::state_access::state_component;
use super::super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StructDef, StructField, Type,
};
use super::super::wgsl_dsl as dsl;
use crate::solver::ir::StateLayout;
use crate::solver::model::FluxLayout;

pub fn generate_ei_explicit_update_wgsl(layout: &StateLayout, flux_layout: &FluxLayout) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (ei_explicit_update)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, flux_layout)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Struct(low_mach_params_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment(
        "Group 1: Fields (consolidated state buffers)".to_string(),
    ));
    items.extend(state_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
        ],
    )
}

fn low_mach_params_struct() -> StructDef {
    StructDef::new(
        "LowMachParams",
        vec![
            StructField::new("model", Type::U32),
            StructField::new("theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
            StructField::new("_pad0", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var("face_owner", Type::array(Type::U32), 0, 0, AccessMode::Read),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var("face_areas", Type::array(Type::F32), 0, 2, AccessMode::Read),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var("cell_vols", Type::array(Type::F32), 0, 5, AccessMode::Read),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var("cell_faces", Type::array(Type::U32), 0, 7, AccessMode::Read),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var("state", Type::array(Type::F32), 1, 0, AccessMode::ReadWrite),
        storage_var("state_old", Type::array(Type::F32), 1, 1, AccessMode::Read),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var("state_iter", Type::array(Type::F32), 1, 9, AccessMode::Read),
        uniform_var("low_mach", Type::Custom("LowMachParams".to_string()), 1, 10),
    ]
}

fn storage_var(name: &str, ty: Type, group: u32, binding: u32, access: AccessMode) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, flux_layout: &FluxLayout) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, flux_layout),
    )
}

fn main_body(layout: &StateLayout, flux_layout: &FluxLayout) -> Block {
    let mut stmts = Vec::new();

    let rho = "rho";
    let rho_u = "rho_u";
    let rho_e = "rho_e";
    let flux_stride = flux_layout.stride;
    let off_rho = flux_layout
        .offset_for(rho)
        .unwrap_or_else(|| panic!("missing flux component {rho}"));
    let off_rho_u_x = flux_layout
        .offset_for(&format!("{rho_u}_x"))
        .unwrap_or_else(|| panic!("missing flux component {rho_u}_x"));
    let off_rho_u_y = flux_layout
        .offset_for(&format!("{rho_u}_y"))
        .unwrap_or_else(|| panic!("missing flux component {rho_u}_y"));
    let off_rho_e = flux_layout
        .offset_for(rho_e)
        .unwrap_or_else(|| panic!("missing flux component {rho_e}"));

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));

    let vol = dsl::max(Expr::ident("cell_vols").index("idx"), 1e-12);
    stmts.push(dsl::let_expr("vol", vol));
    stmts.push(dsl::let_expr(
        "start",
        Expr::ident("cell_face_offsets").index("idx"),
    ));
    stmts.push(dsl::let_expr(
        "end",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx") + 1u32),
    ));

    let rho0 = state_component(layout, "state_old", "idx", rho, 0);
    let rho_u0_x = state_component(layout, "state_old", "idx", rho_u, 0);
    let rho_u0_y = state_component(layout, "state_old", "idx", rho_u, 1);
    let rho_e0 = state_component(layout, "state_old", "idx", rho_e, 0);

    stmts.push(dsl::let_expr("rho0", rho0));
    stmts.push(dsl::let_expr("rho_u0_x", rho_u0_x));
    stmts.push(dsl::let_expr("rho_u0_y", rho_u0_y));
    stmts.push(dsl::let_expr("rho_e0", rho_e0));

    stmts.push(dsl::var_expr("sum_rho", 0.0));
    stmts.push(dsl::var_expr("sum_rho_u_x", 0.0));
    stmts.push(dsl::var_expr("sum_rho_u_y", 0.0));
    stmts.push(dsl::var_expr("sum_rho_e", 0.0));

    let loop_body = {
        let mut loop_stmts = Vec::new();
        loop_stmts.push(dsl::let_expr(
            "face_idx",
            Expr::ident("cell_faces").index("face_offset"),
        ));
        loop_stmts.push(dsl::let_expr(
            "owner",
            Expr::ident("face_owner").index("face_idx"),
        ));
        loop_stmts.push(dsl::let_expr(
            "sign",
            dsl::select(-1.0, 1.0, Expr::ident("owner").eq("idx")),
        ));
        loop_stmts.push(dsl::let_expr("base", Expr::ident("face_idx") * flux_stride));
        loop_stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("sum_rho"),
            Expr::ident("sign") * Expr::ident("fluxes").index(Expr::ident("base") + off_rho),
        ));
        loop_stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("sum_rho_u_x"),
            Expr::ident("sign")
                * Expr::ident("fluxes").index(Expr::ident("base") + off_rho_u_x),
        ));
        loop_stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("sum_rho_u_y"),
            Expr::ident("sign")
                * Expr::ident("fluxes").index(Expr::ident("base") + off_rho_u_y),
        ));
        loop_stmts.push(dsl::assign_op_expr(
            AssignOp::Add,
            Expr::ident("sum_rho_e"),
            Expr::ident("sign") * Expr::ident("fluxes").index(Expr::ident("base") + off_rho_e),
        ));
        dsl::block(loop_stmts)
    };

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("face_offset", Expr::ident("start")),
        Expr::ident("face_offset").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("face_offset")),
        loop_body,
    ));

    stmts.push(dsl::let_expr(
        "factor",
        Expr::ident("constants").field("dt") / Expr::ident("vol"),
    ));

    stmts.push(dsl::assign_expr(
        state_component(layout, "state", "idx", rho, 0),
        Expr::ident("rho0") - Expr::ident("factor") * Expr::ident("sum_rho"),
    ));
    stmts.push(dsl::assign_expr(
        state_component(layout, "state", "idx", rho_u, 0),
        Expr::ident("rho_u0_x") - Expr::ident("factor") * Expr::ident("sum_rho_u_x"),
    ));
    stmts.push(dsl::assign_expr(
        state_component(layout, "state", "idx", rho_u, 1),
        Expr::ident("rho_u0_y") - Expr::ident("factor") * Expr::ident("sum_rho_u_y"),
    ));
    stmts.push(dsl::assign_expr(
        state_component(layout, "state", "idx", rho_e, 0),
        Expr::ident("rho_e0") - Expr::ident("factor") * Expr::ident("sum_rho_e"),
    ));

    Block::new(stmts)
}
