// GENERATED BY CFD2 CODEGEN (compressible_apply)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
}

// Group 0: Fields (consolidated state buffers)

@group(0) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(0) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(0) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(0) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(0) @binding(4) 
var<uniform> constants: Constants;

@group(0) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(0) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(0) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(0) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@group(0) @binding(9) 
var<storage, read> state_iter: array<f32>;

// Group 1: Solver

@group(1) @binding(0) 
var<storage, read> solution: array<f32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    let stride = 7u;
    let num_cells = arrayLength(&state);
    if (idx * stride >= num_cells) {
        return;
    }
    let rho_base = state[idx * 7u + 0u];
    let rho_u_base = vec2<f32>(state[idx * 7u + 1u], state[idx * 7u + 2u]);
    let rho_e_base = state[idx * 7u + 3u];
    let base = idx * 4u;
    let delta_rho = solution[base + 0u];
    let delta_rho_u_x = solution[base + 1u];
    let delta_rho_u_y = solution[base + 2u];
    let delta_rho_e = solution[base + 3u];
    let relax = constants.alpha_u;
    var rho_new = rho_base + relax * delta_rho;
    var rho_u_new_x = rho_u_base.x + relax * delta_rho_u_x;
    var rho_u_new_y = rho_u_base.y + relax * delta_rho_u_y;
    var rho_e_new = rho_e_base + relax * delta_rho_e;
    state[idx * 7u + 0u] = rho_new;
    state[idx * 7u + 1u] = rho_u_new_x;
    state[idx * 7u + 2u] = rho_u_new_y;
    state[idx * 7u + 3u] = rho_e_new;
}
