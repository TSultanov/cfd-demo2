// GENERATED BY CFD2 DSL FUSION (rhie_chow/dp_update_store_grad_p_grad_p_update_correct_velocity_delta_fused)
// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
}


@group(0) @binding(0) var<storage, read_write> state: array<f32>;
@group(0) @binding(1) var<uniform> constants: Constants;
@group(1) @binding(0) var<storage, read> face_owner: array<u32>;
@group(1) @binding(1) var<storage, read> face_neighbor: array<i32>;
@group(1) @binding(2) var<storage, read> face_areas: array<f32>;
@group(1) @binding(3) var<storage, read> face_normals: array<Vector2>;
@group(1) @binding(4) var<storage, read> cell_centers: array<Vector2>;
@group(1) @binding(5) var<storage, read> cell_vols: array<f32>;
@group(1) @binding(6) var<storage, read> cell_face_offsets: array<u32>;
@group(1) @binding(7) var<storage, read> cell_faces: array<u32>;
@group(1) @binding(12) var<storage, read> face_boundary: array<u32>;
@group(1) @binding(13) var<storage, read> face_centers: array<Vector2>;
@group(2) @binding(0) var<storage, read> bc_kind: array<u32>;
@group(2) @binding(1) var<storage, read> bc_value: array<f32>;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= (arrayLength(&state) / max(8u, 1u))) { return; }
    let base = idx * 8u;
    // synthesized by fusion rule: rhie_chow:dp_update_store_grad_p_grad_p_update_correct_velocity_delta_v1
    // begin fused segment: dp_update_from_diag
    let rho = max(constants.density, 0.000000000001);
    let dt = max(constants.dt, 0.0);
    let d_p = constants.alpha_u * dt / rho;
    state[base + 3u] = d_p;
    // end fused segment: dp_update_from_diag
    // begin fused segment: rhie_chow/store_grad_p
    state[base + 6u] = state[base + 4u];
    state[base + 7u] = state[base + 5u];
    // end fused segment: rhie_chow/store_grad_p
    // begin fused segment: rhie_chow/grad_p_update
    let k2_cell_center = cell_centers[idx];
    let k2_cell_center_vec: vec2<f32> = vec2<f32>(k2_cell_center.x, k2_cell_center.y);
    let k2_vol = cell_vols[idx];
    let k2_start = cell_face_offsets[idx];
    let k2_end = cell_face_offsets[idx + 1u];
    var k2_grad_acc_p: vec2<f32> = vec2<f32>(0.0, 0.0);
    for (var k2_k = k2_start; k2_k < k2_end; k2_k++) {
        let k2_face_idx = cell_faces[k2_k];
        let k2_owner = face_owner[k2_face_idx];
        let k2_neighbor_raw = face_neighbor[k2_face_idx];
        let k2_is_boundary = k2_neighbor_raw == -1;
        let k2_boundary_type = face_boundary[k2_face_idx];
        let k2_area = face_areas[k2_face_idx];
        let k2_face_center = face_centers[k2_face_idx];
        let k2_face_center_vec: vec2<f32> = vec2<f32>(k2_face_center.x, k2_face_center.y);
        var k2_normal_vec: vec2<f32> = vec2<f32>(face_normals[k2_face_idx].x, face_normals[k2_face_idx].y);
        if (dot(k2_face_center_vec - k2_cell_center_vec, k2_normal_vec) < 0.0) {
            k2_normal_vec = -k2_normal_vec;
        }
        var k2_other_idx: u32 = idx;
        var k2_other_center_vec: vec2<f32> = k2_face_center_vec;
        if (k2_neighbor_raw != -1) {
            let k2_neighbor = u32(k2_neighbor_raw);
            k2_other_idx = k2_neighbor;
            if (k2_owner != idx) {
                k2_other_idx = k2_owner;
            }
            let k2_other_center = cell_centers[k2_other_idx];
            k2_other_center_vec = vec2<f32>(k2_other_center.x, k2_other_center.y);
        }
        let k2_d_own = abs(dot(k2_face_center_vec - k2_cell_center_vec, k2_normal_vec));
        let k2_d_neigh = abs(dot(k2_other_center_vec - k2_face_center_vec, k2_normal_vec));
        let k2_total_dist = k2_d_own + k2_d_neigh;
        var k2_lambda: f32 = 0.5;
        if (k2_total_dist > 0.000001) {
            k2_lambda = k2_d_neigh / k2_total_dist;
        }
        let k2_lambda_other = 1.0 - k2_lambda;
        let k2__unused_boundary_type = k2_boundary_type;
        k2_grad_acc_p += k2_normal_vec * (state[base + 2u] * k2_lambda + select(state[k2_other_idx * 8u + 2u], select(select(state[base + 2u], bc_value[k2_face_idx * 3u + 2u], bc_kind[k2_face_idx * 3u + 2u] == 1u), state[base + 2u] + bc_value[k2_face_idx * 3u + 2u] * k2_d_own, bc_kind[k2_face_idx * 3u + 2u] == 2u), k2_is_boundary) * k2_lambda_other) * k2_area;
    }
    let k2_grad_out_p: vec2<f32> = k2_grad_acc_p / max(k2_vol, 0.000000000001);
    state[base + 4u] = k2_grad_out_p.x;
    state[base + 5u] = k2_grad_out_p.y;
    // end fused segment: rhie_chow/grad_p_update
    // begin fused segment: rhie_chow/correct_velocity_delta
    let k3_d_p = state[base + 3u];
    let k3_grad_px = state[base + 4u];
    let k3_grad_py = state[base + 5u];
    let k3_grad_old_x = state[base + 6u];
    let k3_grad_old_y = state[base + 7u];
    let k3_corr_x = k3_d_p * (k3_grad_px - k3_grad_old_x);
    let k3_corr_y = k3_d_p * (k3_grad_py - k3_grad_old_y);
    state[base + 0u] = state[base + 0u] - k3_corr_x;
    state[base + 1u] = state[base + 1u] - k3_corr_y;
    // end fused segment: rhie_chow/correct_velocity_delta
}
