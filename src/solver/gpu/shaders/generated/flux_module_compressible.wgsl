// GENERATED BY CFD2 CODEGEN (flux_module)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    var neigh_idx: u32 = owner;
    if (neighbor != -1) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    let c_owner = cell_centers[owner];
    let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    if (dot(face_center_vec - c_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    let c_neigh = cell_centers[neigh_idx];
    let c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
    let d_own = distance(c_owner_vec, face_center_vec);
    let d_neigh = distance(c_neigh_vec, face_center_vec);
    let total_dist = d_own + d_neigh;
    var lambda: f32 = 0.5;
    if (total_dist > 0.000001) {
        lambda = d_neigh / total_dist;
    }
    let lambda_other = 1.0 - lambda;
    let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
    let dist_proj = abs(dot(d_vec, normal_vec));
    let dist = max(dist_proj, 0.000001);
    let a_plus = max(0.0, max(dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]) * 1.0 / state[owner * 7u + 0u], normal_vec) + sqrt(1.4 * 0.39999998 * (state[owner * 7u + 3u] - 0.5 * (state[owner * 7u + 1u] * state[owner * 7u + 1u] + state[owner * 7u + 2u] * state[owner * 7u + 2u]) / state[owner * 7u + 0u]) / state[owner * 7u + 0u]), dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]) * 1.0 / state[neigh_idx * 7u + 0u], normal_vec) + sqrt(1.4 * 0.39999998 * (state[neigh_idx * 7u + 3u] - 0.5 * (state[neigh_idx * 7u + 1u] * state[neigh_idx * 7u + 1u] + state[neigh_idx * 7u + 2u] * state[neigh_idx * 7u + 2u]) / state[neigh_idx * 7u + 0u]) / state[neigh_idx * 7u + 0u])));
    let a_minus = min(0.0, min(dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]) * 1.0 / state[owner * 7u + 0u], normal_vec) - sqrt(1.4 * 0.39999998 * (state[owner * 7u + 3u] - 0.5 * (state[owner * 7u + 1u] * state[owner * 7u + 1u] + state[owner * 7u + 2u] * state[owner * 7u + 2u]) / state[owner * 7u + 0u]) / state[owner * 7u + 0u]), dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]) * 1.0 / state[neigh_idx * 7u + 0u], normal_vec) - sqrt(1.4 * 0.39999998 * (state[neigh_idx * 7u + 3u] - 0.5 * (state[neigh_idx * 7u + 1u] * state[neigh_idx * 7u + 1u] + state[neigh_idx * 7u + 2u] * state[neigh_idx * 7u + 2u]) / state[neigh_idx * 7u + 0u]) / state[neigh_idx * 7u + 0u])));
    let denom = max(a_plus - a_minus, 0.000001);
    fluxes[idx * 4u + 0u] = (a_plus * state[owner * 7u + 0u] * dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]) * 1.0 / state[owner * 7u + 0u], normal_vec) - a_minus * state[neigh_idx * 7u + 0u] * dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]) * 1.0 / state[neigh_idx * 7u + 0u], normal_vec) + a_plus * a_minus * (state[neigh_idx * 7u + 0u] - state[owner * 7u + 0u])) / denom * area;
    fluxes[idx * 4u + 1u] = (a_plus * (dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]), vec2<f32>(1.0, 0.0)) * dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]) * 1.0 / state[owner * 7u + 0u], normal_vec) + 0.39999998 * (state[owner * 7u + 3u] - 0.5 * (state[owner * 7u + 1u] * state[owner * 7u + 1u] + state[owner * 7u + 2u] * state[owner * 7u + 2u]) / state[owner * 7u + 0u]) * dot(normal_vec, vec2<f32>(1.0, 0.0))) - a_minus * (dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]), vec2<f32>(1.0, 0.0)) * dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]) * 1.0 / state[neigh_idx * 7u + 0u], normal_vec) + 0.39999998 * (state[neigh_idx * 7u + 3u] - 0.5 * (state[neigh_idx * 7u + 1u] * state[neigh_idx * 7u + 1u] + state[neigh_idx * 7u + 2u] * state[neigh_idx * 7u + 2u]) / state[neigh_idx * 7u + 0u]) * dot(normal_vec, vec2<f32>(1.0, 0.0))) + a_plus * a_minus * (dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]), vec2<f32>(1.0, 0.0)) - dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]), vec2<f32>(1.0, 0.0)))) / denom * area;
    fluxes[idx * 4u + 2u] = (a_plus * (dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]), vec2<f32>(0.0, 1.0)) * dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]) * 1.0 / state[owner * 7u + 0u], normal_vec) + 0.39999998 * (state[owner * 7u + 3u] - 0.5 * (state[owner * 7u + 1u] * state[owner * 7u + 1u] + state[owner * 7u + 2u] * state[owner * 7u + 2u]) / state[owner * 7u + 0u]) * dot(normal_vec, vec2<f32>(0.0, 1.0))) - a_minus * (dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]), vec2<f32>(0.0, 1.0)) * dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]) * 1.0 / state[neigh_idx * 7u + 0u], normal_vec) + 0.39999998 * (state[neigh_idx * 7u + 3u] - 0.5 * (state[neigh_idx * 7u + 1u] * state[neigh_idx * 7u + 1u] + state[neigh_idx * 7u + 2u] * state[neigh_idx * 7u + 2u]) / state[neigh_idx * 7u + 0u]) * dot(normal_vec, vec2<f32>(0.0, 1.0))) + a_plus * a_minus * (dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]), vec2<f32>(0.0, 1.0)) - dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]), vec2<f32>(0.0, 1.0)))) / denom * area;
    fluxes[idx * 4u + 3u] = (a_plus * (state[owner * 7u + 3u] + 0.39999998 * (state[owner * 7u + 3u] - 0.5 * (state[owner * 7u + 1u] * state[owner * 7u + 1u] + state[owner * 7u + 2u] * state[owner * 7u + 2u]) / state[owner * 7u + 0u])) * dot(vec2<f32>(state[owner * 7u + 1u], state[owner * 7u + 2u]) * 1.0 / state[owner * 7u + 0u], normal_vec) - a_minus * (state[neigh_idx * 7u + 3u] + 0.39999998 * (state[neigh_idx * 7u + 3u] - 0.5 * (state[neigh_idx * 7u + 1u] * state[neigh_idx * 7u + 1u] + state[neigh_idx * 7u + 2u] * state[neigh_idx * 7u + 2u]) / state[neigh_idx * 7u + 0u])) * dot(vec2<f32>(state[neigh_idx * 7u + 1u], state[neigh_idx * 7u + 2u]) * 1.0 / state[neigh_idx * 7u + 0u], normal_vec) + a_plus * a_minus * (state[neigh_idx * 7u + 3u] - state[owner * 7u + 3u])) / denom * area;
}
