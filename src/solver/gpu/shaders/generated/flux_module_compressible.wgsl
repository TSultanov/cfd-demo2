// GENERATED BY CFD2 CODEGEN (flux_module)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;

// Group 2: Boundary conditions (per face x unknown)

@group(2) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(2) @binding(1) 
var<storage, read> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32 = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = owner + value * d_own;
    }
    return select(interior, boundary, is_boundary);
}

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = neighbor == -1;
    var neigh_idx: u32 = owner;
    if (neighbor != -1) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    let c_owner = cell_centers[owner];
    let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    if (dot(face_center_vec - c_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    let c_neigh = cell_centers[neigh_idx];
    var c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec: vec2<f32> = c_neigh_vec;
    if (is_boundary) {
        c_neigh_vec = face_center_vec;
    }
    let d_own = abs(dot(face_center_vec - c_owner_vec, normal_vec));
    let d_neigh = abs(dot(c_neigh_vec - face_center_vec, normal_vec));
    let total_dist = d_own + d_neigh;
    var lambda: f32 = 0.5;
    if (total_dist > 0.000001) {
        lambda = d_neigh / total_dist;
    }
    let lambda_other = 1.0 - lambda;
    let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
    let dist_proj = abs(dot(d_vec, normal_vec));
    let dist = max(dist_proj, 0.000001);
    let s_own_T = bc_neighbor_scalar(state[owner * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_own_grad_T_x = state[owner * 22u + 16u];
    let s_own_grad_T_y = state[owner * 22u + 17u];
    let s_own_grad_rho_x = state[owner * 22u + 12u];
    let s_own_grad_rho_y = state[owner * 22u + 13u];
    let s_own_grad_rho_u_x_x = state[owner * 22u + 3u];
    let s_own_grad_rho_u_x_y = state[owner * 22u + 4u];
    let s_own_grad_rho_u_y_x = state[owner * 22u + 5u];
    let s_own_grad_rho_u_y_y = state[owner * 22u + 6u];
    let s_own_grad_u_x_x = state[owner * 22u + 18u];
    let s_own_grad_u_x_y = state[owner * 22u + 19u];
    let s_own_grad_u_y_x = state[owner * 22u + 20u];
    let s_own_grad_u_y_y = state[owner * 22u + 21u];
    let s_own_rho = bc_neighbor_scalar(state[owner * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_own_rho_u_x = select(bc_neighbor_scalar(state[owner * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_own_rho_u_y = select(bc_neighbor_scalar(state[owner * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let s_own_u_x = select(bc_neighbor_scalar(state[owner * 22u + 10u], state[owner * 22u + 10u], bc_kind[idx * 8u + 4u], bc_value[idx * 8u + 4u], d_own, is_boundary), state[owner * 22u + 10u] - (state[owner * 22u + 10u] * normal_vec.x + state[owner * 22u + 11u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_own_u_y = select(bc_neighbor_scalar(state[owner * 22u + 11u], state[owner * 22u + 11u], bc_kind[idx * 8u + 5u], bc_value[idx * 8u + 5u], d_own, is_boundary), state[owner * 22u + 11u] - (state[owner * 22u + 10u] * normal_vec.x + state[owner * 22u + 11u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let s_neigh_T = bc_neighbor_scalar(state[neigh_idx * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_neigh_grad_T_x = select(state[neigh_idx * 22u + 16u], state[owner * 22u + 16u], is_boundary);
    let s_neigh_grad_T_y = select(state[neigh_idx * 22u + 17u], state[owner * 22u + 17u], is_boundary);
    let s_neigh_grad_rho_x = select(state[neigh_idx * 22u + 12u], state[owner * 22u + 12u], is_boundary);
    let s_neigh_grad_rho_y = select(state[neigh_idx * 22u + 13u], state[owner * 22u + 13u], is_boundary);
    let s_neigh_grad_rho_u_x_x = select(state[neigh_idx * 22u + 3u], state[owner * 22u + 3u], is_boundary);
    let s_neigh_grad_rho_u_x_y = select(state[neigh_idx * 22u + 4u], state[owner * 22u + 4u], is_boundary);
    let s_neigh_grad_rho_u_y_x = select(state[neigh_idx * 22u + 5u], state[owner * 22u + 5u], is_boundary);
    let s_neigh_grad_rho_u_y_y = select(state[neigh_idx * 22u + 6u], state[owner * 22u + 6u], is_boundary);
    let s_neigh_grad_u_x_x = select(state[neigh_idx * 22u + 18u], state[owner * 22u + 18u], is_boundary);
    let s_neigh_grad_u_x_y = select(state[neigh_idx * 22u + 19u], state[owner * 22u + 19u], is_boundary);
    let s_neigh_grad_u_y_x = select(state[neigh_idx * 22u + 20u], state[owner * 22u + 20u], is_boundary);
    let s_neigh_grad_u_y_y = select(state[neigh_idx * 22u + 21u], state[owner * 22u + 21u], is_boundary);
    let s_neigh_rho = bc_neighbor_scalar(state[neigh_idx * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_neigh_rho_u_x = select(bc_neighbor_scalar(state[neigh_idx * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_neigh_rho_u_y = select(bc_neighbor_scalar(state[neigh_idx * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let _cse_5 = s_own_rho_u_x;
    let _cse_6 = s_own_rho_u_y;
    let _cse_4 = vec2<f32>(_cse_5, _cse_6);
    let _cse_3 = _cse_4 * 1.0 / s_own_rho;
    let _cse_2 = dot(_cse_3, normal_vec * area);
    let _cse_21 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_20 = constants.eos_gamma * _cse_21;
    let _cse_19 = _cse_20 / s_own_rho;
    let _cse_18 = _cse_19 + constants.eos_dp_drho;
    let _cse_17 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_18;
    let _cse_25 = dot(_cse_3, normal_vec);
    let _cse_24 = _cse_25 * _cse_25;
    let _cse_23 = min(_cse_24, _cse_18);
    let _cse_22 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_23;
    let _cse_16 = _cse_17 + _cse_22;
    let _cse_28 = max(_cse_24, low_mach_params.theta_floor * _cse_18);
    let _cse_27 = min(_cse_28, _cse_18);
    let _cse_26 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_27;
    let _cse_15 = _cse_16 + _cse_26;
    let _cse_14 = _cse_15 / max(_cse_18, 0.000000000001);
    let _cse_13 = sqrt(_cse_14);
    let _cse_12 = sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * _cse_13;
    let _cse_11 = _cse_12 * area;
    let _cse_10 = _cse_2 + _cse_11;
    let _cse_33 = s_neigh_rho_u_x;
    let _cse_34 = s_neigh_rho_u_y;
    let _cse_32 = vec2<f32>(_cse_33, _cse_34);
    let _cse_31 = _cse_32 * 1.0 / s_neigh_rho;
    let _cse_30 = dot(_cse_31, normal_vec * area);
    let _cse_45 = s_neigh_rho * constants.eos_r * s_neigh_T;
    let _cse_44 = constants.eos_gamma * _cse_45;
    let _cse_43 = _cse_44 / s_neigh_rho;
    let _cse_42 = _cse_43 + constants.eos_dp_drho;
    let _cse_41 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_42;
    let _cse_49 = dot(_cse_31, normal_vec);
    let _cse_48 = _cse_49 * _cse_49;
    let _cse_47 = min(_cse_48, _cse_42);
    let _cse_46 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_47;
    let _cse_40 = _cse_41 + _cse_46;
    let _cse_52 = max(_cse_48, low_mach_params.theta_floor * _cse_42);
    let _cse_51 = min(_cse_52, _cse_42);
    let _cse_50 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_51;
    let _cse_39 = _cse_40 + _cse_50;
    let _cse_38 = _cse_39 / max(_cse_42, 0.000000000001);
    let _cse_37 = sqrt(_cse_38);
    let _cse_36 = sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * _cse_37;
    let _cse_35 = _cse_36 * area;
    let _cse_29 = _cse_30 + _cse_35;
    let _cse_9 = max(_cse_10, _cse_29);
    let _cse_8 = max(_cse_9, 0.0);
    let _cse_57 = _cse_2 - _cse_11;
    let _cse_58 = _cse_30 - _cse_35;
    let _cse_56 = min(_cse_57, _cse_58);
    let _cse_55 = min(_cse_56, 0.0);
    let _cse_54 = _cse_8 - _cse_55;
    let _cse_53 = max(_cse_54, 0.000001);
    let _cse_7 = _cse_8 / _cse_53;
    let _cse_1 = _cse_2 * _cse_7;
    let _cse_59 = _cse_55 * _cse_7;
    let _cse_0 = _cse_1 - _cse_59;
    let _cse_62 = 1.0 - _cse_7;
    let _cse_61 = _cse_30 * _cse_62;
    let _cse_60 = _cse_61 + _cse_59;
    let _cse_63 = _cse_7 * _cse_21 + _cse_62 * _cse_45;
    var phi_0: f32 = _cse_0 * s_own_rho + low_mach_params.pressure_coupling_alpha * (_cse_21 - _cse_45) / max(_cse_18, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_60 * s_neigh_rho + low_mach_params.pressure_coupling_alpha * (_cse_21 - _cse_45) / max(_cse_42, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
    var phi_1: f32 = _cse_0 * _cse_4.x + _cse_60 * _cse_32.x + _cse_63 * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
    var phi_2: f32 = _cse_0 * _cse_4.y + _cse_60 * _cse_32.y + _cse_63 * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
    var phi_3: f32 = _cse_0 * (_cse_21 / max(constants.eos_gm1, 0.000000000001) + 0.5 * s_own_rho * dot(_cse_3, _cse_3) + _cse_21) + _cse_60 * (_cse_45 / max(constants.eos_gm1, 0.000000000001) + 0.5 * s_neigh_rho * dot(_cse_31, _cse_31) + _cse_45) + _cse_59 * (_cse_21 - _cse_45) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_3 * _cse_7 + _cse_31 * _cse_62) * area;
    var phi_4: f32 = 0.0;
    var phi_5: f32 = 0.0;
    var phi_6: f32 = 0.0;
    var phi_7: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_67 = vec2<f32>(s_own_rho_u_x + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), s_own_rho_u_y + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec));
        let _cse_69 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_68 = s_own_rho + _cse_69;
        let _cse_66 = _cse_67 * 1.0 / _cse_68;
        let _cse_83 = _cse_68 * constants.eos_r * (s_own_T + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec));
        let _cse_82 = constants.eos_gamma * _cse_83;
        let _cse_81 = _cse_82 / _cse_68;
        let _cse_80 = _cse_81 + constants.eos_dp_drho;
        let _cse_87 = dot(_cse_66, normal_vec);
        let _cse_86 = _cse_87 * _cse_87;
        let _cse_85 = min(_cse_86, _cse_80);
        let _cse_84 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_85;
        let _cse_79 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_80 + _cse_84;
        let _cse_90 = max(_cse_86, low_mach_params.theta_floor * _cse_80);
        let _cse_89 = min(_cse_90, _cse_80);
        let _cse_88 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_89;
        let _cse_78 = _cse_79 + _cse_88;
        let _cse_77 = _cse_78 / max(_cse_80, 0.000000000001);
        let _cse_76 = sqrt(_cse_77);
        let _cse_75 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), face_center_vec - c_owner_vec)) * _cse_76;
        let _cse_74 = _cse_75 * area;
        let _cse_73 = dot(_cse_66, normal_vec * area) + _cse_74;
        let _cse_94 = s_neigh_rho_u_x + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_95 = s_neigh_rho_u_y + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_93 = vec2<f32>(_cse_94, _cse_95);
        let _cse_98 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_97 = dot(_cse_98, face_center_vec - c_neigh_cell_vec);
        let _cse_96 = s_neigh_rho + _cse_97;
        let _cse_92 = _cse_93 * 1.0 / _cse_96;
        let _cse_109 = _cse_96 * constants.eos_r;
        let _cse_108 = _cse_109 * (s_neigh_T + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec));
        let _cse_107 = constants.eos_gamma * _cse_108;
        let _cse_106 = _cse_107 / _cse_96;
        let _cse_105 = _cse_106 + constants.eos_dp_drho;
        let _cse_113 = dot(_cse_92, normal_vec);
        let _cse_112 = _cse_113 * _cse_113;
        let _cse_111 = min(_cse_112, _cse_105);
        let _cse_110 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_111;
        let _cse_104 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_105 + _cse_110;
        let _cse_116 = max(_cse_112, low_mach_params.theta_floor * _cse_105);
        let _cse_115 = min(_cse_116, _cse_105);
        let _cse_114 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_115;
        let _cse_103 = _cse_104 + _cse_114;
        let _cse_102 = _cse_103 / max(_cse_105, 0.000000000001);
        let _cse_101 = sqrt(_cse_102);
        let _cse_100 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), face_center_vec - c_neigh_cell_vec)) * _cse_101;
        let _cse_99 = _cse_100 * area;
        let _cse_91 = dot(_cse_92, normal_vec * area) + _cse_99;
        let _cse_72 = max(_cse_73, _cse_91);
        let _cse_71 = max(_cse_72, 0.0);
        let _cse_121 = dot(_cse_66, normal_vec * area) - _cse_74;
        let _cse_122 = dot(_cse_92, normal_vec * area) - _cse_99;
        let _cse_120 = min(_cse_121, _cse_122);
        let _cse_119 = min(_cse_120, 0.0);
        let _cse_118 = _cse_71 - _cse_119;
        let _cse_117 = max(_cse_118, 0.000001);
        let _cse_70 = _cse_71 / _cse_117;
        let _cse_65 = dot(_cse_66, normal_vec * area) * _cse_70;
        let _cse_123 = _cse_119 * _cse_70;
        let _cse_64 = _cse_65 - _cse_123;
        let _cse_126 = 1.0 - _cse_70;
        let _cse_125 = dot(_cse_92, normal_vec * area) * _cse_126;
        let _cse_124 = _cse_125 + _cse_123;
        let _cse_127 = _cse_70 * _cse_83 + _cse_126 * _cse_108;
        phi_0 = _cse_64 * _cse_68 + low_mach_params.pressure_coupling_alpha * (_cse_83 - _cse_108) / max(_cse_80, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_124 * _cse_96 + low_mach_params.pressure_coupling_alpha * (_cse_83 - _cse_108) / max(_cse_105, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_64 * _cse_67.x + _cse_124 * _cse_93.x + _cse_127 * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_64 * _cse_67.y + _cse_124 * _cse_93.y + _cse_127 * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_64 * (_cse_83 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_68 * dot(_cse_66, _cse_66) + _cse_83) + _cse_124 * (_cse_108 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_96 * dot(_cse_92, _cse_92) + _cse_108) + _cse_123 * (_cse_83 - _cse_108) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_66 * _cse_70 + _cse_92 * _cse_126) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_132 = s_own_rho_u_x + s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x;
        let _cse_133 = s_own_rho_u_y + s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y;
        let _cse_131 = vec2<f32>(_cse_132, _cse_133);
        let _cse_136 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_135 = _cse_136 - s_own_rho;
        let _cse_134 = s_own_rho + _cse_135;
        let _cse_130 = _cse_131 * 1.0 / _cse_134;
        let _cse_148 = constants.eos_gamma * _cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) / _cse_134;
        let _cse_147 = _cse_148 + constants.eos_dp_drho;
        let _cse_152 = dot(_cse_130, normal_vec);
        let _cse_151 = _cse_152 * _cse_152;
        let _cse_150 = min(_cse_151, _cse_147);
        let _cse_149 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_150;
        let _cse_146 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_147 + _cse_149;
        let _cse_155 = max(_cse_151, low_mach_params.theta_floor * _cse_147);
        let _cse_154 = min(_cse_155, _cse_147);
        let _cse_153 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_154;
        let _cse_145 = _cse_146 + _cse_153;
        let _cse_144 = _cse_145 / max(_cse_147, 0.000000000001);
        let _cse_143 = sqrt(_cse_144);
        let _cse_142 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * _cse_143;
        let _cse_141 = _cse_142 * area;
        let _cse_140 = dot(_cse_130, normal_vec * area) + _cse_141;
        let _cse_159 = s_neigh_rho_u_x + s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x;
        let _cse_160 = s_neigh_rho_u_y + s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y;
        let _cse_158 = vec2<f32>(_cse_159, _cse_160);
        let _cse_164 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_163 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_164;
        let _cse_162 = _cse_163 - s_neigh_rho;
        let _cse_161 = s_neigh_rho + _cse_162;
        let _cse_157 = _cse_158 * 1.0 / _cse_161;
        let _cse_174 = _cse_161 * constants.eos_r * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T);
        let _cse_173 = constants.eos_gamma * _cse_174;
        let _cse_172 = _cse_173 / _cse_161;
        let _cse_171 = _cse_172 + constants.eos_dp_drho;
        let _cse_178 = dot(_cse_157, normal_vec);
        let _cse_177 = _cse_178 * _cse_178;
        let _cse_176 = min(_cse_177, _cse_171);
        let _cse_175 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_176;
        let _cse_170 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_171 + _cse_175;
        let _cse_181 = max(_cse_177, low_mach_params.theta_floor * _cse_171);
        let _cse_180 = min(_cse_181, _cse_171);
        let _cse_179 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_180;
        let _cse_169 = _cse_170 + _cse_179;
        let _cse_168 = _cse_169 / max(_cse_171, 0.000000000001);
        let _cse_167 = sqrt(_cse_168);
        let _cse_166 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * _cse_167;
        let _cse_165 = _cse_166 * area;
        let _cse_156 = dot(_cse_157, normal_vec * area) + _cse_165;
        let _cse_139 = max(_cse_140, _cse_156);
        let _cse_138 = max(_cse_139, 0.0);
        let _cse_186 = dot(_cse_130, normal_vec * area) - _cse_141;
        let _cse_187 = dot(_cse_157, normal_vec * area) - _cse_165;
        let _cse_185 = min(_cse_186, _cse_187);
        let _cse_184 = min(_cse_185, 0.0);
        let _cse_183 = _cse_138 - _cse_184;
        let _cse_182 = max(_cse_183, 0.000001);
        let _cse_137 = _cse_138 / _cse_182;
        let _cse_129 = dot(_cse_130, normal_vec * area) * _cse_137;
        let _cse_188 = _cse_184 * _cse_137;
        let _cse_128 = _cse_129 - _cse_188;
        let _cse_191 = 1.0 - _cse_137;
        let _cse_190 = dot(_cse_157, normal_vec * area) * _cse_191;
        let _cse_189 = _cse_190 + _cse_188;
        phi_0 = _cse_128 * _cse_134 + low_mach_params.pressure_coupling_alpha * (_cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) - _cse_174) / max(_cse_147, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_189 * _cse_161 + low_mach_params.pressure_coupling_alpha * (_cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) - _cse_174) / max(_cse_171, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_128 * _cse_131.x + _cse_189 * _cse_158.x + (_cse_137 * _cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + _cse_191 * _cse_174) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_128 * _cse_131.y + _cse_189 * _cse_158.y + (_cse_137 * _cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + _cse_191 * _cse_174) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_128 * (_cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_134 * dot(_cse_130, _cse_130) + _cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)) + _cse_189 * (_cse_174 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_161 * dot(_cse_157, _cse_157) + _cse_174) + _cse_188 * (_cse_134 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) - _cse_174) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_130 * _cse_137 + _cse_157 * _cse_191) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_196 = s_own_rho_u_x + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), min(s_neigh_rho_u_x - s_own_rho_u_x, 0.0)), max(s_neigh_rho_u_x - s_own_rho_u_x, 0.0));
        let _cse_197 = s_own_rho_u_y + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), min(s_neigh_rho_u_y - s_own_rho_u_y, 0.0)), max(s_neigh_rho_u_y - s_own_rho_u_y, 0.0));
        let _cse_195 = vec2<f32>(_cse_196, _cse_197);
        let _cse_199 = min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec), min(s_neigh_rho - s_own_rho, 0.0)), max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_198 = s_own_rho + _cse_199;
        let _cse_194 = _cse_195 * 1.0 / _cse_198;
        let _cse_211 = constants.eos_gamma * _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / _cse_198;
        let _cse_210 = _cse_211 + constants.eos_dp_drho;
        let _cse_215 = dot(_cse_194, normal_vec);
        let _cse_214 = _cse_215 * _cse_215;
        let _cse_213 = min(_cse_214, _cse_210);
        let _cse_212 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_213;
        let _cse_209 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_210 + _cse_212;
        let _cse_218 = max(_cse_214, low_mach_params.theta_floor * _cse_210);
        let _cse_217 = min(_cse_218, _cse_210);
        let _cse_216 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_217;
        let _cse_208 = _cse_209 + _cse_216;
        let _cse_207 = _cse_208 / max(_cse_210, 0.000000000001);
        let _cse_206 = sqrt(_cse_207);
        let _cse_205 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), face_center_vec - c_owner_vec), min(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0))) * _cse_206;
        let _cse_204 = _cse_205 * area;
        let _cse_203 = dot(_cse_194, normal_vec * area) + _cse_204;
        let _cse_223 = min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_rho_u_x - s_neigh_rho_u_x, 0.0)), max(s_own_rho_u_x - s_neigh_rho_u_x, 0.0));
        let _cse_222 = s_neigh_rho_u_x + _cse_223;
        let _cse_225 = min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_rho_u_y - s_neigh_rho_u_y, 0.0)), max(s_own_rho_u_y - s_neigh_rho_u_y, 0.0));
        let _cse_224 = s_neigh_rho_u_y + _cse_225;
        let _cse_221 = vec2<f32>(_cse_222, _cse_224);
        let _cse_228 = max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_227 = min(_cse_228, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_226 = s_neigh_rho + _cse_227;
        let _cse_220 = _cse_221 * 1.0 / _cse_226;
        let _cse_238 = _cse_226 * constants.eos_r * (s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_237 = constants.eos_gamma * _cse_238;
        let _cse_236 = _cse_237 / _cse_226;
        let _cse_235 = _cse_236 + constants.eos_dp_drho;
        let _cse_242 = dot(_cse_220, normal_vec);
        let _cse_241 = _cse_242 * _cse_242;
        let _cse_240 = min(_cse_241, _cse_235);
        let _cse_239 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_240;
        let _cse_234 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_235 + _cse_239;
        let _cse_245 = max(_cse_241, low_mach_params.theta_floor * _cse_235);
        let _cse_244 = min(_cse_245, _cse_235);
        let _cse_243 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_244;
        let _cse_233 = _cse_234 + _cse_243;
        let _cse_232 = _cse_233 / max(_cse_235, 0.000000000001);
        let _cse_231 = sqrt(_cse_232);
        let _cse_230 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), face_center_vec - c_neigh_cell_vec), min(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0))) * _cse_231;
        let _cse_229 = _cse_230 * area;
        let _cse_219 = dot(_cse_220, normal_vec * area) + _cse_229;
        let _cse_202 = max(_cse_203, _cse_219);
        let _cse_201 = max(_cse_202, 0.0);
        let _cse_250 = dot(_cse_194, normal_vec * area) - _cse_204;
        let _cse_251 = dot(_cse_220, normal_vec * area) - _cse_229;
        let _cse_249 = min(_cse_250, _cse_251);
        let _cse_248 = min(_cse_249, 0.0);
        let _cse_247 = _cse_201 - _cse_248;
        let _cse_246 = max(_cse_247, 0.000001);
        let _cse_200 = _cse_201 / _cse_246;
        let _cse_193 = dot(_cse_194, normal_vec * area) * _cse_200;
        let _cse_252 = _cse_248 * _cse_200;
        let _cse_192 = _cse_193 - _cse_252;
        let _cse_255 = 1.0 - _cse_200;
        let _cse_254 = dot(_cse_220, normal_vec * area) * _cse_255;
        let _cse_253 = _cse_254 + _cse_252;
        phi_0 = _cse_192 * _cse_198 + low_mach_params.pressure_coupling_alpha * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_238) / max(_cse_210, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_253 * _cse_226 + low_mach_params.pressure_coupling_alpha * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_238) / max(_cse_235, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_192 * _cse_195.x + _cse_253 * _cse_221.x + (_cse_200 * _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_255 * _cse_238) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_192 * _cse_195.y + _cse_253 * _cse_221.y + (_cse_200 * _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_255 * _cse_238) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_192 * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_198 * dot(_cse_194, _cse_194) + _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)))) + _cse_253 * (_cse_238 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_226 * dot(_cse_220, _cse_220) + _cse_238) + _cse_252 * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_238) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_194 * _cse_200 + _cse_220 * _cse_255) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_260 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_263 = dot(_cse_260, _cse_260);
        let _cse_262 = (max(-2001.0, min(2.0 * dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_263 / (_cse_263 * _cse_263 + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_263 / (_cse_263 * _cse_263 + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_263 / (_cse_263 * _cse_263 + 0.000000000000000000000000000001) - 1.0, 1999.0))));
        let _cse_261 = _cse_262 * lambda_other;
        let _cse_259 = _cse_260 * _cse_261;
        let _cse_258 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_259;
        let _cse_266 = (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other;
        let _cse_265 = _cse_266 * (s_neigh_rho - s_own_rho);
        let _cse_264 = s_own_rho + _cse_265;
        let _cse_257 = _cse_258 * 1.0 / _cse_264;
        let _cse_278 = constants.eos_gamma * _cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / _cse_264;
        let _cse_277 = _cse_278 + constants.eos_dp_drho;
        let _cse_280 = dot(_cse_257, normal_vec);
        let _cse_279 = _cse_280 * _cse_280;
        let _cse_276 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_277 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_279, _cse_277);
        let _cse_281 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * min(max(_cse_279, low_mach_params.theta_floor * _cse_277), _cse_277);
        let _cse_275 = _cse_276 + _cse_281;
        let _cse_274 = _cse_275 / max(_cse_277, 0.000000000001);
        let _cse_273 = sqrt(_cse_274);
        let _cse_272 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T))) * _cse_273;
        let _cse_271 = _cse_272 * area;
        let _cse_270 = dot(_cse_257, normal_vec * area) + _cse_271;
        let _cse_292 = dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))))) * _cse_263 / (_cse_263 * _cse_263 + 0.000000000000000000000000000001);
        let _cse_291 = 2.0 * _cse_292;
        let _cse_290 = _cse_291 - 1.0;
        let _cse_289 = min(_cse_290, 1999.0);
        let _cse_288 = max(-2001.0, _cse_289);
        let _cse_287 = (_cse_288 + abs(_cse_288)) / (1.0 + abs(_cse_288));
        let _cse_286 = _cse_287 * lambda;
        let _cse_285 = _cse_260 * _cse_286;
        let _cse_284 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_285;
        let _cse_298 = min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0);
        let _cse_297 = max(-2001.0, _cse_298);
        let _cse_296 = (_cse_297 + abs(_cse_297)) / (1.0 + abs(_cse_297));
        let _cse_295 = _cse_296 * lambda;
        let _cse_294 = _cse_295 * (s_neigh_rho - s_own_rho);
        let _cse_293 = s_neigh_rho - _cse_294;
        let _cse_283 = _cse_284 * 1.0 / _cse_293;
        let _cse_306 = constants.eos_gamma * _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) / _cse_293;
        let _cse_305 = _cse_306 + constants.eos_dp_drho;
        let _cse_308 = dot(_cse_283, normal_vec);
        let _cse_307 = _cse_308 * _cse_308;
        let _cse_304 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_305 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_307, _cse_305);
        let _cse_310 = min(max(_cse_307, low_mach_params.theta_floor * _cse_305), _cse_305);
        let _cse_309 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_310;
        let _cse_303 = _cse_304 + _cse_309;
        let _cse_302 = _cse_303 / max(_cse_305, 0.000000000001);
        let _cse_301 = sqrt(_cse_302);
        let _cse_300 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T))) * _cse_301;
        let _cse_299 = _cse_300 * area;
        let _cse_282 = dot(_cse_283, normal_vec * area) + _cse_299;
        let _cse_269 = max(_cse_270, _cse_282);
        let _cse_268 = max(_cse_269, 0.0);
        let _cse_315 = dot(_cse_257, normal_vec * area) - _cse_271;
        let _cse_316 = dot(_cse_283, normal_vec * area) - _cse_299;
        let _cse_314 = min(_cse_315, _cse_316);
        let _cse_313 = min(_cse_314, 0.0);
        let _cse_312 = _cse_268 - _cse_313;
        let _cse_311 = max(_cse_312, 0.000001);
        let _cse_267 = _cse_268 / _cse_311;
        let _cse_317 = _cse_313 * _cse_267;
        let _cse_256 = dot(_cse_257, normal_vec * area) * _cse_267 - _cse_317;
        let _cse_319 = 1.0 - _cse_267;
        let _cse_318 = dot(_cse_283, normal_vec * area) * _cse_319 + _cse_317;
        phi_0 = _cse_256 * _cse_264 + low_mach_params.pressure_coupling_alpha * (_cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) - _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) / max(_cse_277, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_318 * _cse_293 + low_mach_params.pressure_coupling_alpha * (_cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) - _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) / max(_cse_305, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_256 * _cse_258.x + _cse_318 * _cse_284.x + (_cse_267 * _cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) + _cse_319 * _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_256 * _cse_258.y + _cse_318 * _cse_284.y + (_cse_267 * _cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) + _cse_319 * _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_256 * (_cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_264 * dot(_cse_257, _cse_257) + _cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T))) + _cse_318 * (_cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_293 * dot(_cse_283, _cse_283) + _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) + _cse_317 * (_cse_264 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) - _cse_293 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_257 * _cse_267 + _cse_283 * _cse_319) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_325 = min(max(s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x, min(s_neigh_rho_u_x - s_own_rho_u_x, 0.0)), max(s_neigh_rho_u_x - s_own_rho_u_x, 0.0));
        let _cse_324 = s_own_rho_u_x + _cse_325;
        let _cse_327 = min(max(s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y, min(s_neigh_rho_u_y - s_own_rho_u_y, 0.0)), max(s_neigh_rho_u_y - s_own_rho_u_y, 0.0));
        let _cse_326 = s_own_rho_u_y + _cse_327;
        let _cse_323 = vec2<f32>(_cse_324, _cse_326);
        let _cse_329 = min(max(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho, min(s_neigh_rho - s_own_rho, 0.0)), max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_328 = s_own_rho + _cse_329;
        let _cse_322 = _cse_323 * 1.0 / _cse_328;
        let _cse_341 = constants.eos_gamma * _cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / _cse_328;
        let _cse_340 = _cse_341 + constants.eos_dp_drho;
        let _cse_345 = dot(_cse_322, normal_vec);
        let _cse_344 = _cse_345 * _cse_345;
        let _cse_343 = min(_cse_344, _cse_340);
        let _cse_342 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_343;
        let _cse_339 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_340 + _cse_342;
        let _cse_348 = max(_cse_344, low_mach_params.theta_floor * _cse_340);
        let _cse_347 = min(_cse_348, _cse_340);
        let _cse_346 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_347;
        let _cse_338 = _cse_339 + _cse_346;
        let _cse_337 = _cse_338 / max(_cse_340, 0.000000000001);
        let _cse_336 = sqrt(_cse_337);
        let _cse_335 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + min(max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), min(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0))) * _cse_336;
        let _cse_334 = _cse_335 * area;
        let _cse_333 = dot(_cse_322, normal_vec * area) + _cse_334;
        let _cse_353 = min(max(s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x, min(s_own_rho_u_x - s_neigh_rho_u_x, 0.0)), max(s_own_rho_u_x - s_neigh_rho_u_x, 0.0));
        let _cse_352 = s_neigh_rho_u_x + _cse_353;
        let _cse_355 = min(max(s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y, min(s_own_rho_u_y - s_neigh_rho_u_y, 0.0)), max(s_own_rho_u_y - s_neigh_rho_u_y, 0.0));
        let _cse_354 = s_neigh_rho_u_y + _cse_355;
        let _cse_351 = vec2<f32>(_cse_352, _cse_354);
        let _cse_358 = max(s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_357 = min(_cse_358, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_356 = s_neigh_rho + _cse_357;
        let _cse_350 = _cse_351 * 1.0 / _cse_356;
        let _cse_366 = constants.eos_gamma * _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) / _cse_356;
        let _cse_365 = _cse_366 + constants.eos_dp_drho;
        let _cse_370 = dot(_cse_350, normal_vec);
        let _cse_369 = _cse_370 * _cse_370;
        let _cse_368 = min(_cse_369, _cse_365);
        let _cse_367 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_368;
        let _cse_364 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_365 + _cse_367;
        let _cse_373 = max(_cse_369, low_mach_params.theta_floor * _cse_365);
        let _cse_372 = min(_cse_373, _cse_365);
        let _cse_371 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_372;
        let _cse_363 = _cse_364 + _cse_371;
        let _cse_362 = _cse_363 / max(_cse_365, 0.000000000001);
        let _cse_361 = sqrt(_cse_362);
        let _cse_360 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + min(max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), min(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0))) * _cse_361;
        let _cse_359 = _cse_360 * area;
        let _cse_349 = dot(_cse_350, normal_vec * area) + _cse_359;
        let _cse_332 = max(_cse_333, _cse_349);
        let _cse_331 = max(_cse_332, 0.0);
        let _cse_378 = dot(_cse_322, normal_vec * area) - _cse_334;
        let _cse_379 = dot(_cse_350, normal_vec * area) - _cse_359;
        let _cse_377 = min(_cse_378, _cse_379);
        let _cse_376 = min(_cse_377, 0.0);
        let _cse_375 = _cse_331 - _cse_376;
        let _cse_374 = max(_cse_375, 0.000001);
        let _cse_330 = _cse_331 / _cse_374;
        let _cse_321 = dot(_cse_322, normal_vec * area) * _cse_330;
        let _cse_380 = _cse_376 * _cse_330;
        let _cse_320 = _cse_321 - _cse_380;
        let _cse_383 = 1.0 - _cse_330;
        let _cse_382 = dot(_cse_350, normal_vec * area) * _cse_383;
        let _cse_381 = _cse_382 + _cse_380;
        phi_0 = _cse_320 * _cse_328 + low_mach_params.pressure_coupling_alpha * (_cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)))) / max(_cse_340, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_381 * _cse_356 + low_mach_params.pressure_coupling_alpha * (_cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)))) / max(_cse_365, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_320 * _cse_323.x + _cse_381 * _cse_351.x + (_cse_330 * _cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_383 * _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)))) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_320 * _cse_323.y + _cse_381 * _cse_351.y + (_cse_330 * _cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_383 * _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)))) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_320 * (_cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_328 * dot(_cse_322, _cse_322) + _cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)))) + _cse_381 * (_cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0))) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_356 * dot(_cse_350, _cse_350) + _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)))) + _cse_380 * (_cse_328 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_356 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)))) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_322 * _cse_330 + _cse_350 * _cse_383) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_387 = s_own_rho_u_x + (s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x) * abs(s_neigh_rho_u_x - s_own_rho_u_x) / max(abs(s_neigh_rho_u_x - s_own_rho_u_x), abs(s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x) + 0.00000001) * max((s_neigh_rho_u_x - s_own_rho_u_x) * (s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x), 0.0) / max(abs((s_neigh_rho_u_x - s_own_rho_u_x) * (s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x)), 0.00000001);
        let _cse_388 = s_own_rho_u_y + (s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y) * abs(s_neigh_rho_u_y - s_own_rho_u_y) / max(abs(s_neigh_rho_u_y - s_own_rho_u_y), abs(s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y) + 0.00000001) * max((s_neigh_rho_u_y - s_own_rho_u_y) * (s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y), 0.0) / max(abs((s_neigh_rho_u_y - s_own_rho_u_y) * (s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y)), 0.00000001);
        let _cse_386 = vec2<f32>(_cse_387, _cse_388);
        let _cse_390 = (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001);
        let _cse_389 = s_own_rho + _cse_390;
        let _cse_385 = _cse_386 * 1.0 / _cse_389;
        let _cse_402 = constants.eos_gamma * _cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) / _cse_389;
        let _cse_401 = _cse_402 + constants.eos_dp_drho;
        let _cse_406 = dot(_cse_385, normal_vec);
        let _cse_405 = _cse_406 * _cse_406;
        let _cse_404 = min(_cse_405, _cse_401);
        let _cse_403 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_404;
        let _cse_400 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_401 + _cse_403;
        let _cse_409 = max(_cse_405, low_mach_params.theta_floor * _cse_401);
        let _cse_408 = min(_cse_409, _cse_401);
        let _cse_407 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_408;
        let _cse_399 = _cse_400 + _cse_407;
        let _cse_398 = _cse_399 / max(_cse_401, 0.000000000001);
        let _cse_397 = sqrt(_cse_398);
        let _cse_396 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * abs(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / max(abs(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)), abs(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.00000001) * max((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)), 0.0) / max(abs((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T))), 0.00000001)) * _cse_397;
        let _cse_395 = _cse_396 * area;
        let _cse_394 = dot(_cse_385, normal_vec * area) + _cse_395;
        let _cse_414 = (s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x) * abs(s_own_rho_u_x - s_neigh_rho_u_x) / max(abs(s_own_rho_u_x - s_neigh_rho_u_x), abs(s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x) + 0.00000001) * max((s_own_rho_u_x - s_neigh_rho_u_x) * (s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x), 0.0) / max(abs((s_own_rho_u_x - s_neigh_rho_u_x) * (s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x)), 0.00000001);
        let _cse_413 = s_neigh_rho_u_x + _cse_414;
        let _cse_416 = (s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y) * abs(s_own_rho_u_y - s_neigh_rho_u_y) / max(abs(s_own_rho_u_y - s_neigh_rho_u_y), abs(s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y) + 0.00000001) * max((s_own_rho_u_y - s_neigh_rho_u_y) * (s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y), 0.0) / max(abs((s_own_rho_u_y - s_neigh_rho_u_y) * (s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y)), 0.00000001);
        let _cse_415 = s_neigh_rho_u_y + _cse_416;
        let _cse_412 = vec2<f32>(_cse_413, _cse_415);
        let _cse_420 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_419 = _cse_420 - s_neigh_rho;
        let _cse_418 = _cse_419 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_419) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_419, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_419), 0.00000001);
        let _cse_417 = s_neigh_rho + _cse_418;
        let _cse_411 = _cse_412 * 1.0 / _cse_417;
        let _cse_430 = _cse_417 * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001));
        let _cse_429 = constants.eos_gamma * _cse_430;
        let _cse_428 = _cse_429 / _cse_417;
        let _cse_427 = _cse_428 + constants.eos_dp_drho;
        let _cse_434 = dot(_cse_411, normal_vec);
        let _cse_433 = _cse_434 * _cse_434;
        let _cse_432 = min(_cse_433, _cse_427);
        let _cse_431 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_432;
        let _cse_426 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_427 + _cse_431;
        let _cse_437 = max(_cse_433, low_mach_params.theta_floor * _cse_427);
        let _cse_436 = min(_cse_437, _cse_427);
        let _cse_435 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_436;
        let _cse_425 = _cse_426 + _cse_435;
        let _cse_424 = _cse_425 / max(_cse_427, 0.000000000001);
        let _cse_423 = sqrt(_cse_424);
        let _cse_422 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * abs(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) / max(abs(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)), abs(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) + 0.00000001) * max((sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)), 0.0) / max(abs((sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T))), 0.00000001)) * _cse_423;
        let _cse_421 = _cse_422 * area;
        let _cse_410 = dot(_cse_411, normal_vec * area) + _cse_421;
        let _cse_393 = max(_cse_394, _cse_410);
        let _cse_392 = max(_cse_393, 0.0);
        let _cse_442 = dot(_cse_385, normal_vec * area) - _cse_395;
        let _cse_443 = dot(_cse_411, normal_vec * area) - _cse_421;
        let _cse_441 = min(_cse_442, _cse_443);
        let _cse_440 = min(_cse_441, 0.0);
        let _cse_439 = _cse_392 - _cse_440;
        let _cse_438 = max(_cse_439, 0.000001);
        let _cse_391 = _cse_392 / _cse_438;
        let _cse_444 = _cse_440 * _cse_391;
        let _cse_384 = dot(_cse_385, normal_vec * area) * _cse_391 - _cse_444;
        let _cse_447 = 1.0 - _cse_391;
        let _cse_446 = dot(_cse_411, normal_vec * area) * _cse_447;
        let _cse_445 = _cse_446 + _cse_444;
        phi_0 = _cse_384 * _cse_389 + low_mach_params.pressure_coupling_alpha * (_cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) - _cse_430) / max(_cse_401, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area + _cse_445 * _cse_417 + low_mach_params.pressure_coupling_alpha * (_cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) - _cse_430) / max(_cse_427, 0.000000000001) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_384 * _cse_386.x + _cse_445 * _cse_412.x + (_cse_391 * _cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) + _cse_447 * _cse_430) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_384 * _cse_386.y + _cse_445 * _cse_412.y + (_cse_391 * _cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) + _cse_447 * _cse_430) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_384 * (_cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_389 * dot(_cse_385, _cse_385) + _cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001))) + _cse_445 * (_cse_430 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_417 * dot(_cse_411, _cse_411) + _cse_430) + _cse_444 * (_cse_389 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) - _cse_430) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_385 * _cse_391 + _cse_411 * _cse_447) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    fluxes[idx * 8u + 0u] = phi_0;
    fluxes[idx * 8u + 1u] = phi_1;
    fluxes[idx * 8u + 2u] = phi_2;
    fluxes[idx * 8u + 3u] = phi_3;
    fluxes[idx * 8u + 4u] = phi_4;
    fluxes[idx * 8u + 5u] = phi_5;
    fluxes[idx * 8u + 6u] = phi_6;
    fluxes[idx * 8u + 7u] = phi_7;
}
