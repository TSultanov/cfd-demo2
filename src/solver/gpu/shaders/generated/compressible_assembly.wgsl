// GENERATED BY CFD2 CODEGEN (compressible_assembly)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    inlet_velocity: f32,
    ramp_time: f32,
    precond_type: u32,
    precond_model: u32,
    precond_theta_floor: f32,
    pressure_coupling_alpha: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(5) 
var<storage, read> cell_vols: array<f32>;

@group(0) @binding(6) 
var<storage, read> cell_face_offsets: array<u32>;

@group(0) @binding(7) 
var<storage, read> cell_faces: array<u32>;

@group(0) @binding(8) 
var<storage, read> cell_face_matrix_indices: array<u32>;

@group(0) @binding(9) 
var<storage, read> diagonal_indices: array<u32>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields (consolidated state buffers)

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<storage, read_write> grad_rho: array<Vector2>;

@group(1) @binding(6) 
var<storage, read_write> grad_rho_u_x: array<Vector2>;

@group(1) @binding(7) 
var<storage, read_write> grad_rho_u_y: array<Vector2>;

@group(1) @binding(8) 
var<storage, read_write> grad_rho_e: array<Vector2>;

@group(1) @binding(9) 
var<storage, read> state_iter: array<f32>;

// Group 2: Solver

@group(2) @binding(0) 
var<storage, read_write> matrix_values: array<f32>;

@group(2) @binding(1) 
var<storage, read_write> rhs: array<f32>;

@group(2) @binding(2) 
var<storage, read> scalar_row_offsets: array<u32>;

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.x;
    if (idx >= arrayLength(&cell_vols)) {
        return;
    }
    let center = cell_centers[idx];
    let start = cell_face_offsets[idx];
    let end = cell_face_offsets[idx + 1u];
    let vol = cell_vols[idx];
    let scalar_offset = scalar_row_offsets[idx];
    let num_neighbors = scalar_row_offsets[idx + 1u] - scalar_offset;
    let start_row_0 = 16u * scalar_offset;
    let start_row_1 = start_row_0 + 4u * num_neighbors;
    let start_row_2 = start_row_0 + 8u * num_neighbors;
    let start_row_3 = start_row_0 + 12u * num_neighbors;
    let scheme_id = constants.scheme;
    // Jacobian rows/cols: rho, rho_u_x, rho_u_y, rho_e
    var diag_00 = 0.0;
    var diag_01 = 0.0;
    var diag_02 = 0.0;
    var diag_03 = 0.0;
    var diag_10 = 0.0;
    var diag_11 = 0.0;
    var diag_12 = 0.0;
    var diag_13 = 0.0;
    var diag_20 = 0.0;
    var diag_21 = 0.0;
    var diag_22 = 0.0;
    var diag_23 = 0.0;
    var diag_30 = 0.0;
    var diag_31 = 0.0;
    var diag_32 = 0.0;
    var diag_33 = 0.0;
    var sum_rho = 0.0;
    var sum_rho_u_x = 0.0;
    var sum_rho_u_y = 0.0;
    var sum_rho_e = 0.0;
    let rho = state[idx * 7u + 0u];
    let rho_u = vec2<f32>(state[idx * 7u + 1u], state[idx * 7u + 2u]);
    let rho_e = state[idx * 7u + 3u];
    let rho_old = state_old[idx * 7u + 0u];
    let rho_u_old = vec2<f32>(state_old[idx * 7u + 1u], state_old[idx * 7u + 2u]);
    let rho_e_old = state_old[idx * 7u + 3u];
    var coeff_time = vol / constants.dt;
    var rhs_time_rho = coeff_time * rho_old;
    var rhs_time_rho_u_x = coeff_time * rho_u_old.x;
    var rhs_time_rho_u_y = coeff_time * rho_u_old.y;
    var rhs_time_rho_e = coeff_time * rho_e_old;
    var coeff_pseudo = 0.0;
    var rhs_pseudo_rho = 0.0;
    var rhs_pseudo_rho_u_x = 0.0;
    var rhs_pseudo_rho_u_y = 0.0;
    var rhs_pseudo_rho_e = 0.0;
    if (constants.dtau > 0.0) {
        let rho_iter = state_iter[idx * 7u + 0u];
        let rho_u_iter = vec2<f32>(state_iter[idx * 7u + 1u], state_iter[idx * 7u + 2u]);
        let rho_e_iter = state_iter[idx * 7u + 3u];
        coeff_pseudo = vol / constants.dtau;
        rhs_pseudo_rho = coeff_pseudo * rho_iter;
        rhs_pseudo_rho_u_x = coeff_pseudo * rho_u_iter.x;
        rhs_pseudo_rho_u_y = coeff_pseudo * rho_u_iter.y;
        rhs_pseudo_rho_e = coeff_pseudo * rho_e_iter;
    }
    if (constants.time_scheme == 1u) {
        let dt = constants.dt;
        let dt_old = constants.dt_old;
        let r = dt / dt_old;
        let rho_old_old = state_old_old[idx * 7u + 0u];
        let rho_u_old_old = vec2<f32>(state_old_old[idx * 7u + 1u], state_old_old[idx * 7u + 2u]);
        let rho_e_old_old = state_old_old[idx * 7u + 3u];
        coeff_time = vol / dt * (1.0 + 2.0 * r) / (1.0 + r);
        let factor_n = 1.0 + r;
        let factor_nm1 = r * r / (1.0 + r);
        rhs_time_rho = vol / dt * (factor_n * rho_old - factor_nm1 * rho_old_old);
        rhs_time_rho_u_x = vol / dt * (factor_n * rho_u_old.x - factor_nm1 * rho_u_old_old.x);
        rhs_time_rho_u_y = vol / dt * (factor_n * rho_u_old.y - factor_nm1 * rho_u_old_old.y);
        rhs_time_rho_e = vol / dt * (factor_n * rho_e_old - factor_nm1 * rho_e_old_old);
    }
    for (var face_offset = start; face_offset < end; face_offset++) {
        let face_idx = cell_faces[face_offset];
        let owner = face_owner[face_idx];
        let neighbor = face_neighbor[face_idx];
        let boundary_type = face_boundary[face_idx];
        let area = face_areas[face_idx];
        var normal = face_normals[face_idx];
        let f_center = face_centers[face_idx];
        var is_boundary = false;
        var other_idx = 0u;
        var center_r: Vector2;
        if (owner != idx) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        let rho_l_cell = state[idx * 7u + 0u];
        let rho_u_l_cell = vec2<f32>(state[idx * 7u + 1u], state[idx * 7u + 2u]);
        let rho_e_l_cell = state[idx * 7u + 3u];
        var rho_l = rho_l_cell;
        var rho_u_l = rho_u_l_cell;
        var rho_e_l = rho_e_l_cell;
        var rho_r = rho_l;
        var rho_u_r = rho_u_l;
        var rho_e_r = rho_e_l;
        if (neighbor != -1) {
            let neigh_idx = u32(neighbor);
            other_idx = neigh_idx;
            if (owner != idx) {
                other_idx = owner;
            }
            center_r = cell_centers[other_idx];
            let rho_neigh = state[other_idx * 7u + 0u];
            let rho_u_neigh = vec2<f32>(state[other_idx * 7u + 1u], state[other_idx * 7u + 2u]);
            let rho_e_neigh = state[other_idx * 7u + 3u];
            rho_r = rho_neigh;
            rho_u_r.x = rho_u_neigh.x;
            rho_u_r.y = rho_u_neigh.y;
            rho_e_r = rho_e_neigh;
        } else {
            is_boundary = true;
            other_idx = idx;
            center_r = f_center;
        }
        if (is_boundary) {
            if (boundary_type == 1u) {
                rho_u_r.x = rho_r * constants.inlet_velocity;
                rho_u_r.y = 0.0;
            } else {
                if (boundary_type == 3u) {
                    rho_u_r.x = -rho_u_l.x;
                    rho_u_r.y = -rho_u_l.y;
                }
            }
        }
        let rho_r_cell = rho_r;
        let rho_u_r_cell = rho_u_r;
        let rho_e_r_cell = rho_e_r;
        if (!is_boundary && scheme_id != 0u) {
            let r_l_x = f_center.x - center.x;
            let r_l_y = f_center.y - center.y;
            let r_r_x = f_center.x - center_r.x;
            let r_r_y = f_center.y - center_r.y;
            let inv_rho_l_cell = 1.0 / max(rho_l_cell, 1e-8);
            let u_l_x_cell = rho_u_l_cell.x * inv_rho_l_cell;
            let u_l_y_cell = rho_u_l_cell.y * inv_rho_l_cell;
            let u2_l_cell = u_l_x_cell * u_l_x_cell + u_l_y_cell * u_l_y_cell;
            let p_l_cell = max(0.0, (1.4 - 1.0) * (rho_e_l_cell - 0.5 * rho_l_cell * u2_l_cell));
            let inv_rho_r_cell = 1.0 / max(rho_r_cell, 1e-8);
            let u_r_x_cell = rho_u_r_cell.x * inv_rho_r_cell;
            let u_r_y_cell = rho_u_r_cell.y * inv_rho_r_cell;
            let u2_r_cell = u_r_x_cell * u_r_x_cell + u_r_y_cell * u_r_y_cell;
            let p_r_cell = max(0.0, (1.4 - 1.0) * (rho_e_r_cell - 0.5 * rho_r_cell * u2_r_cell));
            let grad_rho_l = grad_rho[idx];
            let grad_rho_u_x_l = grad_rho_u_x[idx];
            let grad_rho_u_y_l = grad_rho_u_y[idx];
            let grad_rho_e_l = grad_rho_e[idx];
            let grad_rho_r = grad_rho[other_idx];
            let grad_rho_u_x_r = grad_rho_u_x[other_idx];
            let grad_rho_u_y_r = grad_rho_u_y[other_idx];
            let grad_rho_e_r = grad_rho_e[other_idx];
            let grad_u_x_l_x = (grad_rho_u_x_l.x - u_l_x_cell * grad_rho_l.x) * inv_rho_l_cell;
            let grad_u_x_l_y = (grad_rho_u_x_l.y - u_l_x_cell * grad_rho_l.y) * inv_rho_l_cell;
            let grad_u_y_l_x = (grad_rho_u_y_l.x - u_l_y_cell * grad_rho_l.x) * inv_rho_l_cell;
            let grad_u_y_l_y = (grad_rho_u_y_l.y - u_l_y_cell * grad_rho_l.y) * inv_rho_l_cell;
            let grad_u_x_r_x = (grad_rho_u_x_r.x - u_r_x_cell * grad_rho_r.x) * inv_rho_r_cell;
            let grad_u_x_r_y = (grad_rho_u_x_r.y - u_r_x_cell * grad_rho_r.y) * inv_rho_r_cell;
            let grad_u_y_r_x = (grad_rho_u_y_r.x - u_r_y_cell * grad_rho_r.x) * inv_rho_r_cell;
            let grad_u_y_r_y = (grad_rho_u_y_r.y - u_r_y_cell * grad_rho_r.y) * inv_rho_r_cell;
            let grad_u2_l_x = 2.0 * u_l_x_cell * grad_u_x_l_x + 2.0 * u_l_y_cell * grad_u_y_l_x;
            let grad_u2_l_y = 2.0 * u_l_x_cell * grad_u_x_l_y + 2.0 * u_l_y_cell * grad_u_y_l_y;
            let grad_u2_r_x = 2.0 * u_r_x_cell * grad_u_x_r_x + 2.0 * u_r_y_cell * grad_u_y_r_x;
            let grad_u2_r_y = 2.0 * u_r_x_cell * grad_u_x_r_y + 2.0 * u_r_y_cell * grad_u_y_r_y;
            let grad_rho_u2_l_x = u2_l_cell * grad_rho_l.x + rho_l_cell * grad_u2_l_x;
            let grad_rho_u2_l_y = u2_l_cell * grad_rho_l.y + rho_l_cell * grad_u2_l_y;
            let grad_rho_u2_r_x = u2_r_cell * grad_rho_r.x + rho_r_cell * grad_u2_r_x;
            let grad_rho_u2_r_y = u2_r_cell * grad_rho_r.y + rho_r_cell * grad_u2_r_y;
            let grad_p_l_x = (1.4 - 1.0) * (grad_rho_e_l.x - 0.5 * grad_rho_u2_l_x);
            let grad_p_l_y = (1.4 - 1.0) * (grad_rho_e_l.y - 0.5 * grad_rho_u2_l_y);
            let grad_p_r_x = (1.4 - 1.0) * (grad_rho_e_r.x - 0.5 * grad_rho_u2_r_x);
            let grad_p_r_y = (1.4 - 1.0) * (grad_rho_e_r.y - 0.5 * grad_rho_u2_r_y);
            let diff_rho_l = rho_r_cell - rho_l_cell;
            let min_diff_rho_l = min(diff_rho_l, 0.0);
            let max_diff_rho_l = max(diff_rho_l, 0.0);
            let delta_rho_l = grad_rho_l.x * r_l_x + grad_rho_l.y * r_l_y;
            let delta_rho_l_limited = min(max(delta_rho_l, min_diff_rho_l), max_diff_rho_l);
            let diff_u_l_x = u_r_x_cell - u_l_x_cell;
            let min_diff_u_l_x = min(diff_u_l_x, 0.0);
            let max_diff_u_l_x = max(diff_u_l_x, 0.0);
            let delta_u_l_x = grad_u_x_l_x * r_l_x + grad_u_x_l_y * r_l_y;
            let delta_u_l_x_limited = min(max(delta_u_l_x, min_diff_u_l_x), max_diff_u_l_x);
            let diff_u_l_y = u_r_y_cell - u_l_y_cell;
            let min_diff_u_l_y = min(diff_u_l_y, 0.0);
            let max_diff_u_l_y = max(diff_u_l_y, 0.0);
            let delta_u_l_y = grad_u_y_l_x * r_l_x + grad_u_y_l_y * r_l_y;
            let delta_u_l_y_limited = min(max(delta_u_l_y, min_diff_u_l_y), max_diff_u_l_y);
            let diff_p_l = p_r_cell - p_l_cell;
            let min_diff_p_l = min(diff_p_l, 0.0);
            let max_diff_p_l = max(diff_p_l, 0.0);
            let delta_p_l = grad_p_l_x * r_l_x + grad_p_l_y * r_l_y;
            let delta_p_l_limited = min(max(delta_p_l, min_diff_p_l), max_diff_p_l);
            let rho_l_face = rho_l_cell + delta_rho_l_limited;
            let u_l_x_face = u_l_x_cell + delta_u_l_x_limited;
            let u_l_y_face = u_l_y_cell + delta_u_l_y_limited;
            let p_l_face = p_l_cell + delta_p_l_limited;
            let diff_rho_r = rho_l_cell - rho_r_cell;
            let min_diff_rho_r = min(diff_rho_r, 0.0);
            let max_diff_rho_r = max(diff_rho_r, 0.0);
            let delta_rho_r = grad_rho_r.x * r_r_x + grad_rho_r.y * r_r_y;
            let delta_rho_r_limited = min(max(delta_rho_r, min_diff_rho_r), max_diff_rho_r);
            let diff_u_r_x = u_l_x_cell - u_r_x_cell;
            let min_diff_u_r_x = min(diff_u_r_x, 0.0);
            let max_diff_u_r_x = max(diff_u_r_x, 0.0);
            let delta_u_r_x = grad_u_x_r_x * r_r_x + grad_u_x_r_y * r_r_y;
            let delta_u_r_x_limited = min(max(delta_u_r_x, min_diff_u_r_x), max_diff_u_r_x);
            let diff_u_r_y = u_l_y_cell - u_r_y_cell;
            let min_diff_u_r_y = min(diff_u_r_y, 0.0);
            let max_diff_u_r_y = max(diff_u_r_y, 0.0);
            let delta_u_r_y = grad_u_y_r_x * r_r_x + grad_u_y_r_y * r_r_y;
            let delta_u_r_y_limited = min(max(delta_u_r_y, min_diff_u_r_y), max_diff_u_r_y);
            let diff_p_r = p_l_cell - p_r_cell;
            let min_diff_p_r = min(diff_p_r, 0.0);
            let max_diff_p_r = max(diff_p_r, 0.0);
            let delta_p_r = grad_p_r_x * r_r_x + grad_p_r_y * r_r_y;
            let delta_p_r_limited = min(max(delta_p_r, min_diff_p_r), max_diff_p_r);
            let rho_r_face = rho_r_cell + delta_rho_r_limited;
            let u_r_x_face = u_r_x_cell + delta_u_r_x_limited;
            let u_r_y_face = u_r_y_cell + delta_u_r_y_limited;
            let p_r_face = p_r_cell + delta_p_r_limited;
            rho_l = rho_l_face;
            rho_u_l.x = rho_l_face * u_l_x_face;
            rho_u_l.y = rho_l_face * u_l_y_face;
            rho_e_l = p_l_face / (1.4 - 1.0) + 0.5 * rho_l_face * (u_l_x_face * u_l_x_face + u_l_y_face * u_l_y_face);
            rho_r = rho_r_face;
            rho_u_r.x = rho_r_face * u_r_x_face;
            rho_u_r.y = rho_r_face * u_r_y_face;
            rho_e_r = p_r_face / (1.4 - 1.0) + 0.5 * rho_r_face * (u_r_x_face * u_r_x_face + u_r_y_face * u_r_y_face);
        }
        let inv_rho_l = 1.0 / max(rho_l, 1e-8);
        let u_l_x = rho_u_l.x * inv_rho_l;
        let u_l_y = rho_u_l.y * inv_rho_l;
        let ke_l = 0.5 * rho_l * (u_l_x * u_l_x + u_l_y * u_l_y);
        let p_l = max(0.0, (1.4 - 1.0) * (rho_e_l - ke_l));
        let u_n_l = u_l_x * normal.x + u_l_y * normal.y;
        let c_l = sqrt(1.4 * p_l * inv_rho_l);
        let inv_rho_r = 1.0 / max(rho_r, 1e-8);
        let u_r_x = rho_u_r.x * inv_rho_r;
        let u_r_y = rho_u_r.y * inv_rho_r;
        let ke_r = 0.5 * rho_r * (u_r_x * u_r_x + u_r_y * u_r_y);
        let p_r = max(0.0, (1.4 - 1.0) * (rho_e_r - ke_r));
        let u_n_r = u_r_x * normal.x + u_r_y * normal.y;
        let c_r = sqrt(1.4 * p_r * inv_rho_r);
        let u_face_x = 0.5 * (u_l_x + u_r_x);
        let u_face_y = 0.5 * (u_l_y + u_r_y);
        let u_face_n = u_face_x * normal.x + u_face_y * normal.y;
        let c_bar = 0.5 * (c_l + c_r);
        let mach = abs(u_face_n) / max(c_bar, 1e-6);
        let mach2 = mach * mach;
        let beta = mach;
        var c_l_eff = c_l * beta;
        var c_r_eff = c_r * beta;
        if (constants.precond_model == 1u) {
            let theta = min(1.0, max(mach2, constants.precond_theta_floor));
            let one_minus_theta = 1.0 - theta;
            c_l_eff = sqrt(theta * c_l * c_l + one_minus_theta * u_n_l * u_n_l);
            c_r_eff = sqrt(theta * c_r * c_r + one_minus_theta * u_n_r * u_n_r);
        }
        let flux_adv = u_face_n * area;
        let dx = center_r.x - center.x;
        let dy = center_r.y - center.y;
        let dist = max(sqrt(dx * dx + dy * dy), 1e-6);
        let mu = constants.viscosity;
        let a_plus = max(0.0, max(u_n_l + c_l_eff, u_n_r + c_r_eff));
        let a_minus = min(0.0, min(u_n_l - c_l_eff, u_n_r - c_r_eff));
        let denom = max(a_plus - a_minus, 1e-6);
        let a_prod = a_plus * a_minus;
        let a_pos = a_plus / denom;
        let a_neg = 1.0 - a_pos;
        let a_prod_scaled = a_prod / denom;
        let flux_rho_l = rho_l * u_n_l;
        let flux_rho_r = rho_r * u_n_r;
        var flux_rho = a_pos * flux_rho_l + a_neg * flux_rho_r + a_prod_scaled * (rho_r - rho_l);
        let flux_rho_u_x_l = rho_u_l.x * u_n_l + p_l * normal.x;
        let flux_rho_u_x_r = rho_u_r.x * u_n_r + p_r * normal.x;
        var flux_rho_u_x = a_pos * flux_rho_u_x_l + a_neg * flux_rho_u_x_r + a_prod_scaled * (rho_u_r.x - rho_u_l.x);
        let flux_rho_u_y_l = rho_u_l.y * u_n_l + p_l * normal.y;
        let flux_rho_u_y_r = rho_u_r.y * u_n_r + p_r * normal.y;
        var flux_rho_u_y = a_pos * flux_rho_u_y_l + a_neg * flux_rho_u_y_r + a_prod_scaled * (rho_u_r.y - rho_u_l.y);
        let diff_u_x = -mu * (u_r_x - u_l_x) / dist;
        let diff_u_y = -mu * (u_r_y - u_l_y) / dist;
        flux_rho_u_x = flux_rho_u_x + diff_u_x;
        flux_rho_u_y = flux_rho_u_y + diff_u_y;
        let flux_rho_e_l = (rho_e_l + p_l) * u_n_l;
        let flux_rho_e_r = (rho_e_r + p_r) * u_n_r;
        var flux_rho_e = a_pos * flux_rho_e_l + a_neg * flux_rho_e_r + a_prod_scaled * (rho_e_r - rho_e_l);
        let inv_rho_l_cell = 1.0 / max(rho_l_cell, 1e-8);
        let inv_rho_r_cell = 1.0 / max(rho_r_cell, 1e-8);
        let u_l_x_cell = rho_u_l_cell.x * inv_rho_l_cell;
        let u_l_y_cell = rho_u_l_cell.y * inv_rho_l_cell;
        let u_r_x_cell = rho_u_r_cell.x * inv_rho_r_cell;
        let u_r_y_cell = rho_u_r_cell.y * inv_rho_r_cell;
        let u2_l_cell = u_l_x_cell * u_l_x_cell + u_l_y_cell * u_l_y_cell;
        let u2_r_cell = u_r_x_cell * u_r_x_cell + u_r_y_cell * u_r_y_cell;
        let grad_rho_l = grad_rho[idx];
        let grad_rho_u_x_l = grad_rho_u_x[idx];
        let grad_rho_u_y_l = grad_rho_u_y[idx];
        let grad_rho_e_l = grad_rho_e[idx];
        let grad_rho_r = grad_rho[other_idx];
        let grad_rho_u_x_r = grad_rho_u_x[other_idx];
        let grad_rho_u_y_r = grad_rho_u_y[other_idx];
        let grad_rho_e_r = grad_rho_e[other_idx];
        let grad_u_x_l_x = (grad_rho_u_x_l.x - u_l_x_cell * grad_rho_l.x) * inv_rho_l_cell;
        let grad_u_x_l_y = (grad_rho_u_x_l.y - u_l_x_cell * grad_rho_l.y) * inv_rho_l_cell;
        let grad_u_y_l_x = (grad_rho_u_y_l.x - u_l_y_cell * grad_rho_l.x) * inv_rho_l_cell;
        let grad_u_y_l_y = (grad_rho_u_y_l.y - u_l_y_cell * grad_rho_l.y) * inv_rho_l_cell;
        let grad_u_x_r_x = (grad_rho_u_x_r.x - u_r_x_cell * grad_rho_r.x) * inv_rho_r_cell;
        let grad_u_x_r_y = (grad_rho_u_x_r.y - u_r_x_cell * grad_rho_r.y) * inv_rho_r_cell;
        let grad_u_y_r_x = (grad_rho_u_y_r.x - u_r_y_cell * grad_rho_r.x) * inv_rho_r_cell;
        let grad_u_y_r_y = (grad_rho_u_y_r.y - u_r_y_cell * grad_rho_r.y) * inv_rho_r_cell;
        let grad_u2_l_x = 2.0 * u_l_x_cell * grad_u_x_l_x + 2.0 * u_l_y_cell * grad_u_y_l_x;
        let grad_u2_l_y = 2.0 * u_l_x_cell * grad_u_x_l_y + 2.0 * u_l_y_cell * grad_u_y_l_y;
        let grad_u2_r_x = 2.0 * u_r_x_cell * grad_u_x_r_x + 2.0 * u_r_y_cell * grad_u_y_r_x;
        let grad_u2_r_y = 2.0 * u_r_x_cell * grad_u_x_r_y + 2.0 * u_r_y_cell * grad_u_y_r_y;
        let grad_rho_u2_l_x = u2_l_cell * grad_rho_l.x + rho_l_cell * grad_u2_l_x;
        let grad_rho_u2_l_y = u2_l_cell * grad_rho_l.y + rho_l_cell * grad_u2_l_y;
        let grad_rho_u2_r_x = u2_r_cell * grad_rho_r.x + rho_r_cell * grad_u2_r_x;
        let grad_rho_u2_r_y = u2_r_cell * grad_rho_r.y + rho_r_cell * grad_u2_r_y;
        let grad_p_l_x = (1.4 - 1.0) * (grad_rho_e_l.x - 0.5 * grad_rho_u2_l_x);
        let grad_p_l_y = (1.4 - 1.0) * (grad_rho_e_l.y - 0.5 * grad_rho_u2_l_y);
        let grad_p_r_x = (1.4 - 1.0) * (grad_rho_e_r.x - 0.5 * grad_rho_u2_r_x);
        let grad_p_r_y = (1.4 - 1.0) * (grad_rho_e_r.y - 0.5 * grad_rho_u2_r_y);
        let grad_p_l_n = grad_p_l_x * normal.x + grad_p_l_y * normal.y;
        let grad_p_r_n = grad_p_r_x * normal.x + grad_p_r_y * normal.y;
        let grad_p_face_n = 0.5 * (grad_p_l_n + grad_p_r_n);
        let grad_p_jump_n = (p_r - p_l) / dist;
        let rho_face = 0.5 * (rho_l + rho_r);
        let pc_alpha = constants.pressure_coupling_alpha;
        let m_corr = pc_alpha * constants.dt / max(rho_face, 1e-8) * (grad_p_face_n - grad_p_jump_n);
        let h_l = (rho_e_l + p_l) * inv_rho_l;
        let h_r = (rho_e_r + p_r) * inv_rho_r;
        let h_face = 0.5 * (h_l + h_r);
        flux_rho += m_corr;
        flux_rho_u_x += m_corr * u_face_x;
        flux_rho_u_y += m_corr * u_face_y;
        flux_rho_e += m_corr * h_face;
        flux_rho_e = flux_rho_e + diff_u_x * u_face_x + diff_u_y * u_face_y;
        sum_rho += flux_rho * area;
        sum_rho_u_x += flux_rho_u_x * area;
        sum_rho_u_y += flux_rho_u_y * area;
        sum_rho_e += flux_rho_e * area;
        let q_l = u_l_x * u_l_x + u_l_y * u_l_y;
        let dp_drho_l = 0.5 * (1.4 - 1.0) * q_l;
        let dp_dru_l = -(1.4 - 1.0) * u_l_x;
        let dp_drv_l = -(1.4 - 1.0) * u_l_y;
        let dp_dre_l = 1.4 - 1.0;
        let H_l = (rho_e_l + p_l) * inv_rho_l;
        let q_r = u_r_x * u_r_x + u_r_y * u_r_y;
        let dp_drho_r = 0.5 * (1.4 - 1.0) * q_r;
        let dp_dru_r = -(1.4 - 1.0) * u_r_x;
        let dp_drv_r = -(1.4 - 1.0) * u_r_y;
        let dp_dre_r = 1.4 - 1.0;
        let H_r = (rho_e_r + p_r) * inv_rho_r;
        let a_l = a_plus / denom;
        let a_r = -a_minus / denom;
        var jac_l_00 = -a_prod_scaled;
        var jac_l_01 = a_l * normal.x;
        var jac_l_02 = a_l * normal.y;
        var jac_l_03 = 0.0;
        var jac_r_00 = a_prod_scaled;
        var jac_r_01 = a_r * normal.x;
        var jac_r_02 = a_r * normal.y;
        var jac_r_03 = 0.0;
        let A_l_10 = -u_l_x * u_n_l + dp_drho_l * normal.x;
        let A_l_11 = u_n_l + u_l_x * normal.x + dp_dru_l * normal.x;
        let A_l_12 = u_l_x * normal.y + dp_drv_l * normal.x;
        let A_l_13 = dp_dre_l * normal.x;
        let A_l_20 = -u_l_y * u_n_l + dp_drho_l * normal.y;
        let A_l_21 = u_l_y * normal.x + dp_dru_l * normal.y;
        let A_l_22 = u_n_l + u_l_y * normal.y + dp_drv_l * normal.y;
        let A_l_23 = dp_dre_l * normal.y;
        let A_l_30 = -H_l * u_n_l + dp_drho_l * u_n_l;
        let A_l_31 = H_l * normal.x + dp_dru_l * u_n_l;
        let A_l_32 = H_l * normal.y + dp_drv_l * u_n_l;
        let A_l_33 = 1.4 * u_n_l;
        let A_r_10 = -u_r_x * u_n_r + dp_drho_r * normal.x;
        let A_r_11 = u_n_r + u_r_x * normal.x + dp_dru_r * normal.x;
        let A_r_12 = u_r_x * normal.y + dp_drv_r * normal.x;
        let A_r_13 = dp_dre_r * normal.x;
        let A_r_20 = -u_r_y * u_n_r + dp_drho_r * normal.y;
        let A_r_21 = u_r_y * normal.x + dp_dru_r * normal.y;
        let A_r_22 = u_n_r + u_r_y * normal.y + dp_drv_r * normal.y;
        let A_r_23 = dp_dre_r * normal.y;
        let A_r_30 = -H_r * u_n_r + dp_drho_r * u_n_r;
        let A_r_31 = H_r * normal.x + dp_dru_r * u_n_r;
        let A_r_32 = H_r * normal.y + dp_drv_r * u_n_r;
        let A_r_33 = 1.4 * u_n_r;
        var jac_l_10 = a_l * A_l_10;
        var jac_l_11 = a_l * A_l_11 - a_prod_scaled;
        var jac_l_12 = a_l * A_l_12;
        var jac_l_13 = a_l * A_l_13;
        var jac_r_10 = a_r * A_r_10;
        var jac_r_11 = a_r * A_r_11 + a_prod_scaled;
        var jac_r_12 = a_r * A_r_12;
        var jac_r_13 = a_r * A_r_13;
        var jac_l_20 = a_l * A_l_20;
        var jac_l_21 = a_l * A_l_21;
        var jac_l_22 = a_l * A_l_22 - a_prod_scaled;
        var jac_l_23 = a_l * A_l_23;
        var jac_r_20 = a_r * A_r_20;
        var jac_r_21 = a_r * A_r_21;
        var jac_r_22 = a_r * A_r_22 + a_prod_scaled;
        var jac_r_23 = a_r * A_r_23;
        var jac_l_30 = a_l * A_l_30;
        var jac_l_31 = a_l * A_l_31;
        var jac_l_32 = a_l * A_l_32;
        var jac_l_33 = a_l * A_l_33 - a_prod_scaled;
        var jac_r_30 = a_r * A_r_30;
        var jac_r_31 = a_r * A_r_31;
        var jac_r_32 = a_r * A_r_32;
        var jac_r_33 = a_r * A_r_33 + a_prod_scaled;
        let mu_over_dist = mu / dist;
        let du_lx_drho = -u_l_x * inv_rho_l;
        let du_lx_dru = inv_rho_l;
        let du_lx_drv = 0.0;
        let du_ly_drho = -u_l_y * inv_rho_l;
        let du_ly_dru = 0.0;
        let du_ly_drv = inv_rho_l;
        let du_rx_drho = -u_r_x * inv_rho_r;
        let du_rx_dru = inv_rho_r;
        let du_rx_drv = 0.0;
        let du_ry_drho = -u_r_y * inv_rho_r;
        let du_ry_dru = 0.0;
        let du_ry_drv = inv_rho_r;
        let d_diff_x_l_rho = mu_over_dist * du_lx_drho;
        let d_diff_x_l_ru = mu_over_dist * du_lx_dru;
        let d_diff_x_l_rv = 0.0;
        let d_diff_x_l_re = 0.0;
        let d_diff_y_l_rho = mu_over_dist * du_ly_drho;
        let d_diff_y_l_ru = 0.0;
        let d_diff_y_l_rv = mu_over_dist * du_ly_drv;
        let d_diff_y_l_re = 0.0;
        let d_diff_x_r_rho = -mu_over_dist * du_rx_drho;
        let d_diff_x_r_ru = -mu_over_dist * du_rx_dru;
        let d_diff_x_r_rv = 0.0;
        let d_diff_x_r_re = 0.0;
        let d_diff_y_r_rho = -mu_over_dist * du_ry_drho;
        let d_diff_y_r_ru = 0.0;
        let d_diff_y_r_rv = -mu_over_dist * du_ry_drv;
        let d_diff_y_r_re = 0.0;
        jac_l_10 += d_diff_x_l_rho;
        jac_l_11 += d_diff_x_l_ru;
        jac_l_12 += d_diff_x_l_rv;
        jac_l_13 += d_diff_x_l_re;
        jac_l_20 += d_diff_y_l_rho;
        jac_l_21 += d_diff_y_l_ru;
        jac_l_22 += d_diff_y_l_rv;
        jac_l_23 += d_diff_y_l_re;
        jac_r_10 += d_diff_x_r_rho;
        jac_r_11 += d_diff_x_r_ru;
        jac_r_12 += d_diff_x_r_rv;
        jac_r_13 += d_diff_x_r_re;
        jac_r_20 += d_diff_y_r_rho;
        jac_r_21 += d_diff_y_r_ru;
        jac_r_22 += d_diff_y_r_rv;
        jac_r_23 += d_diff_y_r_re;
        let du_face_x_l_rho = 0.5 * du_lx_drho;
        let du_face_x_l_ru = 0.5 * du_lx_dru;
        let du_face_x_l_rv = 0.0;
        let du_face_x_l_re = 0.0;
        let du_face_y_l_rho = 0.5 * du_ly_drho;
        let du_face_y_l_ru = 0.0;
        let du_face_y_l_rv = 0.5 * du_ly_drv;
        let du_face_y_l_re = 0.0;
        let du_face_x_r_rho = 0.5 * du_rx_drho;
        let du_face_x_r_ru = 0.5 * du_rx_dru;
        let du_face_x_r_rv = 0.0;
        let du_face_x_r_re = 0.0;
        let du_face_y_r_rho = 0.5 * du_ry_drho;
        let du_face_y_r_ru = 0.0;
        let du_face_y_r_rv = 0.5 * du_ry_drv;
        let du_face_y_r_re = 0.0;
        let d_e_visc_l_rho = d_diff_x_l_rho * u_face_x + diff_u_x * du_face_x_l_rho + d_diff_y_l_rho * u_face_y + diff_u_y * du_face_y_l_rho;
        let d_e_visc_l_ru = d_diff_x_l_ru * u_face_x + diff_u_x * du_face_x_l_ru + d_diff_y_l_ru * u_face_y + diff_u_y * du_face_y_l_ru;
        let d_e_visc_l_rv = d_diff_x_l_rv * u_face_x + diff_u_x * du_face_x_l_rv + d_diff_y_l_rv * u_face_y + diff_u_y * du_face_y_l_rv;
        let d_e_visc_l_re = d_diff_x_l_re * u_face_x + diff_u_x * du_face_x_l_re + d_diff_y_l_re * u_face_y + diff_u_y * du_face_y_l_re;
        let d_e_visc_r_rho = d_diff_x_r_rho * u_face_x + diff_u_x * du_face_x_r_rho + d_diff_y_r_rho * u_face_y + diff_u_y * du_face_y_r_rho;
        let d_e_visc_r_ru = d_diff_x_r_ru * u_face_x + diff_u_x * du_face_x_r_ru + d_diff_y_r_ru * u_face_y + diff_u_y * du_face_y_r_ru;
        let d_e_visc_r_rv = d_diff_x_r_rv * u_face_x + diff_u_x * du_face_x_r_rv + d_diff_y_r_rv * u_face_y + diff_u_y * du_face_y_r_rv;
        let d_e_visc_r_re = d_diff_x_r_re * u_face_x + diff_u_x * du_face_x_r_re + d_diff_y_r_re * u_face_y + diff_u_y * du_face_y_r_re;
        jac_l_30 += d_e_visc_l_rho;
        jac_l_31 += d_e_visc_l_ru;
        jac_l_32 += d_e_visc_l_rv;
        jac_l_33 += d_e_visc_l_re;
        jac_r_30 += d_e_visc_r_rho;
        jac_r_31 += d_e_visc_r_ru;
        jac_r_32 += d_e_visc_r_rv;
        jac_r_33 += d_e_visc_r_re;
        if (!is_boundary) {
            let scalar_mat_idx = cell_face_matrix_indices[face_offset];
            var neighbor_rank = 0u;
            if (scalar_mat_idx != 4294967295u) {
                neighbor_rank = scalar_mat_idx - scalar_offset;
            } else {
                neighbor_rank = scalar_mat_idx - scalar_offset;
            }
            let base_0 = start_row_0 + 4u * neighbor_rank;
            let base_1 = start_row_1 + 4u * neighbor_rank;
            let base_2 = start_row_2 + 4u * neighbor_rank;
            let base_3 = start_row_3 + 4u * neighbor_rank;
            matrix_values[base_0 + 0u] = jac_r_00 * area;
            matrix_values[base_0 + 1u] = jac_r_01 * area;
            matrix_values[base_0 + 2u] = jac_r_02 * area;
            matrix_values[base_0 + 3u] = jac_r_03 * area;
            matrix_values[base_1 + 0u] = jac_r_10 * area;
            matrix_values[base_1 + 1u] = jac_r_11 * area;
            matrix_values[base_1 + 2u] = jac_r_12 * area;
            matrix_values[base_1 + 3u] = jac_r_13 * area;
            matrix_values[base_2 + 0u] = jac_r_20 * area;
            matrix_values[base_2 + 1u] = jac_r_21 * area;
            matrix_values[base_2 + 2u] = jac_r_22 * area;
            matrix_values[base_2 + 3u] = jac_r_23 * area;
            matrix_values[base_3 + 0u] = jac_r_30 * area;
            matrix_values[base_3 + 1u] = jac_r_31 * area;
            matrix_values[base_3 + 2u] = jac_r_32 * area;
            matrix_values[base_3 + 3u] = jac_r_33 * area;
            diag_00 += jac_l_00 * area;
            diag_01 += jac_l_01 * area;
            diag_02 += jac_l_02 * area;
            diag_03 += jac_l_03 * area;
            diag_10 += jac_l_10 * area;
            diag_11 += jac_l_11 * area;
            diag_12 += jac_l_12 * area;
            diag_13 += jac_l_13 * area;
            diag_20 += jac_l_20 * area;
            diag_21 += jac_l_21 * area;
            diag_22 += jac_l_22 * area;
            diag_23 += jac_l_23 * area;
            diag_30 += jac_l_30 * area;
            diag_31 += jac_l_31 * area;
            diag_32 += jac_l_32 * area;
            diag_33 += jac_l_33 * area;
        } else {
            var eff_00 = jac_l_00 + jac_r_00;
            var eff_01 = jac_l_01 + jac_r_01;
            var eff_02 = jac_l_02 + jac_r_02;
            var eff_03 = jac_l_03 + jac_r_03;
            var eff_10 = jac_l_10 + jac_r_10;
            var eff_11 = jac_l_11 + jac_r_11;
            var eff_12 = jac_l_12 + jac_r_12;
            var eff_13 = jac_l_13 + jac_r_13;
            var eff_20 = jac_l_20 + jac_r_20;
            var eff_21 = jac_l_21 + jac_r_21;
            var eff_22 = jac_l_22 + jac_r_22;
            var eff_23 = jac_l_23 + jac_r_23;
            var eff_30 = jac_l_30 + jac_r_30;
            var eff_31 = jac_l_31 + jac_r_31;
            var eff_32 = jac_l_32 + jac_r_32;
            var eff_33 = jac_l_33 + jac_r_33;
            if (boundary_type == 1u) {
                eff_00 = jac_l_00 + jac_r_00 + jac_r_01 * constants.inlet_velocity;
                eff_01 = jac_l_01;
                eff_02 = jac_l_02;
                eff_03 = jac_l_03 + jac_r_03;
                eff_10 = jac_l_10 + jac_r_10 + jac_r_11 * constants.inlet_velocity;
                eff_11 = jac_l_11;
                eff_12 = jac_l_12;
                eff_13 = jac_l_13 + jac_r_13;
                eff_20 = jac_l_20 + jac_r_20 + jac_r_21 * constants.inlet_velocity;
                eff_21 = jac_l_21;
                eff_22 = jac_l_22;
                eff_23 = jac_l_23 + jac_r_23;
                eff_30 = jac_l_30 + jac_r_30 + jac_r_31 * constants.inlet_velocity;
                eff_31 = jac_l_31;
                eff_32 = jac_l_32;
                eff_33 = jac_l_33 + jac_r_33;
            } else {
                if (boundary_type == 3u) {
                    eff_00 = jac_l_00 + jac_r_00;
                    eff_01 = jac_l_01 - jac_r_01;
                    eff_02 = jac_l_02 - jac_r_02;
                    eff_03 = jac_l_03 + jac_r_03;
                    eff_10 = jac_l_10 + jac_r_10;
                    eff_11 = jac_l_11 - jac_r_11;
                    eff_12 = jac_l_12 - jac_r_12;
                    eff_13 = jac_l_13 + jac_r_13;
                    eff_20 = jac_l_20 + jac_r_20;
                    eff_21 = jac_l_21 - jac_r_21;
                    eff_22 = jac_l_22 - jac_r_22;
                    eff_23 = jac_l_23 + jac_r_23;
                    eff_30 = jac_l_30 + jac_r_30;
                    eff_31 = jac_l_31 - jac_r_31;
                    eff_32 = jac_l_32 - jac_r_32;
                    eff_33 = jac_l_33 + jac_r_33;
                }
            }
            diag_00 += eff_00 * area;
            diag_01 += eff_01 * area;
            diag_02 += eff_02 * area;
            diag_03 += eff_03 * area;
            diag_10 += eff_10 * area;
            diag_11 += eff_11 * area;
            diag_12 += eff_12 * area;
            diag_13 += eff_13 * area;
            diag_20 += eff_20 * area;
            diag_21 += eff_21 * area;
            diag_22 += eff_22 * area;
            diag_23 += eff_23 * area;
            diag_30 += eff_30 * area;
            diag_31 += eff_31 * area;
            diag_32 += eff_32 * area;
            diag_33 += eff_33 * area;
        }
    }
    var rhs_rho = rhs_time_rho + rhs_pseudo_rho - (coeff_time + coeff_pseudo) * rho - sum_rho;
    var rhs_rho_u_x = rhs_time_rho_u_x + rhs_pseudo_rho_u_x - (coeff_time + coeff_pseudo) * rho_u.x - sum_rho_u_x;
    var rhs_rho_u_y = rhs_time_rho_u_y + rhs_pseudo_rho_u_y - (coeff_time + coeff_pseudo) * rho_u.y - sum_rho_u_y;
    var rhs_rho_e = rhs_time_rho_e + rhs_pseudo_rho_e - (coeff_time + coeff_pseudo) * rho_e - sum_rho_e;
    diag_00 += coeff_time;
    diag_11 += coeff_time;
    diag_22 += coeff_time;
    diag_33 += coeff_time;
    diag_00 += coeff_pseudo;
    diag_11 += coeff_pseudo;
    diag_22 += coeff_pseudo;
    diag_33 += coeff_pseudo;
    let scalar_diag_idx = diagonal_indices[idx];
    let diag_rank = scalar_diag_idx - scalar_offset;
    let diag_base_0 = start_row_0 + 4u * diag_rank;
    let diag_base_1 = start_row_1 + 4u * diag_rank;
    let diag_base_2 = start_row_2 + 4u * diag_rank;
    let diag_base_3 = start_row_3 + 4u * diag_rank;
    matrix_values[diag_base_0 + 0u] = diag_00;
    matrix_values[diag_base_0 + 1u] = diag_01;
    matrix_values[diag_base_0 + 2u] = diag_02;
    matrix_values[diag_base_0 + 3u] = diag_03;
    matrix_values[diag_base_1 + 0u] = diag_10;
    matrix_values[diag_base_1 + 1u] = diag_11;
    matrix_values[diag_base_1 + 2u] = diag_12;
    matrix_values[diag_base_1 + 3u] = diag_13;
    matrix_values[diag_base_2 + 0u] = diag_20;
    matrix_values[diag_base_2 + 1u] = diag_21;
    matrix_values[diag_base_2 + 2u] = diag_22;
    matrix_values[diag_base_2 + 3u] = diag_23;
    matrix_values[diag_base_3 + 0u] = diag_30;
    matrix_values[diag_base_3 + 1u] = diag_31;
    matrix_values[diag_base_3 + 2u] = diag_32;
    matrix_values[diag_base_3 + 3u] = diag_33;
    rhs[4u * idx + 0u] = rhs_rho;
    rhs[4u * idx + 1u] = rhs_rho_u_x;
    rhs[4u * idx + 2u] = rhs_rho_u_y;
    rhs[4u * idx + 3u] = rhs_rho_e;
}
