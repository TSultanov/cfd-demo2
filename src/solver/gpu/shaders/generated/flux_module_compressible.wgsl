// GENERATED BY CFD2 CODEGEN (flux_module)

// DO NOT EDIT MANUALLY

struct Vector2 {
    x: f32,
    y: f32,
}

struct Constants {
    dt: f32,
    dt_old: f32,
    dtau: f32,
    time: f32,
    viscosity: f32,
    density: f32,
    component: u32,
    alpha_p: f32,
    scheme: u32,
    alpha_u: f32,
    stride_x: u32,
    time_scheme: u32,
    eos_gamma: f32,
    eos_gm1: f32,
    eos_r: f32,
    eos_dp_drho: f32,
    eos_p_offset: f32,
    eos_theta_ref: f32,
}

struct LowMachParams {
    model: u32,
    theta_floor: f32,
    pressure_coupling_alpha: f32,
    _pad0: f32,
}

// Group 0: Mesh

@group(0) @binding(0) 
var<storage, read> face_owner: array<u32>;

@group(0) @binding(1) 
var<storage, read> face_neighbor: array<i32>;

@group(0) @binding(2) 
var<storage, read> face_areas: array<f32>;

@group(0) @binding(3) 
var<storage, read> face_normals: array<Vector2>;

@group(0) @binding(4) 
var<storage, read> cell_centers: array<Vector2>;

@group(0) @binding(12) 
var<storage, read> face_boundary: array<u32>;

@group(0) @binding(13) 
var<storage, read> face_centers: array<Vector2>;

// Group 1: Fields

@group(1) @binding(0) 
var<storage, read_write> state: array<f32>;

@group(1) @binding(1) 
var<storage, read> state_old: array<f32>;

@group(1) @binding(2) 
var<storage, read> state_old_old: array<f32>;

@group(1) @binding(3) 
var<storage, read_write> fluxes: array<f32>;

@group(1) @binding(4) 
var<uniform> constants: Constants;

@group(1) @binding(5) 
var<uniform> low_mach_params: LowMachParams;

// Group 2: Boundary conditions (per face x unknown)

@group(2) @binding(0) 
var<storage, read> bc_kind: array<u32>;

@group(2) @binding(1) 
var<storage, read> bc_value: array<f32>;

fn bc_neighbor_scalar(interior: f32, owner: f32, kind: u32, value: f32, d_own: f32, is_boundary: bool) -> f32 {
    var boundary: f32 = owner;
    if (kind == 1u) {
        boundary = value;
    }
    if (kind == 2u) {
        boundary = owner + value * d_own;
    }
    return select(interior, boundary, is_boundary);
}

@compute
@workgroup_size(64)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let idx = global_id.y * constants.stride_x + global_id.x;
    if (idx >= arrayLength(&face_areas)) {
        return;
    }
    let owner = face_owner[idx];
    let neighbor = face_neighbor[idx];
    let is_boundary = neighbor == -1;
    var neigh_idx: u32 = owner;
    if (neighbor != -1) {
        neigh_idx = u32(neighbor);
    }
    let area = face_areas[idx];
    let boundary_type = face_boundary[idx];
    let face_center = face_centers[idx];
    var normal_vec: vec2<f32> = vec2<f32>(face_normals[idx].x, face_normals[idx].y);
    let c_owner = cell_centers[owner];
    let c_owner_vec: vec2<f32> = vec2<f32>(c_owner.x, c_owner.y);
    let face_center_vec: vec2<f32> = vec2<f32>(face_center.x, face_center.y);
    if (dot(face_center_vec - c_owner_vec, normal_vec) < 0.0) {
        normal_vec = -normal_vec;
    }
    let c_neigh = cell_centers[neigh_idx];
    var c_neigh_vec: vec2<f32> = vec2<f32>(c_neigh.x, c_neigh.y);
    let c_neigh_cell_vec: vec2<f32> = c_neigh_vec;
    if (is_boundary) {
        c_neigh_vec = face_center_vec;
    }
    let d_own = abs(dot(face_center_vec - c_owner_vec, normal_vec));
    let d_neigh = abs(dot(c_neigh_vec - face_center_vec, normal_vec));
    let total_dist = d_own + d_neigh;
    var lambda: f32 = 0.5;
    if (total_dist > 0.000001) {
        lambda = d_neigh / total_dist;
    }
    let lambda_other = 1.0 - lambda;
    let d_vec: vec2<f32> = c_neigh_vec - c_owner_vec;
    let dist_proj = abs(dot(d_vec, normal_vec));
    let dist = max(dist_proj, 0.000001);
    let s_own_T = bc_neighbor_scalar(state[owner * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_own_grad_T_x = state[owner * 22u + 16u];
    let s_own_grad_T_y = state[owner * 22u + 17u];
    let s_own_grad_rho_x = state[owner * 22u + 12u];
    let s_own_grad_rho_y = state[owner * 22u + 13u];
    let s_own_grad_rho_u_x_x = state[owner * 22u + 3u];
    let s_own_grad_rho_u_x_y = state[owner * 22u + 4u];
    let s_own_grad_rho_u_y_x = state[owner * 22u + 5u];
    let s_own_grad_rho_u_y_y = state[owner * 22u + 6u];
    let s_own_grad_u_x_x = state[owner * 22u + 18u];
    let s_own_grad_u_x_y = state[owner * 22u + 19u];
    let s_own_grad_u_y_x = state[owner * 22u + 20u];
    let s_own_grad_u_y_y = state[owner * 22u + 21u];
    let s_own_rho = bc_neighbor_scalar(state[owner * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_own_rho_u_x = select(bc_neighbor_scalar(state[owner * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_own_rho_u_y = select(bc_neighbor_scalar(state[owner * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let s_own_u_x = select(bc_neighbor_scalar(state[owner * 22u + 10u], state[owner * 22u + 10u], bc_kind[idx * 8u + 4u], bc_value[idx * 8u + 4u], d_own, is_boundary), state[owner * 22u + 10u] - (state[owner * 22u + 10u] * normal_vec.x + state[owner * 22u + 11u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_own_u_y = select(bc_neighbor_scalar(state[owner * 22u + 11u], state[owner * 22u + 11u], bc_kind[idx * 8u + 5u], bc_value[idx * 8u + 5u], d_own, is_boundary), state[owner * 22u + 11u] - (state[owner * 22u + 10u] * normal_vec.x + state[owner * 22u + 11u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let s_neigh_T = bc_neighbor_scalar(state[neigh_idx * 22u + 9u], state[owner * 22u + 9u], bc_kind[idx * 8u + 7u], bc_value[idx * 8u + 7u], d_own, is_boundary);
    let s_neigh_grad_T_x = select(state[neigh_idx * 22u + 16u], state[owner * 22u + 16u], is_boundary);
    let s_neigh_grad_T_y = select(state[neigh_idx * 22u + 17u], state[owner * 22u + 17u], is_boundary);
    let s_neigh_grad_rho_x = select(state[neigh_idx * 22u + 12u], state[owner * 22u + 12u], is_boundary);
    let s_neigh_grad_rho_y = select(state[neigh_idx * 22u + 13u], state[owner * 22u + 13u], is_boundary);
    let s_neigh_grad_rho_u_x_x = select(state[neigh_idx * 22u + 3u], state[owner * 22u + 3u], is_boundary);
    let s_neigh_grad_rho_u_x_y = select(state[neigh_idx * 22u + 4u], state[owner * 22u + 4u], is_boundary);
    let s_neigh_grad_rho_u_y_x = select(state[neigh_idx * 22u + 5u], state[owner * 22u + 5u], is_boundary);
    let s_neigh_grad_rho_u_y_y = select(state[neigh_idx * 22u + 6u], state[owner * 22u + 6u], is_boundary);
    let s_neigh_grad_u_x_x = select(state[neigh_idx * 22u + 18u], state[owner * 22u + 18u], is_boundary);
    let s_neigh_grad_u_x_y = select(state[neigh_idx * 22u + 19u], state[owner * 22u + 19u], is_boundary);
    let s_neigh_grad_u_y_x = select(state[neigh_idx * 22u + 20u], state[owner * 22u + 20u], is_boundary);
    let s_neigh_grad_u_y_y = select(state[neigh_idx * 22u + 21u], state[owner * 22u + 21u], is_boundary);
    let s_neigh_rho = bc_neighbor_scalar(state[neigh_idx * 22u + 0u], state[owner * 22u + 0u], bc_kind[idx * 8u + 0u], bc_value[idx * 8u + 0u], d_own, is_boundary);
    let s_neigh_rho_u_x = select(bc_neighbor_scalar(state[neigh_idx * 22u + 1u], state[owner * 22u + 1u], bc_kind[idx * 8u + 1u], bc_value[idx * 8u + 1u], d_own, is_boundary), state[owner * 22u + 1u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.x, is_boundary && boundary_type == 4u);
    let s_neigh_rho_u_y = select(bc_neighbor_scalar(state[neigh_idx * 22u + 2u], state[owner * 22u + 2u], bc_kind[idx * 8u + 2u], bc_value[idx * 8u + 2u], d_own, is_boundary), state[owner * 22u + 2u] - (state[owner * 22u + 1u] * normal_vec.x + state[owner * 22u + 2u] * normal_vec.y) * normal_vec.y, is_boundary && boundary_type == 4u);
    let _cse_4 = s_own_rho_u_x;
    let _cse_5 = s_own_rho_u_y;
    let _cse_3 = vec2<f32>(_cse_4, _cse_5);
    let _cse_2 = _cse_3 * 1.0 / s_own_rho;
    let _cse_17 = max(0.0, constants.dtau / (constants.dtau + 0.000000000001));
    let _cse_16 = min(1.0, _cse_17);
    let _cse_23 = s_own_rho * constants.eos_r * s_own_T;
    let _cse_22 = constants.eos_gamma * _cse_23;
    let _cse_21 = _cse_22 / s_own_rho;
    let _cse_20 = _cse_21 + constants.eos_dp_drho;
    let _cse_26 = dot(_cse_2, _cse_2);
    let _cse_25 = min(_cse_26, _cse_20);
    let _cse_24 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_25;
    let _cse_19 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_20 + _cse_24;
    let _cse_29 = max(_cse_26, low_mach_params.theta_floor * _cse_20);
    let _cse_28 = min(_cse_29, _cse_20);
    let _cse_27 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_28;
    let _cse_18 = _cse_19 + _cse_27;
    let _cse_15 = _cse_16 * _cse_18;
    let _cse_14 = _cse_15 + (1.0 - _cse_16) * _cse_20;
    let _cse_13 = _cse_14 / max(_cse_20, 0.000000000001);
    let _cse_12 = sqrt(_cse_13);
    let _cse_11 = sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * _cse_12;
    let _cse_10 = _cse_11 * area;
    let _cse_9 = dot(_cse_2, normal_vec * area) + _cse_10;
    let _cse_33 = s_neigh_rho_u_x;
    let _cse_34 = s_neigh_rho_u_y;
    let _cse_32 = vec2<f32>(_cse_33, _cse_34);
    let _cse_31 = _cse_32 * 1.0 / s_neigh_rho;
    let _cse_46 = s_neigh_rho * constants.eos_r * s_neigh_T;
    let _cse_45 = constants.eos_gamma * _cse_46;
    let _cse_44 = _cse_45 / s_neigh_rho;
    let _cse_43 = _cse_44 + constants.eos_dp_drho;
    let _cse_49 = dot(_cse_31, _cse_31);
    let _cse_48 = min(_cse_49, _cse_43);
    let _cse_47 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_48;
    let _cse_42 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_43 + _cse_47;
    let _cse_52 = max(_cse_49, low_mach_params.theta_floor * _cse_43);
    let _cse_51 = min(_cse_52, _cse_43);
    let _cse_50 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_51;
    let _cse_41 = _cse_42 + _cse_50;
    let _cse_40 = _cse_16 * _cse_41;
    let _cse_39 = _cse_40 + (1.0 - _cse_16) * _cse_43;
    let _cse_38 = _cse_39 / max(_cse_43, 0.000000000001);
    let _cse_37 = sqrt(_cse_38);
    let _cse_36 = sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * _cse_37;
    let _cse_35 = _cse_36 * area;
    let _cse_30 = dot(_cse_31, normal_vec * area) + _cse_35;
    let _cse_8 = max(_cse_9, _cse_30);
    let _cse_7 = max(_cse_8, 0.0);
    let _cse_57 = dot(_cse_2, normal_vec * area) - _cse_10;
    let _cse_58 = dot(_cse_31, normal_vec * area) - _cse_35;
    let _cse_56 = min(_cse_57, _cse_58);
    let _cse_55 = min(_cse_56, 0.0);
    let _cse_54 = _cse_7 - _cse_55;
    let _cse_53 = max(_cse_54, 0.000001);
    let _cse_6 = _cse_7 / _cse_53;
    let _cse_1 = dot(_cse_2, normal_vec * area) * _cse_6;
    let _cse_59 = _cse_55 * _cse_6;
    let _cse_0 = _cse_1 - _cse_59;
    let _cse_62 = 1.0 - _cse_6;
    let _cse_61 = dot(_cse_31, normal_vec * area) * _cse_62;
    let _cse_60 = _cse_61 + _cse_59;
    let _cse_63 = _cse_6 * _cse_23 + _cse_62 * _cse_46;
    var phi_0: f32 = _cse_0 * s_own_rho + _cse_60 * s_neigh_rho + low_mach_params.pressure_coupling_alpha * (_cse_23 - _cse_46) * 0.5 * (1.0 / max(_cse_20, 0.000000000001) + 1.0 / max(_cse_43, 0.000000000001)) * _cse_16 * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
    var phi_1: f32 = _cse_0 * _cse_3.x + _cse_60 * _cse_32.x + _cse_63 * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
    var phi_2: f32 = _cse_0 * _cse_3.y + _cse_60 * _cse_32.y + _cse_63 * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
    var phi_3: f32 = _cse_0 * (_cse_23 / max(constants.eos_gm1, 0.000000000001) + 0.5 * s_own_rho * _cse_26 + _cse_23) + _cse_60 * (_cse_46 / max(constants.eos_gm1, 0.000000000001) + 0.5 * s_neigh_rho * _cse_49 + _cse_46) + _cse_59 * (_cse_23 - _cse_46) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_2 * _cse_6 + _cse_31 * _cse_62) * area;
    var phi_4: f32 = 0.0;
    var phi_5: f32 = 0.0;
    var phi_6: f32 = 0.0;
    var phi_7: f32 = 0.0;
    if (constants.scheme == 1u && !is_boundary) {
        let _cse_67 = vec2<f32>(s_own_rho_u_x + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), s_own_rho_u_y + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec));
        let _cse_69 = dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec);
        let _cse_68 = s_own_rho + _cse_69;
        let _cse_66 = _cse_67 * 1.0 / _cse_68;
        let _cse_85 = _cse_68 * constants.eos_r * (s_own_T + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec));
        let _cse_84 = constants.eos_gamma * _cse_85;
        let _cse_83 = _cse_84 / _cse_68;
        let _cse_82 = _cse_83 + constants.eos_dp_drho;
        let _cse_88 = dot(_cse_66, _cse_66);
        let _cse_87 = min(_cse_88, _cse_82);
        let _cse_86 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_87;
        let _cse_81 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_82 + _cse_86;
        let _cse_91 = max(_cse_88, low_mach_params.theta_floor * _cse_82);
        let _cse_90 = min(_cse_91, _cse_82);
        let _cse_89 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_90;
        let _cse_80 = _cse_81 + _cse_89;
        let _cse_79 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_80;
        let _cse_78 = _cse_79 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_82;
        let _cse_77 = _cse_78 / max(_cse_82, 0.000000000001);
        let _cse_76 = sqrt(_cse_77);
        let _cse_75 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), face_center_vec - c_owner_vec)) * _cse_76;
        let _cse_74 = _cse_75 * area;
        let _cse_73 = dot(_cse_66, normal_vec * area) + _cse_74;
        let _cse_95 = s_neigh_rho_u_x + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_96 = s_neigh_rho_u_y + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec);
        let _cse_94 = vec2<f32>(_cse_95, _cse_96);
        let _cse_99 = vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary));
        let _cse_98 = dot(_cse_99, face_center_vec - c_neigh_cell_vec);
        let _cse_97 = s_neigh_rho + _cse_98;
        let _cse_93 = _cse_94 * 1.0 / _cse_97;
        let _cse_111 = _cse_97 * constants.eos_r * (s_neigh_T + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec));
        let _cse_110 = constants.eos_gamma * _cse_111;
        let _cse_109 = _cse_110 / _cse_97;
        let _cse_108 = _cse_109 + constants.eos_dp_drho;
        let _cse_114 = dot(_cse_93, _cse_93);
        let _cse_113 = min(_cse_114, _cse_108);
        let _cse_112 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_113;
        let _cse_107 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_108 + _cse_112;
        let _cse_117 = max(_cse_114, low_mach_params.theta_floor * _cse_108);
        let _cse_116 = min(_cse_117, _cse_108);
        let _cse_115 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_116;
        let _cse_106 = _cse_107 + _cse_115;
        let _cse_105 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_106;
        let _cse_104 = _cse_105 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_108;
        let _cse_103 = _cse_104 / max(_cse_108, 0.000000000001);
        let _cse_102 = sqrt(_cse_103);
        let _cse_101 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), face_center_vec - c_neigh_cell_vec)) * _cse_102;
        let _cse_100 = _cse_101 * area;
        let _cse_92 = dot(_cse_93, normal_vec * area) + _cse_100;
        let _cse_72 = max(_cse_73, _cse_92);
        let _cse_71 = max(_cse_72, 0.0);
        let _cse_122 = dot(_cse_66, normal_vec * area) - _cse_74;
        let _cse_123 = dot(_cse_93, normal_vec * area) - _cse_100;
        let _cse_121 = min(_cse_122, _cse_123);
        let _cse_120 = min(_cse_121, 0.0);
        let _cse_119 = _cse_71 - _cse_120;
        let _cse_118 = max(_cse_119, 0.000001);
        let _cse_70 = _cse_71 / _cse_118;
        let _cse_65 = dot(_cse_66, normal_vec * area) * _cse_70;
        let _cse_124 = _cse_120 * _cse_70;
        let _cse_64 = _cse_65 - _cse_124;
        let _cse_127 = 1.0 - _cse_70;
        let _cse_126 = dot(_cse_93, normal_vec * area) * _cse_127;
        let _cse_125 = _cse_126 + _cse_124;
        phi_0 = _cse_64 * _cse_68 + _cse_125 * _cse_97 + low_mach_params.pressure_coupling_alpha * (_cse_85 - _cse_111) * 0.5 * (1.0 / max(_cse_82, 0.000000000001) + 1.0 / max(_cse_108, 0.000000000001)) * min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_64 * _cse_67.x + _cse_125 * _cse_94.x + (_cse_70 * _cse_85 + _cse_127 * _cse_111) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_64 * _cse_67.y + _cse_125 * _cse_94.y + (_cse_70 * _cse_85 + _cse_127 * _cse_111) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_64 * (_cse_85 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_68 * _cse_88 + _cse_85) + _cse_125 * (_cse_111 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_97 * _cse_114 + _cse_111) + _cse_124 * (_cse_85 - _cse_111) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_66 * _cse_70 + _cse_93 * _cse_127) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 2u && !is_boundary) {
        let _cse_131 = vec2<f32>(s_own_rho_u_x + s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x, s_own_rho_u_y + s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y);
        let _cse_134 = s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125;
        let _cse_133 = _cse_134 - s_own_rho;
        let _cse_132 = s_own_rho + _cse_133;
        let _cse_130 = _cse_131 * 1.0 / _cse_132;
        let _cse_148 = constants.eos_gamma * _cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) / _cse_132;
        let _cse_147 = _cse_148 + constants.eos_dp_drho;
        let _cse_151 = dot(_cse_130, _cse_130);
        let _cse_150 = min(_cse_151, _cse_147);
        let _cse_149 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_150;
        let _cse_146 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_147 + _cse_149;
        let _cse_154 = max(_cse_151, low_mach_params.theta_floor * _cse_147);
        let _cse_153 = min(_cse_154, _cse_147);
        let _cse_152 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_153;
        let _cse_145 = _cse_146 + _cse_152;
        let _cse_144 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_145;
        let _cse_143 = _cse_144 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_147;
        let _cse_142 = _cse_143 / max(_cse_147, 0.000000000001);
        let _cse_141 = sqrt(_cse_142);
        let _cse_140 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * _cse_141;
        let _cse_139 = _cse_140 * area;
        let _cse_138 = dot(_cse_130, normal_vec * area) + _cse_139;
        let _cse_158 = s_neigh_rho_u_x + s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x;
        let _cse_159 = s_neigh_rho_u_y + s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y;
        let _cse_157 = vec2<f32>(_cse_158, _cse_159);
        let _cse_163 = dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_162 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + _cse_163;
        let _cse_161 = _cse_162 - s_neigh_rho;
        let _cse_160 = s_neigh_rho + _cse_161;
        let _cse_156 = _cse_157 * 1.0 / _cse_160;
        let _cse_175 = _cse_160 * constants.eos_r * (s_neigh_T + s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T);
        let _cse_174 = constants.eos_gamma * _cse_175;
        let _cse_173 = _cse_174 / _cse_160;
        let _cse_172 = _cse_173 + constants.eos_dp_drho;
        let _cse_178 = dot(_cse_156, _cse_156);
        let _cse_177 = min(_cse_178, _cse_172);
        let _cse_176 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_177;
        let _cse_171 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_172 + _cse_176;
        let _cse_181 = max(_cse_178, low_mach_params.theta_floor * _cse_172);
        let _cse_180 = min(_cse_181, _cse_172);
        let _cse_179 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_180;
        let _cse_170 = _cse_171 + _cse_179;
        let _cse_169 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_170;
        let _cse_168 = _cse_169 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_172;
        let _cse_167 = _cse_168 / max(_cse_172, 0.000000000001);
        let _cse_166 = sqrt(_cse_167);
        let _cse_165 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * _cse_166;
        let _cse_164 = _cse_165 * area;
        let _cse_155 = dot(_cse_156, normal_vec * area) + _cse_164;
        let _cse_137 = max(_cse_138, _cse_155);
        let _cse_136 = max(_cse_137, 0.0);
        let _cse_186 = dot(_cse_130, normal_vec * area) - _cse_139;
        let _cse_187 = dot(_cse_156, normal_vec * area) - _cse_164;
        let _cse_185 = min(_cse_186, _cse_187);
        let _cse_184 = min(_cse_185, 0.0);
        let _cse_183 = _cse_136 - _cse_184;
        let _cse_182 = max(_cse_183, 0.000001);
        let _cse_135 = _cse_136 / _cse_182;
        let _cse_129 = dot(_cse_130, normal_vec * area) * _cse_135;
        let _cse_188 = _cse_184 * _cse_135;
        let _cse_128 = _cse_129 - _cse_188;
        let _cse_191 = 1.0 - _cse_135;
        let _cse_190 = dot(_cse_156, normal_vec * area) * _cse_191;
        let _cse_189 = _cse_190 + _cse_188;
        phi_0 = _cse_128 * _cse_132 + _cse_189 * _cse_160 + low_mach_params.pressure_coupling_alpha * (_cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) - _cse_175) * 0.5 * (1.0 / max(_cse_147, 0.000000000001) + 1.0 / max(_cse_172, 0.000000000001)) * min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_128 * _cse_131.x + _cse_189 * _cse_157.x + (_cse_135 * _cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + _cse_191 * _cse_175) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_128 * _cse_131.y + _cse_189 * _cse_157.y + (_cse_135 * _cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + _cse_191 * _cse_175) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_128 * (_cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_132 * _cse_151 + _cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)) + _cse_189 * (_cse_175 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_160 * _cse_178 + _cse_175) + _cse_188 * (_cse_132 * constants.eos_r * (s_own_T + s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) - _cse_175) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_130 * _cse_135 + _cse_156 * _cse_191) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 3u && !is_boundary) {
        let _cse_196 = s_own_rho_u_x + min(max(dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), face_center_vec - c_owner_vec), min(s_neigh_rho_u_x - s_own_rho_u_x, 0.0)), max(s_neigh_rho_u_x - s_own_rho_u_x, 0.0));
        let _cse_197 = s_own_rho_u_y + min(max(dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), face_center_vec - c_owner_vec), min(s_neigh_rho_u_y - s_own_rho_u_y, 0.0)), max(s_neigh_rho_u_y - s_own_rho_u_y, 0.0));
        let _cse_195 = vec2<f32>(_cse_196, _cse_197);
        let _cse_199 = min(max(dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), face_center_vec - c_owner_vec), min(s_neigh_rho - s_own_rho, 0.0)), max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_198 = s_own_rho + _cse_199;
        let _cse_194 = _cse_195 * 1.0 / _cse_198;
        let _cse_213 = constants.eos_gamma * _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / _cse_198;
        let _cse_212 = _cse_213 + constants.eos_dp_drho;
        let _cse_216 = dot(_cse_194, _cse_194);
        let _cse_215 = min(_cse_216, _cse_212);
        let _cse_214 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_215;
        let _cse_211 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_212 + _cse_214;
        let _cse_219 = max(_cse_216, low_mach_params.theta_floor * _cse_212);
        let _cse_218 = min(_cse_219, _cse_212);
        let _cse_217 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_218;
        let _cse_210 = _cse_211 + _cse_217;
        let _cse_209 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_210;
        let _cse_208 = _cse_209 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_212;
        let _cse_207 = _cse_208 / max(_cse_212, 0.000000000001);
        let _cse_206 = sqrt(_cse_207);
        let _cse_205 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), face_center_vec - c_owner_vec), min(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0))) * _cse_206;
        let _cse_204 = _cse_205 * area;
        let _cse_203 = dot(_cse_194, normal_vec * area) + _cse_204;
        let _cse_223 = s_neigh_rho_u_x + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_rho_u_x - s_neigh_rho_u_x, 0.0)), max(s_own_rho_u_x - s_neigh_rho_u_x, 0.0));
        let _cse_224 = s_neigh_rho_u_y + min(max(dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_rho_u_y - s_neigh_rho_u_y, 0.0)), max(s_own_rho_u_y - s_neigh_rho_u_y, 0.0));
        let _cse_222 = vec2<f32>(_cse_223, _cse_224);
        let _cse_227 = max(dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_226 = min(_cse_227, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_225 = s_neigh_rho + _cse_226;
        let _cse_221 = _cse_222 * 1.0 / _cse_225;
        let _cse_239 = _cse_225 * constants.eos_r * (s_neigh_T + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), face_center_vec - c_neigh_cell_vec), min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_238 = constants.eos_gamma * _cse_239;
        let _cse_237 = _cse_238 / _cse_225;
        let _cse_236 = _cse_237 + constants.eos_dp_drho;
        let _cse_242 = dot(_cse_221, _cse_221);
        let _cse_241 = min(_cse_242, _cse_236);
        let _cse_240 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_241;
        let _cse_235 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_236 + _cse_240;
        let _cse_245 = max(_cse_242, low_mach_params.theta_floor * _cse_236);
        let _cse_244 = min(_cse_245, _cse_236);
        let _cse_243 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_244;
        let _cse_234 = _cse_235 + _cse_243;
        let _cse_233 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_234;
        let _cse_232 = _cse_233 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_236;
        let _cse_231 = _cse_232 / max(_cse_236, 0.000000000001);
        let _cse_230 = sqrt(_cse_231);
        let _cse_229 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + min(max(dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), face_center_vec - c_neigh_cell_vec), min(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0))) * _cse_230;
        let _cse_228 = _cse_229 * area;
        let _cse_220 = dot(_cse_221, normal_vec * area) + _cse_228;
        let _cse_202 = max(_cse_203, _cse_220);
        let _cse_201 = max(_cse_202, 0.0);
        let _cse_250 = dot(_cse_194, normal_vec * area) - _cse_204;
        let _cse_251 = dot(_cse_221, normal_vec * area) - _cse_228;
        let _cse_249 = min(_cse_250, _cse_251);
        let _cse_248 = min(_cse_249, 0.0);
        let _cse_247 = _cse_201 - _cse_248;
        let _cse_246 = max(_cse_247, 0.000001);
        let _cse_200 = _cse_201 / _cse_246;
        let _cse_193 = dot(_cse_194, normal_vec * area) * _cse_200;
        let _cse_252 = _cse_248 * _cse_200;
        let _cse_192 = _cse_193 - _cse_252;
        let _cse_255 = 1.0 - _cse_200;
        let _cse_254 = dot(_cse_221, normal_vec * area) * _cse_255;
        let _cse_253 = _cse_254 + _cse_252;
        phi_0 = _cse_192 * _cse_198 + _cse_253 * _cse_225 + low_mach_params.pressure_coupling_alpha * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_239) * 0.5 * (1.0 / max(_cse_212, 0.000000000001) + 1.0 / max(_cse_236, 0.000000000001)) * min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_192 * _cse_195.x + _cse_253 * _cse_222.x + (_cse_200 * _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_255 * _cse_239) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_192 * _cse_195.y + _cse_253 * _cse_222.y + (_cse_200 * _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_255 * _cse_239) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_192 * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_198 * _cse_216 + _cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)))) + _cse_253 * (_cse_239 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_225 * _cse_242 + _cse_239) + _cse_252 * (_cse_198 * constants.eos_r * (s_own_T + min(max(dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), face_center_vec - c_owner_vec), min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_239) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_194 * _cse_200 + _cse_221 * _cse_255) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 4u && !is_boundary) {
        let _cse_260 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - vec2<f32>(s_own_rho_u_x, s_own_rho_u_y);
        let _cse_261 = dot(_cse_260, _cse_260);
        let _cse_259 = _cse_260 * (max(-2001.0, min(2.0 * dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_261 / (_cse_261 * _cse_261 + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_261 / (_cse_261 * _cse_261 + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y)), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y)))) * _cse_261 / (_cse_261 * _cse_261 + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other;
        let _cse_258 = vec2<f32>(s_own_rho_u_x, s_own_rho_u_y) + _cse_259;
        let _cse_265 = (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y)) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0, 1999.0))));
        let _cse_264 = _cse_265 * lambda_other;
        let _cse_263 = _cse_264 * (s_neigh_rho - s_own_rho);
        let _cse_262 = s_own_rho + _cse_263;
        let _cse_257 = _cse_258 * 1.0 / _cse_262;
        let _cse_278 = constants.eos_gamma * _cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / _cse_262;
        let _cse_277 = _cse_278 + constants.eos_dp_drho;
        let _cse_279 = dot(_cse_257, _cse_257);
        let _cse_276 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_277 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_279, _cse_277) + max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * min(max(_cse_279, low_mach_params.theta_floor * _cse_277), _cse_277);
        let _cse_275 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_276;
        let _cse_274 = _cse_275 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_277;
        let _cse_273 = _cse_274 / max(_cse_277, 0.000000000001);
        let _cse_272 = sqrt(_cse_273);
        let _cse_271 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T))) * _cse_272;
        let _cse_270 = _cse_271 * area;
        let _cse_269 = dot(_cse_257, normal_vec * area) + _cse_270;
        let _cse_290 = dot(_cse_260, vec2<f32>(dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary))), dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary))))) * _cse_261 / (_cse_261 * _cse_261 + 0.000000000000000000000000000001);
        let _cse_289 = 2.0 * _cse_290;
        let _cse_288 = _cse_289 - 1.0;
        let _cse_287 = min(_cse_288, 1999.0);
        let _cse_286 = max(-2001.0, _cse_287);
        let _cse_285 = (_cse_286 + abs(_cse_286)) / (1.0 + abs(_cse_286));
        let _cse_284 = _cse_285 * lambda;
        let _cse_283 = _cse_260 * _cse_284;
        let _cse_282 = vec2<f32>(s_neigh_rho_u_x, s_neigh_rho_u_y) - _cse_283;
        let _cse_297 = 2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary))) * (s_neigh_rho - s_own_rho) / ((s_neigh_rho - s_own_rho) * (s_neigh_rho - s_own_rho) + 0.000000000000000000000000000001) - 1.0;
        let _cse_296 = min(_cse_297, 1999.0);
        let _cse_295 = max(-2001.0, _cse_296);
        let _cse_294 = (_cse_295 + abs(_cse_295)) / (1.0 + abs(_cse_295));
        let _cse_293 = _cse_294 * lambda;
        let _cse_292 = _cse_293 * (s_neigh_rho - s_own_rho);
        let _cse_291 = s_neigh_rho - _cse_292;
        let _cse_281 = _cse_282 * 1.0 / _cse_291;
        let _cse_307 = constants.eos_gamma * _cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) / _cse_291;
        let _cse_306 = _cse_307 + constants.eos_dp_drho;
        let _cse_308 = dot(_cse_281, _cse_281);
        let _cse_305 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_306 + max(0.0, 1.0 - abs(f32(low_mach_params.model))) * min(_cse_308, _cse_306);
        let _cse_310 = min(max(_cse_308, low_mach_params.theta_floor * _cse_306), _cse_306);
        let _cse_309 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_310;
        let _cse_304 = _cse_305 + _cse_309;
        let _cse_303 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_304;
        let _cse_302 = _cse_303 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_306;
        let _cse_301 = _cse_302 / max(_cse_306, 0.000000000001);
        let _cse_300 = sqrt(_cse_301);
        let _cse_299 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / ((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T))) * _cse_300;
        let _cse_298 = _cse_299 * area;
        let _cse_280 = dot(_cse_281, normal_vec * area) + _cse_298;
        let _cse_268 = max(_cse_269, _cse_280);
        let _cse_267 = max(_cse_268, 0.0);
        let _cse_315 = dot(_cse_257, normal_vec * area) - _cse_270;
        let _cse_316 = dot(_cse_281, normal_vec * area) - _cse_298;
        let _cse_314 = min(_cse_315, _cse_316);
        let _cse_313 = min(_cse_314, 0.0);
        let _cse_312 = _cse_267 - _cse_313;
        let _cse_311 = max(_cse_312, 0.000001);
        let _cse_266 = _cse_267 / _cse_311;
        let _cse_317 = _cse_313 * _cse_266;
        let _cse_256 = dot(_cse_257, normal_vec * area) * _cse_266 - _cse_317;
        let _cse_319 = 1.0 - _cse_266;
        let _cse_318 = dot(_cse_281, normal_vec * area) * _cse_319 + _cse_317;
        phi_0 = _cse_256 * _cse_262 + _cse_318 * _cse_291 + low_mach_params.pressure_coupling_alpha * (_cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) - _cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) * 0.5 * (1.0 / max(_cse_277, 0.000000000001) + 1.0 / max(_cse_306, 0.000000000001)) * min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_256 * _cse_258.x + _cse_318 * _cse_282.x + (_cse_266 * _cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) + _cse_319 * _cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_256 * _cse_258.y + _cse_318 * _cse_282.y + (_cse_266 * _cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) + _cse_319 * _cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_256 * (_cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_262 * _cse_279 + _cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T))) + _cse_318 * (_cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T)) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_291 * _cse_308 + _cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) + _cse_317 * (_cse_262 * constants.eos_r * (s_own_T + (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(s_own_grad_T_x, s_own_grad_T_y)) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda_other * (s_neigh_T - s_own_T)) - _cse_291 * constants.eos_r * (s_neigh_T - (max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)) + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) / (1.0 + abs(max(-2001.0, min(2.0 * dot(c_neigh_cell_vec - c_owner_vec, vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary))) * (s_neigh_T - s_own_T) / ((s_neigh_T - s_own_T) * (s_neigh_T - s_own_T) + 0.000000000000000000000000000001) - 1.0, 1999.0)))) * lambda * (s_neigh_T - s_own_T))) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_257 * _cse_266 + _cse_281 * _cse_319) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 5u && !is_boundary) {
        let _cse_324 = s_own_rho_u_x + min(max(s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x, min(s_neigh_rho_u_x - s_own_rho_u_x, 0.0)), max(s_neigh_rho_u_x - s_own_rho_u_x, 0.0));
        let _cse_325 = s_own_rho_u_y + min(max(s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y, min(s_neigh_rho_u_y - s_own_rho_u_y, 0.0)), max(s_neigh_rho_u_y - s_own_rho_u_y, 0.0));
        let _cse_323 = vec2<f32>(_cse_324, _cse_325);
        let _cse_327 = min(max(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho, min(s_neigh_rho - s_own_rho, 0.0)), max(s_neigh_rho - s_own_rho, 0.0));
        let _cse_326 = s_own_rho + _cse_327;
        let _cse_322 = _cse_323 * 1.0 / _cse_326;
        let _cse_341 = constants.eos_gamma * _cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / _cse_326;
        let _cse_340 = _cse_341 + constants.eos_dp_drho;
        let _cse_344 = dot(_cse_322, _cse_322);
        let _cse_343 = min(_cse_344, _cse_340);
        let _cse_342 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_343;
        let _cse_339 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_340 + _cse_342;
        let _cse_347 = max(_cse_344, low_mach_params.theta_floor * _cse_340);
        let _cse_346 = min(_cse_347, _cse_340);
        let _cse_345 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_346;
        let _cse_338 = _cse_339 + _cse_345;
        let _cse_337 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_338;
        let _cse_336 = _cse_337 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_340;
        let _cse_335 = _cse_336 / max(_cse_340, 0.000000000001);
        let _cse_334 = sqrt(_cse_335);
        let _cse_333 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + min(max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), min(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.0))) * _cse_334;
        let _cse_332 = _cse_333 * area;
        let _cse_331 = dot(_cse_322, normal_vec * area) + _cse_332;
        let _cse_351 = s_neigh_rho_u_x + min(max(s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x, min(s_own_rho_u_x - s_neigh_rho_u_x, 0.0)), max(s_own_rho_u_x - s_neigh_rho_u_x, 0.0));
        let _cse_352 = s_neigh_rho_u_y + min(max(s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y, min(s_own_rho_u_y - s_neigh_rho_u_y, 0.0)), max(s_own_rho_u_y - s_neigh_rho_u_y, 0.0));
        let _cse_350 = vec2<f32>(_cse_351, _cse_352);
        let _cse_355 = max(s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho, min(s_own_rho - s_neigh_rho, 0.0));
        let _cse_354 = min(_cse_355, max(s_own_rho - s_neigh_rho, 0.0));
        let _cse_353 = s_neigh_rho + _cse_354;
        let _cse_349 = _cse_350 * 1.0 / _cse_353;
        let _cse_367 = _cse_353 * constants.eos_r * (s_neigh_T + min(max(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T, min(s_own_T - s_neigh_T, 0.0)), max(s_own_T - s_neigh_T, 0.0)));
        let _cse_366 = constants.eos_gamma * _cse_367;
        let _cse_365 = _cse_366 / _cse_353;
        let _cse_364 = _cse_365 + constants.eos_dp_drho;
        let _cse_370 = dot(_cse_349, _cse_349);
        let _cse_369 = min(_cse_370, _cse_364);
        let _cse_368 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_369;
        let _cse_363 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_364 + _cse_368;
        let _cse_373 = max(_cse_370, low_mach_params.theta_floor * _cse_364);
        let _cse_372 = min(_cse_373, _cse_364);
        let _cse_371 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_372;
        let _cse_362 = _cse_363 + _cse_371;
        let _cse_361 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_362;
        let _cse_360 = _cse_361 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_364;
        let _cse_359 = _cse_360 / max(_cse_364, 0.000000000001);
        let _cse_358 = sqrt(_cse_359);
        let _cse_357 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + min(max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), min(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0)), max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.0))) * _cse_358;
        let _cse_356 = _cse_357 * area;
        let _cse_348 = dot(_cse_349, normal_vec * area) + _cse_356;
        let _cse_330 = max(_cse_331, _cse_348);
        let _cse_329 = max(_cse_330, 0.0);
        let _cse_378 = dot(_cse_322, normal_vec * area) - _cse_332;
        let _cse_379 = dot(_cse_349, normal_vec * area) - _cse_356;
        let _cse_377 = min(_cse_378, _cse_379);
        let _cse_376 = min(_cse_377, 0.0);
        let _cse_375 = _cse_329 - _cse_376;
        let _cse_374 = max(_cse_375, 0.000001);
        let _cse_328 = _cse_329 / _cse_374;
        let _cse_321 = dot(_cse_322, normal_vec * area) * _cse_328;
        let _cse_380 = _cse_376 * _cse_328;
        let _cse_320 = _cse_321 - _cse_380;
        let _cse_383 = 1.0 - _cse_328;
        let _cse_382 = dot(_cse_349, normal_vec * area) * _cse_383;
        let _cse_381 = _cse_382 + _cse_380;
        phi_0 = _cse_320 * _cse_326 + _cse_381 * _cse_353 + low_mach_params.pressure_coupling_alpha * (_cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_367) * 0.5 * (1.0 / max(_cse_340, 0.000000000001) + 1.0 / max(_cse_364, 0.000000000001)) * min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_320 * _cse_323.x + _cse_381 * _cse_350.x + (_cse_328 * _cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_383 * _cse_367) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_320 * _cse_323.y + _cse_381 * _cse_350.y + (_cse_328 * _cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) + _cse_383 * _cse_367) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_320 * (_cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_326 * _cse_344 + _cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0)))) + _cse_381 * (_cse_367 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_353 * _cse_370 + _cse_367) + _cse_380 * (_cse_326 * constants.eos_r * (s_own_T + min(max(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T, min(s_neigh_T - s_own_T, 0.0)), max(s_neigh_T - s_own_T, 0.0))) - _cse_367) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_322 * _cse_328 + _cse_349 * _cse_383) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    if (constants.scheme == 6u && !is_boundary) {
        let _cse_386 = vec2<f32>(s_own_rho_u_x + (s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x) * abs(s_neigh_rho_u_x - s_own_rho_u_x) / max(abs(s_neigh_rho_u_x - s_own_rho_u_x), abs(s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x) + 0.00000001) * max((s_neigh_rho_u_x - s_own_rho_u_x) * (s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x), 0.0) / max(abs((s_neigh_rho_u_x - s_own_rho_u_x) * (s_own_rho_u_x * 0.625 + s_neigh_rho_u_x * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_x_x, s_own_grad_rho_u_x_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_x)), 0.00000001), s_own_rho_u_y + (s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y) * abs(s_neigh_rho_u_y - s_own_rho_u_y) / max(abs(s_neigh_rho_u_y - s_own_rho_u_y), abs(s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y) + 0.00000001) * max((s_neigh_rho_u_y - s_own_rho_u_y) * (s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y), 0.0) / max(abs((s_neigh_rho_u_y - s_own_rho_u_y) * (s_own_rho_u_y * 0.625 + s_neigh_rho_u_y * 0.375 + dot(vec2<f32>(s_own_grad_rho_u_y_x, s_own_grad_rho_u_y_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho_u_y)), 0.00000001));
        let _cse_388 = (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) * abs(s_neigh_rho - s_own_rho) / max(abs(s_neigh_rho - s_own_rho), abs(s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho) + 0.00000001) * max((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho), 0.0) / max(abs((s_neigh_rho - s_own_rho) * (s_own_rho * 0.625 + s_neigh_rho * 0.375 + dot(vec2<f32>(s_own_grad_rho_x, s_own_grad_rho_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_rho)), 0.00000001);
        let _cse_387 = s_own_rho + _cse_388;
        let _cse_385 = _cse_386 * 1.0 / _cse_387;
        let _cse_402 = constants.eos_gamma * _cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) / _cse_387;
        let _cse_401 = _cse_402 + constants.eos_dp_drho;
        let _cse_405 = dot(_cse_385, _cse_385);
        let _cse_404 = min(_cse_405, _cse_401);
        let _cse_403 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_404;
        let _cse_400 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_401 + _cse_403;
        let _cse_408 = max(_cse_405, low_mach_params.theta_floor * _cse_401);
        let _cse_407 = min(_cse_408, _cse_401);
        let _cse_406 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_407;
        let _cse_399 = _cse_400 + _cse_406;
        let _cse_398 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_399;
        let _cse_397 = _cse_398 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_401;
        let _cse_396 = _cse_397 / max(_cse_401, 0.000000000001);
        let _cse_395 = sqrt(_cse_396);
        let _cse_394 = (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) + (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * abs(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) / max(abs(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)), abs(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) + 0.00000001) * max((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)), 0.0) / max(abs((sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) - sqrt(constants.eos_gamma * constants.eos_r * s_own_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_own_T), 0.000000000001), c_neigh_cell_vec - c_owner_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_own_T))), 0.00000001)) * _cse_395;
        let _cse_393 = _cse_394 * area;
        let _cse_392 = dot(_cse_385, normal_vec * area) + _cse_393;
        let _cse_413 = (s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x) * abs(s_own_rho_u_x - s_neigh_rho_u_x) / max(abs(s_own_rho_u_x - s_neigh_rho_u_x), abs(s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x) + 0.00000001) * max((s_own_rho_u_x - s_neigh_rho_u_x) * (s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x), 0.0) / max(abs((s_own_rho_u_x - s_neigh_rho_u_x) * (s_neigh_rho_u_x * 0.625 + s_own_rho_u_x * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_x_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_x_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_x)), 0.00000001);
        let _cse_412 = s_neigh_rho_u_x + _cse_413;
        let _cse_415 = (s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y) * abs(s_own_rho_u_y - s_neigh_rho_u_y) / max(abs(s_own_rho_u_y - s_neigh_rho_u_y), abs(s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y) + 0.00000001) * max((s_own_rho_u_y - s_neigh_rho_u_y) * (s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y), 0.0) / max(abs((s_own_rho_u_y - s_neigh_rho_u_y) * (s_neigh_rho_u_y * 0.625 + s_own_rho_u_y * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_u_y_x, 0.0, is_boundary), select(s_neigh_grad_rho_u_y_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_rho_u_y)), 0.00000001);
        let _cse_414 = s_neigh_rho_u_y + _cse_415;
        let _cse_411 = vec2<f32>(_cse_412, _cse_414);
        let _cse_419 = s_neigh_rho * 0.625 + s_own_rho * 0.375 + dot(vec2<f32>(select(s_neigh_grad_rho_x, 0.0, is_boundary), select(s_neigh_grad_rho_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125;
        let _cse_418 = _cse_419 - s_neigh_rho;
        let _cse_417 = _cse_418 * abs(s_own_rho - s_neigh_rho) / max(abs(s_own_rho - s_neigh_rho), abs(_cse_418) + 0.00000001) * max((s_own_rho - s_neigh_rho) * _cse_418, 0.0) / max(abs((s_own_rho - s_neigh_rho) * _cse_418), 0.00000001);
        let _cse_416 = s_neigh_rho + _cse_417;
        let _cse_410 = _cse_411 * 1.0 / _cse_416;
        let _cse_431 = _cse_416 * constants.eos_r * (s_neigh_T + (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) * abs(s_own_T - s_neigh_T) / max(abs(s_own_T - s_neigh_T), abs(s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T) + 0.00000001) * max((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T), 0.0) / max(abs((s_own_T - s_neigh_T) * (s_neigh_T * 0.625 + s_own_T * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)), c_owner_vec - c_neigh_cell_vec) * 0.125 - s_neigh_T)), 0.00000001));
        let _cse_430 = constants.eos_gamma * _cse_431;
        let _cse_429 = _cse_430 / _cse_416;
        let _cse_428 = _cse_429 + constants.eos_dp_drho;
        let _cse_434 = dot(_cse_410, _cse_410);
        let _cse_433 = min(_cse_434, _cse_428);
        let _cse_432 = max(0.0, 1.0 - abs(f32(low_mach_params.model))) * _cse_433;
        let _cse_427 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0)) * _cse_428 + _cse_432;
        let _cse_437 = max(_cse_434, low_mach_params.theta_floor * _cse_428);
        let _cse_436 = min(_cse_437, _cse_428);
        let _cse_435 = max(0.0, 1.0 - abs(f32(low_mach_params.model) - 1.0)) * _cse_436;
        let _cse_426 = _cse_427 + _cse_435;
        let _cse_425 = min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * _cse_426;
        let _cse_424 = _cse_425 + (1.0 - min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001)))) * _cse_428;
        let _cse_423 = _cse_424 / max(_cse_428, 0.000000000001);
        let _cse_422 = sqrt(_cse_423);
        let _cse_421 = (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) + (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * abs(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) / max(abs(sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)), abs(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) + 0.00000001) * max((sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)), 0.0) / max(abs((sqrt(constants.eos_gamma * constants.eos_r * s_own_T) - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T)) * (sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T) * 0.625 + sqrt(constants.eos_gamma * constants.eos_r * s_own_T) * 0.375 + dot(vec2<f32>(select(s_neigh_grad_T_x, 0.0, is_boundary), select(s_neigh_grad_T_y, 0.0, is_boundary)) * 0.5 * constants.eos_gamma * constants.eos_r / max(sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T), 0.000000000001), c_owner_vec - c_neigh_cell_vec) * 0.125 - sqrt(constants.eos_gamma * constants.eos_r * s_neigh_T))), 0.00000001)) * _cse_422;
        let _cse_420 = _cse_421 * area;
        let _cse_409 = dot(_cse_410, normal_vec * area) + _cse_420;
        let _cse_391 = max(_cse_392, _cse_409);
        let _cse_390 = max(_cse_391, 0.0);
        let _cse_442 = dot(_cse_385, normal_vec * area) - _cse_393;
        let _cse_443 = dot(_cse_410, normal_vec * area) - _cse_420;
        let _cse_441 = min(_cse_442, _cse_443);
        let _cse_440 = min(_cse_441, 0.0);
        let _cse_439 = _cse_390 - _cse_440;
        let _cse_438 = max(_cse_439, 0.000001);
        let _cse_389 = _cse_390 / _cse_438;
        let _cse_444 = _cse_440 * _cse_389;
        let _cse_384 = dot(_cse_385, normal_vec * area) * _cse_389 - _cse_444;
        let _cse_447 = 1.0 - _cse_389;
        let _cse_446 = dot(_cse_410, normal_vec * area) * _cse_447;
        let _cse_445 = _cse_446 + _cse_444;
        phi_0 = _cse_384 * _cse_387 + _cse_445 * _cse_416 + low_mach_params.pressure_coupling_alpha * (_cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) - _cse_431) * 0.5 * (1.0 / max(_cse_401, 0.000000000001) + 1.0 / max(_cse_428, 0.000000000001)) * min(1.0, max(0.0, constants.dtau / (constants.dtau + 0.000000000001))) * (1.0 - max(0.0, 1.0 - abs(f32(low_mach_params.model) - 2.0))) * area;
        phi_1 = _cse_384 * _cse_386.x + _cse_445 * _cse_411.x + (_cse_389 * _cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) + _cse_447 * _cse_431) * area * normal_vec.x - (constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other) * area;
        phi_2 = _cse_384 * _cse_386.y + _cse_445 * _cse_411.y + (_cse_389 * _cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) + _cse_447 * _cse_431) * area * normal_vec.y - (constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other) * area;
        phi_3 = _cse_384 * (_cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_387 * _cse_405 + _cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001))) + _cse_445 * (_cse_431 / max(constants.eos_gm1, 0.000000000001) + 0.5 * _cse_416 * _cse_434 + _cse_431) + _cse_444 * (_cse_387 * constants.eos_r * (s_own_T + (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) * abs(s_neigh_T - s_own_T) / max(abs(s_neigh_T - s_own_T), abs(s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T) + 0.00000001) * max((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T), 0.0) / max(abs((s_neigh_T - s_own_T) * (s_own_T * 0.625 + s_neigh_T * 0.375 + dot(vec2<f32>(s_own_grad_T_x, s_own_grad_T_y), c_neigh_cell_vec - c_owner_vec) * 0.125 - s_own_T)), 0.00000001)) - _cse_431) - dot(vec2<f32>(dot(vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_x - state[owner * 22u + 10u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_x_x, 0.0, is_boundary), select(s_neigh_grad_u_x_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_x_x, s_own_grad_u_x_y) * lambda_other)), normal_vec), dot(vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other + normal_vec * select(0.0, 1.0, is_boundary) * ((s_own_u_y - state[owner * 22u + 11u]) / max(dist, 0.000001) - dot(normal_vec, vec2<f32>(select(s_neigh_grad_u_y_x, 0.0, is_boundary), select(s_neigh_grad_u_y_y, 0.0, is_boundary)) * lambda + vec2<f32>(s_own_grad_u_y_x, s_own_grad_u_y_y) * lambda_other)), normal_vec)) * constants.viscosity + vec2<f32>(constants.viscosity * ((2.0 * select(s_neigh_grad_u_x_x, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.x + (select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.y) * lambda + constants.viscosity * ((2.0 * s_own_grad_u_x_x - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.x + (s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.y) * lambda_other, constants.viscosity * ((select(s_neigh_grad_u_x_y, 0.0, is_boundary) + select(s_neigh_grad_u_y_x, 0.0, is_boundary)) * normal_vec.x + (2.0 * select(s_neigh_grad_u_y_y, 0.0, is_boundary) - 0.6666667 * (select(s_neigh_grad_u_x_x, 0.0, is_boundary) + select(s_neigh_grad_u_y_y, 0.0, is_boundary))) * normal_vec.y) * lambda + constants.viscosity * ((s_own_grad_u_x_y + s_own_grad_u_y_x) * normal_vec.x + (2.0 * s_own_grad_u_y_y - 0.6666667 * (s_own_grad_u_x_x + s_own_grad_u_y_y)) * normal_vec.y) * lambda_other), _cse_385 * _cse_389 + _cse_410 * _cse_447) * area;
        phi_4 = 0.0;
        phi_5 = 0.0;
        phi_6 = 0.0;
        phi_7 = 0.0;
    }
    fluxes[idx * 8u + 0u] = phi_0;
    fluxes[idx * 8u + 1u] = phi_1;
    fluxes[idx * 8u + 2u] = phi_2;
    fluxes[idx * 8u + 3u] = phi_3;
    fluxes[idx * 8u + 4u] = phi_4;
    fluxes[idx * 8u + 5u] = phi_5;
    fluxes[idx * 8u + 6u] = phi_6;
    fluxes[idx * 8u + 7u] = phi_7;
}
