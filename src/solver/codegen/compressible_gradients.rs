use super::dsl as typed;
use super::state_access::{state_scalar, state_vec2};
use crate::solver::model::CompressibleFields;
use crate::solver::model::backend::StateLayout;
use super::wgsl_ast::{
    AccessMode, AssignOp, Attribute, Block, Expr, Function, GlobalVar, Item, Module, Param, Stmt,
    StructDef, StructField, Type,
};
use super::wgsl_dsl as dsl;

pub fn generate_compressible_gradients_wgsl(
    layout: &StateLayout,
    fields: &CompressibleFields,
) -> String {
    let mut module = Module::new();
    module.push(Item::Comment(
        "GENERATED BY CFD2 CODEGEN (compressible_gradients)".to_string(),
    ));
    module.push(Item::Comment("DO NOT EDIT MANUALLY".to_string()));
    module.extend(base_items());
    module.push(Item::Function(main_fn(layout, fields)));
    module.to_wgsl()
}

fn base_items() -> Vec<Item> {
    let mut items = Vec::new();
    items.push(Item::Struct(vector2_struct()));
    items.push(Item::Struct(constants_struct()));
    items.push(Item::Comment("Group 0: Mesh".to_string()));
    items.extend(mesh_bindings());
    items.push(Item::Comment("Group 1: Fields".to_string()));
    items.extend(state_bindings());
    items
}

fn vector2_struct() -> StructDef {
    StructDef::new(
        "Vector2",
        vec![
            StructField::new("x", Type::F32),
            StructField::new("y", Type::F32),
        ],
    )
}

fn constants_struct() -> StructDef {
    StructDef::new(
        "Constants",
        vec![
            StructField::new("dt", Type::F32),
            StructField::new("dt_old", Type::F32),
            StructField::new("dtau", Type::F32),
            StructField::new("time", Type::F32),
            StructField::new("viscosity", Type::F32),
            StructField::new("density", Type::F32),
            StructField::new("component", Type::U32),
            StructField::new("alpha_p", Type::F32),
            StructField::new("scheme", Type::U32),
            StructField::new("alpha_u", Type::F32),
            StructField::new("stride_x", Type::U32),
            StructField::new("time_scheme", Type::U32),
            StructField::new("inlet_velocity", Type::F32),
            StructField::new("ramp_time", Type::F32),
            StructField::new("precond_type", Type::U32),
            StructField::new("precond_model", Type::U32),
            StructField::new("precond_theta_floor", Type::F32),
            StructField::new("pressure_coupling_alpha", Type::F32),
        ],
    )
}

fn mesh_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "face_owner",
            Type::array(Type::U32),
            0,
            0,
            AccessMode::Read,
        ),
        storage_var(
            "face_neighbor",
            Type::array(Type::I32),
            0,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "face_areas",
            Type::array(Type::F32),
            0,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "face_normals",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            3,
            AccessMode::Read,
        ),
        storage_var(
            "cell_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            4,
            AccessMode::Read,
        ),
        storage_var(
            "cell_vols",
            Type::array(Type::F32),
            0,
            5,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_offsets",
            Type::array(Type::U32),
            0,
            6,
            AccessMode::Read,
        ),
        storage_var(
            "cell_faces",
            Type::array(Type::U32),
            0,
            7,
            AccessMode::Read,
        ),
        storage_var(
            "cell_face_matrix_indices",
            Type::array(Type::U32),
            0,
            8,
            AccessMode::Read,
        ),
        storage_var(
            "diagonal_indices",
            Type::array(Type::U32),
            0,
            9,
            AccessMode::Read,
        ),
        storage_var(
            "face_boundary",
            Type::array(Type::U32),
            0,
            12,
            AccessMode::Read,
        ),
        storage_var(
            "face_centers",
            Type::array(Type::Custom("Vector2".to_string())),
            0,
            13,
            AccessMode::Read,
        ),
    ]
}

fn state_bindings() -> Vec<Item> {
    vec![
        storage_var(
            "state",
            Type::array(Type::F32),
            1,
            0,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_old",
            Type::array(Type::F32),
            1,
            1,
            AccessMode::Read,
        ),
        storage_var(
            "state_old_old",
            Type::array(Type::F32),
            1,
            2,
            AccessMode::Read,
        ),
        storage_var(
            "fluxes",
            Type::array(Type::F32),
            1,
            3,
            AccessMode::ReadWrite,
        ),
        uniform_var("constants", Type::Custom("Constants".to_string()), 1, 4),
        storage_var(
            "grad_rho",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            5,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_x",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            6,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_u_y",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            7,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "grad_rho_e",
            Type::array(Type::Custom("Vector2".to_string())),
            1,
            8,
            AccessMode::ReadWrite,
        ),
        storage_var(
            "state_iter",
            Type::array(Type::F32),
            1,
            9,
            AccessMode::Read,
        ),
    ]
}

fn storage_var(
    name: &str,
    ty: Type,
    group: u32,
    binding: u32,
    access: AccessMode,
) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Storage,
        Some(access),
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn uniform_var(name: &str, ty: Type, group: u32, binding: u32) -> Item {
    Item::GlobalVar(GlobalVar::new(
        name,
        ty,
        super::wgsl_ast::StorageClass::Uniform,
        None,
        vec![Attribute::Group(group), Attribute::Binding(binding)],
    ))
}

fn main_fn(layout: &StateLayout, fields: &CompressibleFields) -> Function {
    let params = vec![Param::new(
        "global_id",
        Type::vec3_u32(),
        vec![Attribute::Builtin("global_invocation_id".to_string())],
    )];
    Function::new(
        "main",
        params,
        None,
        vec![Attribute::Compute, Attribute::WorkgroupSize(64)],
        main_body(layout, fields),
    )
}

fn main_body(layout: &StateLayout, fields: &CompressibleFields) -> Block {
    let mut stmts = Vec::new();
    let rho_field = fields.rho.name();
    let rho_u_field = fields.rho_u.name();
    let rho_e_field = fields.rho_e.name();

    let rho_expr = state_scalar(layout, "state", "idx", rho_field);
    let rho_u_expr = state_vec2(layout, "state", "idx", rho_u_field);
    let rho_e_expr = state_scalar(layout, "state", "idx", rho_e_field);

    stmts.push(dsl::let_expr("idx", Expr::ident("global_id").field("x")));
    stmts.push(dsl::if_block_expr(
        Expr::ident("idx").ge(Expr::call_named(
            "arrayLength",
            vec![Expr::ident("cell_vols").addr_of()],
        )),
        dsl::block(vec![Stmt::Return(None)]),
        None,
    ));
    stmts.push(dsl::let_expr(
        "center",
        Expr::ident("cell_centers").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "vol",
        Expr::ident("cell_vols").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "start",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx")),
    ));
    stmts.push(dsl::let_expr(
        "end",
        Expr::ident("cell_face_offsets").index(Expr::ident("idx") + 1u32),
    ));

    stmts.push(dsl::let_expr("rho_l", rho_expr));
    stmts.push(dsl::let_expr("rho_u_l", rho_u_expr));
    stmts.push(dsl::let_expr("rho_e_l", rho_e_expr));

    let zeros = typed::VecExpr::<2>::zeros().expr();
    stmts.push(dsl::var_typed_expr(
        "grad_rho_accum",
        Type::vec2_f32(),
        Some(zeros),
    ));
    stmts.push(dsl::var_typed_expr(
        "grad_rho_u_x_accum",
        Type::vec2_f32(),
        Some(zeros),
    ));
    stmts.push(dsl::var_typed_expr(
        "grad_rho_u_y_accum",
        Type::vec2_f32(),
        Some(zeros),
    ));
    stmts.push(dsl::var_typed_expr(
        "grad_rho_e_accum",
        Type::vec2_f32(),
        Some(zeros),
    ));

    let mut loop_body = Vec::new();
    loop_body.push(dsl::let_expr(
        "face_idx",
        Expr::ident("cell_faces").index(Expr::ident("k")),
    ));
    loop_body.push(dsl::let_expr(
        "owner",
        Expr::ident("face_owner").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "neighbor",
        Expr::ident("face_neighbor").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::let_expr(
        "area",
        Expr::ident("face_areas").index(Expr::ident("face_idx")),
    ));
    loop_body.push(dsl::var_typed_expr(
        "normal",
        Type::vec2_f32(),
        Some(
            typed::VecExpr::<2>::from_xy_fields(
                Expr::ident("face_normals").index(Expr::ident("face_idx")),
            )
            .expr(),
        ),
    ));
    loop_body.push(dsl::if_block_expr(
        Expr::ident("owner").ne(Expr::ident("idx")),
        dsl::block(vec![dsl::assign_expr(
            Expr::ident("normal"),
            -Expr::ident("normal"),
        )]),
        None,
    ));

    loop_body.push(dsl::var_typed_expr("rho_r", Type::F32, Some(Expr::ident("rho_l"))));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_r",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l")),
    ));
    loop_body.push(dsl::var_typed_expr("rho_e_r", Type::F32, Some(Expr::ident("rho_e_l"))));

    let rho_neigh_expr = state_scalar(layout, "state", "other_idx", rho_field);
    let rho_u_neigh_expr = state_vec2(layout, "state", "other_idx", rho_u_field);
    let rho_e_neigh_expr = state_scalar(layout, "state", "other_idx", rho_e_field);
    loop_body.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![
            dsl::var_typed_expr(
                "other_idx",
                Type::U32,
                Some(Expr::call_named("u32", vec![Expr::ident("neighbor")])),
            ),
            dsl::if_block_expr(
                Expr::ident("owner").ne(Expr::ident("idx")),
                dsl::block(vec![dsl::assign_expr(
                    Expr::ident("other_idx"),
                    Expr::ident("owner"),
                )]),
                None,
            ),
            dsl::let_expr("rho_neigh", rho_neigh_expr),
            dsl::let_expr("rho_u_neigh", rho_u_neigh_expr),
            dsl::let_expr("rho_e_neigh", rho_e_neigh_expr),
            dsl::assign_expr(Expr::ident("rho_r"), Expr::ident("rho_neigh")),
            dsl::assign_expr(Expr::ident("rho_u_r"), Expr::ident("rho_u_neigh")),
            dsl::assign_expr(Expr::ident("rho_e_r"), Expr::ident("rho_e_neigh")),
        ]),
        None,
    ));

    loop_body.push(dsl::var_typed_expr("rho_face", Type::F32, Some(Expr::ident("rho_l"))));
    loop_body.push(dsl::var_typed_expr(
        "rho_u_face",
        Type::vec2_f32(),
        Some(Expr::ident("rho_u_l")),
    ));
    loop_body.push(dsl::var_typed_expr("rho_e_face", Type::F32, Some(Expr::ident("rho_e_l"))));
    loop_body.push(dsl::if_block_expr(
        Expr::ident("neighbor").ne(-1),
        dsl::block(vec![
            dsl::assign_expr(
                Expr::ident("rho_face"),
                (Expr::ident("rho_l") + Expr::ident("rho_r")) * 0.5,
            ),
            dsl::assign_expr(
                Expr::ident("rho_u_face"),
                (Expr::ident("rho_u_l") + Expr::ident("rho_u_r")) * 0.5,
            ),
            dsl::assign_expr(
                Expr::ident("rho_e_face"),
                (Expr::ident("rho_e_l") + Expr::ident("rho_e_r")) * 0.5,
            ),
        ]),
        None,
    ));

    let add_flux = |target: &str, face_value: Expr| {
        let flux = typed::VecExpr::<2>::from_expr(Expr::ident("normal"))
            .mul_scalar(face_value * Expr::ident("area"));
        dsl::assign_op_expr(AssignOp::Add, Expr::ident(target), flux.expr())
    };

    loop_body.push(add_flux("grad_rho_accum", Expr::ident("rho_face")));
    loop_body.push(add_flux(
        "grad_rho_u_x_accum",
        Expr::ident("rho_u_face").field("x"),
    ));
    loop_body.push(add_flux(
        "grad_rho_u_y_accum",
        Expr::ident("rho_u_face").field("y"),
    ));
    loop_body.push(add_flux("grad_rho_e_accum", Expr::ident("rho_e_face")));

    stmts.push(dsl::for_loop_expr(
        dsl::for_init_var_expr("k", Expr::ident("start")),
        Expr::ident("k").lt(Expr::ident("end")),
        dsl::for_step_increment_expr(Expr::ident("k")),
        dsl::block(loop_body),
    ));

    for accum in [
        "grad_rho_accum",
        "grad_rho_u_x_accum",
        "grad_rho_u_y_accum",
        "grad_rho_e_accum",
    ] {
        stmts.push(dsl::assign_expr(
            Expr::ident(accum),
            typed::VecExpr::<2>::from_expr(Expr::ident(accum))
                .div_scalar(Expr::ident("vol"))
                .expr(),
        ));
    }

    let store_grad = |buf: &str, accum: &str| {
        dsl::assign_expr(
            Expr::ident(buf)
                .index(Expr::ident("idx")),
            typed::VecExpr::<2>::from_expr(Expr::ident(accum)).to_vector2_struct(),
        )
    };

    stmts.push(store_grad("grad_rho", "grad_rho_accum"));
    stmts.push(store_grad("grad_rho_u_x", "grad_rho_u_x_accum"));
    stmts.push(store_grad("grad_rho_u_y", "grad_rho_u_y_accum"));
    stmts.push(store_grad("grad_rho_e", "grad_rho_e_accum"));

    Block::new(stmts)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::solver::model::compressible_model;

    #[test]
    fn compressible_gradients_codegen_emits_grad_buffers() {
        let model = compressible_model();
        let fields = model.fields.compressible().expect("compressible fields");
        let wgsl = generate_compressible_gradients_wgsl(&model.state_layout, fields);
        assert!(wgsl.contains("grad_rho"));
        assert!(wgsl.contains("grad_rho_u_x"));
        assert!(wgsl.contains("grad_rho_u_y"));
        assert!(wgsl.contains("grad_rho_e"));
    }
}
